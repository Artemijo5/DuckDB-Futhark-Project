// Generated by Futhark 0.26.0 (prerelease - include info below when reporting bugs).
// git: 1de4f0c (Fri Jan 24 11:10:52 2025 +0100)
// Compiled with GHC 9.4.8.

// We need to define _GNU_SOURCE before
// _any_ headers files are imported to get
// the usage statistics of a thread (i.e. have RUSAGE_THREAD) on GNU/Linux
// https://manpages.courier-mta.org/htmlman2/getrusage.2.html
#ifndef _GNU_SOURCE // Avoid possible double-definition warning.
#define _GNU_SOURCE
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-const-variable"
#pragma clang diagnostic ignored "-Wparentheses"
#pragma clang diagnostic ignored "-Wunused-label"
#pragma clang diagnostic ignored "-Wunused-but-set-variable"
#elif __GNUC__
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-const-variable"
#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif

// Headers
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

// Initialisation
struct futhark_context_config;
struct futhark_context_config *futhark_context_config_new(void);
void futhark_context_config_free(struct futhark_context_config *cfg);
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg, const char *param_name, size_t new_value);
struct futhark_context;
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg);
void futhark_context_free(struct futhark_context *cfg);
void futhark_context_config_set_debugging(struct futhark_context_config *cfg, int flag);
void futhark_context_config_set_profiling(struct futhark_context_config *cfg, int flag);
void futhark_context_config_set_logging(struct futhark_context_config *cfg, int flag);
int futhark_get_tuning_param_count(void);
const char *futhark_get_tuning_param_name(int);
const char *futhark_get_tuning_param_class(int);

// Arrays
struct futhark_i32_1d;
struct futhark_i32_1d *futhark_new_i32_1d(struct futhark_context *ctx, const int32_t *data, int64_t dim0);
struct futhark_i32_1d *futhark_new_raw_i32_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0);
int futhark_free_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr);
int futhark_values_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr, int32_t *data);
int futhark_index_i32_1d(struct futhark_context *ctx, int32_t *out, struct futhark_i32_1d *arr, int64_t i0);
unsigned char *futhark_values_raw_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr);
const int64_t *futhark_shape_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr);
struct futhark_i64_1d;
struct futhark_i64_1d *futhark_new_i64_1d(struct futhark_context *ctx, const int64_t *data, int64_t dim0);
struct futhark_i64_1d *futhark_new_raw_i64_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0);
int futhark_free_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr);
int futhark_values_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr, int64_t *data);
int futhark_index_i64_1d(struct futhark_context *ctx, int64_t *out, struct futhark_i64_1d *arr, int64_t i0);
unsigned char *futhark_values_raw_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr);
const int64_t *futhark_shape_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr);
struct futhark_u8_2d;
struct futhark_u8_2d *futhark_new_u8_2d(struct futhark_context *ctx, const uint8_t *data, int64_t dim0, int64_t dim1);
struct futhark_u8_2d *futhark_new_raw_u8_2d(struct futhark_context *ctx, unsigned char *data, int64_t dim0, int64_t dim1);
int futhark_free_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr);
int futhark_values_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr, uint8_t *data);
int futhark_index_u8_2d(struct futhark_context *ctx, uint8_t *out, struct futhark_u8_2d *arr, int64_t i0, int64_t i1);
unsigned char *futhark_values_raw_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr);
const int64_t *futhark_shape_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr);

// Opaque values
struct futhark_opaque_joinPairs_bsq;
struct futhark_opaque_partitionInfo;
struct futhark_opaque_partitionedSet_GFTR;
struct futhark_opaque_partitionedSet_GFUR;
struct futhark_opaque_radix_hashTable;
int futhark_free_opaque_joinPairs_bsq(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq *obj);
int futhark_store_opaque_joinPairs_bsq(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_bsq *obj, void **p, size_t *n);
struct futhark_opaque_joinPairs_bsq *futhark_restore_opaque_joinPairs_bsq(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_joinPairs_bsq_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_bsq *obj);
int futhark_project_opaque_joinPairs_bsq_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_bsq *obj);
int futhark_project_opaque_joinPairs_bsq_vs(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_joinPairs_bsq *obj);
int futhark_new_opaque_joinPairs_bsq(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_u8_2d *f_vs);
int futhark_free_opaque_partitionInfo(struct futhark_context *ctx, struct futhark_opaque_partitionInfo *obj);
int futhark_store_opaque_partitionInfo(struct futhark_context *ctx, const struct futhark_opaque_partitionInfo *obj, void **p, size_t *n);
struct futhark_opaque_partitionInfo *futhark_restore_opaque_partitionInfo(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_partitionInfo_bounds(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_partitionInfo *obj);
int futhark_project_opaque_partitionInfo_depths(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_partitionInfo *obj);
int futhark_project_opaque_partitionInfo_maxDepth(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_partitionInfo *obj);
int futhark_project_opaque_partitionInfo_radixSize(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_partitionInfo *obj);
int futhark_project_opaque_partitionInfo_totalBytes(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_partitionInfo *obj);
int futhark_new_opaque_partitionInfo(struct futhark_context *ctx, struct futhark_opaque_partitionInfo **out, const struct futhark_i64_1d *f_bounds, const struct futhark_i32_1d *f_depths, const int32_t f_maxDepth, const int32_t f_radixSizze, const int32_t f_totalBytes);
int futhark_free_opaque_partitionedSet_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR *obj);
int futhark_store_opaque_partitionedSet_GFTR(struct futhark_context *ctx, const struct futhark_opaque_partitionedSet_GFTR *obj, void **p, size_t *n);
struct futhark_opaque_partitionedSet_GFTR *futhark_restore_opaque_partitionedSet_GFTR(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_partitionedSet_GFTR_ks(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFTR *obj);
int futhark_project_opaque_partitionedSet_GFTR_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFTR *obj);
int futhark_new_opaque_partitionedSet_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR **out, const struct futhark_u8_2d *f_ks, const struct futhark_u8_2d *f_pL);
int futhark_free_opaque_partitionedSet_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR *obj);
int futhark_store_opaque_partitionedSet_GFUR(struct futhark_context *ctx, const struct futhark_opaque_partitionedSet_GFUR *obj, void **p, size_t *n);
struct futhark_opaque_partitionedSet_GFUR *futhark_restore_opaque_partitionedSet_GFUR(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_partitionedSet_GFUR_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_partitionedSet_GFUR *obj);
int futhark_project_opaque_partitionedSet_GFUR_ks(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFUR *obj);
int futhark_new_opaque_partitionedSet_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR **out, const struct futhark_i64_1d *f_idx, const struct futhark_u8_2d *f_ks);
int futhark_free_opaque_radix_hashTable(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable *obj);
int futhark_store_opaque_radix_hashTable(struct futhark_context *ctx, const struct futhark_opaque_radix_hashTable *obj, void **p, size_t *n);
struct futhark_opaque_radix_hashTable *futhark_restore_opaque_radix_hashTable(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_radix_hashTable_first_info_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_radix_hashTable *obj);
int futhark_project_opaque_radix_hashTable_last_info_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_radix_hashTable *obj);
int futhark_new_opaque_radix_hashTable(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable **out, const struct futhark_i64_1d *f_first_info_idx, const struct futhark_i64_1d *f_last_info_idx);

// Entry points
int futhark_entry_Inner_Radix_Hash_Join(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq **out0, const int32_t in0, const struct futhark_u8_2d *in1, const struct futhark_u8_2d *in2, const struct futhark_opaque_partitionInfo *in3, const struct futhark_opaque_partitionInfo *in4, const struct futhark_opaque_radix_hashTable *in5, const struct futhark_opaque_radix_hashTable *in6, const int64_t in7);
int futhark_entry_calc_partitions_from_partitioned_set(struct futhark_context *ctx, struct futhark_opaque_partitionInfo **out0, const int32_t in0, const struct futhark_u8_2d *in1, const int64_t in2, const int64_t in3, const int32_t in4);
int futhark_entry_create_hash_table_from_partitioned_set(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable **out0, const struct futhark_u8_2d *in0, const struct futhark_opaque_partitionInfo *in1, const int64_t in2);
int futhark_entry_partition_and_deepen_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR **out0, const int16_t in0, const int64_t in1, const int32_t in2, const struct futhark_u8_2d *in3, const struct futhark_u8_2d *in4, const int64_t in5, const int32_t in6);
int futhark_entry_partition_and_deepen_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR **out0, const int16_t in0, const int64_t in1, const int32_t in2, const struct futhark_u8_2d *in3, const int64_t in4, const int64_t in5, const int32_t in6);

// Miscellaneous
int futhark_context_sync(struct futhark_context *ctx);
void futhark_context_config_set_cache_file(struct futhark_context_config *cfg, const char *f);
char *futhark_context_get_error(struct futhark_context *ctx);
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f);
void futhark_context_pause_profiling(struct futhark_context *ctx);
void futhark_context_unpause_profiling(struct futhark_context *ctx);
char *futhark_context_report(struct futhark_context *ctx);
int futhark_context_clear_caches(struct futhark_context *ctx);
#define FUTHARK_BACKEND_c
#define FUTHARK_SUCCESS 0
#define FUTHARK_PROGRAM_ERROR 2
#define FUTHARK_OUT_OF_MEMORY 3

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <stdint.h>
// If NDEBUG is set, the assert() macro will do nothing. Since Futhark
// (unfortunately) makes use of assert() for error detection (and even some
// side effects), we want to avoid that.
#undef NDEBUG
#include <assert.h>
#include <stdarg.h>
#define SCALAR_FUN_ATTR static inline
// Start of util.h.
//
// Various helper functions that are useful in all generated C code.

#include <errno.h>
#include <string.h>

static const char *fut_progname = "(embedded Futhark)";

static void futhark_panic(int eval, const char *fmt, ...) __attribute__((noreturn));
static char* msgprintf(const char *s, ...);
static void* slurp_file(const char *filename, size_t *size);
static int dump_file(const char *file, const void *buf, size_t n);
struct str_builder;
static void str_builder_init(struct str_builder *b);
static void str_builder(struct str_builder *b, const char *s, ...);
static char *strclone(const char *str);

static void futhark_panic(int eval, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  fprintf(stderr, "%s: ", fut_progname);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  exit(eval);
}

// For generating arbitrary-sized error messages.  It is the callers
// responsibility to free the buffer at some point.
static char* msgprintf(const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = 1 + (size_t)vsnprintf(NULL, 0, s, vl);
  char *buffer = (char*) malloc(needed);
  va_start(vl, s); // Must re-init.
  vsnprintf(buffer, needed, s, vl);
  return buffer;
}

static inline void check_err(int errval, int sets_errno, const char *fun, int line,
                             const char *msg, ...) {
  if (errval) {
    char errnum[10];

    va_list vl;
    va_start(vl, msg);

    fprintf(stderr, "ERROR: ");
    vfprintf(stderr, msg, vl);
    fprintf(stderr, " in %s() at line %d with error code %s\n",
            fun, line,
            sets_errno ? strerror(errno) : errnum);
    exit(errval);
  }
}

#define CHECK_ERR(err, ...) check_err(err, 0, __func__, __LINE__, __VA_ARGS__)
#define CHECK_ERRNO(err, ...) check_err(err, 1, __func__, __LINE__, __VA_ARGS__)

// Read the rest of an open file into a NUL-terminated string; returns
// NULL on error.
static void* fslurp_file(FILE *f, size_t *size) {
  long start = ftell(f);
  fseek(f, 0, SEEK_END);
  long src_size = ftell(f)-start;
  fseek(f, start, SEEK_SET);
  unsigned char *s = (unsigned char*) malloc((size_t)src_size + 1);
  if (fread(s, 1, (size_t)src_size, f) != (size_t)src_size) {
    free(s);
    s = NULL;
  } else {
    s[src_size] = '\0';
  }

  if (size) {
    *size = (size_t)src_size;
  }

  return s;
}

// Read a file into a NUL-terminated string; returns NULL on error.
static void* slurp_file(const char *filename, size_t *size) {
  FILE *f = fopen(filename, "rb"); // To avoid Windows messing with linebreaks.
  if (f == NULL) return NULL;
  unsigned char *s = fslurp_file(f, size);
  fclose(f);
  return s;
}

// Dump 'n' bytes from 'buf' into the file at the designated location.
// Returns 0 on success.
static int dump_file(const char *file, const void *buf, size_t n) {
  FILE *f = fopen(file, "w");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(buf, sizeof(char), n, f) != n) {
    return 1;
  }

  if (fclose(f) != 0) {
    return 1;
  }

  return 0;
}

struct str_builder {
  char *str;
  size_t capacity; // Size of buffer.
  size_t used; // Bytes used, *not* including final zero.
};

static void str_builder_init(struct str_builder *b) {
  b->capacity = 10;
  b->used = 0;
  b->str = malloc(b->capacity);
  b->str[0] = 0;
}

static void str_builder(struct str_builder *b, const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = (size_t)vsnprintf(NULL, 0, s, vl);

  while (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }

  va_start(vl, s); // Must re-init.
  vsnprintf(b->str+b->used, b->capacity-b->used, s, vl);
  b->used += needed;
}

static void str_builder_str(struct str_builder *b, const char *s) {
  size_t needed = strlen(s);
  if (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }
  strcpy(b->str+b->used, s);
  b->used += needed;
}

static void str_builder_char(struct str_builder *b, char c) {
  size_t needed = 1;
  if (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }
  b->str[b->used] = c;
  b->str[b->used+1] = 0;
  b->used += needed;
}

static void str_builder_json_str(struct str_builder* sb, const char* s) {
  str_builder_char(sb, '"');
  for (int j = 0; s[j]; j++) {
    char c = s[j];
    switch (c) {
    case '\n':
      str_builder_str(sb, "\\n");
      break;
    case '"':
      str_builder_str(sb, "\\\"");
      break;
    default:
      str_builder_char(sb, c);
    }
  }
  str_builder_char(sb, '"');
}

static char *strclone(const char *str) {
  size_t size = strlen(str) + 1;
  char *copy = (char*) malloc(size);
  if (copy == NULL) {
    return NULL;
  }

  memcpy(copy, str, size);
  return copy;
}

// Assumes NULL-terminated.
static char *strconcat(const char *src_fragments[]) {
  size_t src_len = 0;
  const char **p;

  for (p = src_fragments; *p; p++) {
    src_len += strlen(*p);
  }

  char *src = (char*) malloc(src_len + 1);
  size_t n = 0;
  for (p = src_fragments; *p; p++) {
    strcpy(src + n, *p);
    n += strlen(*p);
  }

  return src;
}

// End of util.h.
// Start of cache.h

#define CACHE_HASH_SIZE 8 // In 32-bit words.

struct cache_hash {
  uint32_t hash[CACHE_HASH_SIZE];
};

// Initialise a blank cache.
static void cache_hash_init(struct cache_hash *c);

// Hash some bytes and add them to the accumulated hash.
static void cache_hash(struct cache_hash *out, const char *in, size_t n);

// Try to restore cache contents from a file with the given name.
// Assumes the cache is invalid if it contains the given hash.
// Allocates memory and reads the cache conents, which is returned in
// *buf with size *buflen.  If the cache is successfully loaded, this
// function returns 0.  Otherwise it returns nonzero.  Errno is set if
// the failure to load the cache is due to anything except invalid
// cache conents.  Note that failing to restore the cache is not
// necessarily a problem: it might just be invalid or not created yet.
static int cache_restore(const char *fname, const struct cache_hash *hash,
                         unsigned char **buf, size_t *buflen);

// Store cache contents in the given file, with the given hash.
static int cache_store(const char *fname, const struct cache_hash *hash,
                       const unsigned char *buf, size_t buflen);

// Now for the implementation.

static void cache_hash_init(struct cache_hash *c) {
  memset(c->hash, 0, CACHE_HASH_SIZE * sizeof(uint32_t));
}

static void cache_hash(struct cache_hash *out, const char *in, size_t n) {
  // Adaptation of djb2 for larger output size by storing intermediate
  // states.
  uint32_t hash = 5381;
  for (size_t i = 0; i < n; i++) {
    hash = ((hash << 5) + hash) + in[i];
    out->hash[i % CACHE_HASH_SIZE] ^= hash;
  }
}

#define CACHE_HEADER_SIZE 8
static const char cache_header[CACHE_HEADER_SIZE] = "FUTHARK\0";

static int cache_restore(const char *fname, const struct cache_hash *hash,
                         unsigned char **buf, size_t *buflen) {
  FILE *f = fopen(fname, "rb");

  if (f == NULL) {
    return 1;
  }

  char f_header[CACHE_HEADER_SIZE];

  if (fread(f_header, sizeof(char), CACHE_HEADER_SIZE, f) != CACHE_HEADER_SIZE) {
    goto error;
  }

  if (memcmp(f_header, cache_header, CACHE_HEADER_SIZE) != 0) {
    goto error;
  }

  if (fseek(f, 0, SEEK_END) != 0) {
    goto error;
  }
  int64_t f_size = (int64_t)ftell(f);
  if (fseek(f, CACHE_HEADER_SIZE, SEEK_SET) != 0) {
    goto error;
  }

  int64_t expected_size;

  if (fread(&expected_size, sizeof(int64_t), 1, f) != 1) {
    goto error;
  }

  if (f_size != expected_size) {
    errno = 0;
    goto error;
  }

  int32_t f_hash[CACHE_HASH_SIZE];

  if (fread(f_hash, sizeof(int32_t), CACHE_HASH_SIZE, f) != CACHE_HASH_SIZE) {
    goto error;
  }

  if (memcmp(f_hash, hash->hash, CACHE_HASH_SIZE) != 0) {
    errno = 0;
    goto error;
  }

  *buflen = f_size - CACHE_HEADER_SIZE - sizeof(int64_t) - CACHE_HASH_SIZE*sizeof(int32_t);
  *buf = malloc(*buflen);
  if (fread(*buf, sizeof(char), *buflen, f) != *buflen) {
    free(*buf);
    goto error;
  }

  fclose(f);

  return 0;

 error:
  fclose(f);
  return 1;
}

static int cache_store(const char *fname, const struct cache_hash *hash,
                       const unsigned char *buf, size_t buflen) {
  FILE *f = fopen(fname, "wb");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(cache_header, CACHE_HEADER_SIZE, 1, f) != 1) {
    goto error;
  }

  int64_t size = CACHE_HEADER_SIZE + sizeof(int64_t) + CACHE_HASH_SIZE*sizeof(int32_t) + buflen;

  if (fwrite(&size, sizeof(size), 1, f) != 1) {
    goto error;
  }

  if (fwrite(hash->hash, sizeof(int32_t), CACHE_HASH_SIZE, f) != CACHE_HASH_SIZE) {
    goto error;
  }

  if (fwrite(buf, sizeof(unsigned char), buflen, f) != buflen) {
    goto error;
  }

  fclose(f);

  return 0;

 error:
  fclose(f);
  return 1;
}

// End of cache.h
// Start of half.h.

// Conversion functions are from http://half.sourceforge.net/, but
// translated to C.
//
// Copyright (c) 2012-2021 Christian Rau
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef __OPENCL_VERSION__
#define __constant
#endif

__constant static const uint16_t base_table[512] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };

__constant static const unsigned char shift_table[512] = {
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };

__constant static const uint32_t mantissa_table[2048] = {
  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
  0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
  0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
__constant static const uint32_t exponent_table[64] = {
  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
__constant static const unsigned short offset_table[64] = {
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };

SCALAR_FUN_ATTR uint16_t float2halfbits(float value) {
  union { float x; uint32_t y; } u;
  u.x = value;
  uint32_t bits = u.y;

  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;

  return hbits;
}

SCALAR_FUN_ATTR float halfbits2float(uint16_t value) {
  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];

  union { uint32_t x; float y; } u;
  u.x = bits;
  return u.y;
}

SCALAR_FUN_ATTR uint16_t halfbitsnextafter(uint16_t from, uint16_t to) {
  int fabs = from & 0x7FFF, tabs = to & 0x7FFF;
  if(fabs > 0x7C00 || tabs > 0x7C00) {
    return ((from&0x7FFF)>0x7C00) ? (from|0x200) : (to|0x200);
  }
  if(from == to || !(fabs|tabs)) {
    return to;
  }
  if(!fabs) {
    return (to&0x8000)+1;
  }
  unsigned int out =
    from +
    (((from>>15)^(unsigned int)((from^(0x8000|(0x8000-(from>>15))))<(to^(0x8000|(0x8000-(to>>15))))))<<1)
    - 1;
  return out;
}

// End of half.h.
// Start of timing.h.

// The function get_wall_time() returns the wall time in microseconds
// (with an unspecified offset).

#ifdef _WIN32

#include <windows.h>

static int64_t get_wall_time(void) {
  LARGE_INTEGER time,freq;
  assert(QueryPerformanceFrequency(&freq));
  assert(QueryPerformanceCounter(&time));
  return ((double)time.QuadPart / freq.QuadPart) * 1000000;
}

static int64_t get_wall_time_ns(void) {
  return get_wall_time() * 1000;
}

#else
// Assuming POSIX

#include <time.h>
#include <sys/time.h>

static int64_t get_wall_time(void) {
  struct timeval time;
  assert(gettimeofday(&time,NULL) == 0);
  return time.tv_sec * 1000000 + time.tv_usec;
}

static int64_t get_wall_time_ns(void) {
  struct timespec time;
  assert(clock_gettime(CLOCK_REALTIME, &time) == 0);
  return time.tv_sec * 1000000000 + time.tv_nsec;
}

#endif

// End of timing.h.
// Start of lock.h.

// A very simple cross-platform implementation of locks.  Uses
// pthreads on Unix and some Windows thing there.  Futhark's
// host-level code is not multithreaded, but user code may be, so we
// need some mechanism for ensuring atomic access to API functions.
// This is that mechanism.  It is not exposed to user code at all, so
// we do not have to worry about name collisions.

#ifdef _WIN32

typedef HANDLE lock_t;

static void create_lock(lock_t *lock) {
  *lock = CreateMutex(NULL,  // Default security attributes.
                      FALSE, // Initially unlocked.
                      NULL); // Unnamed.
}

static void lock_lock(lock_t *lock) {
  assert(WaitForSingleObject(*lock, INFINITE) == WAIT_OBJECT_0);
}

static void lock_unlock(lock_t *lock) {
  assert(ReleaseMutex(*lock));
}

static void free_lock(lock_t *lock) {
  CloseHandle(*lock);
}

#else
// Assuming POSIX

#include <pthread.h>

typedef pthread_mutex_t lock_t;

static void create_lock(lock_t *lock) {
  int r = pthread_mutex_init(lock, NULL);
  assert(r == 0);
}

static void lock_lock(lock_t *lock) {
  int r = pthread_mutex_lock(lock);
  assert(r == 0);
}

static void lock_unlock(lock_t *lock) {
  int r = pthread_mutex_unlock(lock);
  assert(r == 0);
}

static void free_lock(lock_t *lock) {
  // Nothing to do for pthreads.
  (void)lock;
}

#endif

// End of lock.h.
// Start of free_list.h.

typedef uintptr_t fl_mem;

// An entry in the free list.  May be invalid, to avoid having to
// deallocate entries as soon as they are removed.  There is also a
// tag, to help with memory reuse.
struct free_list_entry {
  size_t size;
  fl_mem mem;
  const char *tag;
  unsigned char valid;
};

struct free_list {
  struct free_list_entry *entries; // Pointer to entries.
  int capacity;                    // Number of entries.
  int used;                        // Number of valid entries.
  lock_t lock;                     // Thread safety.
};

static void free_list_init(struct free_list *l) {
  l->capacity = 30; // Picked arbitrarily.
  l->used = 0;
  l->entries = (struct free_list_entry*) malloc(sizeof(struct free_list_entry) * l->capacity);
  for (int i = 0; i < l->capacity; i++) {
    l->entries[i].valid = 0;
  }
  create_lock(&l->lock);
}

// Remove invalid entries from the free list.
static void free_list_pack(struct free_list *l) {
  lock_lock(&l->lock);
  int p = 0;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[p] = l->entries[i];
      if (i > p) {
        l->entries[i].valid = 0;
      }
      p++;
    }
  }

  // Now p is the number of used elements.  We don't want it to go
  // less than the default capacity (although in practice it's OK as
  // long as it doesn't become 1).
  if (p < 30) {
    p = 30;
  }
  l->entries = realloc(l->entries, p * sizeof(struct free_list_entry));
  l->capacity = p;
  lock_unlock(&l->lock);
}

static void free_list_destroy(struct free_list *l) {
  assert(l->used == 0);
  free(l->entries);
  free_lock(&l->lock);
}

// Not part of the interface, so no locking.
static int free_list_find_invalid(struct free_list *l) {
  int i;
  for (i = 0; i < l->capacity; i++) {
    if (!l->entries[i].valid) {
      break;
    }
  }
  return i;
}

static void free_list_insert(struct free_list *l, size_t size, fl_mem mem, const char *tag) {
  lock_lock(&l->lock);
  int i = free_list_find_invalid(l);

  if (i == l->capacity) {
    // List is full; so we have to grow it.
    int new_capacity = l->capacity * 2 * sizeof(struct free_list_entry);
    l->entries = realloc(l->entries, new_capacity);
    for (int j = 0; j < l->capacity; j++) {
      l->entries[j+l->capacity].valid = 0;
    }
    l->capacity *= 2;
  }

  // Now 'i' points to the first invalid entry.
  l->entries[i].valid = 1;
  l->entries[i].size = size;
  l->entries[i].mem = mem;
  l->entries[i].tag = tag;

  l->used++;
  lock_unlock(&l->lock);
}

// Determine whether this entry in the free list is acceptable for
// satisfying the request.  Not public, so no locking.
static bool free_list_acceptable(size_t size, const char* tag, struct free_list_entry *entry) {
  // We check not just the hard requirement (is the entry acceptable
  // and big enough?) but also put a cap on how much wasted space
  // (internal fragmentation) we allow.  This is necessarily a
  // heuristic, and a crude one.

  if (!entry->valid) {
    return false;
  }

  if (size > entry->size) {
    return false;
  }

  // We know the block fits.  Now the question is whether it is too
  // big.  Our policy is as follows:
  //
  // 1) We don't care about wasted space below 4096 bytes (to avoid
  // churn in tiny allocations).
  //
  // 2) If the tag matches, we allow _any_ amount of wasted space.
  //
  // 3) Otherwise we allow up to 50% wasted space.

  if (entry->size < 4096) {
    return true;
  }

  if (entry->tag == tag) {
    return true;
  }

  if (entry->size < size * 2) {
    return true;
  }

  return false;
}

// Find and remove a memory block of the indicated tag, or if that
// does not exist, another memory block with exactly the desired size.
// Returns 0 on success.
static int free_list_find(struct free_list *l, size_t size, const char *tag,
                          size_t *size_out, fl_mem *mem_out) {
  lock_lock(&l->lock);
  int size_match = -1;
  int i;
  int ret = 1;
  for (i = 0; i < l->capacity; i++) {
    if (free_list_acceptable(size, tag, &l->entries[i]) &&
        (size_match < 0 || l->entries[i].size < l->entries[size_match].size)) {
      // If this entry is valid, has sufficient size, and is smaller than the
      // best entry found so far, use this entry.
      size_match = i;
    }
  }

  if (size_match >= 0) {
    l->entries[size_match].valid = 0;
    *size_out = l->entries[size_match].size;
    *mem_out = l->entries[size_match].mem;
    l->used--;
    ret = 0;
  }
  lock_unlock(&l->lock);
  return ret;
}

// Remove the first block in the free list.  Returns 0 if a block was
// removed, and nonzero if the free list was already empty.
static int free_list_first(struct free_list *l, fl_mem *mem_out) {
  lock_lock(&l->lock);
  int ret = 1;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[i].valid = 0;
      *mem_out = l->entries[i].mem;
      l->used--;
      ret = 0;
      break;
    }
  }
  lock_unlock(&l->lock);
  return ret;
}

// End of free_list.h.
// Start of event_list.h

typedef int (*event_report_fn)(struct str_builder*, void*);

struct event {
  void* data;
  event_report_fn f;
  const char* name;
  char *description;
};

struct event_list {
  struct event *events;
  int num_events;
  int capacity;
};

static void event_list_init(struct event_list *l) {
  l->capacity = 100;
  l->num_events = 0;
  l->events = calloc(l->capacity, sizeof(struct event));
}

static void event_list_free(struct event_list *l) {
  free(l->events);
}

static void add_event_to_list(struct event_list *l,
                              const char* name,
                              char* description,
                              void* data,
                              event_report_fn f) {
  if (l->num_events == l->capacity) {
    l->capacity *= 2;
    l->events = realloc(l->events, l->capacity * sizeof(struct event));
  }
  l->events[l->num_events].name = name;
  l->events[l->num_events].description = description;
  l->events[l->num_events].data = data;
  l->events[l->num_events].f = f;
  l->num_events++;
}

static int report_events_in_list(struct event_list *l,
                                 struct str_builder* sb) {
  int ret = 0;
  for (int i = 0; i < l->num_events; i++) {
    if (i != 0) {
      str_builder_str(sb, ",");
    }
    str_builder_str(sb, "{\"name\":");
    str_builder_json_str(sb, l->events[i].name);
    str_builder_str(sb, ",\"description\":");
    str_builder_json_str(sb, l->events[i].description);
    free(l->events[i].description);
    if (l->events[i].f(sb, l->events[i].data) != 0) {
      ret = 1;
      break;
    }
    str_builder(sb, "}");
  }
  event_list_free(l);
  event_list_init(l);
  return ret;
}

// End of event_list.h

#ifdef _MSC_VER
#define inline __inline
#endif
#include <string.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <ctype.h>



#define FUTHARK_F64_ENABLED

// Start of scalar.h.

// Implementation of the primitive scalar operations.  Very
// repetitive.  This code is inserted directly into both CUDA and
// OpenCL programs, as well as the CPU code, so it has some #ifdefs to
// work everywhere.  Some operations are defined as macros because
// this allows us to use them as constant expressions in things like
// array sizes and static initialisers.

// Some of the #ifdefs are because OpenCL uses type-generic functions
// for some operations (e.g. sqrt), while C and CUDA sensibly use
// distinct functions for different precisions (e.g. sqrtf() and
// sqrt()).  This is quite annoying.  Due to C's unfortunate casting
// rules, it is also really easy to accidentally implement
// floating-point functions in the wrong precision, so be careful.

// Double-precision definitions are only included if the preprocessor
// macro FUTHARK_F64_ENABLED is set.

SCALAR_FUN_ATTR int32_t futrts_to_bits32(float x);
SCALAR_FUN_ATTR float futrts_from_bits32(int32_t x);

SCALAR_FUN_ATTR uint8_t add8(uint8_t x, uint8_t y) {
  return x + y;
}

SCALAR_FUN_ATTR uint16_t add16(uint16_t x, uint16_t y) {
  return x + y;
}

SCALAR_FUN_ATTR uint32_t add32(uint32_t x, uint32_t y) {
  return x + y;
}

SCALAR_FUN_ATTR uint64_t add64(uint64_t x, uint64_t y) {
  return x + y;
}

SCALAR_FUN_ATTR uint8_t sub8(uint8_t x, uint8_t y) {
  return x - y;
}

SCALAR_FUN_ATTR uint16_t sub16(uint16_t x, uint16_t y) {
  return x - y;
}

SCALAR_FUN_ATTR uint32_t sub32(uint32_t x, uint32_t y) {
  return x - y;
}

SCALAR_FUN_ATTR uint64_t sub64(uint64_t x, uint64_t y) {
  return x - y;
}

SCALAR_FUN_ATTR uint8_t mul8(uint8_t x, uint8_t y) {
  return x * y;
}

SCALAR_FUN_ATTR uint16_t mul16(uint16_t x, uint16_t y) {
  return x * y;
}

SCALAR_FUN_ATTR uint32_t mul32(uint32_t x, uint32_t y) {
  return x * y;
}

SCALAR_FUN_ATTR uint64_t mul64(uint64_t x, uint64_t y) {
  return x * y;
}

#if ISPC

SCALAR_FUN_ATTR uint8_t udiv8(uint8_t x, uint8_t y) {
  // This strange pattern is used to prevent the ISPC compiler from
  // causing SIGFPEs and bogus results on divisions where inactive lanes
  // have 0-valued divisors. It ensures that any inactive lane instead
  // has a divisor of 1. https://github.com/ispc/ispc/issues/2292
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR uint16_t udiv16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR uint32_t udiv32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }


  return x / ys;
}

SCALAR_FUN_ATTR uint64_t udiv64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }


  return x / ys;
}

SCALAR_FUN_ATTR uint8_t udiv_up8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }


  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint16_t udiv_up16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint32_t udiv_up32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint64_t udiv_up64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint8_t umod8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR uint16_t umod16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }


  return x % ys;
}

SCALAR_FUN_ATTR uint32_t umod32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR uint64_t umod64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint8_t umod_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR uint16_t umod_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR uint32_t umod_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR uint64_t umod_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int8_t sdiv8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int8_t q = x / ys;
  int8_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int16_t sdiv16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int16_t q = x / ys;
  int16_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int32_t sdiv32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  int32_t q = x / ys;
  int32_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int64_t sdiv64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int64_t q = x / ys;
  int64_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

SCALAR_FUN_ATTR int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

SCALAR_FUN_ATTR int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

SCALAR_FUN_ATTR int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

SCALAR_FUN_ATTR int8_t smod8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int8_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int16_t smod16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int16_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int32_t smod32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int32_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int64_t smod64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int64_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

SCALAR_FUN_ATTR int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

SCALAR_FUN_ATTR int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

SCALAR_FUN_ATTR int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

SCALAR_FUN_ATTR int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

SCALAR_FUN_ATTR int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

SCALAR_FUN_ATTR int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

SCALAR_FUN_ATTR int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

SCALAR_FUN_ATTR int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

SCALAR_FUN_ATTR int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

SCALAR_FUN_ATTR int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

SCALAR_FUN_ATTR int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

SCALAR_FUN_ATTR int8_t squot8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR int16_t squot16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR int32_t squot32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR int64_t squot64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR int8_t srem8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR int16_t srem16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR int32_t srem32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR int64_t srem64(int64_t x, int64_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR int8_t squot_safe8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int16_t squot_safe16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int32_t squot_safe32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int64_t squot_safe64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int8_t srem_safe8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int16_t srem_safe16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int32_t srem_safe32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int64_t srem_safe64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

#else

SCALAR_FUN_ATTR uint8_t udiv8(uint8_t x, uint8_t y) {
  return x / y;
}

SCALAR_FUN_ATTR uint16_t udiv16(uint16_t x, uint16_t y) {
  return x / y;
}

SCALAR_FUN_ATTR uint32_t udiv32(uint32_t x, uint32_t y) {
  return x / y;
}

SCALAR_FUN_ATTR uint64_t udiv64(uint64_t x, uint64_t y) {
  return x / y;
}

SCALAR_FUN_ATTR uint8_t udiv_up8(uint8_t x, uint8_t y) {
  return (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint16_t udiv_up16(uint16_t x, uint16_t y) {
  return (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint32_t udiv_up32(uint32_t x, uint32_t y) {
  return (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint64_t udiv_up64(uint64_t x, uint64_t y) {
  return (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint8_t umod8(uint8_t x, uint8_t y) {
  return x % y;
}

SCALAR_FUN_ATTR uint16_t umod16(uint16_t x, uint16_t y) {
  return x % y;
}

SCALAR_FUN_ATTR uint32_t umod32(uint32_t x, uint32_t y) {
  return x % y;
}

SCALAR_FUN_ATTR uint64_t umod64(uint64_t x, uint64_t y) {
  return x % y;
}

SCALAR_FUN_ATTR uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint8_t umod_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR uint16_t umod_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR uint32_t umod_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR uint64_t umod_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR int8_t sdiv8(int8_t x, int8_t y) {
  int8_t q = x / y;
  int8_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int16_t sdiv16(int16_t x, int16_t y) {
  int16_t q = x / y;
  int16_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int32_t sdiv32(int32_t x, int32_t y) {
  int32_t q = x / y;
  int32_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int64_t sdiv64(int64_t x, int64_t y) {
  int64_t q = x / y;
  int64_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

SCALAR_FUN_ATTR int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

SCALAR_FUN_ATTR int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

SCALAR_FUN_ATTR int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

SCALAR_FUN_ATTR int8_t smod8(int8_t x, int8_t y) {
  int8_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int16_t smod16(int16_t x, int16_t y) {
  int16_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int32_t smod32(int32_t x, int32_t y) {
  int32_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int64_t smod64(int64_t x, int64_t y) {
  int64_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

SCALAR_FUN_ATTR int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

SCALAR_FUN_ATTR int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

SCALAR_FUN_ATTR int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

SCALAR_FUN_ATTR int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

SCALAR_FUN_ATTR int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

SCALAR_FUN_ATTR int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

SCALAR_FUN_ATTR int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

SCALAR_FUN_ATTR int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

SCALAR_FUN_ATTR int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

SCALAR_FUN_ATTR int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

SCALAR_FUN_ATTR int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

SCALAR_FUN_ATTR int8_t squot8(int8_t x, int8_t y) {
  return x / y;
}

SCALAR_FUN_ATTR int16_t squot16(int16_t x, int16_t y) {
  return x / y;
}

SCALAR_FUN_ATTR int32_t squot32(int32_t x, int32_t y) {
  return x / y;
}

SCALAR_FUN_ATTR int64_t squot64(int64_t x, int64_t y) {
  return x / y;
}

SCALAR_FUN_ATTR int8_t srem8(int8_t x, int8_t y) {
  return x % y;
}

SCALAR_FUN_ATTR int16_t srem16(int16_t x, int16_t y) {
  return x % y;
}

SCALAR_FUN_ATTR int32_t srem32(int32_t x, int32_t y) {
  return x % y;
}

SCALAR_FUN_ATTR int64_t srem64(int64_t x, int64_t y) {
  return x % y;
}

SCALAR_FUN_ATTR int8_t squot_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR int16_t squot_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR int32_t squot_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR int64_t squot_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR int8_t srem_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR int16_t srem_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR int32_t srem_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR int64_t srem_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x % y;
}

#endif

SCALAR_FUN_ATTR int8_t smin8(int8_t x, int8_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR int16_t smin16(int16_t x, int16_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR int32_t smin32(int32_t x, int32_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR int64_t smin64(int64_t x, int64_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR uint8_t umin8(uint8_t x, uint8_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR uint16_t umin16(uint16_t x, uint16_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR uint32_t umin32(uint32_t x, uint32_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR uint64_t umin64(uint64_t x, uint64_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR int8_t smax8(int8_t x, int8_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR int16_t smax16(int16_t x, int16_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR int32_t smax32(int32_t x, int32_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR int64_t smax64(int64_t x, int64_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint8_t umax8(uint8_t x, uint8_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint16_t umax16(uint16_t x, uint16_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint32_t umax32(uint32_t x, uint32_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint64_t umax64(uint64_t x, uint64_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint8_t shl8(uint8_t x, uint8_t y) {
  return (uint8_t)(x << y);
}

SCALAR_FUN_ATTR uint16_t shl16(uint16_t x, uint16_t y) {
  return (uint16_t)(x << y);
}

SCALAR_FUN_ATTR uint32_t shl32(uint32_t x, uint32_t y) {
  return x << y;
}

SCALAR_FUN_ATTR uint64_t shl64(uint64_t x, uint64_t y) {
  return x << y;
}

SCALAR_FUN_ATTR uint8_t lshr8(uint8_t x, uint8_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR uint16_t lshr16(uint16_t x, uint16_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR uint32_t lshr32(uint32_t x, uint32_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR uint64_t lshr64(uint64_t x, uint64_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR int8_t ashr8(int8_t x, int8_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR int16_t ashr16(int16_t x, int16_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR int32_t ashr32(int32_t x, int32_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR int64_t ashr64(int64_t x, int64_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR uint8_t and8(uint8_t x, uint8_t y) {
  return x & y;
}

SCALAR_FUN_ATTR uint16_t and16(uint16_t x, uint16_t y) {
  return x & y;
}

SCALAR_FUN_ATTR uint32_t and32(uint32_t x, uint32_t y) {
  return x & y;
}

SCALAR_FUN_ATTR uint64_t and64(uint64_t x, uint64_t y) {
  return x & y;
}

SCALAR_FUN_ATTR uint8_t or8(uint8_t x, uint8_t y) {
  return x | y;
}

SCALAR_FUN_ATTR uint16_t or16(uint16_t x, uint16_t y) {
  return x | y;
}

SCALAR_FUN_ATTR uint32_t or32(uint32_t x, uint32_t y) {
  return x | y;
}

SCALAR_FUN_ATTR uint64_t or64(uint64_t x, uint64_t y) {
  return x | y;
}

SCALAR_FUN_ATTR uint8_t xor8(uint8_t x, uint8_t y) {
  return x ^ y;
}

SCALAR_FUN_ATTR uint16_t xor16(uint16_t x, uint16_t y) {
  return x ^ y;
}

SCALAR_FUN_ATTR uint32_t xor32(uint32_t x, uint32_t y) {
  return x ^ y;
}

SCALAR_FUN_ATTR uint64_t xor64(uint64_t x, uint64_t y) {
  return x ^ y;
}

SCALAR_FUN_ATTR bool ult8(uint8_t x, uint8_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool ult16(uint16_t x, uint16_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool ult32(uint32_t x, uint32_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool ult64(uint64_t x, uint64_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool ule8(uint8_t x, uint8_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool ule16(uint16_t x, uint16_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool ule32(uint32_t x, uint32_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool ule64(uint64_t x, uint64_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool slt8(int8_t x, int8_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool slt16(int16_t x, int16_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool slt32(int32_t x, int32_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool slt64(int64_t x, int64_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool sle8(int8_t x, int8_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool sle16(int16_t x, int16_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool sle32(int32_t x, int32_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool sle64(int64_t x, int64_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR uint8_t pow8(uint8_t x, uint8_t y) {
  uint8_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR uint16_t pow16(uint16_t x, uint16_t y) {
  uint16_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR uint32_t pow32(uint32_t x, uint32_t y) {
  uint32_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR uint64_t pow64(uint64_t x, uint64_t y) {
  uint64_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR bool itob_i8_bool(int8_t x) {
  return x != 0;
}

SCALAR_FUN_ATTR bool itob_i16_bool(int16_t x) {
  return x != 0;
}

SCALAR_FUN_ATTR bool itob_i32_bool(int32_t x) {
  return x != 0;
}

SCALAR_FUN_ATTR bool itob_i64_bool(int64_t x) {
  return x != 0;
}

SCALAR_FUN_ATTR int8_t btoi_bool_i8(bool x) {
  return x;
}

SCALAR_FUN_ATTR int16_t btoi_bool_i16(bool x) {
  return x;
}

SCALAR_FUN_ATTR int32_t btoi_bool_i32(bool x) {
  return x;
}

SCALAR_FUN_ATTR int64_t btoi_bool_i64(bool x) {
  return x;
}

#define sext_i8_i8(x) ((int8_t) (int8_t) (x))
#define sext_i8_i16(x) ((int16_t) (int8_t) (x))
#define sext_i8_i32(x) ((int32_t) (int8_t) (x))
#define sext_i8_i64(x) ((int64_t) (int8_t) (x))
#define sext_i16_i8(x) ((int8_t) (int16_t) (x))
#define sext_i16_i16(x) ((int16_t) (int16_t) (x))
#define sext_i16_i32(x) ((int32_t) (int16_t) (x))
#define sext_i16_i64(x) ((int64_t) (int16_t) (x))
#define sext_i32_i8(x) ((int8_t) (int32_t) (x))
#define sext_i32_i16(x) ((int16_t) (int32_t) (x))
#define sext_i32_i32(x) ((int32_t) (int32_t) (x))
#define sext_i32_i64(x) ((int64_t) (int32_t) (x))
#define sext_i64_i8(x) ((int8_t) (int64_t) (x))
#define sext_i64_i16(x) ((int16_t) (int64_t) (x))
#define sext_i64_i32(x) ((int32_t) (int64_t) (x))
#define sext_i64_i64(x) ((int64_t) (int64_t) (x))
#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))
#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))
#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))
#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))
#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))
#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))
#define zext_i16_i32(x) ((int32_t) (uint16_t) (x))
#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))
#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))
#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))
#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))
#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))
#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))
#define zext_i64_i16(x) ((int16_t) (uint64_t) (x))
#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))
#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))

SCALAR_FUN_ATTR int8_t abs8(int8_t x) {
  return (int8_t)abs(x);
}

SCALAR_FUN_ATTR int16_t abs16(int16_t x) {
  return (int16_t)abs(x);
}

SCALAR_FUN_ATTR int32_t abs32(int32_t x) {
  return abs(x);
}

SCALAR_FUN_ATTR int64_t abs64(int64_t x) {
#if defined(__OPENCL_VERSION__) || defined(ISPC)
  return abs(x);
#else
  return llabs(x);
#endif
}

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR int32_t futrts_popc8(int8_t x) {
  return popcount(x);
}

SCALAR_FUN_ATTR int32_t futrts_popc16(int16_t x) {
  return popcount(x);
}

SCALAR_FUN_ATTR int32_t futrts_popc32(int32_t x) {
  return popcount(x);
}

SCALAR_FUN_ATTR int32_t futrts_popc64(int64_t x) {
  return popcount(x);
}
#elif defined(__CUDA_ARCH__)

SCALAR_FUN_ATTR int32_t futrts_popc8(int8_t x) {
  return __popc(zext_i8_i32(x));
}

SCALAR_FUN_ATTR int32_t futrts_popc16(int16_t x) {
  return __popc(zext_i16_i32(x));
}

SCALAR_FUN_ATTR int32_t futrts_popc32(int32_t x) {
  return __popc(x);
}

SCALAR_FUN_ATTR int32_t futrts_popc64(int64_t x) {
  return __popcll(x);
}

#else // Not OpenCL or CUDA, but plain C.

SCALAR_FUN_ATTR int32_t futrts_popc8(uint8_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

SCALAR_FUN_ATTR int32_t futrts_popc16(uint16_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

SCALAR_FUN_ATTR int32_t futrts_popc32(uint32_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

SCALAR_FUN_ATTR int32_t futrts_popc64(uint64_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR uint8_t  futrts_umul_hi8 ( uint8_t a,  uint8_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint8_t  futrts_smul_hi8 ( int8_t a,  int8_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint16_t futrts_smul_hi16(int16_t a, int16_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return mul_hi(a, b); }
#elif defined(__CUDA_ARCH__)
SCALAR_FUN_ATTR  uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return __umulhi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return __umul64hi(a, b); }
SCALAR_FUN_ATTR  uint8_t futrts_smul_hi8 ( int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return __mulhi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return __mul64hi(a, b); }
#elif ISPC
SCALAR_FUN_ATTR uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) {
  uint64_t ah = a >> 32;
  uint64_t al = a & 0xffffffff;
  uint64_t bh = b >> 32;
  uint64_t bl = b & 0xffffffff;

  uint64_t p1 = al * bl;
  uint64_t p2 = al * bh;
  uint64_t p3 = ah * bl;
  uint64_t p4 = ah * bh;

  uint64_t p1h = p1 >> 32;
  uint64_t p2h = p2 >> 32;
  uint64_t p3h = p3 >> 32;
  uint64_t p2l = p2 & 0xffffffff;
  uint64_t p3l = p3 & 0xffffffff;

  uint64_t l = p1h + p2l + p3l;
  uint64_t m = (p2 >> 32) + (p3 >> 32);
  uint64_t h = (l >> 32) + m + p4;

  return h;
}
SCALAR_FUN_ATTR  int8_t futrts_smul_hi8 ( int8_t a,  int8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
SCALAR_FUN_ATTR int64_t futrts_smul_hi64(int64_t a, int64_t b) {
  uint64_t ah = a >> 32;
  uint64_t al = a & 0xffffffff;
  uint64_t bh = b >> 32;
  uint64_t bl = b & 0xffffffff;

  uint64_t p1 =  al * bl;
  int64_t  p2 = al * bh;
  int64_t  p3 = ah * bl;
  uint64_t p4 =  ah * bh;

  uint64_t p1h = p1 >> 32;
  uint64_t p2h = p2 >> 32;
  uint64_t p3h = p3 >> 32;
  uint64_t p2l = p2 & 0xffffffff;
  uint64_t p3l = p3 & 0xffffffff;

  uint64_t l = p1h + p2l + p3l;
  uint64_t m = (p2 >> 32) + (p3 >> 32);
  uint64_t h = (l >> 32) + m + p4;

  return h;
}

#else // Not OpenCL, ISPC, or CUDA, but plain C.
SCALAR_FUN_ATTR uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return ((__uint128_t)a) * ((__uint128_t)b) >> 64; }
SCALAR_FUN_ATTR int8_t futrts_smul_hi8(int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }
SCALAR_FUN_ATTR int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }
SCALAR_FUN_ATTR int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((int64_t)a) * ((int64_t)b) >> 32; }
SCALAR_FUN_ATTR int64_t futrts_smul_hi64(int64_t a, int64_t b) { return ((__int128_t)a) * ((__int128_t)b) >> 64; }
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR  uint8_t futrts_umad_hi8 ( uint8_t a,  uint8_t b,  uint8_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR  uint8_t futrts_smad_hi8( int8_t a,  int8_t b,   int8_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return mad_hi(a, b, c); }
#else // Not OpenCL

SCALAR_FUN_ATTR  uint8_t futrts_umad_hi8( uint8_t a,  uint8_t b,  uint8_t c) { return futrts_umul_hi8(a, b) + c; }
SCALAR_FUN_ATTR uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return futrts_umul_hi16(a, b) + c; }
SCALAR_FUN_ATTR uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return futrts_umul_hi32(a, b) + c; }
SCALAR_FUN_ATTR uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return futrts_umul_hi64(a, b) + c; }
SCALAR_FUN_ATTR  uint8_t futrts_smad_hi8 ( int8_t a,  int8_t b,  int8_t c) { return futrts_smul_hi8(a, b) + c; }
SCALAR_FUN_ATTR uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return futrts_smul_hi16(a, b) + c; }
SCALAR_FUN_ATTR uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return futrts_smul_hi32(a, b) + c; }
SCALAR_FUN_ATTR uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return futrts_smul_hi64(a, b) + c; }
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR int32_t futrts_clzz8(int8_t x) {
  return clz(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) {
  return clz(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) {
  return clz(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) {
  return clz(x);
}

#elif defined(__CUDA_ARCH__)

SCALAR_FUN_ATTR int32_t futrts_clzz8(int8_t x) {
  return __clz(zext_i8_i32(x)) - 24;
}

SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) {
  return __clz(zext_i16_i32(x)) - 16;
}

SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) {
  return __clz(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) {
  return __clzll(x);
}

#elif ISPC

SCALAR_FUN_ATTR int32_t futrts_clzz8(int8_t x) {
  return count_leading_zeros((int32_t)(uint8_t)x)-24;
}

SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) {
  return count_leading_zeros((int32_t)(uint16_t)x)-16;
}

SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) {
  return count_leading_zeros(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) {
  return count_leading_zeros(x);
}

#else // Not OpenCL, ISPC or CUDA, but plain C.

SCALAR_FUN_ATTR int32_t futrts_clzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24;
}

SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16;
}

SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_clz((uint32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_clzll((uint64_t)x);
}
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  int i = 0;
  for (; i < 8 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  int i = 0;
  for (; i < 16 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  int i = 0;
  for (; i < 32 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  int i = 0;
  for (; i < 64 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

#elif defined(__CUDA_ARCH__)

SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  int y = __ffs(x);
  return y == 0 ? 8 : y - 1;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  int y = __ffs(x);
  return y == 0 ? 16 : y - 1;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  int y = __ffs(x);
  return y == 0 ? 32 : y - 1;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  int y = __ffsll(x);
  return y == 0 ? 64 : y - 1;
}

#elif ISPC

SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : count_trailing_zeros((int32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : count_trailing_zeros((int32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  return count_trailing_zeros(x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  return count_trailing_zeros(x);
}

#else // Not OpenCL or CUDA, but plain C.

SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_ctz((uint32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_ctz((uint32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_ctz((uint32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_ctzll((uint64_t)x);
}
#endif

SCALAR_FUN_ATTR float fdiv32(float x, float y) {
  return x / y;
}

SCALAR_FUN_ATTR float fadd32(float x, float y) {
  return x + y;
}

SCALAR_FUN_ATTR float fsub32(float x, float y) {
  return x - y;
}

SCALAR_FUN_ATTR float fmul32(float x, float y) {
  return x * y;
}

SCALAR_FUN_ATTR bool cmplt32(float x, float y) {
  return x < y;
}

SCALAR_FUN_ATTR bool cmple32(float x, float y) {
  return x <= y;
}

SCALAR_FUN_ATTR float sitofp_i8_f32(int8_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float sitofp_i16_f32(int16_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float sitofp_i32_f32(int32_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float sitofp_i64_f32(int64_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float uitofp_i8_f32(uint8_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float uitofp_i16_f32(uint16_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float uitofp_i32_f32(uint32_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float uitofp_i64_f32(uint64_t x) {
  return (float) x;
}

#ifdef __OPENCL_VERSION__
SCALAR_FUN_ATTR float fabs32(float x) {
  return fabs(x);
}

SCALAR_FUN_ATTR float fmax32(float x, float y) {
  return fmax(x, y);
}

SCALAR_FUN_ATTR float fmin32(float x, float y) {
  return fmin(x, y);
}

SCALAR_FUN_ATTR float fpow32(float x, float y) {
  return pow(x, y);
}

#elif ISPC

SCALAR_FUN_ATTR float fabs32(float x) {
  return abs(x);
}

SCALAR_FUN_ATTR float fmax32(float x, float y) {
  return isnan(x) ? y : isnan(y) ? x : max(x, y);
}

SCALAR_FUN_ATTR float fmin32(float x, float y) {
  return isnan(x) ? y : isnan(y) ? x : min(x, y);
}

SCALAR_FUN_ATTR float fpow32(float a, float b) {
  float ret;
  foreach_active (i) {
      uniform float r = __stdlib_powf(extract(a, i), extract(b, i));
      ret = insert(ret, i, r);
  }
  return ret;
}

#else // Not OpenCL, but CUDA or plain C.

SCALAR_FUN_ATTR float fabs32(float x) {
  return fabsf(x);
}

SCALAR_FUN_ATTR float fmax32(float x, float y) {
  return fmaxf(x, y);
}

SCALAR_FUN_ATTR float fmin32(float x, float y) {
  return fminf(x, y);
}

SCALAR_FUN_ATTR float fpow32(float x, float y) {
  return powf(x, y);
}
#endif

SCALAR_FUN_ATTR bool futrts_isnan32(float x) {
  return isnan(x);
}

#if ISPC

SCALAR_FUN_ATTR bool futrts_isinf32(float x) {
  return !isnan(x) && isnan(x - x);
}

SCALAR_FUN_ATTR bool futrts_isfinite32(float x) {
  return !isnan(x) && !futrts_isinf32(x);
}

#else

SCALAR_FUN_ATTR bool futrts_isinf32(float x) {
  return isinf(x);
}

#endif

SCALAR_FUN_ATTR int8_t fptosi_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

SCALAR_FUN_ATTR int16_t fptosi_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

SCALAR_FUN_ATTR int32_t fptosi_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

SCALAR_FUN_ATTR int64_t fptosi_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int64_t) x;
  };
}

SCALAR_FUN_ATTR uint8_t fptoui_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

SCALAR_FUN_ATTR uint16_t fptoui_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

SCALAR_FUN_ATTR uint32_t fptoui_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

SCALAR_FUN_ATTR uint64_t fptoui_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

SCALAR_FUN_ATTR bool ftob_f32_bool(float x) {
  return x != 0;
}

SCALAR_FUN_ATTR float btof_bool_f32(bool x) {
  return x ? 1 : 0;
}

#ifdef __OPENCL_VERSION__
SCALAR_FUN_ATTR float futrts_log32(float x) {
  return log(x);
}

SCALAR_FUN_ATTR float futrts_log2_32(float x) {
  return log2(x);
}

SCALAR_FUN_ATTR float futrts_log10_32(float x) {
  return log10(x);
}

SCALAR_FUN_ATTR float futrts_log1p_32(float x) {
  return log1p(x);
}

SCALAR_FUN_ATTR float futrts_sqrt32(float x) {
  return sqrt(x);
}

SCALAR_FUN_ATTR float futrts_cbrt32(float x) {
  return cbrt(x);
}

SCALAR_FUN_ATTR float futrts_exp32(float x) {
  return exp(x);
}

SCALAR_FUN_ATTR float futrts_cos32(float x) {
  return cos(x);
}

SCALAR_FUN_ATTR float futrts_sin32(float x) {
  return sin(x);
}

SCALAR_FUN_ATTR float futrts_tan32(float x) {
  return tan(x);
}

SCALAR_FUN_ATTR float futrts_acos32(float x) {
  return acos(x);
}

SCALAR_FUN_ATTR float futrts_asin32(float x) {
  return asin(x);
}

SCALAR_FUN_ATTR float futrts_atan32(float x) {
  return atan(x);
}

SCALAR_FUN_ATTR float futrts_cosh32(float x) {
  return cosh(x);
}

SCALAR_FUN_ATTR float futrts_sinh32(float x) {
  return sinh(x);
}

SCALAR_FUN_ATTR float futrts_tanh32(float x) {
  return tanh(x);
}

SCALAR_FUN_ATTR float futrts_acosh32(float x) {
  return acosh(x);
}

SCALAR_FUN_ATTR float futrts_asinh32(float x) {
  return asinh(x);
}

SCALAR_FUN_ATTR float futrts_atanh32(float x) {
  return atanh(x);
}

SCALAR_FUN_ATTR float futrts_atan2_32(float x, float y) {
  return atan2(x, y);
}

SCALAR_FUN_ATTR float futrts_hypot32(float x, float y) {
  return hypot(x, y);
}

SCALAR_FUN_ATTR float futrts_gamma32(float x) {
  return tgamma(x);
}

SCALAR_FUN_ATTR float futrts_lgamma32(float x) {
  return lgamma(x);
}

SCALAR_FUN_ATTR float futrts_erf32(float x) {
  return erf(x);
}

SCALAR_FUN_ATTR float futrts_erfc32(float x) {
  return erfc(x);
}

SCALAR_FUN_ATTR float fmod32(float x, float y) {
  return fmod(x, y);
}

SCALAR_FUN_ATTR float futrts_round32(float x) {
  return rint(x);
}

SCALAR_FUN_ATTR float futrts_floor32(float x) {
  return floor(x);
}

SCALAR_FUN_ATTR float futrts_ceil32(float x) {
  return ceil(x);
}

SCALAR_FUN_ATTR float futrts_nextafter32(float x, float y) {
  return nextafter(x, y);
}

SCALAR_FUN_ATTR float futrts_lerp32(float v0, float v1, float t) {
  return mix(v0, v1, t);
}

SCALAR_FUN_ATTR float futrts_ldexp32(float x, int32_t y) {
  return ldexp(x, y);
}

SCALAR_FUN_ATTR float futrts_copysign32(float x, float y) {
  return copysign(x, y);
}

SCALAR_FUN_ATTR float futrts_mad32(float a, float b, float c) {
  return mad(a, b, c);
}

SCALAR_FUN_ATTR float futrts_fma32(float a, float b, float c) {
  return fma(a, b, c);
}

#elif ISPC

SCALAR_FUN_ATTR float futrts_log32(float x) {
  return futrts_isfinite32(x) || (futrts_isinf32(x) && x < 0)? log(x) : x;
}

SCALAR_FUN_ATTR float futrts_log2_32(float x) {
  return futrts_log32(x) / log(2.0f);
}

SCALAR_FUN_ATTR float futrts_log10_32(float x) {
  return futrts_log32(x) / log(10.0f);
}

SCALAR_FUN_ATTR float futrts_log1p_32(float x) {
  if(x == -1.0f || (futrts_isinf32(x) && x > 0.0f)) return x / 0.0f;
  float y = 1.0f + x;
  float z = y - 1.0f;
  return log(y) - (z-x)/y;
}

SCALAR_FUN_ATTR float futrts_sqrt32(float x) {
  return sqrt(x);
}

extern "C" unmasked uniform float cbrtf(uniform float);
SCALAR_FUN_ATTR float futrts_cbrt32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = cbrtf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR float futrts_exp32(float x) {
  return exp(x);
}

SCALAR_FUN_ATTR float futrts_cos32(float x) {
  return cos(x);
}

SCALAR_FUN_ATTR float futrts_sin32(float x) {
  return sin(x);
}

SCALAR_FUN_ATTR float futrts_tan32(float x) {
  return tan(x);
}

SCALAR_FUN_ATTR float futrts_acos32(float x) {
  return acos(x);
}

SCALAR_FUN_ATTR float futrts_asin32(float x) {
  return asin(x);
}

SCALAR_FUN_ATTR float futrts_atan32(float x) {
  return atan(x);
}

SCALAR_FUN_ATTR float futrts_cosh32(float x) {
  return (exp(x)+exp(-x)) / 2.0f;
}

SCALAR_FUN_ATTR float futrts_sinh32(float x) {
  return (exp(x)-exp(-x)) / 2.0f;
}

SCALAR_FUN_ATTR float futrts_tanh32(float x) {
  return futrts_sinh32(x)/futrts_cosh32(x);
}

SCALAR_FUN_ATTR float futrts_acosh32(float x) {
  float f = x+sqrt(x*x-1);
  if(futrts_isfinite32(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR float futrts_asinh32(float x) {
  float f = x+sqrt(x*x+1);
  if(futrts_isfinite32(f)) return log(f);
  return f;

}

SCALAR_FUN_ATTR float futrts_atanh32(float x) {
  float f = (1+x)/(1-x);
  if(futrts_isfinite32(f)) return log(f)/2.0f;
  return f;

}

SCALAR_FUN_ATTR float futrts_atan2_32(float x, float y) {
  return (x == 0.0f && y == 0.0f) ? 0.0f : atan2(x, y);
}

SCALAR_FUN_ATTR float futrts_hypot32(float x, float y) {
  if (futrts_isfinite32(x) && futrts_isfinite32(y)) {
    x = abs(x);
    y = abs(y);
    float a;
    float b;
    if (x >= y){
        a = x;
        b = y;
    } else {
        a = y;
        b = x;
    }
    if(b == 0){
      return a;
    }

    int e;
    float an;
    float bn;
    an = frexp (a, &e);
    bn = ldexp (b, - e);
    float cn;
    cn = sqrt (an * an + bn * bn);
    return ldexp (cn, e);
  } else {
    if (futrts_isinf32(x) || futrts_isinf32(y)) return INFINITY;
    else return x + y;
  }

}

extern "C" unmasked uniform float tgammaf(uniform float x);
SCALAR_FUN_ATTR float futrts_gamma32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = tgammaf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float lgammaf(uniform float x);
SCALAR_FUN_ATTR float futrts_lgamma32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = lgammaf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float erff(uniform float x);
SCALAR_FUN_ATTR float futrts_erf32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = erff(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float erfcf(uniform float x);
SCALAR_FUN_ATTR float futrts_erfc32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = erfcf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR float fmod32(float x, float y) {
  return x - y * trunc(x/y);
}

SCALAR_FUN_ATTR float futrts_round32(float x) {
  return round(x);
}

SCALAR_FUN_ATTR float futrts_floor32(float x) {
  return floor(x);
}

SCALAR_FUN_ATTR float futrts_ceil32(float x) {
  return ceil(x);
}

extern "C" unmasked uniform float nextafterf(uniform float x, uniform float y);
SCALAR_FUN_ATTR float futrts_nextafter32(float x, float y) {
  float res;
  foreach_active (i) {
    uniform float r = nextafterf(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR float futrts_ldexp32(float x, int32_t y) {
  return x * pow((double)2.0, (double)y);
}

SCALAR_FUN_ATTR float futrts_copysign32(float x, float y) {
  int32_t xb = futrts_to_bits32(x);
  int32_t yb = futrts_to_bits32(y);
  return futrts_from_bits32((xb & ~(1<<31)) | (yb & (1<<31)));
}

SCALAR_FUN_ATTR float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

SCALAR_FUN_ATTR float futrts_fma32(float a, float b, float c) {
  return a * b + c;
}

#else // Not OpenCL or ISPC, but CUDA or plain C.

SCALAR_FUN_ATTR float futrts_log32(float x) {
  return logf(x);
}

SCALAR_FUN_ATTR float futrts_log2_32(float x) {
  return log2f(x);
}

SCALAR_FUN_ATTR float futrts_log10_32(float x) {
  return log10f(x);
}

SCALAR_FUN_ATTR float futrts_log1p_32(float x) {
  return log1pf(x);
}

SCALAR_FUN_ATTR float futrts_sqrt32(float x) {
  return sqrtf(x);
}

SCALAR_FUN_ATTR float futrts_cbrt32(float x) {
  return cbrtf(x);
}

SCALAR_FUN_ATTR float futrts_exp32(float x) {
  return expf(x);
}

SCALAR_FUN_ATTR float futrts_cos32(float x) {
  return cosf(x);
}

SCALAR_FUN_ATTR float futrts_sin32(float x) {
  return sinf(x);
}

SCALAR_FUN_ATTR float futrts_tan32(float x) {
  return tanf(x);
}

SCALAR_FUN_ATTR float futrts_acos32(float x) {
  return acosf(x);
}

SCALAR_FUN_ATTR float futrts_asin32(float x) {
  return asinf(x);
}

SCALAR_FUN_ATTR float futrts_atan32(float x) {
  return atanf(x);
}

SCALAR_FUN_ATTR float futrts_cosh32(float x) {
  return coshf(x);
}

SCALAR_FUN_ATTR float futrts_sinh32(float x) {
  return sinhf(x);
}

SCALAR_FUN_ATTR float futrts_tanh32(float x) {
  return tanhf(x);
}

SCALAR_FUN_ATTR float futrts_acosh32(float x) {
  return acoshf(x);
}

SCALAR_FUN_ATTR float futrts_asinh32(float x) {
  return asinhf(x);
}

SCALAR_FUN_ATTR float futrts_atanh32(float x) {
  return atanhf(x);
}

SCALAR_FUN_ATTR float futrts_atan2_32(float x, float y) {
  return atan2f(x, y);
}

SCALAR_FUN_ATTR float futrts_hypot32(float x, float y) {
  return hypotf(x, y);
}

SCALAR_FUN_ATTR float futrts_gamma32(float x) {
  return tgammaf(x);
}

SCALAR_FUN_ATTR float futrts_lgamma32(float x) {
  return lgammaf(x);
}

SCALAR_FUN_ATTR float futrts_erf32(float x) {
  return erff(x);
}

SCALAR_FUN_ATTR float futrts_erfc32(float x) {
  return erfcf(x);
}

SCALAR_FUN_ATTR float fmod32(float x, float y) {
  return fmodf(x, y);
}

SCALAR_FUN_ATTR float futrts_round32(float x) {
  return rintf(x);
}

SCALAR_FUN_ATTR float futrts_floor32(float x) {
  return floorf(x);
}

SCALAR_FUN_ATTR float futrts_ceil32(float x) {
  return ceilf(x);
}

SCALAR_FUN_ATTR float futrts_nextafter32(float x, float y) {
  return nextafterf(x, y);
}

SCALAR_FUN_ATTR float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR float futrts_ldexp32(float x, int32_t y) {
  return ldexpf(x, y);
}

SCALAR_FUN_ATTR float futrts_copysign32(float x, float y) {
  return copysignf(x, y);
}

SCALAR_FUN_ATTR float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

SCALAR_FUN_ATTR float futrts_fma32(float a, float b, float c) {
  return fmaf(a, b, c);
}
#endif

#if ISPC
SCALAR_FUN_ATTR int32_t futrts_to_bits32(float x) {
  return intbits(x);
}

SCALAR_FUN_ATTR float futrts_from_bits32(int32_t x) {
  return floatbits(x);
}
#else
SCALAR_FUN_ATTR int32_t futrts_to_bits32(float x) {
  union {
    float f;
    int32_t t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR float futrts_from_bits32(int32_t x) {
  union {
    int32_t f;
    float t;
  } p;

  p.f = x;
  return p.t;
}
#endif

SCALAR_FUN_ATTR float fsignum32(float x) {
  return futrts_isnan32(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0);
}

#ifdef FUTHARK_F64_ENABLED

SCALAR_FUN_ATTR double futrts_from_bits64(int64_t x);
SCALAR_FUN_ATTR int64_t futrts_to_bits64(double x);

#if ISPC
SCALAR_FUN_ATTR bool futrts_isinf64(float x) {
  return !isnan(x) && isnan(x - x);
}

SCALAR_FUN_ATTR bool futrts_isfinite64(float x) {
  return !isnan(x) && !futrts_isinf64(x);
}

SCALAR_FUN_ATTR double fdiv64(double x, double y) {
  return x / y;
}

SCALAR_FUN_ATTR double fadd64(double x, double y) {
  return x + y;
}

SCALAR_FUN_ATTR double fsub64(double x, double y) {
  return x - y;
}

SCALAR_FUN_ATTR double fmul64(double x, double y) {
  return x * y;
}

SCALAR_FUN_ATTR bool cmplt64(double x, double y) {
  return x < y;
}

SCALAR_FUN_ATTR bool cmple64(double x, double y) {
  return x <= y;
}

SCALAR_FUN_ATTR double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double fabs64(double x) {
  return abs(x);
}

SCALAR_FUN_ATTR double fmax64(double x, double y) {
  return isnan(x) ? y : isnan(y) ? x : max(x, y);
}

SCALAR_FUN_ATTR double fmin64(double x, double y) {
  return isnan(x) ? y : isnan(y) ? x : min(x, y);
}

SCALAR_FUN_ATTR double fpow64(double a, double b) {
  float ret;
  foreach_active (i) {
      uniform float r = __stdlib_powf(extract(a, i), extract(b, i));
      ret = insert(ret, i, r);
  }
  return ret;
}

SCALAR_FUN_ATTR double futrts_log64(double x) {
  return futrts_isfinite64(x) || (futrts_isinf64(x) && x < 0)? log(x) : x;
}

SCALAR_FUN_ATTR double futrts_log2_64(double x) {
  return futrts_log64(x)/log(2.0d);
}

SCALAR_FUN_ATTR double futrts_log10_64(double x) {
  return futrts_log64(x)/log(10.0d);
}

SCALAR_FUN_ATTR double futrts_log1p_64(double x) {
  if(x == -1.0d || (futrts_isinf64(x) && x > 0.0d)) return x / 0.0d;
  double y = 1.0d + x;
  double z = y - 1.0d;
  return log(y) - (z-x)/y;
}

SCALAR_FUN_ATTR double futrts_sqrt64(double x) {
  return sqrt(x);
}

extern "C" unmasked uniform double cbrt(uniform double);
SCALAR_FUN_ATTR double futrts_cbrt64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = cbrtf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_exp64(double x) {
  return exp(x);
}

SCALAR_FUN_ATTR double futrts_cos64(double x) {
  return cos(x);
}

SCALAR_FUN_ATTR double futrts_sin64(double x) {
  return sin(x);
}

SCALAR_FUN_ATTR double futrts_tan64(double x) {
  return tan(x);
}

SCALAR_FUN_ATTR double futrts_acos64(double x) {
  return acos(x);
}

SCALAR_FUN_ATTR double futrts_asin64(double x) {
  return asin(x);
}

SCALAR_FUN_ATTR double futrts_atan64(double x) {
  return atan(x);
}

SCALAR_FUN_ATTR double futrts_cosh64(double x) {
  return (exp(x)+exp(-x)) / 2.0d;
}

SCALAR_FUN_ATTR double futrts_sinh64(double x) {
  return (exp(x)-exp(-x)) / 2.0d;
}

SCALAR_FUN_ATTR double futrts_tanh64(double x) {
  return futrts_sinh64(x)/futrts_cosh64(x);
}

SCALAR_FUN_ATTR double futrts_acosh64(double x) {
  double f = x+sqrt(x*x-1.0d);
  if(futrts_isfinite64(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR double futrts_asinh64(double x) {
  double f = x+sqrt(x*x+1.0d);
  if(futrts_isfinite64(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR double futrts_atanh64(double x) {
  double f = (1.0d+x)/(1.0d-x);
  if(futrts_isfinite64(f)) return log(f)/2.0d;
  return f;

}

SCALAR_FUN_ATTR double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

extern "C" unmasked uniform double hypot(uniform double x, uniform double y);
SCALAR_FUN_ATTR double futrts_hypot64(double x, double y) {
  double res;
  foreach_active (i) {
    uniform double r = hypot(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double tgamma(uniform double x);
SCALAR_FUN_ATTR double futrts_gamma64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = tgamma(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double lgamma(uniform double x);
SCALAR_FUN_ATTR double futrts_lgamma64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = lgamma(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double erf(uniform double x);
SCALAR_FUN_ATTR double futrts_erf64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = erf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double erfc(uniform double x);
SCALAR_FUN_ATTR double futrts_erfc64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = erfc(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_fma64(double a, double b, double c) {
  return a * b + c;
}

SCALAR_FUN_ATTR double futrts_round64(double x) {
  return round(x);
}

SCALAR_FUN_ATTR double futrts_ceil64(double x) {
  return ceil(x);
}

extern "C" unmasked uniform double nextafter(uniform float x, uniform double y);
SCALAR_FUN_ATTR float futrts_nextafter64(double x, double y) {
  double res;
  foreach_active (i) {
    uniform double r = nextafter(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_floor64(double x) {
  return floor(x);
}

SCALAR_FUN_ATTR bool futrts_isnan64(double x) {
  return isnan(x);
}

SCALAR_FUN_ATTR int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

SCALAR_FUN_ATTR int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

SCALAR_FUN_ATTR int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

SCALAR_FUN_ATTR int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

SCALAR_FUN_ATTR uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

SCALAR_FUN_ATTR uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

SCALAR_FUN_ATTR uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

SCALAR_FUN_ATTR uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

SCALAR_FUN_ATTR bool ftob_f64_bool(double x) {
  return x != 0.0;
}

SCALAR_FUN_ATTR double btof_bool_f64(bool x) {
  return x ? 1.0 : 0.0;
}

SCALAR_FUN_ATTR int64_t futrts_to_bits64(double x) {
  int64_t res;
  foreach_active (i) {
    uniform double tmp = extract(x, i);
    uniform int64_t r = *((uniform int64_t* uniform)&tmp);
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_from_bits64(int64_t x) {
  double res;
  foreach_active (i) {
    uniform int64_t tmp = extract(x, i);
    uniform double r = *((uniform double* uniform)&tmp);
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double fmod64(double x, double y) {
  return x - y * trunc(x/y);
}

SCALAR_FUN_ATTR double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0 ? 1.0d : 0.0d) - (x < 0 ? 1.0d : 0.0d);
}

SCALAR_FUN_ATTR double futrts_lerp64(double v0, double v1, double t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR double futrts_ldexp64(double x, int32_t y) {
  return x * pow((double)2.0, (double)y);
}

SCALAR_FUN_ATTR double futrts_copysign64(double x, double y) {
  int64_t xb = futrts_to_bits64(x);
  int64_t yb = futrts_to_bits64(y);
  return futrts_from_bits64((xb & ~(((int64_t)1)<<63)) | (yb & (((int64_t)1)<<63)));
}

SCALAR_FUN_ATTR double futrts_mad64(double a, double b, double c) {
  return a * b + c;
}

SCALAR_FUN_ATTR float fpconv_f32_f32(float x) {
  return (float) x;
}

SCALAR_FUN_ATTR double fpconv_f32_f64(float x) {
  return (double) x;
}

SCALAR_FUN_ATTR float fpconv_f64_f32(double x) {
  return (float) x;
}

SCALAR_FUN_ATTR double fpconv_f64_f64(double x) {
  return (double) x;
}

#else

SCALAR_FUN_ATTR double fdiv64(double x, double y) {
  return x / y;
}

SCALAR_FUN_ATTR double fadd64(double x, double y) {
  return x + y;
}

SCALAR_FUN_ATTR double fsub64(double x, double y) {
  return x - y;
}

SCALAR_FUN_ATTR double fmul64(double x, double y) {
  return x * y;
}

SCALAR_FUN_ATTR bool cmplt64(double x, double y) {
  return x < y;
}

SCALAR_FUN_ATTR bool cmple64(double x, double y) {
  return x <= y;
}

SCALAR_FUN_ATTR double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double fabs64(double x) {
  return fabs(x);
}

SCALAR_FUN_ATTR double fmax64(double x, double y) {
  return fmax(x, y);
}

SCALAR_FUN_ATTR double fmin64(double x, double y) {
  return fmin(x, y);
}

SCALAR_FUN_ATTR double fpow64(double x, double y) {
  return pow(x, y);
}

SCALAR_FUN_ATTR double futrts_log64(double x) {
  return log(x);
}

SCALAR_FUN_ATTR double futrts_log2_64(double x) {
  return log2(x);
}

SCALAR_FUN_ATTR double futrts_log10_64(double x) {
  return log10(x);
}

SCALAR_FUN_ATTR double futrts_log1p_64(double x) {
  return log1p(x);
}

SCALAR_FUN_ATTR double futrts_sqrt64(double x) {
  return sqrt(x);
}

SCALAR_FUN_ATTR double futrts_cbrt64(double x) {
  return cbrt(x);
}

SCALAR_FUN_ATTR double futrts_exp64(double x) {
  return exp(x);
}

SCALAR_FUN_ATTR double futrts_cos64(double x) {
  return cos(x);
}

SCALAR_FUN_ATTR double futrts_sin64(double x) {
  return sin(x);
}

SCALAR_FUN_ATTR double futrts_tan64(double x) {
  return tan(x);
}

SCALAR_FUN_ATTR double futrts_acos64(double x) {
  return acos(x);
}

SCALAR_FUN_ATTR double futrts_asin64(double x) {
  return asin(x);
}

SCALAR_FUN_ATTR double futrts_atan64(double x) {
  return atan(x);
}

SCALAR_FUN_ATTR double futrts_cosh64(double x) {
  return cosh(x);
}

SCALAR_FUN_ATTR double futrts_sinh64(double x) {
  return sinh(x);
}

SCALAR_FUN_ATTR double futrts_tanh64(double x) {
  return tanh(x);
}

SCALAR_FUN_ATTR double futrts_acosh64(double x) {
  return acosh(x);
}

SCALAR_FUN_ATTR double futrts_asinh64(double x) {
  return asinh(x);
}

SCALAR_FUN_ATTR double futrts_atanh64(double x) {
  return atanh(x);
}

SCALAR_FUN_ATTR double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

SCALAR_FUN_ATTR double futrts_hypot64(double x, double y) {
  return hypot(x, y);
}

SCALAR_FUN_ATTR double futrts_gamma64(double x) {
  return tgamma(x);
}

SCALAR_FUN_ATTR double futrts_lgamma64(double x) {
  return lgamma(x);
}

SCALAR_FUN_ATTR double futrts_erf64(double x) {
  return erf(x);
}

SCALAR_FUN_ATTR double futrts_erfc64(double x) {
  return erfc(x);
}

SCALAR_FUN_ATTR double futrts_fma64(double a, double b, double c) {
  return fma(a, b, c);
}

SCALAR_FUN_ATTR double futrts_round64(double x) {
  return rint(x);
}

SCALAR_FUN_ATTR double futrts_ceil64(double x) {
  return ceil(x);
}

SCALAR_FUN_ATTR float futrts_nextafter64(float x, float y) {
  return nextafter(x, y);
}

SCALAR_FUN_ATTR double futrts_floor64(double x) {
  return floor(x);
}

SCALAR_FUN_ATTR bool futrts_isnan64(double x) {
  return isnan(x);
}

SCALAR_FUN_ATTR bool futrts_isinf64(double x) {
  return isinf(x);
}

SCALAR_FUN_ATTR int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

SCALAR_FUN_ATTR int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

SCALAR_FUN_ATTR int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

SCALAR_FUN_ATTR int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

SCALAR_FUN_ATTR uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

SCALAR_FUN_ATTR uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

SCALAR_FUN_ATTR uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

SCALAR_FUN_ATTR uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

SCALAR_FUN_ATTR bool ftob_f64_bool(double x) {
  return x != 0;
}

SCALAR_FUN_ATTR double btof_bool_f64(bool x) {
  return x ? 1 : 0;
}

SCALAR_FUN_ATTR int64_t futrts_to_bits64(double x) {
  union {
    double f;
    int64_t t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR double futrts_from_bits64(int64_t x) {
  union {
    int64_t f;
    double t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR double fmod64(double x, double y) {
  return fmod(x, y);
}

SCALAR_FUN_ATTR double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);
}

SCALAR_FUN_ATTR double futrts_lerp64(double v0, double v1, double t) {
#ifdef __OPENCL_VERSION__
  return mix(v0, v1, t);
#else
  return v0 + (v1 - v0) * t;
#endif
}

SCALAR_FUN_ATTR double futrts_ldexp64(double x, int32_t y) {
  return ldexp(x, y);
}

SCALAR_FUN_ATTR float futrts_copysign64(double x, double y) {
  return copysign(x, y);
}

SCALAR_FUN_ATTR double futrts_mad64(double a, double b, double c) {
#ifdef __OPENCL_VERSION__
  return mad(a, b, c);
#else
  return a * b + c;
#endif
}

SCALAR_FUN_ATTR float fpconv_f32_f32(float x) {
  return (float) x;
}

SCALAR_FUN_ATTR double fpconv_f32_f64(float x) {
  return (double) x;
}

SCALAR_FUN_ATTR float fpconv_f64_f32(double x) {
  return (float) x;
}

SCALAR_FUN_ATTR double fpconv_f64_f64(double x) {
  return (double) x;
}

#endif

#endif

// End of scalar.h.
// Start of scalar_f16.h.

// Half-precision is emulated if needed (e.g. in straight C) with the
// native type used if possible.  The emulation works by typedef'ing
// 'float' to 'f16', and then implementing all operations on single
// precision.  To cut down on duplication, we use the same code for
// those Futhark functions that require just operators or casts.  The
// in-memory representation for arrays will still be 16 bits even
// under emulation, so the compiler will have to be careful when
// generating reads or writes.

#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600) && !(defined(ISPC))
#define EMULATE_F16
#endif

#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#endif

#ifdef EMULATE_F16

// Note that the half-precision storage format is still 16 bits - the
// compiler will have to be real careful!
typedef float f16;

#elif ISPC
typedef float16 f16;

#else

#ifdef __CUDA_ARCH__
#include <cuda_fp16.h>
#endif

typedef half f16;

#endif

// Some of these functions convert to single precision because half
// precision versions are not available.

SCALAR_FUN_ATTR f16 fadd16(f16 x, f16 y) {
  return x + y;
}

SCALAR_FUN_ATTR f16 fsub16(f16 x, f16 y) {
  return x - y;
}

SCALAR_FUN_ATTR f16 fmul16(f16 x, f16 y) {
  return x * y;
}

SCALAR_FUN_ATTR bool cmplt16(f16 x, f16 y) {
  return x < y;
}

SCALAR_FUN_ATTR bool cmple16(f16 x, f16 y) {
  return x <= y;
}

SCALAR_FUN_ATTR f16 sitofp_i8_f16(int8_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 sitofp_i16_f16(int16_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 sitofp_i32_f16(int32_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 sitofp_i64_f16(int64_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 uitofp_i8_f16(uint8_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 uitofp_i16_f16(uint16_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 uitofp_i32_f16(uint32_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 uitofp_i64_f16(uint64_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR int8_t fptosi_f16_i8(f16 x) {
  return (int8_t) (float) x;
}

SCALAR_FUN_ATTR int16_t fptosi_f16_i16(f16 x) {
  return (int16_t) x;
}

SCALAR_FUN_ATTR int32_t fptosi_f16_i32(f16 x) {
  return (int32_t) x;
}

SCALAR_FUN_ATTR int64_t fptosi_f16_i64(f16 x) {
  return (int64_t) x;
}

SCALAR_FUN_ATTR uint8_t fptoui_f16_i8(f16 x) {
  return (uint8_t) (float) x;
}

SCALAR_FUN_ATTR uint16_t fptoui_f16_i16(f16 x) {
  return (uint16_t) x;
}

SCALAR_FUN_ATTR uint32_t fptoui_f16_i32(f16 x) {
  return (uint32_t) x;
}

SCALAR_FUN_ATTR uint64_t fptoui_f16_i64(f16 x) {
  return (uint64_t) x;
}

SCALAR_FUN_ATTR bool ftob_f16_bool(f16 x) {
  return x != (f16)0;
}

SCALAR_FUN_ATTR f16 btof_bool_f16(bool x) {
  return x ? 1 : 0;
}

#ifndef EMULATE_F16
SCALAR_FUN_ATTR bool futrts_isnan16(f16 x) {
  return isnan((float)x);
}

#ifdef __OPENCL_VERSION__

SCALAR_FUN_ATTR f16 fabs16(f16 x) {
  return fabs(x);
}

SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) {
  return fmax(x, y);
}

SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) {
  return fmin(x, y);
}

SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}

#elif ISPC
SCALAR_FUN_ATTR f16 fabs16(f16 x) {
  return abs(x);
}

SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) {
  return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : max(x, y);
}

SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) {
  return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : min(x, y);
}

SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}

#else // Assuming CUDA.

SCALAR_FUN_ATTR f16 fabs16(f16 x) {
  return fabsf(x);
}

SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) {
  return fmaxf(x, y);
}

SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) {
  return fminf(x, y);
}

SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) {
  return powf(x, y);
}
#endif

#if ISPC
SCALAR_FUN_ATTR bool futrts_isinf16(float x) {
  return !futrts_isnan16(x) && futrts_isnan16(x - x);
}
SCALAR_FUN_ATTR bool futrts_isfinite16(float x) {
  return !futrts_isnan16(x) && !futrts_isinf16(x);
}

#else

SCALAR_FUN_ATTR bool futrts_isinf16(f16 x) {
  return isinf((float)x);
}
#endif

#ifdef __OPENCL_VERSION__
SCALAR_FUN_ATTR f16 futrts_log16(f16 x) {
  return log(x);
}

SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) {
  return log2(x);
}

SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) {
  return log10(x);
}

SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) {
  return log1p(x);
}

SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) {
  return sqrt(x);
}

SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) {
  return cbrt(x);
}

SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) {
  return exp(x);
}

SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) {
  return cos(x);
}

SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) {
  return sin(x);
}

SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) {
  return tan(x);
}

SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) {
  return acos(x);
}

SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) {
  return asin(x);
}

SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) {
  return atan(x);
}

SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) {
  return cosh(x);
}

SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) {
  return sinh(x);
}

SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) {
  return tanh(x);
}

SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) {
  return acosh(x);
}

SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) {
  return asinh(x);
}

SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) {
  return atanh(x);
}

SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2(x, y);
}

SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) {
  return hypot(x, y);
}

SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) {
  return tgamma(x);
}

SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) {
  return lgamma(x);
}

SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) {
  return erf(x);
}

SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) {
  return erfc(x);
}

SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) {
  return fmod(x, y);
}

SCALAR_FUN_ATTR f16 futrts_round16(f16 x) {
  return rint(x);
}

SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) {
  return floor(x);
}

SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) {
  return ceil(x);
}

SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) {
  return nextafter(x, y);
}

SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return mix(v0, v1, t);
}

SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) {
  return ldexp(x, y);
}

SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) {
  return copysign(x, y);
}

SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return mad(a, b, c);
}

SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fma(a, b, c);
}
#elif ISPC

SCALAR_FUN_ATTR f16 futrts_log16(f16 x) {
  return futrts_isfinite16(x) || (futrts_isinf16(x) && x < 0) ? log(x) : x;
}

SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) {
  return futrts_log16(x) / log(2.0f16);
}

SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) {
  return futrts_log16(x) / log(10.0f16);
}

SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) {
  if(x == -1.0f16 || (futrts_isinf16(x) && x > 0.0f16)) return x / 0.0f16;
  f16 y = 1.0f16 + x;
  f16 z = y - 1.0f16;
  return log(y) - (z-x)/y;
}

SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) {
  return (float16)sqrt((float)x);
}

SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) {
  return exp(x);
}

SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) {
  return (float16)cos((float)x);
}

SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) {
  return (float16)sin((float)x);
}

SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) {
  return (float16)tan((float)x);
}

SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) {
  return (float16)acos((float)x);
}

SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) {
  return (float16)asin((float)x);
}

SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) {
  return (float16)atan((float)x);
}

SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) {
  return (exp(x)+exp(-x)) / 2.0f16;
}

SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) {
  return (exp(x)-exp(-x)) / 2.0f16;
}

SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) {
  return futrts_sinh16(x)/futrts_cosh16(x);
}

SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) {
  float16 f = x+(float16)sqrt((float)(x*x-1));
  if(futrts_isfinite16(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) {
  float16 f = x+(float16)sqrt((float)(x*x+1));
  if(futrts_isfinite16(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) {
  float16 f = (1+x)/(1-x);
  if(futrts_isfinite16(f)) return log(f)/2.0f16;
  return f;
}

SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) {
  return (float16)atan2((float)x, (float)y);
}

SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) {
  return (float16)futrts_hypot32((float)x, (float)y);
}

extern "C" unmasked uniform float tgammaf(uniform float x);
SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) {
  f16 res;
  foreach_active (i) {
    uniform f16 r = (f16)tgammaf(extract((float)x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float lgammaf(uniform float x);
SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) {
  f16 res;
  foreach_active (i) {
    uniform f16 r = (f16)lgammaf(extract((float)x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) {
  f16 res = (f16)futrts_cbrt32((float)x);
  return res;
}

SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) {
  f16 res = (f16)futrts_erf32((float)x);
  return res;
}

SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) {
  f16 res = (f16)futrts_erfc32((float)x);
  return res;
}

SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) {
  return x - y * (float16)trunc((float) (x/y));
}

SCALAR_FUN_ATTR f16 futrts_round16(f16 x) {
  return (float16)round((float)x);
}

SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) {
  return (float16)floor((float)x);
}

SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) {
  return (float16)ceil((float)x);
}

SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) {
  return (float16)futrts_nextafter32((float)x, (float) y);
}

SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) {
  return futrts_ldexp32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) {
  return futrts_copysign32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

#else // Assume CUDA.

SCALAR_FUN_ATTR f16 futrts_log16(f16 x) {
  return hlog(x);
}

SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) {
  return hlog2(x);
}

SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) {
  return hlog10(x);
}

SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) {
  return (f16)log1pf((float)x);
}

SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) {
  return hsqrt(x);
}

SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) {
  return cbrtf(x);
}

SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) {
  return hexp(x);
}

SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) {
  return hcos(x);
}

SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) {
  return hsin(x);
}

SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) {
  return tanf(x);
}

SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) {
  return acosf(x);
}

SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) {
  return asinf(x);
}

SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) {
  return atanf(x);
}

SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) {
  return coshf(x);
}

SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) {
  return sinhf(x);
}

SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) {
  return tanhf(x);
}

SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) {
  return acoshf(x);
}

SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) {
  return asinhf(x);
}

SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) {
  return atanhf(x);
}

SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2f(x, y);
}

SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) {
  return hypotf(x, y);
}

SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) {
  return tgammaf(x);
}

SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) {
  return lgammaf(x);
}

SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) {
  return erff(x);
}

SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) {
  return erfcf(x);
}

SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) {
  return fmodf(x, y);
}

SCALAR_FUN_ATTR f16 futrts_round16(f16 x) {
  return rintf(x);
}

SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) {
  return hfloor(x);
}

SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) {
  return hceil(x);
}

SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) {
  return __ushort_as_half(halfbitsnextafter(__half_as_ushort(x), __half_as_ushort(y)));
}

SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) {
  return futrts_ldexp32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) {
  return futrts_copysign32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fmaf(a, b, c);
}

#endif

// The CUDA __half type cannot be put in unions for some reason, so we
// use bespoke conversion functions instead.
#ifdef __CUDA_ARCH__
SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  return __half_as_ushort(x);
}
SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  return __ushort_as_half(x);
}
#elif ISPC

SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  varying int16_t y = *((varying int16_t * uniform)&x);
  return y;
}

SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  varying f16 y = *((varying f16 * uniform)&x);
  return y;
}
#else
SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  union {
    f16 f;
    int16_t t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  union {
    int16_t f;
    f16 t;
  } p;

  p.f = x;
  return p.t;
}
#endif

#else // No native f16 - emulate.

SCALAR_FUN_ATTR f16 fabs16(f16 x) {
  return fabs32(x);
}

SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) {
  return fmax32(x, y);
}

SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) {
  return fmin32(x, y);
}

SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) {
  return fpow32(x, y);
}

SCALAR_FUN_ATTR bool futrts_isnan16(f16 x) {
  return futrts_isnan32(x);
}

SCALAR_FUN_ATTR bool futrts_isinf16(f16 x) {
  return futrts_isinf32(x);
}

SCALAR_FUN_ATTR f16 futrts_log16(f16 x) {
  return futrts_log32(x);
}

SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) {
  return futrts_log2_32(x);
}

SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) {
  return futrts_log10_32(x);
}

SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) {
  return futrts_log1p_32(x);
}

SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) {
  return futrts_sqrt32(x);
}

SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) {
  return futrts_cbrt32(x);
}

SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) {
  return futrts_exp32(x);
}

SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) {
  return futrts_cos32(x);
}

SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) {
  return futrts_sin32(x);
}

SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) {
  return futrts_tan32(x);
}

SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) {
  return futrts_acos32(x);
}

SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) {
  return futrts_asin32(x);
}

SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) {
  return futrts_atan32(x);
}

SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) {
  return futrts_cosh32(x);
}

SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) {
  return futrts_sinh32(x);
}

SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) {
  return futrts_tanh32(x);
}

SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) {
  return futrts_acosh32(x);
}

SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) {
  return futrts_asinh32(x);
}

SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) {
  return futrts_atanh32(x);
}

SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) {
  return futrts_atan2_32(x, y);
}

SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) {
  return futrts_hypot32(x, y);
}

SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) {
  return futrts_gamma32(x);
}

SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) {
  return futrts_lgamma32(x);
}

SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) {
  return futrts_erf32(x);
}

SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) {
  return futrts_erfc32(x);
}

SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) {
  return fmod32(x, y);
}

SCALAR_FUN_ATTR f16 futrts_round16(f16 x) {
  return futrts_round32(x);
}

SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) {
  return futrts_floor32(x);
}

SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) {
  return futrts_ceil32(x);
}

SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) {
  return halfbits2float(halfbitsnextafter(float2halfbits(x), float2halfbits(y)));
}

SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return futrts_lerp32(v0, v1, t);
}

SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) {
  return futrts_ldexp32(x, y);
}

SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) {
  return futrts_copysign32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return futrts_mad32(a, b, c);
}

SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return futrts_fma32(a, b, c);
}

// Even when we are using an OpenCL that does not support cl_khr_fp16,
// it must still support vload_half for actually creating a
// half-precision number, which can then be efficiently converted to a
// float.  Similarly for vstore_half.
#ifdef __OPENCL_VERSION__

SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  int16_t y;
  // Violating strict aliasing here.
  vstore_half((float)x, 0, (half*)&y);
  return y;
}

SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  return (f16)vload_half(0, (half*)&x);
}

#else

SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  return (int16_t)float2halfbits(x);
}

SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  return halfbits2float((uint16_t)x);
}

SCALAR_FUN_ATTR f16 fsignum16(f16 x) {
  return futrts_isnan16(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0);
}

#endif

#endif

SCALAR_FUN_ATTR float fpconv_f16_f16(f16 x) {
  return x;
}

SCALAR_FUN_ATTR float fpconv_f16_f32(f16 x) {
  return x;
}

SCALAR_FUN_ATTR f16 fpconv_f32_f16(float x) {
  return (f16) x;
}

#ifdef FUTHARK_F64_ENABLED

SCALAR_FUN_ATTR double fpconv_f16_f64(f16 x) {
  return (double) x;
}

#if ISPC
SCALAR_FUN_ATTR f16 fpconv_f64_f16(double x) {
  return (f16) ((float)x);
}
#else
SCALAR_FUN_ATTR f16 fpconv_f64_f16(double x) {
  return (f16) x;
}
#endif
#endif


// End of scalar_f16.h.

// Start of context_prototypes.h
//
// Prototypes for the functions in context.h, or that will be called
// from those functions, that need to be available very early.

struct futhark_context_config;
struct futhark_context;

static void set_error(struct futhark_context* ctx, char *error);

// These are called in context/config new/free functions and contain
// shared setup.  They are generated by the compiler itself.
static int init_constants(struct futhark_context*);
static int free_constants(struct futhark_context*);
static void setup_program(struct futhark_context* ctx);
static void teardown_program(struct futhark_context *ctx);

// Allocate host memory.  Must be freed with host_free().
static void host_alloc(struct futhark_context* ctx, size_t size, const char* tag, size_t* size_out, void** mem_out);
// Allocate memory allocated with host_alloc().
static void host_free(struct futhark_context* ctx, size_t size, const char* tag, void* mem);

// Log that a copy has occurred.
static void log_copy(struct futhark_context* ctx,
                     const char *kind, int r,
                     int64_t dst_offset, int64_t dst_strides[r],
                     int64_t src_offset, int64_t src_strides[r],
                     int64_t shape[r]);

static void log_transpose(struct futhark_context* ctx,
                          int64_t k, int64_t m, int64_t n);

static bool lmad_map_tr(int64_t *num_arrays_out, int64_t *n_out, int64_t *m_out,
                        int r,
                        const int64_t dst_strides[r],
                        const int64_t src_strides[r],
                        const int64_t shape[r]);

static bool lmad_contiguous(int r, int64_t strides[r], int64_t shape[r]);

static bool lmad_memcpyable(int r,
                            int64_t dst_strides[r], int64_t src_strides[r], int64_t shape[r]);

static void add_event(struct futhark_context* ctx,
                      const char* name,
                      char* description,
                      void* data,
                      event_report_fn f);

// Functions that must be defined by the backend.
static void backend_context_config_setup(struct futhark_context_config* cfg);
static void backend_context_config_teardown(struct futhark_context_config* cfg);
static int backend_context_setup(struct futhark_context *ctx);
static void backend_context_teardown(struct futhark_context *ctx);

// End of of context_prototypes.h

struct memblock {
    int *references;
    unsigned char *mem;
    int64_t size;
    const char *desc;
};
struct constants {
    int dummy;
};
struct tuning_params {
    int dummy;
};
static const int num_tuning_params = 0;
static const char *tuning_param_names[] = {NULL};
static const char *tuning_param_vars[] = {NULL};
static const char *tuning_param_classes[] = {NULL};
static int64_t tuning_param_defaults[] = {0};
// Start of backends/c.h

struct futhark_context_config {
  int in_use;
  int debugging;
  int profiling;
  int logging;
  char *cache_fname;
  int num_tuning_params;
  int64_t *tuning_params;
  const char** tuning_param_names;
  const char** tuning_param_vars;
  const char** tuning_param_classes;
};

static void backend_context_config_setup(struct futhark_context_config* cfg) {
  (void)cfg;
}

static void backend_context_config_teardown(struct futhark_context_config* cfg) {
  (void)cfg;
}

int futhark_context_config_set_tuning_param(struct futhark_context_config* cfg, const char *param_name, size_t param_value) {
  (void)cfg; (void)param_name; (void)param_value;
  return 1;
}

struct futhark_context {
  struct futhark_context_config* cfg;
  int detail_memory;
  int debugging;
  int profiling;
  int profiling_paused;
  int logging;
  lock_t lock;
  char *error;
  lock_t error_lock;
  FILE *log;
  struct constants *constants;
  struct free_list free_list;
  struct event_list event_list;
  int64_t peak_mem_usage_default;
  int64_t cur_mem_usage_default;
  struct program* program;
  bool program_initialised;
};

int backend_context_setup(struct futhark_context* ctx) {
  (void)ctx;
  return 0;
}

void backend_context_teardown(struct futhark_context* ctx) {
  (void)ctx;
}

int futhark_context_sync(struct futhark_context* ctx) {
  (void)ctx;
  return 0;
}

// End of backends/c.h

struct program {
    int dummy;
};
static void setup_program(struct futhark_context *ctx)
{
    (void) ctx;
    
    int error = 0;
    
    (void) error;
    ctx->program = malloc(sizeof(struct program));
}
static void teardown_program(struct futhark_context *ctx)
{
    (void) ctx;
    
    int error = 0;
    
    (void) error;
    free(ctx->program);
}
static void set_tuning_params(struct futhark_context *ctx)
{
    (void) ctx;
}
int memblock_unref(struct futhark_context *ctx, struct memblock *block, const char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(ctx->log, "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n", desc, block->desc, "default space", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_default -= block->size;
            host_free(ctx, (size_t) block->size, desc, (void *) block->mem);
            free(block->references);
            if (ctx->detail_memory)
                fprintf(ctx->log, "%lld bytes freed (now allocated: %lld bytes)\n", (long long) block->size, (long long) ctx->cur_mem_usage_default);
        }
        block->references = NULL;
    }
    return 0;
}
int memblock_alloc(struct futhark_context *ctx, struct memblock *block, int64_t size, const char *desc)
{
    if (size < 0)
        futhark_panic(1, "Negative allocation of %lld bytes attempted for %s in %s.\n", (long long) size, desc, "default space", ctx->cur_mem_usage_default);
    
    int ret = memblock_unref(ctx, block, desc);
    
    if (ret != FUTHARK_SUCCESS)
        return ret;
    if (ctx->detail_memory)
        fprintf(ctx->log, "Allocating %lld bytes for %s in %s (currently allocated: %lld bytes).\n", (long long) size, desc, "default space", (long long) ctx->cur_mem_usage_default);
    host_alloc(ctx, (size_t) size, desc, (size_t *) &size, (void *) &block->mem);
    if (ctx->error == NULL) {
        block->references = (int *) malloc(sizeof(int));
        *block->references = 1;
        block->size = size;
        block->desc = desc;
        
        long long new_usage = ctx->cur_mem_usage_default + size;
        
        if (ctx->detail_memory)
            fprintf(ctx->log, "Received block of %lld bytes; now allocated: %lld bytes", (long long) block->size, new_usage);
        ctx->cur_mem_usage_default = new_usage;
        if (new_usage > ctx->peak_mem_usage_default) {
            ctx->peak_mem_usage_default = new_usage;
            if (ctx->detail_memory)
                fprintf(ctx->log, " (new peak).\n");
        } else if (ctx->detail_memory)
            fprintf(ctx->log, ".\n");
        return FUTHARK_SUCCESS;
    } else {
        // We are naively assuming that any memory allocation error is due to OOM.
        lock_lock(&ctx->error_lock);
        
        char *old_error = ctx->error;
        
        ctx->error = msgprintf("Failed to allocate memory in %s.\nAttempted allocation: %12lld bytes\nCurrently allocated:  %12lld bytes\n%s", "default space", (long long) size, (long long) ctx->cur_mem_usage_default, old_error);
        free(old_error);
        lock_unlock(&ctx->error_lock);
        return FUTHARK_OUT_OF_MEMORY;
    }
}
int memblock_set(struct futhark_context *ctx, struct memblock *lhs, struct memblock *rhs, const char *lhs_desc)
{
    int ret = memblock_unref(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
char *futhark_context_report(struct futhark_context *ctx)
{
    if (futhark_context_sync(ctx) != 0)
        return NULL;
    
    struct str_builder builder;
    
    str_builder_init(&builder);
    str_builder_char(&builder, '{');
    str_builder_str(&builder, "\"memory\":{");
    str_builder(&builder, "\"default space\": %lld", (long long) ctx->peak_mem_usage_default);
    str_builder_str(&builder, "},\"events\":[");
    if (report_events_in_list(&ctx->event_list, &builder) != 0) {
        free(builder.str);
        return NULL;
    } else {
        str_builder_str(&builder, "]}");
        return builder.str;
    }
}
int futhark_context_clear_caches(struct futhark_context *ctx)
{
    lock_lock(&ctx->lock);
    ctx->peak_mem_usage_default = 0;
    lock_unlock(&ctx->lock);
    return ctx->error != NULL;
}

// Start of context.h

// Internal functions.

static void set_error(struct futhark_context* ctx, char *error) {
  lock_lock(&ctx->error_lock);
  if (ctx->error == NULL) {
    ctx->error = error;
  } else {
    free(error);
  }
  lock_unlock(&ctx->error_lock);
}

// XXX: should be static, but used in ispc_util.h
void lexical_realloc_error(struct futhark_context* ctx, size_t new_size) {
  set_error(ctx,
            msgprintf("Failed to allocate memory.\nAttempted allocation: %12lld bytes\n",
                      (long long) new_size));
}

static int lexical_realloc(struct futhark_context *ctx,
                           unsigned char **ptr,
                           int64_t *old_size,
                           int64_t new_size) {
  unsigned char *new = realloc(*ptr, (size_t)new_size);
  if (new == NULL) {
    lexical_realloc_error(ctx, new_size);
    return FUTHARK_OUT_OF_MEMORY;
  } else {
    *ptr = new;
    *old_size = new_size;
    return FUTHARK_SUCCESS;
  }
}

static void free_all_in_free_list(struct futhark_context* ctx) {
  fl_mem mem;
  free_list_pack(&ctx->free_list);
  while (free_list_first(&ctx->free_list, (fl_mem*)&mem) == 0) {
    free((void*)mem);
  }
}

static int is_small_alloc(size_t size) {
  return size < 1024*1024;
}

static void host_alloc(struct futhark_context* ctx,
                       size_t size, const char* tag, size_t* size_out, void** mem_out) {
  if (is_small_alloc(size) || free_list_find(&ctx->free_list, size, tag, size_out, (fl_mem*)mem_out) != 0) {
    *size_out = size;
    *mem_out = malloc(size);
  }
}

static void host_free(struct futhark_context* ctx,
                      size_t size, const char* tag, void* mem) {
  // Small allocations are handled by malloc()s own free list.  The
  // threshold here is kind of arbitrary, but seems to work OK.
  // Larger allocations are mmap()ed/munmapped() every time, which is
  // very slow, and Futhark programs tend to use a few very large
  // allocations.
  if (is_small_alloc(size)) {
    free(mem);
  } else {
    free_list_insert(&ctx->free_list, size, (fl_mem)mem, tag);
  }
}

static void add_event(struct futhark_context* ctx,
                      const char* name,
                      char* description,
                      void* data,
                      event_report_fn f) {
  if (ctx->logging) {
    fprintf(ctx->log, "Event: %s\n%s\n", name, description);
  }
  add_event_to_list(&ctx->event_list, name, description, data, f);
}

char *futhark_context_get_error(struct futhark_context *ctx) {
  char *error = ctx->error;
  ctx->error = NULL;
  return error;
}

void futhark_context_config_set_debugging(struct futhark_context_config *cfg, int flag) {
    cfg->profiling = cfg->logging = cfg->debugging = flag;
}

void futhark_context_config_set_profiling(struct futhark_context_config *cfg, int flag) {
    cfg->profiling = flag;
}

void futhark_context_config_set_logging(struct futhark_context_config *cfg, int flag) {
    cfg->logging = flag;
}

void futhark_context_config_set_cache_file(struct futhark_context_config *cfg, const char *f) {
  cfg->cache_fname = strdup(f);
}

int futhark_get_tuning_param_count(void) {
  return num_tuning_params;
}

const char *futhark_get_tuning_param_name(int i) {
  return tuning_param_names[i];
}

const char *futhark_get_tuning_param_class(int i) {
    return tuning_param_classes[i];
}

void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f){
  ctx->log = f;
}

void futhark_context_pause_profiling(struct futhark_context *ctx) {
  ctx->profiling_paused = 1;
}

void futhark_context_unpause_profiling(struct futhark_context *ctx) {
  ctx->profiling_paused = 0;
}

struct futhark_context_config* futhark_context_config_new(void) {
  struct futhark_context_config* cfg = malloc(sizeof(struct futhark_context_config));
  if (cfg == NULL) {
    return NULL;
  }
  cfg->in_use = 0;
  cfg->debugging = 0;
  cfg->profiling = 0;
  cfg->logging = 0;
  cfg->cache_fname = NULL;
  cfg->num_tuning_params = num_tuning_params;
  cfg->tuning_params = malloc(cfg->num_tuning_params * sizeof(int64_t));
  memcpy(cfg->tuning_params, tuning_param_defaults,
         cfg->num_tuning_params * sizeof(int64_t));
  cfg->tuning_param_names = tuning_param_names;
  cfg->tuning_param_vars = tuning_param_vars;
  cfg->tuning_param_classes = tuning_param_classes;
  backend_context_config_setup(cfg);
  return cfg;
}

void futhark_context_config_free(struct futhark_context_config* cfg) {
  assert(!cfg->in_use);
  backend_context_config_teardown(cfg);
  free(cfg->cache_fname);
  free(cfg->tuning_params);
  free(cfg);
}

struct futhark_context* futhark_context_new(struct futhark_context_config* cfg) {
  struct futhark_context* ctx = malloc(sizeof(struct futhark_context));
  if (ctx == NULL) {
    return NULL;
  }
  assert(!cfg->in_use);
  ctx->cfg = cfg;
  ctx->cfg->in_use = 1;
  ctx->program_initialised = false;
  create_lock(&ctx->error_lock);
  create_lock(&ctx->lock);
  free_list_init(&ctx->free_list);
  event_list_init(&ctx->event_list);
  ctx->peak_mem_usage_default = 0;
  ctx->cur_mem_usage_default = 0;
  ctx->constants = malloc(sizeof(struct constants));
  ctx->debugging = cfg->debugging;
  ctx->logging = cfg->logging;
  ctx->detail_memory = cfg->logging;
  ctx->profiling = cfg->profiling;
  ctx->profiling_paused = 0;
  ctx->error = NULL;
  ctx->log = stderr;
  set_tuning_params(ctx);
  if (backend_context_setup(ctx) == 0) {
    setup_program(ctx);
    init_constants(ctx);
    ctx->program_initialised = true;
    (void)futhark_context_clear_caches(ctx);
    (void)futhark_context_sync(ctx);
  }
  return ctx;
}

void futhark_context_free(struct futhark_context* ctx) {
  if (ctx->program_initialised) {
    free_constants(ctx);
    teardown_program(ctx);
  }
  backend_context_teardown(ctx);
  free_all_in_free_list(ctx);
  free_list_destroy(&ctx->free_list);
  event_list_free(&ctx->event_list);
  free(ctx->constants);
  free(ctx->error);
  free_lock(&ctx->lock);
  free_lock(&ctx->error_lock);
  ctx->cfg->in_use = 0;
  free(ctx);
}

// End of context.h

// Start of copy.h

// Cache-oblivious map-transpose function.
#define GEN_MAP_TRANSPOSE(NAME, ELEM_TYPE)                              \
  static void map_transpose_##NAME                                      \
  (ELEM_TYPE* dst, ELEM_TYPE* src,                                      \
   int64_t k, int64_t m, int64_t n,                                     \
   int64_t cb, int64_t ce, int64_t rb, int64_t re)                      \
  {                                                                     \
  int32_t r = re - rb;                                                  \
  int32_t c = ce - cb;                                                  \
  if (k == 1) {                                                         \
    if (r <= 64 && c <= 64) {                                           \
      for (int64_t j = 0; j < c; j++) {                                 \
        for (int64_t i = 0; i < r; i++) {                               \
          dst[(j + cb) * n + (i + rb)] = src[(i + rb) * m + (j + cb)];  \
        }                                                               \
      }                                                                 \
    } else if (c <= r) {                                                \
      map_transpose_##NAME(dst, src, k, m, n, cb, ce, rb, rb + r/2);    \
      map_transpose_##NAME(dst, src, k, m, n, cb, ce, rb + r/2, re);    \
    } else {                                                            \
      map_transpose_##NAME(dst, src, k, m, n, cb, cb + c/2, rb, re);    \
      map_transpose_##NAME(dst, src, k, m, n, cb + c/2, ce, rb, re);    \
    }                                                                   \
  } else {                                                              \
  for (int64_t i = 0; i < k; i++) {                                     \
    map_transpose_##NAME(dst + i * m * n, src + i * m * n, 1, m, n, cb, ce, rb, re); \
  }\
} \
}

// Straightforward LMAD copy function.
#define GEN_LMAD_COPY_ELEMENTS(NAME, ELEM_TYPE)                         \
  static void lmad_copy_elements_##NAME(int r,                          \
                                        ELEM_TYPE* dst, int64_t dst_strides[r], \
                                        ELEM_TYPE *src, int64_t src_strides[r], \
                                        int64_t shape[r]) {             \
    if (r == 1) {                                                       \
      for (int i = 0; i < shape[0]; i++) {                              \
        dst[i*dst_strides[0]] = src[i*src_strides[0]];                  \
      }                                                                 \
    } else if (r > 1) {                                                 \
      for (int i = 0; i < shape[0]; i++) {                              \
        lmad_copy_elements_##NAME(r-1,                                  \
                                  dst+i*dst_strides[0], dst_strides+1,  \
                                  src+i*src_strides[0], src_strides+1,  \
                                  shape+1);                             \
      }                                                                 \
    }                                                                   \
  }                                                                     \

// Check whether this LMAD can be seen as a transposed 2D array.  This
// is done by checking every possible splitting point.
static bool lmad_is_tr(int64_t *n_out, int64_t *m_out,
                       int r,
                       const int64_t strides[r],
                       const int64_t shape[r]) {
  for (int i = 1; i < r; i++) {
    int n = 1, m = 1;
    bool ok = true;
    int64_t expected = 1;
    // Check strides before 'i'.
    for (int j = i-1; j >= 0; j--) {
      ok = ok && strides[j] == expected;
      expected *= shape[j];
      n *= shape[j];
    }
    // Check strides after 'i'.
    for (int j = r-1; j >= i; j--) {
      ok = ok && strides[j] == expected;
      expected *= shape[j];
      m *= shape[j];
    }
    if (ok) {
      *n_out = n;
      *m_out = m;
      return true;
    }
  }
  return false;
}

// This function determines whether the a 'dst' LMAD is row-major and
// 'src' LMAD is column-major.  Both LMADs are for arrays of the same
// shape.  Both LMADs are allowed to have additional dimensions "on
// top".  Essentially, this function determines whether a copy from
// 'src' to 'dst' is a "map(transpose)" that we know how to implement
// efficiently.  The LMADs can have arbitrary rank, and the main
// challenge here is checking whether the src LMAD actually
// corresponds to a 2D column-major layout by morally collapsing
// dimensions.  There is a lot of looping here, but the actual trip
// count is going to be very low in practice.
//
// Returns true if this is indeed a map(transpose), and writes the
// number of arrays, and moral array size to appropriate output
// parameters.
static bool lmad_map_tr(int64_t *num_arrays_out, int64_t *n_out, int64_t *m_out,
                        int r,
                        const int64_t dst_strides[r],
                        const int64_t src_strides[r],
                        const int64_t shape[r]) {
  int64_t rowmajor_strides[r];
  rowmajor_strides[r-1] = 1;

  for (int i = r-2; i >= 0; i--) {
    rowmajor_strides[i] = rowmajor_strides[i+1] * shape[i+1];
  }

  // map_r will be the number of mapped dimensions on top.
  int map_r = 0;
  int64_t num_arrays = 1;
  for (int i = 0; i < r; i++) {
    if (dst_strides[i] != rowmajor_strides[i] ||
        src_strides[i] != rowmajor_strides[i]) {
      break;
    } else {
      num_arrays *= shape[i];
      map_r++;
    }
  }

  *num_arrays_out = num_arrays;

  if (r==map_r) {
    return false;
  }

  if (memcmp(&rowmajor_strides[map_r],
             &dst_strides[map_r],
             sizeof(int64_t)*(r-map_r)) == 0) {
    return lmad_is_tr(n_out, m_out, r-map_r, src_strides+map_r, shape+map_r);
  } else if (memcmp(&rowmajor_strides[map_r],
                    &src_strides[map_r],
                    sizeof(int64_t)*(r-map_r)) == 0) {
    return lmad_is_tr(m_out, n_out, r-map_r, dst_strides+map_r, shape+map_r);
  }
  return false;
}

// Check if the strides correspond to row-major strides of *any*
// permutation of the shape.  This is done by recursive search with
// backtracking.  This is worst-case exponential, but hopefully the
// arrays we encounter do not have that many dimensions.
static bool lmad_contiguous_search(int checked, int64_t expected,
                                   int r,
                                   int64_t strides[r], int64_t shape[r], bool used[r]) {
  for (int i = 0; i < r; i++) {
    for (int j = 0; j < r; j++) {
      if (!used[j] && strides[j] == expected && strides[j] >= 0) {
        used[j] = true;
        if (checked+1 == r ||
            lmad_contiguous_search(checked+1, expected * shape[j], r, strides, shape, used)) {
          return true;
        }
        used[j] = false;
      }
    }
  }
  return false;
}

// Does this LMAD correspond to an array with positive strides and no
// holes?
static bool lmad_contiguous(int r, int64_t strides[r], int64_t shape[r]) {
  bool used[r];
  for (int i = 0; i < r; i++) {
    used[i] = false;
  }
  return lmad_contiguous_search(0, 1, r, strides, shape, used);
}

// Does this copy correspond to something that could be done with a
// memcpy()-like operation?  I.e. do the LMADs actually represent the
// same in-memory layout and are they contiguous?
static bool lmad_memcpyable(int r,
                            int64_t dst_strides[r], int64_t src_strides[r], int64_t shape[r]) {
  if (!lmad_contiguous(r, dst_strides, shape)) {
    return false;
  }
  for (int i = 0; i < r; i++) {
    if (dst_strides[i] != src_strides[i] && shape[i] != 1) {
      return false;
    }
  }
  return true;
}


static void log_copy(struct futhark_context* ctx,
                     const char *kind, int r,
                     int64_t dst_offset, int64_t dst_strides[r],
                     int64_t src_offset, int64_t src_strides[r],
                     int64_t shape[r]) {
  if (ctx->logging) {
    fprintf(ctx->log, "\n# Copy %s\n", kind);
    fprintf(ctx->log, "Shape: ");
    for (int i = 0; i < r; i++) { fprintf(ctx->log, "[%ld]", (long int)shape[i]); }
    fprintf(ctx->log, "\n");
    fprintf(ctx->log, "Dst offset: %ld\n", (long int)dst_offset);
    fprintf(ctx->log, "Dst strides:");
    for (int i = 0; i < r; i++) { fprintf(ctx->log, " %ld", (long int)dst_strides[i]); }
    fprintf(ctx->log, "\n");
    fprintf(ctx->log, "Src offset: %ld\n", (long int)src_offset);
    fprintf(ctx->log, "Src strides:");
    for (int i = 0; i < r; i++) { fprintf(ctx->log, " %ld", (long int)src_strides[i]); }
    fprintf(ctx->log, "\n");
  }
}

static void log_transpose(struct futhark_context* ctx,
                          int64_t k, int64_t n, int64_t m) {
  if (ctx->logging) {
    fprintf(ctx->log, "## Transpose\n");
    fprintf(ctx->log, "Arrays     : %ld\n", (long int)k);
    fprintf(ctx->log, "X elements : %ld\n", (long int)m);
    fprintf(ctx->log, "Y elements : %ld\n", (long int)n);
    fprintf(ctx->log, "\n");
  }
}

#define GEN_LMAD_COPY(NAME, ELEM_TYPE)                                  \
  static void lmad_copy_##NAME                                          \
  (struct futhark_context *ctx, int r,                                  \
   ELEM_TYPE* dst, int64_t dst_offset, int64_t dst_strides[r],          \
   ELEM_TYPE *src, int64_t src_offset, int64_t src_strides[r],          \
   int64_t shape[r]) {                                                  \
    log_copy(ctx, "CPU to CPU", r, dst_offset, dst_strides,             \
             src_offset, src_strides, shape);                           \
    int64_t size = 1;                                                   \
    for (int i = 0; i < r; i++) { size *= shape[i]; }                   \
    if (size == 0) { return; }                                          \
    int64_t k, n, m;                                                    \
    if (lmad_map_tr(&k, &n, &m,                                         \
                    r, dst_strides, src_strides, shape)) {              \
      log_transpose(ctx, k, n, m);                                      \
      map_transpose_##NAME                                              \
        (dst+dst_offset, src+src_offset, k, n, m, 0, n, 0, m);          \
    } else if (lmad_memcpyable(r, dst_strides, src_strides, shape)) {   \
      if (ctx->logging) {fprintf(ctx->log, "## Flat copy\n\n");}          \
      memcpy(dst+dst_offset, src+src_offset, size*sizeof(*dst));        \
    } else {                                                            \
      if (ctx->logging) {fprintf(ctx->log, "## General copy\n\n");}       \
      lmad_copy_elements_##NAME                                         \
        (r,                                                             \
         dst+dst_offset, dst_strides,                                   \
         src+src_offset, src_strides, shape);                           \
    }                                                                   \
  }

GEN_MAP_TRANSPOSE(1b, uint8_t)
GEN_MAP_TRANSPOSE(2b, uint16_t)
GEN_MAP_TRANSPOSE(4b, uint32_t)
GEN_MAP_TRANSPOSE(8b, uint64_t)

GEN_LMAD_COPY_ELEMENTS(1b, uint8_t)
GEN_LMAD_COPY_ELEMENTS(2b, uint16_t)
GEN_LMAD_COPY_ELEMENTS(4b, uint32_t)
GEN_LMAD_COPY_ELEMENTS(8b, uint64_t)

GEN_LMAD_COPY(1b, uint8_t)
GEN_LMAD_COPY(2b, uint16_t)
GEN_LMAD_COPY(4b, uint32_t)
GEN_LMAD_COPY(8b, uint64_t)

// End of copy.h

#define FUTHARK_FUN_ATTR static

FUTHARK_FUN_ATTR int futrts_entry_Inner_Radix_Hash_Join(struct futhark_context *ctx, struct memblock *mem_out_p_36018, struct memblock *mem_out_p_36019, struct memblock *mem_out_p_36020, int64_t *out_prim_out_36021, int64_t *out_prim_out_36022, int64_t *out_prim_out_36023, struct memblock pR_mem_35253, struct memblock pS_mem_35254, struct memblock bounds_mem_35255, struct memblock depths_mem_35256, struct memblock bounds_mem_35257, struct memblock depths_mem_35258, struct memblock first_info_idx_mem_35259, struct memblock last_info_idx_mem_35260, struct memblock first_info_idx_mem_35261, struct memblock last_info_idx_mem_35262, int64_t nR_23541, int64_t b_23542, int64_t nS_23543, int64_t dz2081U_23544, int64_t dz2081U_23545, int64_t dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546, int32_t radix_sizze_23547, int32_t maxDepth_23552, int32_t radixSizze_23553, int32_t totalBytes_23554, int32_t maxDepth_23557, int32_t radixSizze_23558, int32_t totalBytes_23559, int64_t scatter_psizze_23564);
FUTHARK_FUN_ATTR int futrts_entry_calc_partitions_from_partitioned_set(struct futhark_context *ctx, struct memblock *mem_out_p_36058, struct memblock *mem_out_p_36059, int64_t *out_prim_out_36060, int64_t *out_prim_out_36061, int32_t *out_prim_out_36062, int32_t *out_prim_out_36063, int32_t *out_prim_out_36064, struct memblock pXs_mem_35253, int64_t n_20311, int64_t b_20312, int32_t radix_sizze_20313, int64_t offset_20315, int64_t sizze_thresh_20316, int32_t max_depth_20317);
FUTHARK_FUN_ATTR int futrts_entry_create_hash_table_from_partitioned_set(struct futhark_context *ctx, struct memblock *mem_out_p_36072, struct memblock *mem_out_p_36073, int64_t *out_prim_out_36074, struct memblock pXs_mem_35253, struct memblock bounds_mem_35254, struct memblock depths_mem_35255, int64_t n_21066, int64_t b_21067, int64_t dz2080U_21068, int64_t dz2081U_21069, int32_t maxDepth_21073, int32_t radixSizze_21074, int32_t totalBytes_21075, int64_t scatter_psizze_21076);
FUTHARK_FUN_ATTR int futrts_entry_partition_and_deepen_GFTR(struct futhark_context *ctx, struct memblock *mem_out_p_36078, struct memblock *mem_out_p_36079, struct memblock xs_mem_35253, struct memblock pL_mem_35254, int64_t n_18088, int64_t b_18089, int64_t pL_b_18090, int16_t block_sizze_18091, int64_t gather_psizze_18092, int32_t radix_sizze_18093, int64_t sizze_thresh_18096, int32_t max_depth_18097);
FUTHARK_FUN_ATTR int futrts_entry_partition_and_deepen_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_36091, struct memblock *mem_out_p_36092, struct memblock xs_mem_35253, int64_t n_19460, int64_t b_19461, int16_t block_sizze_19462, int64_t gather_psizze_19463, int32_t radix_sizze_19464, int64_t offset_19466, int64_t sizze_thresh_19467, int32_t max_depth_19468);
FUTHARK_FUN_ATTR int futrts_getPartitionBounds_8373(struct futhark_context *ctx, struct memblock *mem_out_p_36103, struct memblock *mem_out_p_36104, int64_t *out_prim_out_36105, int64_t *out_prim_out_36106, int32_t *out_prim_out_36107, int32_t *out_prim_out_36108, int32_t *out_prim_out_36109, struct memblock pXs_mem_35253, int64_t n_17191, int64_t b_17192, int32_t curDepth_17193, int32_t i_17195, int32_t j_17196);
FUTHARK_FUN_ATTR int futrts_partitioned_scatter_8506(struct futhark_context *ctx, struct memblock *mem_out_p_36115, struct memblock dest_mem_35253, struct memblock is_mem_35254, struct memblock vs_mem_35255, int64_t nd_20572, int64_t n_20573, int64_t psizze_20574);
FUTHARK_FUN_ATTR int futrts_set_bit_2464(struct futhark_context *ctx, int8_t *out_prim_out_36117, int32_t bit_15397, int8_t x_15398, int32_t b_15399);

static int init_constants(struct futhark_context *ctx)
{
    (void) ctx;
    
    int err = 0;
    
    
  cleanup:
    return err;
}
static int free_constants(struct futhark_context *ctx)
{
    (void) ctx;
    return 0;
}
struct futhark_u8_2d {
    struct memblock mem;
    int64_t shape[2];
};
struct futhark_u8_2d *futhark_new_u8_2d(struct futhark_context *ctx, const uint8_t *data, int64_t dim0, int64_t dim1)
{
    int err = 0;
    struct futhark_u8_2d *bad = NULL;
    struct futhark_u8_2d *arr = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * dim1 * 1, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    if ((size_t) (dim0 * dim1) * 1 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) (dim0 * dim1) * 1);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_u8_2d *futhark_new_raw_u8_2d(struct futhark_context *ctx, unsigned char *data, int64_t dim0, int64_t dim1)
{
    int err = 0;
    struct futhark_u8_2d *bad = NULL;
    struct futhark_u8_2d *arr = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr, uint8_t *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) (arr->shape[0] * arr->shape[1]) * 1 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) (arr->shape[0] * arr->shape[1]) * 1);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_u8_2d(struct futhark_context *ctx, uint8_t *out, struct futhark_u8_2d *arr, int64_t i0, int64_t i1)
{
    int err = 0;
    
    if ((i0 >= 0 && i0 < arr->shape[0]) && (i1 >= 0 && i1 < arr->shape[1])) {
        lock_lock(&ctx->lock);
        if (1 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 1 * (i0 * arr->shape[1] + i1 * 1), 1);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_i32_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_i32_1d *futhark_new_i32_1d(struct futhark_context *ctx, const int32_t *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i32_1d *bad = NULL;
    struct futhark_i32_1d *arr = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 4, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 4 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) dim0 * 4);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_i32_1d *futhark_new_raw_i32_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i32_1d *bad = NULL;
    struct futhark_i32_1d *arr = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr, int32_t *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 4 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 4);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_i32_1d(struct futhark_context *ctx, int32_t *out, struct futhark_i32_1d *arr, int64_t i0)
{
    int err = 0;
    
    if (i0 >= 0 && i0 < arr->shape[0]) {
        lock_lock(&ctx->lock);
        if (4 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 4 * (i0 * 1), 4);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_i64_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_i64_1d *futhark_new_i64_1d(struct futhark_context *ctx, const int64_t *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i64_1d *bad = NULL;
    struct futhark_i64_1d *arr = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 8, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 8 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) dim0 * 8);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_i64_1d *futhark_new_raw_i64_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i64_1d *bad = NULL;
    struct futhark_i64_1d *arr = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr, int64_t *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 8 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 8);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_i64_1d(struct futhark_context *ctx, int64_t *out, struct futhark_i64_1d *arr, int64_t i0)
{
    int err = 0;
    
    if (i0 >= 0 && i0 < arr->shape[0]) {
        lock_lock(&ctx->lock);
        if (8 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 8 * (i0 * 1), 8);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_opaque_partitionedSet_GFTR {
    struct futhark_u8_2d *v0;
    struct futhark_u8_2d *v1;
};
int futhark_project_opaque_partitionedSet_GFTR_ks(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFTR *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v0, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionedSet_GFTR_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFTR *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v1, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_partitionedSet_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR **out, const struct futhark_u8_2d *f_ks, const struct futhark_u8_2d *f_pL)
{
    struct futhark_opaque_partitionedSet_GFTR *v = malloc(sizeof(struct futhark_opaque_partitionedSet_GFTR));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_u8_2d));
        *v->v0 = *f_ks;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_u8_2d));
        *v->v1 = *f_pL;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_partitionedSet_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_partitionedSet_GFTR(struct futhark_context *ctx, const struct futhark_opaque_partitionedSet_GFTR *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v0)[0] * futhark_shape_u8_2d(ctx, obj->v0)[1] * sizeof(int8_t);
    int64_t size_1 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v0), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v0, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v0)[0] * futhark_shape_u8_2d(ctx, obj->v0)[1] * sizeof(int8_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v1), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v1, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_partitionedSet_GFTR *futhark_restore_opaque_partitionedSet_GFTR(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_partitionedSet_GFTR *obj = malloc(sizeof(struct futhark_opaque_partitionedSet_GFTR));
    int64_t shape_0[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * shape_0[1] * sizeof(int8_t);
    
    int64_t shape_1[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * shape_1[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_u8_2d(ctx, data_0, shape_0[0], shape_0[1]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_u8_2d(ctx, data_1, shape_1[0], shape_1[1]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_partitionedSet_GFUR {
    struct futhark_i64_1d *v0;
    struct futhark_u8_2d *v1;
};
int futhark_project_opaque_partitionedSet_GFUR_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_partitionedSet_GFUR *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionedSet_GFUR_ks(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFUR *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v1, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_partitionedSet_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR **out, const struct futhark_i64_1d *f_idx, const struct futhark_u8_2d *f_ks)
{
    struct futhark_opaque_partitionedSet_GFUR *v = malloc(sizeof(struct futhark_opaque_partitionedSet_GFUR));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_idx;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_u8_2d));
        *v->v1 = *f_ks;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_partitionedSet_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_partitionedSet_GFUR(struct futhark_context *ctx, const struct futhark_opaque_partitionedSet_GFUR *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v1), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v1, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_partitionedSet_GFUR *futhark_restore_opaque_partitionedSet_GFUR(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_partitionedSet_GFUR *obj = malloc(sizeof(struct futhark_opaque_partitionedSet_GFUR));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * shape_1[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_u8_2d(ctx, data_1, shape_1[0], shape_1[1]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_partitionInfo {
    struct futhark_i64_1d *v0;
    struct futhark_i32_1d *v1;
    int32_t v2;
    int32_t v3;
    int32_t v4;
};
int futhark_project_opaque_partitionInfo_bounds(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionInfo_depths(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    struct futhark_i32_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i32_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i32_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionInfo_maxDepth(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    int32_t v;
    
    v = obj->v2;
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionInfo_radixSize(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    int32_t v;
    
    v = obj->v3;
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionInfo_totalBytes(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    int32_t v;
    
    v = obj->v4;
    *out = v;
    return 0;
}
int futhark_new_opaque_partitionInfo(struct futhark_context *ctx, struct futhark_opaque_partitionInfo **out, const struct futhark_i64_1d *f_bounds, const struct futhark_i32_1d *f_depths, const int32_t f_maxDepth, const int32_t f_radixSizze, const int32_t f_totalBytes)
{
    struct futhark_opaque_partitionInfo *v = malloc(sizeof(struct futhark_opaque_partitionInfo));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_bounds;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i32_1d));
        *v->v1 = *f_depths;
        (void) (*v->v1->mem.references)++;
    }
    v->v2 = f_maxDepth;
    v->v3 = f_radixSizze;
    v->v4 = f_totalBytes;
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_partitionInfo(struct futhark_context *ctx, struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_partitionInfo(struct futhark_context *ctx, const struct futhark_opaque_partitionInfo *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i32_1d(ctx, obj->v1)[0] * sizeof(int32_t);
    int64_t size_2 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int32_t);
    int64_t size_3 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int32_t);
    int64_t size_4 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int32_t);
    
    *n = size_0 + size_1 + size_2 + size_3 + size_4;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, futhark_shape_i32_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i32_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i32_1d(ctx, obj->v1)[0] * sizeof(int32_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, &obj->v2, sizeof(obj->v2));
        out += sizeof(obj->v2);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, &obj->v3, sizeof(obj->v3));
        out += sizeof(obj->v3);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, &obj->v4, sizeof(obj->v4));
        out += sizeof(obj->v4);
    }
    return ret;
}
struct futhark_opaque_partitionInfo *futhark_restore_opaque_partitionInfo(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_partitionInfo *obj = malloc(sizeof(struct futhark_opaque_partitionInfo));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int32_t);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    src += sizeof(obj->v2);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_3 = src;
    
    src += sizeof(obj->v3);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_4 = src;
    
    src += sizeof(obj->v4);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i32_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
        memcpy(&obj->v2, data_2, sizeof(obj->v2));
        memcpy(&obj->v3, data_3, sizeof(obj->v3));
        memcpy(&obj->v4, data_4, sizeof(obj->v4));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_radix_hashTable {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
};
int futhark_project_opaque_radix_hashTable_first_info_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_radix_hashTable *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_radix_hashTable_last_info_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_radix_hashTable *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_radix_hashTable(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable **out, const struct futhark_i64_1d *f_first_info_idx, const struct futhark_i64_1d *f_last_info_idx)
{
    struct futhark_opaque_radix_hashTable *v = malloc(sizeof(struct futhark_opaque_radix_hashTable));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_first_info_idx;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_last_info_idx;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_radix_hashTable(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_radix_hashTable(struct futhark_context *ctx, const struct futhark_opaque_radix_hashTable *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    }
    return ret;
}
struct futhark_opaque_radix_hashTable *futhark_restore_opaque_radix_hashTable(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_radix_hashTable *obj = malloc(sizeof(struct futhark_opaque_radix_hashTable));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_joinPairs_bsq {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
    struct futhark_u8_2d *v2;
};
int futhark_project_opaque_joinPairs_bsq_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_bsq *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_bsq_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_bsq *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_bsq_vs(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_joinPairs_bsq *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v2, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_joinPairs_bsq(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_u8_2d *f_vs)
{
    struct futhark_opaque_joinPairs_bsq *v = malloc(sizeof(struct futhark_opaque_joinPairs_bsq));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_ix;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_iy;
        (void) (*v->v1->mem.references)++;
    }
    {
        v->v2 = malloc(sizeof(struct futhark_u8_2d));
        *v->v2 = *f_vs;
        (void) (*v->v2->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_joinPairs_bsq(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    if (obj->v2 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v2)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_joinPairs_bsq(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_bsq *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    int64_t size_2 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v2)[0] * futhark_shape_u8_2d(ctx, obj->v2)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1 + size_2;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v2), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v2, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v2)[0] * futhark_shape_u8_2d(ctx, obj->v2)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_joinPairs_bsq *futhark_restore_opaque_joinPairs_bsq(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_joinPairs_bsq *obj = malloc(sizeof(struct futhark_opaque_joinPairs_bsq));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    
    int64_t shape_2[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_2, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    obj->v2 = NULL;
    src += shape_2[0] * shape_2[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
        obj->v2 = futhark_new_u8_2d(ctx, data_2, shape_2[0], shape_2[1]);
        if (obj->v2 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        if (obj->v2 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v2)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}

FUTHARK_FUN_ATTR int futrts_entry_Inner_Radix_Hash_Join(struct futhark_context *ctx, struct memblock *mem_out_p_36018, struct memblock *mem_out_p_36019, struct memblock *mem_out_p_36020, int64_t *out_prim_out_36021, int64_t *out_prim_out_36022, int64_t *out_prim_out_36023, struct memblock pR_mem_35253, struct memblock pS_mem_35254, struct memblock bounds_mem_35255, struct memblock depths_mem_35256, struct memblock bounds_mem_35257, struct memblock depths_mem_35258, struct memblock first_info_idx_mem_35259, struct memblock last_info_idx_mem_35260, struct memblock first_info_idx_mem_35261, struct memblock last_info_idx_mem_35262, int64_t nR_23541, int64_t b_23542, int64_t nS_23543, int64_t dz2081U_23544, int64_t dz2081U_23545, int64_t dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546, int32_t radix_sizze_23547, int32_t maxDepth_23552, int32_t radixSizze_23553, int32_t totalBytes_23554, int32_t maxDepth_23557, int32_t radixSizze_23558, int32_t totalBytes_23559, int64_t scatter_psizze_23564)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_35264_cached_sizze_36024 = 0;
    unsigned char *mem_35264 = NULL;
    int64_t mem_35266_cached_sizze_36025 = 0;
    unsigned char *mem_35266 = NULL;
    int64_t mem_35268_cached_sizze_36026 = 0;
    unsigned char *mem_35268 = NULL;
    int64_t mem_35270_cached_sizze_36027 = 0;
    unsigned char *mem_35270 = NULL;
    int64_t mem_35272_cached_sizze_36028 = 0;
    unsigned char *mem_35272 = NULL;
    int64_t mem_35291_cached_sizze_36029 = 0;
    unsigned char *mem_35291 = NULL;
    int64_t mem_35292_cached_sizze_36030 = 0;
    unsigned char *mem_35292 = NULL;
    int64_t mem_35305_cached_sizze_36031 = 0;
    unsigned char *mem_35305 = NULL;
    int64_t mem_35306_cached_sizze_36032 = 0;
    unsigned char *mem_35306 = NULL;
    int64_t mem_35319_cached_sizze_36033 = 0;
    unsigned char *mem_35319 = NULL;
    int64_t mem_35320_cached_sizze_36034 = 0;
    unsigned char *mem_35320 = NULL;
    int64_t mem_35333_cached_sizze_36035 = 0;
    unsigned char *mem_35333 = NULL;
    int64_t mem_35334_cached_sizze_36036 = 0;
    unsigned char *mem_35334 = NULL;
    int64_t mem_35350_cached_sizze_36037 = 0;
    unsigned char *mem_35350 = NULL;
    int64_t mem_35351_cached_sizze_36038 = 0;
    unsigned char *mem_35351 = NULL;
    int64_t mem_35364_cached_sizze_36039 = 0;
    unsigned char *mem_35364 = NULL;
    int64_t mem_35365_cached_sizze_36040 = 0;
    unsigned char *mem_35365 = NULL;
    int64_t mem_35381_cached_sizze_36041 = 0;
    unsigned char *mem_35381 = NULL;
    int64_t mem_35382_cached_sizze_36042 = 0;
    unsigned char *mem_35382 = NULL;
    int64_t mem_35395_cached_sizze_36043 = 0;
    unsigned char *mem_35395 = NULL;
    int64_t mem_35396_cached_sizze_36044 = 0;
    unsigned char *mem_35396 = NULL;
    int64_t mem_35412_cached_sizze_36045 = 0;
    unsigned char *mem_35412 = NULL;
    int64_t mem_35413_cached_sizze_36046 = 0;
    unsigned char *mem_35413 = NULL;
    int64_t mem_35426_cached_sizze_36047 = 0;
    unsigned char *mem_35426 = NULL;
    int64_t mem_35427_cached_sizze_36048 = 0;
    unsigned char *mem_35427 = NULL;
    int64_t mem_35456_cached_sizze_36049 = 0;
    unsigned char *mem_35456 = NULL;
    int64_t mem_35458_cached_sizze_36050 = 0;
    unsigned char *mem_35458 = NULL;
    int64_t mem_35460_cached_sizze_36051 = 0;
    unsigned char *mem_35460 = NULL;
    int64_t mem_35559_cached_sizze_36052 = 0;
    unsigned char *mem_35559 = NULL;
    int64_t mem_35560_cached_sizze_36053 = 0;
    unsigned char *mem_35560 = NULL;
    int64_t mem_35574_cached_sizze_36054 = 0;
    unsigned char *mem_35574 = NULL;
    int64_t mem_35672_cached_sizze_36055 = 0;
    unsigned char *mem_35672 = NULL;
    int64_t mem_35673_cached_sizze_36056 = 0;
    unsigned char *mem_35673 = NULL;
    int64_t mem_35687_cached_sizze_36057 = 0;
    unsigned char *mem_35687 = NULL;
    struct memblock mem_param_tmp_35910;
    
    mem_param_tmp_35910.references = NULL;
    
    struct memblock mem_param_tmp_35909;
    
    mem_param_tmp_35909.references = NULL;
    
    struct memblock mem_param_tmp_35908;
    
    mem_param_tmp_35908.references = NULL;
    
    struct memblock mem_35761;
    
    mem_35761.references = NULL;
    
    struct memblock mem_35759;
    
    mem_35759.references = NULL;
    
    struct memblock mem_35757;
    
    mem_35757.references = NULL;
    
    struct memblock mem_param_tmp_35919;
    
    mem_param_tmp_35919.references = NULL;
    
    struct memblock mem_param_tmp_35918;
    
    mem_param_tmp_35918.references = NULL;
    
    struct memblock mem_param_tmp_35917;
    
    mem_param_tmp_35917.references = NULL;
    
    struct memblock mem_35745;
    
    mem_35745.references = NULL;
    
    struct memblock mem_35743;
    
    mem_35743.references = NULL;
    
    struct memblock mem_35741;
    
    mem_35741.references = NULL;
    
    struct memblock mem_param_tmp_35994;
    
    mem_param_tmp_35994.references = NULL;
    
    struct memblock mem_param_tmp_35993;
    
    mem_param_tmp_35993.references = NULL;
    
    struct memblock mem_param_tmp_35992;
    
    mem_param_tmp_35992.references = NULL;
    
    struct memblock mem_35535;
    
    mem_35535.references = NULL;
    
    struct memblock mem_35533;
    
    mem_35533.references = NULL;
    
    struct memblock mem_35531;
    
    mem_35531.references = NULL;
    
    struct memblock mem_param_tmp_36001;
    
    mem_param_tmp_36001.references = NULL;
    
    struct memblock mem_35519;
    
    mem_35519.references = NULL;
    
    struct memblock ext_mem_35522;
    
    ext_mem_35522.references = NULL;
    
    struct memblock mem_param_35516;
    
    mem_param_35516.references = NULL;
    
    struct memblock ext_mem_35525;
    
    ext_mem_35525.references = NULL;
    
    struct memblock mem_param_35513;
    
    mem_param_35513.references = NULL;
    
    struct memblock mem_param_35510;
    
    mem_param_35510.references = NULL;
    
    struct memblock mem_param_35507;
    
    mem_param_35507.references = NULL;
    
    struct memblock ext_mem_35543;
    
    ext_mem_35543.references = NULL;
    
    struct memblock ext_mem_35544;
    
    ext_mem_35544.references = NULL;
    
    struct memblock ext_mem_35545;
    
    ext_mem_35545.references = NULL;
    
    struct memblock mem_param_tmp_35973;
    
    mem_param_tmp_35973.references = NULL;
    
    struct memblock mem_param_tmp_35972;
    
    mem_param_tmp_35972.references = NULL;
    
    struct memblock mem_param_tmp_35971;
    
    mem_param_tmp_35971.references = NULL;
    
    struct memblock mem_35594;
    
    mem_35594.references = NULL;
    
    struct memblock ext_mem_35590;
    
    ext_mem_35590.references = NULL;
    
    struct memblock mem_35586;
    
    mem_35586.references = NULL;
    
    struct memblock mem_35596;
    
    mem_35596.references = NULL;
    
    struct memblock mem_35592;
    
    mem_35592.references = NULL;
    
    struct memblock mem_param_35557;
    
    mem_param_35557.references = NULL;
    
    struct memblock mem_param_35554;
    
    mem_param_35554.references = NULL;
    
    struct memblock mem_param_35551;
    
    mem_param_35551.references = NULL;
    
    struct memblock ext_mem_35604;
    
    ext_mem_35604.references = NULL;
    
    struct memblock ext_mem_35605;
    
    ext_mem_35605.references = NULL;
    
    struct memblock ext_mem_35606;
    
    ext_mem_35606.references = NULL;
    
    struct memblock mem_35588;
    
    mem_35588.references = NULL;
    
    struct memblock mem_35547;
    
    mem_35547.references = NULL;
    
    struct memblock ext_mem_35610;
    
    ext_mem_35610.references = NULL;
    
    struct memblock ext_mem_35613;
    
    ext_mem_35613.references = NULL;
    
    struct memblock ext_mem_35616;
    
    ext_mem_35616.references = NULL;
    
    struct memblock mem_param_tmp_35951;
    
    mem_param_tmp_35951.references = NULL;
    
    struct memblock mem_param_tmp_35950;
    
    mem_param_tmp_35950.references = NULL;
    
    struct memblock mem_param_tmp_35949;
    
    mem_param_tmp_35949.references = NULL;
    
    struct memblock mem_35648;
    
    mem_35648.references = NULL;
    
    struct memblock mem_35646;
    
    mem_35646.references = NULL;
    
    struct memblock mem_35644;
    
    mem_35644.references = NULL;
    
    struct memblock mem_param_tmp_35958;
    
    mem_param_tmp_35958.references = NULL;
    
    struct memblock mem_35632;
    
    mem_35632.references = NULL;
    
    struct memblock ext_mem_35635;
    
    ext_mem_35635.references = NULL;
    
    struct memblock mem_param_35629;
    
    mem_param_35629.references = NULL;
    
    struct memblock ext_mem_35638;
    
    ext_mem_35638.references = NULL;
    
    struct memblock mem_param_35626;
    
    mem_param_35626.references = NULL;
    
    struct memblock mem_param_35623;
    
    mem_param_35623.references = NULL;
    
    struct memblock mem_param_35620;
    
    mem_param_35620.references = NULL;
    
    struct memblock ext_mem_35656;
    
    ext_mem_35656.references = NULL;
    
    struct memblock ext_mem_35657;
    
    ext_mem_35657.references = NULL;
    
    struct memblock ext_mem_35658;
    
    ext_mem_35658.references = NULL;
    
    struct memblock mem_param_tmp_35930;
    
    mem_param_tmp_35930.references = NULL;
    
    struct memblock mem_param_tmp_35929;
    
    mem_param_tmp_35929.references = NULL;
    
    struct memblock mem_param_tmp_35928;
    
    mem_param_tmp_35928.references = NULL;
    
    struct memblock mem_35707;
    
    mem_35707.references = NULL;
    
    struct memblock ext_mem_35703;
    
    ext_mem_35703.references = NULL;
    
    struct memblock mem_35699;
    
    mem_35699.references = NULL;
    
    struct memblock mem_35709;
    
    mem_35709.references = NULL;
    
    struct memblock mem_35705;
    
    mem_35705.references = NULL;
    
    struct memblock mem_param_35670;
    
    mem_param_35670.references = NULL;
    
    struct memblock mem_param_35667;
    
    mem_param_35667.references = NULL;
    
    struct memblock mem_param_35664;
    
    mem_param_35664.references = NULL;
    
    struct memblock ext_mem_35717;
    
    ext_mem_35717.references = NULL;
    
    struct memblock ext_mem_35718;
    
    ext_mem_35718.references = NULL;
    
    struct memblock ext_mem_35719;
    
    ext_mem_35719.references = NULL;
    
    struct memblock mem_35701;
    
    mem_35701.references = NULL;
    
    struct memblock mem_35660;
    
    mem_35660.references = NULL;
    
    struct memblock ext_mem_35723;
    
    ext_mem_35723.references = NULL;
    
    struct memblock ext_mem_35726;
    
    ext_mem_35726.references = NULL;
    
    struct memblock ext_mem_35729;
    
    ext_mem_35729.references = NULL;
    
    struct memblock ext_mem_35733;
    
    ext_mem_35733.references = NULL;
    
    struct memblock ext_mem_35736;
    
    ext_mem_35736.references = NULL;
    
    struct memblock ext_mem_35739;
    
    ext_mem_35739.references = NULL;
    
    struct memblock mem_param_35503;
    
    mem_param_35503.references = NULL;
    
    struct memblock mem_param_35499;
    
    mem_param_35499.references = NULL;
    
    struct memblock mem_param_35496;
    
    mem_param_35496.references = NULL;
    
    struct memblock ext_mem_35753;
    
    ext_mem_35753.references = NULL;
    
    struct memblock ext_mem_35754;
    
    ext_mem_35754.references = NULL;
    
    struct memblock ext_mem_35755;
    
    ext_mem_35755.references = NULL;
    
    struct memblock mem_param_35493;
    
    mem_param_35493.references = NULL;
    
    struct memblock mem_param_35489;
    
    mem_param_35489.references = NULL;
    
    struct memblock mem_param_35486;
    
    mem_param_35486.references = NULL;
    
    struct memblock ext_mem_35769;
    
    ext_mem_35769.references = NULL;
    
    struct memblock ext_mem_35770;
    
    ext_mem_35770.references = NULL;
    
    struct memblock ext_mem_35771;
    
    ext_mem_35771.references = NULL;
    
    struct memblock mem_35483;
    
    mem_35483.references = NULL;
    
    struct memblock mem_35482;
    
    mem_35482.references = NULL;
    
    struct memblock mem_35481;
    
    mem_35481.references = NULL;
    
    struct memblock mem_35480;
    
    mem_35480.references = NULL;
    
    struct memblock mem_35479;
    
    mem_35479.references = NULL;
    
    struct memblock mem_out_35847;
    
    mem_out_35847.references = NULL;
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    int64_t prim_out_35848;
    int64_t prim_out_35849;
    int64_t prim_out_35850;
    int64_t i32_res_26560 = sext_i32_i64(radix_sizze_23547);
    bool nonnegative_26561 = sle64((int64_t) 0, i32_res_26560);
    bool nonzzero_cert_26562;
    
    if (!nonnegative_26561) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  ftHashJoin.fut:7:47-528:53\n   #1  ftHashJoin.fut:522:1-542:70\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t arg_26563 = shl64((int64_t) 1, i32_res_26560);
    bool assert_cond_26564 = arg_26563 == dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546;
    bool assert_c_26565;
    
    if (!assert_cond_26564) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: entry point arguments have invalid sizes.", "-> #0  unknown location\n   #1  ftHashJoin.fut:522:1-542:70\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool nonnegative_26566 = sle32(0, radix_sizze_23547);
    bool nonzzero_cert_26567;
    
    if (!nonnegative_26566) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  ftHashJoin.fut:365:24-36\n   #1  ftHashJoin.fut:528:4-539:18\n   #2  ftHashJoin.fut:522:1-542:70\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int32_t i32_arg0_26568 = shl32(1, radix_sizze_23547);
    int64_t i32_res_26569 = sext_i32_i64(i32_arg0_26568);
    bool bounds_invalid_upwards_26570 = slt64(i32_res_26569, (int64_t) 0);
    bool valid_26571 = !bounds_invalid_upwards_26570;
    bool range_valid_c_26572;
    
    if (!valid_26571) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) i32_res_26569, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  ftHashJoin.fut:366:7-16\n   #2  ftHashJoin.fut:528:4-539:18\n   #3  ftHashJoin.fut:522:1-542:70\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_35263 = (int64_t) 8 * i32_res_26569;
    
    if (mem_35264_cached_sizze_36024 < bytes_35263) {
        err = lexical_realloc(ctx, &mem_35264, &mem_35264_cached_sizze_36024, bytes_35263);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_35266_cached_sizze_36025 < bytes_35263) {
        err = lexical_realloc(ctx, &mem_35266, &mem_35266_cached_sizze_36025, bytes_35263);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_35268_cached_sizze_36026 < bytes_35263) {
        err = lexical_realloc(ctx, &mem_35268, &mem_35268_cached_sizze_36026, bytes_35263);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_35270_cached_sizze_36027 < bytes_35263) {
        err = lexical_realloc(ctx, &mem_35270, &mem_35270_cached_sizze_36027, bytes_35263);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_35272_cached_sizze_36028 < bytes_35263) {
        err = lexical_realloc(ctx, &mem_35272, &mem_35272_cached_sizze_36028, bytes_35263);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t discard_35175;
    int64_t scanacc_35163 = (int64_t) 0;
    
    for (int64_t i_35169 = 0; i_35169 < i32_res_26569; i_35169++) {
        bool y_28900 = slt64(i_35169, dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546);
        bool index_certs_28902;
        
        if (!y_28900) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_35169, "] out of bounds for array of shape [", (long long) dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546, "].", "-> #0  ftHashJoin.fut:368:17-24\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t rpi_28903 = ((int64_t *) first_info_idx_mem_35259.mem)[i_35169];
        int64_t spi_28904 = ((int64_t *) first_info_idx_mem_35261.mem)[i_35169];
        bool cond_28905 = rpi_28903 == (int64_t) -1;
        bool cond_f_res_28906 = spi_28904 == (int64_t) -1;
        bool x_28907 = !cond_28905;
        bool y_28908 = cond_f_res_28906 && x_28907;
        bool cond_28909 = cond_28905 || y_28908;
        int64_t lifted_lambda_res_28910;
        int64_t lifted_lambda_res_28911;
        
        if (cond_28909) {
            lifted_lambda_res_28910 = (int64_t) -1;
            lifted_lambda_res_28911 = (int64_t) -1;
        } else {
            bool x_28912 = sle64((int64_t) 0, spi_28904);
            bool y_28913 = slt64(spi_28904, dz2081U_23544);
            bool bounds_check_28914 = x_28912 && y_28913;
            bool index_certs_28915;
            
            if (!bounds_check_28914) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) spi_28904, "] out of bounds for array of shape [", (long long) dz2081U_23544, "].", "-> #0  ftHashJoin.fut:376:20-33\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int32_t zeze_lhs_28916 = ((int32_t *) depths_mem_35256.mem)[spi_28904];
            bool cond_28917 = zeze_lhs_28916 == 1;
            bool cond_28918;
            
            if (cond_28917) {
                cond_28918 = 1;
            } else {
                bool y_28919 = slt64(spi_28904, dz2081U_23545);
                bool bounds_check_28920 = x_28912 && y_28919;
                bool index_certs_28921;
                
                if (!bounds_check_28920) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) spi_28904, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:376:42-55\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t zeze_lhs_28922 = ((int32_t *) depths_mem_35258.mem)[spi_28904];
                bool cond_f_res_28923 = zeze_lhs_28922 == 1;
                
                cond_28918 = cond_f_res_28923;
            }
            
            bool x_35819 = !cond_28918;
            int64_t last_potential_spi_28937;
            
            if (x_35819) {
                int64_t x_35821 = ((int64_t *) last_info_idx_mem_35262.mem)[i_35169];
                
                last_potential_spi_28937 = x_35821;
            } else {
                last_potential_spi_28937 = (int64_t) 0;
            }
            
            int64_t zs_lhs_28938 = sub64(last_potential_spi_28937, spi_28904);
            int64_t min_arg1_28939 = sdiv64(zs_lhs_28938, (int64_t) 2);
            int64_t min_res_28940 = smin64((int64_t) 1, min_arg1_28939);
            bool loop_cond_28941 = slt64((int64_t) 0, min_res_28940);
            int64_t lifted_lambda_res_f_res_28924;
            int64_t lifted_lambda_res_f_res_28925;
            
            if (cond_28918) {
                int64_t tmp_34392 = ((int64_t *) last_info_idx_mem_35262.mem)[i_35169];
                
                lifted_lambda_res_f_res_28924 = spi_28904;
                lifted_lambda_res_f_res_28925 = tmp_34392;
            } else {
                bool x_28927 = sle64((int64_t) 0, rpi_28903);
                bool y_28928 = slt64(rpi_28903, dz2081U_23544);
                bool bounds_check_28929 = x_28927 && y_28928;
                bool index_certs_28930;
                
                if (!bounds_check_28929) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) rpi_28903, "] out of bounds for array of shape [", (long long) dz2081U_23544, "].", "-> #0  ftHashJoin.fut:380:28-41\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t cur_R_28931 = ((int64_t *) bounds_mem_35255.mem)[rpi_28903];
                bool x_28932 = sle64((int64_t) 0, cur_R_28931);
                bool y_28933 = slt64(cur_R_28931, nR_23541);
                bool bounds_check_28934 = x_28932 && y_28933;
                bool index_certs_28935;
                
                if (!bounds_check_28934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) cur_R_28931, "] out of bounds for array of shape [", (long long) nR_23541, "].", "-> #0  ftHashJoin.fut:380:25-42\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool loop_not_taken_28942 = !loop_cond_28941;
                bool protect_assert_disj_28943 = bounds_check_28929 || loop_not_taken_28942;
                bool index_certs_28944;
                
                if (!protect_assert_disj_28943) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) rpi_28903, "] out of bounds for array of shape [", (long long) dz2081U_23544, "].", "-> #0  ftHashJoin.fut:388:41-54\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t i64_res_28947 = sext_i64_i32(b_23542);
                int32_t i32_arg0_28948 = sub32(i64_res_28947, 1);
                int64_t i32_res_28949 = sext_i32_i64(i32_arg0_28948);
                bool x_28951 = sle64((int64_t) 0, i32_res_28949);
                bool y_28952 = slt64(i32_res_28949, b_23542);
                bool bounds_check_28953 = x_28951 && y_28952;
                bool protect_assert_disj_28954 = loop_not_taken_28942 || bounds_check_28953;
                bool index_certs_28955;
                
                if (!protect_assert_disj_28954) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_28949, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:32:48-64\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t min_arg0_28945;
                
                if (loop_cond_28941) {
                    int32_t x_34393 = ((int32_t *) depths_mem_35256.mem)[rpi_28903];
                    
                    min_arg0_28945 = x_34393;
                } else {
                    min_arg0_28945 = 0;
                }
                if (mem_35291_cached_sizze_36029 < b_23542) {
                    err = lexical_realloc(ctx, &mem_35291, &mem_35291_cached_sizze_36029, b_23542);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
                if (mem_35292_cached_sizze_36030 < b_23542) {
                    err = lexical_realloc(ctx, &mem_35292, &mem_35292_cached_sizze_36030, b_23542);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
                
                bool lifted_lambda_res_f_res_f_res_28956;
                int64_t lifted_lambda_res_f_res_f_res_28957;
                int64_t lifted_lambda_res_f_res_f_res_28958;
                bool loop_while_28959;
                int64_t first_spi_28960;
                int64_t step_28961;
                
                loop_while_28959 = loop_cond_28941;
                first_spi_28960 = spi_28904;
                step_28961 = min_res_28940;
                while (loop_while_28959) {
                    bool x_28962 = sle64((int64_t) 0, first_spi_28960);
                    bool y_28963 = slt64(first_spi_28960, dz2081U_23545);
                    bool bounds_check_28964 = x_28962 && y_28963;
                    bool index_certs_28965;
                    
                    if (!bounds_check_28964) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) first_spi_28960, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:387:32-51\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t cur_S_28966 = ((int64_t *) bounds_mem_35257.mem)[first_spi_28960];
                    bool x_28967 = sle64((int64_t) 0, cur_S_28966);
                    bool y_28968 = slt64(cur_S_28966, nS_23543);
                    bool bounds_check_28969 = x_28967 && y_28968;
                    bool index_certs_28970;
                    
                    if (!bounds_check_28969) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) cur_S_28966, "] out of bounds for array of shape [", (long long) nS_23543, "].", "-> #0  ftHashJoin.fut:387:29-52\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t min_arg1_28972 = ((int32_t *) depths_mem_35258.mem)[first_spi_28960];
                    int32_t min_res_28973 = smin32(min_arg0_28945, min_arg1_28972);
                    int32_t zm_lhs_28974 = mul32(radix_sizze_23547, min_res_28973);
                    int32_t last_bit_28975 = sub32(zm_lhs_28974, 1);
                    bool cond_28976 = slt64(spi_28904, first_spi_28960);
                    int64_t tmp_34394 = sub64(first_spi_28960, (int64_t) 1);
                    bool x_34395 = sle64((int64_t) 0, tmp_34394);
                    bool y_34396 = slt64(tmp_34394, dz2081U_23545);
                    bool bounds_check_34397 = x_34395 && y_34396;
                    bool loop_not_taken_35813 = !cond_28976;
                    bool protect_assert_disj_35814 = bounds_check_34397 || loop_not_taken_35813;
                    bool index_certs_34398;
                    
                    if (!protect_assert_disj_35814) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34394, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:390:59-80\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t zm_rhs_29024 = sdiv32(last_bit_28975, 8);
                    int32_t zm_lhs_29025 = sub32(i64_res_28947, zm_rhs_29024);
                    int32_t i32_arg0_29026 = sub32(zm_lhs_29025, 1);
                    int64_t i32_res_29027 = sext_i32_i64(i32_arg0_29026);
                    bool y_29044 = slt64(i32_res_29027, b_23542);
                    bool x_29043 = sle64((int64_t) 0, i32_res_29027);
                    bool bounds_check_29045 = x_29043 && y_29044;
                    bool index_certs_29046;
                    
                    if (!bounds_check_29045) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_29027, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:33:38-54\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t lmad_ext_35288 = b_23542 * cur_S_28966;
                    int64_t tmp_34399;
                    
                    if (cond_28976) {
                        int64_t x_35815 = ((int64_t *) bounds_mem_35257.mem)[tmp_34394];
                        
                        tmp_34399 = x_35815;
                    } else {
                        tmp_34399 = (int64_t) 0;
                    }
                    
                    int64_t lmad_ext_35289 = b_23542 * tmp_34399;
                    int64_t ext_35290;
                    
                    if (cond_28976) {
                        ext_35290 = lmad_ext_35289;
                    } else {
                        ext_35290 = lmad_ext_35288;
                    }
                    if (cond_28976) {
                        bool x_34400 = sle64((int64_t) 0, tmp_34399);
                        bool y_34401 = slt64(tmp_34399, nS_23543);
                        bool bounds_check_34402 = x_34400 && y_34401;
                        bool index_certs_34403;
                        
                        if (!bounds_check_34402) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34399, "] out of bounds for array of shape [", (long long) nS_23543, "].", "-> #0  ftHashJoin.fut:390:56-81\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                    }
                    
                    int32_t prev_depth_28989;
                    
                    if (cond_28976) {
                        bool index_certs_34409;
                        
                        if (!bounds_check_34397) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34394, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:391:83-104\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t min_arg1_34410 = ((int32_t *) depths_mem_35258.mem)[tmp_34394];
                        int32_t min_arg0_34411 = ((int32_t *) depths_mem_35256.mem)[rpi_28903];
                        int32_t min_res_34412 = smin32(min_arg1_34410, min_arg0_34411);
                        
                        prev_depth_28989 = min_res_34412;
                    } else {
                        prev_depth_28989 = min_res_28973;
                    }
                    
                    int32_t zm_lhs_28998 = mul32(radix_sizze_23547, prev_depth_28989);
                    int32_t prev_last_bit_28999 = sub32(zm_lhs_28998, 1);
                    bool cond_29000 = slt64(first_spi_28960, last_potential_spi_28937);
                    
                    for (int64_t i_35084 = 0; i_35084 < b_23542; i_35084++) {
                        int8_t eta_p_29697 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35084];
                        int8_t eta_p_29698 = ((int8_t *) pS_mem_35254.mem)[cur_S_28966 * b_23542 + i_35084];
                        bool cond_29700 = sle64(i_35084, i32_res_28949);
                        bool cond_t_res_29701 = sle64(i32_res_29027, i_35084);
                        bool x_29702 = cond_29700 && cond_t_res_29701;
                        int8_t lifted_lambda_res_29703;
                        
                        if (x_29702) {
                            lifted_lambda_res_29703 = eta_p_29697;
                        } else {
                            lifted_lambda_res_29703 = (int8_t) 0;
                        }
                        
                        int8_t lifted_lambda_res_29708;
                        
                        if (x_29702) {
                            lifted_lambda_res_29708 = eta_p_29698;
                        } else {
                            lifted_lambda_res_29708 = (int8_t) 0;
                        }
                        ((int8_t *) mem_35291)[i_35084] = lifted_lambda_res_29708;
                        ((int8_t *) mem_35292)[i_35084] = lifted_lambda_res_29703;
                    }
                    
                    int8_t za_lhs_29057 = ((int8_t *) mem_35291)[i32_res_28949];
                    int8_t mod1_x_29058 = (int8_t) -1 & za_lhs_29057;
                    
                    ((int8_t *) mem_35291)[i32_res_28949] = mod1_x_29058;
                    
                    int8_t za_lhs_29060 = ((int8_t *) mem_35291)[i32_res_29027];
                    int32_t lastBit_29028 = smod32(last_bit_28975, 8);
                    int32_t zm_lhs_29029 = sub32(8, lastBit_29028);
                    int32_t i32_arg0_29030 = sub32(zm_lhs_29029, 1);
                    int8_t unsign_arg0_29031 = zext_i32_i8(i32_arg0_29030);
                    int8_t unsign_arg0_29032 = lshr8((int8_t) -1, unsign_arg0_29031);
                    int8_t tmp_29061 = unsign_arg0_29032 & za_lhs_29060;
                    
                    ((int8_t *) mem_35291)[i32_res_29027] = tmp_29061;
                    
                    int8_t za_lhs_29040 = ((int8_t *) mem_35292)[i32_res_28949];
                    int8_t mod1_x_29041 = (int8_t) -1 & za_lhs_29040;
                    
                    ((int8_t *) mem_35292)[i32_res_28949] = mod1_x_29041;
                    
                    int8_t za_lhs_29047 = ((int8_t *) mem_35292)[i32_res_29027];
                    int8_t tmp_29048 = unsign_arg0_29032 & za_lhs_29047;
                    
                    ((int8_t *) mem_35292)[i32_res_29027] = tmp_29048;
                    
                    bool defunc_0_reduce_res_34579;
                    bool redout_35087 = 1;
                    
                    for (int64_t i_35088 = 0; i_35088 < b_23542; i_35088++) {
                        int8_t eta_p_29691 = ((int8_t *) mem_35292)[i_35088];
                        int8_t eta_p_29692 = ((int8_t *) mem_35291)[i_35088];
                        bool defunc_0_f_res_29693 = eta_p_29691 == eta_p_29692;
                        bool x_29071 = defunc_0_f_res_29693 && redout_35087;
                        bool redout_tmp_35862 = x_29071;
                        
                        redout_35087 = redout_tmp_35862;
                    }
                    defunc_0_reduce_res_34579 = redout_35087;
                    
                    bool cond_29072;
                    
                    if (defunc_0_reduce_res_34579) {
                        bool cond_34416 = first_spi_28960 == spi_28904;
                        bool cond_t_res_34417;
                        
                        if (cond_34416) {
                            cond_t_res_34417 = 1;
                        } else {
                            int32_t zm_rhs_34418 = sdiv32(prev_last_bit_28999, 8);
                            int32_t zm_lhs_34419 = sub32(i64_res_28947, zm_rhs_34418);
                            int32_t i32_arg0_34420 = sub32(zm_lhs_34419, 1);
                            int64_t i32_res_34421 = sext_i32_i64(i32_arg0_34420);
                            bool index_certs_34442;
                            
                            if (!bounds_check_28953) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_28949, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:32:48-64\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            bool x_34446 = sle64((int64_t) 0, i32_res_34421);
                            bool y_34447 = slt64(i32_res_34421, b_23542);
                            bool bounds_check_34448 = x_34446 && y_34447;
                            bool index_certs_34449;
                            
                            if (!bounds_check_34448) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_34421, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:33:38-54\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t lastBit_34422 = smod32(prev_last_bit_28999, 8);
                            int32_t zm_lhs_34423 = sub32(8, lastBit_34422);
                            int32_t i32_arg0_34424 = sub32(zm_lhs_34423, 1);
                            int8_t unsign_arg0_34425 = zext_i32_i8(i32_arg0_34424);
                            int8_t unsign_arg0_34426 = lshr8((int8_t) -1, unsign_arg0_34425);
                            
                            if (mem_35305_cached_sizze_36031 < b_23542) {
                                err = lexical_realloc(ctx, &mem_35305, &mem_35305_cached_sizze_36031, b_23542);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            if (mem_35306_cached_sizze_36032 < b_23542) {
                                err = lexical_realloc(ctx, &mem_35306, &mem_35306_cached_sizze_36032, b_23542);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            for (int64_t i_35093 = 0; i_35093 < b_23542; i_35093++) {
                                int8_t eta_p_34430 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35093];
                                int8_t eta_p_34431 = ((int8_t *) pS_mem_35254.mem)[ext_35290 + i_35093];
                                bool cond_34432 = sle64(i_35093, i32_res_28949);
                                bool cond_t_res_34433 = sle64(i32_res_34421, i_35093);
                                bool x_34434 = cond_34432 && cond_t_res_34433;
                                int8_t lifted_lambda_res_34435;
                                
                                if (x_34434) {
                                    lifted_lambda_res_34435 = eta_p_34430;
                                } else {
                                    lifted_lambda_res_34435 = (int8_t) 0;
                                }
                                
                                int8_t lifted_lambda_res_34439;
                                
                                if (x_34434) {
                                    lifted_lambda_res_34439 = eta_p_34431;
                                } else {
                                    lifted_lambda_res_34439 = (int8_t) 0;
                                }
                                ((int8_t *) mem_35305)[i_35093] = lifted_lambda_res_34439;
                                ((int8_t *) mem_35306)[i_35093] = lifted_lambda_res_34435;
                            }
                            
                            int8_t za_lhs_34443 = ((int8_t *) mem_35306)[i32_res_28949];
                            int8_t mod1_x_34444 = (int8_t) -1 & za_lhs_34443;
                            
                            ((int8_t *) mem_35306)[i32_res_28949] = mod1_x_34444;
                            
                            int8_t za_lhs_34450 = ((int8_t *) mem_35306)[i32_res_34421];
                            int8_t tmp_34451 = unsign_arg0_34426 & za_lhs_34450;
                            
                            ((int8_t *) mem_35306)[i32_res_34421] = tmp_34451;
                            
                            int8_t za_lhs_34453 = ((int8_t *) mem_35305)[i32_res_28949];
                            int8_t mod1_x_34454 = (int8_t) -1 & za_lhs_34453;
                            
                            ((int8_t *) mem_35305)[i32_res_28949] = mod1_x_34454;
                            
                            int8_t za_lhs_34456 = ((int8_t *) mem_35305)[i32_res_34421];
                            int8_t tmp_34457 = unsign_arg0_34426 & za_lhs_34456;
                            
                            ((int8_t *) mem_35305)[i32_res_34421] = tmp_34457;
                            
                            bool defunc_0_reduce_res_34459;
                            bool redout_35096 = 0;
                            
                            for (int64_t i_35097 = 0; i_35097 < b_23542; i_35097++) {
                                int8_t eta_p_34460 = ((int8_t *) mem_35306)[i_35097];
                                int8_t eta_p_34461 = ((int8_t *) mem_35305)[i_35097];
                                bool defunc_0_f_res_34462 = eta_p_34460 == eta_p_34461;
                                bool defunc_0_f_res_34463 = !defunc_0_f_res_34462;
                                bool defunc_0_op_res_34466 = defunc_0_f_res_34463 || redout_35096;
                                bool redout_tmp_35865 = defunc_0_op_res_34466;
                                
                                redout_35096 = redout_tmp_35865;
                            }
                            defunc_0_reduce_res_34459 = redout_35096;
                            cond_t_res_34417 = defunc_0_reduce_res_34459;
                        }
                        cond_29072 = cond_t_res_34417;
                    } else {
                        cond_29072 = 0;
                    }
                    
                    int32_t next_depth_29013;
                    
                    if (cond_29000) {
                        int64_t min_arg1_34468 = add64((int64_t) 1, first_spi_28960);
                        bool x_34469 = sle64((int64_t) 0, min_arg1_34468);
                        bool y_34470 = slt64(min_arg1_34468, dz2081U_23545);
                        bool bounds_check_34471 = x_34469 && y_34470;
                        bool index_certs_34472;
                        
                        if (!bounds_check_34471) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_arg1_34468, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:394:98-119\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t min_arg1_34473 = ((int32_t *) depths_mem_35258.mem)[min_arg1_34468];
                        int32_t min_arg0_34474 = ((int32_t *) depths_mem_35256.mem)[rpi_28903];
                        int32_t min_res_34475 = smin32(min_arg1_34473, min_arg0_34474);
                        
                        next_depth_29013 = min_res_34475;
                    } else {
                        next_depth_29013 = min_res_28973;
                    }
                    
                    int32_t zm_lhs_29022 = mul32(radix_sizze_23547, next_depth_29013);
                    int32_t next_last_bit_29023 = sub32(zm_lhs_29022, 1);
                    int64_t loopres_29125;
                    int64_t loopres_29126;
                    
                    if (cond_29072) {
                        loopres_29125 = first_spi_28960;
                        loopres_29126 = (int64_t) 0;
                    } else {
                        bool index_certs_29134;
                        
                        if (!bounds_check_28953) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_28949, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:32:48-64\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool loop_cond_t_res_29154 = slt64((int64_t) 0, b_23542);
                        
                        if (mem_35319_cached_sizze_36033 < b_23542) {
                            err = lexical_realloc(ctx, &mem_35319, &mem_35319_cached_sizze_36033, b_23542);
                            if (err != FUTHARK_SUCCESS)
                                goto cleanup;
                        }
                        if (mem_35320_cached_sizze_36034 < b_23542) {
                            err = lexical_realloc(ctx, &mem_35320, &mem_35320_cached_sizze_36034, b_23542);
                            if (err != FUTHARK_SUCCESS)
                                goto cleanup;
                        }
                        for (int64_t i_35102 = 0; i_35102 < b_23542; i_35102++) {
                            int8_t eta_p_29753 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35102];
                            int8_t eta_p_29754 = ((int8_t *) pS_mem_35254.mem)[cur_S_28966 * b_23542 + i_35102];
                            bool cond_29756 = sle64(i_35102, i32_res_28949);
                            bool cond_t_res_29757 = sle64(i32_res_29027, i_35102);
                            bool x_29758 = cond_29756 && cond_t_res_29757;
                            int8_t lifted_lambda_res_29759;
                            
                            if (x_29758) {
                                lifted_lambda_res_29759 = eta_p_29753;
                            } else {
                                lifted_lambda_res_29759 = (int8_t) 0;
                            }
                            
                            int8_t lifted_lambda_res_29764;
                            
                            if (x_29758) {
                                lifted_lambda_res_29764 = eta_p_29754;
                            } else {
                                lifted_lambda_res_29764 = (int8_t) 0;
                            }
                            ((int8_t *) mem_35319)[i_35102] = lifted_lambda_res_29764;
                            ((int8_t *) mem_35320)[i_35102] = lifted_lambda_res_29759;
                        }
                        
                        int8_t za_lhs_29148 = ((int8_t *) mem_35319)[i32_res_28949];
                        int8_t mod1_x_29149 = (int8_t) -1 & za_lhs_29148;
                        
                        ((int8_t *) mem_35319)[i32_res_28949] = mod1_x_29149;
                        
                        int8_t za_lhs_29151 = ((int8_t *) mem_35319)[i32_res_29027];
                        int8_t tmp_29152 = unsign_arg0_29032 & za_lhs_29151;
                        
                        ((int8_t *) mem_35319)[i32_res_29027] = tmp_29152;
                        
                        int8_t za_lhs_29135 = ((int8_t *) mem_35320)[i32_res_28949];
                        int8_t mod1_x_29136 = (int8_t) -1 & za_lhs_29135;
                        
                        ((int8_t *) mem_35320)[i32_res_28949] = mod1_x_29136;
                        
                        int8_t za_lhs_29138 = ((int8_t *) mem_35320)[i32_res_29027];
                        int8_t tmp_29139 = unsign_arg0_29032 & za_lhs_29138;
                        
                        ((int8_t *) mem_35320)[i32_res_29027] = tmp_29139;
                        
                        bool radix_gt_res_29155;
                        int64_t radix_gt_res_29156;
                        bool radix_gt_res_29157;
                        bool loop_while_29158;
                        int64_t p_29159;
                        bool p_29160;
                        
                        loop_while_29158 = loop_cond_t_res_29154;
                        p_29159 = (int64_t) 0;
                        p_29160 = 0;
                        while (loop_while_29158) {
                            bool x_29161 = sle64((int64_t) 0, p_29159);
                            bool y_29162 = slt64(p_29159, b_23542);
                            bool bounds_check_29163 = x_29161 && y_29162;
                            bool index_certs_29164;
                            
                            if (!bounds_check_29163) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_29159, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:104:17-27\n   #1  ftHashJoin.fut:401:20-51\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftHashJoin.fut:367:8-439:6\n   #4  ftHashJoin.fut:528:4-539:18\n   #5  ftHashJoin.fut:522:1-542:70\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int8_t zl_lhs_29165 = ((int8_t *) mem_35320)[p_29159];
                            int8_t zl_rhs_29166 = ((int8_t *) mem_35319)[p_29159];
                            bool dlt_29167 = ult8(zl_lhs_29165, zl_rhs_29166);
                            bool dgt_29168 = ult8(zl_rhs_29166, zl_lhs_29165);
                            bool tmp_29169 = dlt_29167 || dgt_29168;
                            bool cond_29170 = !tmp_29169;
                            int64_t tmp_29171;
                            
                            if (cond_29170) {
                                int64_t tmp_t_res_34476 = add64((int64_t) 1, p_29159);
                                
                                tmp_29171 = tmp_t_res_34476;
                            } else {
                                tmp_29171 = b_23542;
                            }
                            
                            bool cond_29173 = !dgt_29168;
                            bool loop_cond_t_res_29174 = slt64(tmp_29171, b_23542);
                            bool x_29175 = cond_29173 && loop_cond_t_res_29174;
                            bool loop_while_tmp_35868 = x_29175;
                            int64_t p_tmp_35869 = tmp_29171;
                            bool p_tmp_35870 = dgt_29168;
                            
                            loop_while_29158 = loop_while_tmp_35868;
                            p_29159 = p_tmp_35869;
                            p_29160 = p_tmp_35870;
                        }
                        radix_gt_res_29155 = loop_while_29158;
                        radix_gt_res_29156 = p_29159;
                        radix_gt_res_29157 = p_29160;
                        
                        int64_t loopres_f_res_29176;
                        int64_t loopres_f_res_29177;
                        
                        if (radix_gt_res_29157) {
                            bool cond_34491 = first_spi_28960 == last_potential_spi_28937;
                            int64_t tmp_34495 = add64((int64_t) 1, first_spi_28960);
                            bool x_34496 = sle64((int64_t) 0, tmp_34495);
                            bool y_34497 = slt64(tmp_34495, dz2081U_23545);
                            bool bounds_check_34498 = x_34496 && y_34497;
                            bool loop_not_taken_35807 = !cond_29000;
                            bool protect_assert_disj_35808 = bounds_check_34498 || loop_not_taken_35807;
                            bool protect_assert_disj_35833 = cond_34491 || protect_assert_disj_35808;
                            bool index_certs_34499;
                            
                            if (!protect_assert_disj_35833) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34495, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:393:74-95\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            bool x_35830 = !cond_34491;
                            bool protect_cond_conj_35834 = cond_29000 && x_35830;
                            int64_t tmp_34500;
                            
                            if (protect_cond_conj_35834) {
                                int64_t x_35809 = ((int64_t *) bounds_mem_35257.mem)[tmp_34495];
                                
                                tmp_34500 = x_35809;
                            } else {
                                tmp_34500 = (int64_t) 0;
                            }
                            
                            int64_t lmad_ext_35348 = b_23542 * tmp_34500;
                            int64_t ext_35349;
                            
                            if (cond_29000) {
                                ext_35349 = lmad_ext_35348;
                            } else {
                                ext_35349 = lmad_ext_35288;
                            }
                            
                            int64_t loopres_f_res_t_res_34492;
                            int64_t loopres_f_res_t_res_34493;
                            
                            if (cond_34491) {
                                loopres_f_res_t_res_34492 = (int64_t) -1;
                                loopres_f_res_t_res_34493 = (int64_t) 0;
                            } else {
                                int32_t zm_rhs_34506 = sdiv32(next_last_bit_29023, 8);
                                int32_t zm_lhs_34507 = sub32(i64_res_28947, zm_rhs_34506);
                                int32_t i32_arg0_34508 = sub32(zm_lhs_34507, 1);
                                int64_t i32_res_34509 = sext_i32_i64(i32_arg0_34508);
                                bool x_34533 = sle64((int64_t) 0, i32_res_34509);
                                bool y_34534 = slt64(i32_res_34509, b_23542);
                                bool bounds_check_34535 = x_34533 && y_34534;
                                bool index_certs_34536;
                                
                                if (!bounds_check_34535) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_34509, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:33:38-54\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                if (cond_29000) {
                                    bool x_34501 = sle64((int64_t) 0, tmp_34500);
                                    bool y_34502 = slt64(tmp_34500, nS_23543);
                                    bool bounds_check_34503 = x_34501 && y_34502;
                                    bool index_certs_34504;
                                    
                                    if (!bounds_check_34503) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34500, "] out of bounds for array of shape [", (long long) nS_23543, "].", "-> #0  ftHashJoin.fut:393:71-96\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                }
                                
                                int32_t lastBit_34510 = smod32(next_last_bit_29023, 8);
                                int32_t zm_lhs_34511 = sub32(8, lastBit_34510);
                                int32_t i32_arg0_34512 = sub32(zm_lhs_34511, 1);
                                int8_t unsign_arg0_34513 = zext_i32_i8(i32_arg0_34512);
                                int8_t unsign_arg0_34514 = lshr8((int8_t) -1, unsign_arg0_34513);
                                
                                if (mem_35350_cached_sizze_36037 < b_23542) {
                                    err = lexical_realloc(ctx, &mem_35350, &mem_35350_cached_sizze_36037, b_23542);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                if (mem_35351_cached_sizze_36038 < b_23542) {
                                    err = lexical_realloc(ctx, &mem_35351, &mem_35351_cached_sizze_36038, b_23542);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                for (int64_t i_35109 = 0; i_35109 < b_23542; i_35109++) {
                                    int8_t eta_p_34518 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35109];
                                    int8_t eta_p_34519 = ((int8_t *) pS_mem_35254.mem)[ext_35349 + i_35109];
                                    bool cond_34520 = sle64(i_35109, i32_res_28949);
                                    bool cond_t_res_34521 = sle64(i32_res_34509, i_35109);
                                    bool x_34522 = cond_34520 && cond_t_res_34521;
                                    int8_t lifted_lambda_res_34523;
                                    
                                    if (x_34522) {
                                        lifted_lambda_res_34523 = eta_p_34518;
                                    } else {
                                        lifted_lambda_res_34523 = (int8_t) 0;
                                    }
                                    
                                    int8_t lifted_lambda_res_34527;
                                    
                                    if (x_34522) {
                                        lifted_lambda_res_34527 = eta_p_34519;
                                    } else {
                                        lifted_lambda_res_34527 = (int8_t) 0;
                                    }
                                    ((int8_t *) mem_35350)[i_35109] = lifted_lambda_res_34527;
                                    ((int8_t *) mem_35351)[i_35109] = lifted_lambda_res_34523;
                                }
                                
                                int8_t za_lhs_34530 = ((int8_t *) mem_35351)[i32_res_28949];
                                int8_t mod1_x_34531 = (int8_t) -1 & za_lhs_34530;
                                
                                ((int8_t *) mem_35351)[i32_res_28949] = mod1_x_34531;
                                
                                int8_t za_lhs_34537 = ((int8_t *) mem_35351)[i32_res_34509];
                                int8_t tmp_34538 = unsign_arg0_34514 & za_lhs_34537;
                                
                                ((int8_t *) mem_35351)[i32_res_34509] = tmp_34538;
                                
                                int8_t za_lhs_34540 = ((int8_t *) mem_35350)[i32_res_28949];
                                int8_t mod1_x_34541 = (int8_t) -1 & za_lhs_34540;
                                
                                ((int8_t *) mem_35350)[i32_res_28949] = mod1_x_34541;
                                
                                int8_t za_lhs_34543 = ((int8_t *) mem_35350)[i32_res_34509];
                                int8_t tmp_34544 = unsign_arg0_34514 & za_lhs_34543;
                                
                                ((int8_t *) mem_35350)[i32_res_34509] = tmp_34544;
                                
                                bool radix_lt_res_34546;
                                int64_t radix_lt_res_34547;
                                bool radix_lt_res_34548;
                                bool loop_while_34549;
                                int64_t p_34550;
                                bool p_34551;
                                
                                loop_while_34549 = loop_cond_t_res_29154;
                                p_34550 = (int64_t) 0;
                                p_34551 = 0;
                                while (loop_while_34549) {
                                    bool x_34552 = sle64((int64_t) 0, p_34550);
                                    bool y_34553 = slt64(p_34550, b_23542);
                                    bool bounds_check_34554 = x_34552 && y_34553;
                                    bool index_certs_34555;
                                    
                                    if (!bounds_check_34554) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_34550, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:71:17-27\n   #1  ftHashJoin.fut:404:23-60\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftHashJoin.fut:367:8-439:6\n   #4  ftHashJoin.fut:528:4-539:18\n   #5  ftHashJoin.fut:522:1-542:70\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int8_t zl_lhs_34556 = ((int8_t *) mem_35351)[p_34550];
                                    int8_t zl_rhs_34557 = ((int8_t *) mem_35350)[p_34550];
                                    bool dlt_34558 = ult8(zl_lhs_34556, zl_rhs_34557);
                                    bool dgt_34559 = ult8(zl_rhs_34557, zl_lhs_34556);
                                    bool tmp_34560 = dlt_34558 || dgt_34559;
                                    bool cond_34561 = !tmp_34560;
                                    int64_t tmp_34562;
                                    
                                    if (cond_34561) {
                                        int64_t tmp_t_res_34563 = add64((int64_t) 1, p_34550);
                                        
                                        tmp_34562 = tmp_t_res_34563;
                                    } else {
                                        tmp_34562 = b_23542;
                                    }
                                    
                                    bool cond_34564 = !dlt_34558;
                                    bool loop_cond_t_res_34565 = slt64(tmp_34562, b_23542);
                                    bool x_34566 = cond_34564 && loop_cond_t_res_34565;
                                    bool loop_while_tmp_35873 = x_34566;
                                    int64_t p_tmp_35874 = tmp_34562;
                                    bool p_tmp_35875 = dlt_34558;
                                    
                                    loop_while_34549 = loop_while_tmp_35873;
                                    p_34550 = p_tmp_35874;
                                    p_34551 = p_tmp_35875;
                                }
                                radix_lt_res_34546 = loop_while_34549;
                                radix_lt_res_34547 = p_34550;
                                radix_lt_res_34548 = p_34551;
                                
                                int64_t loopres_f_res_t_res_f_res_34567;
                                int64_t loopres_f_res_t_res_f_res_34568;
                                
                                if (radix_lt_res_34548) {
                                    loopres_f_res_t_res_f_res_34567 = (int64_t) -1;
                                    loopres_f_res_t_res_f_res_34568 = (int64_t) 0;
                                } else {
                                    int64_t tmp_34569 = add64(first_spi_28960, step_28961);
                                    int64_t min_arg1_34570 = sdiv64(step_28961, (int64_t) 2);
                                    int64_t min_res_34571 = smin64((int64_t) 1, min_arg1_34570);
                                    
                                    loopres_f_res_t_res_f_res_34567 = tmp_34569;
                                    loopres_f_res_t_res_f_res_34568 = min_res_34571;
                                }
                                loopres_f_res_t_res_34492 = loopres_f_res_t_res_f_res_34567;
                                loopres_f_res_t_res_34493 = loopres_f_res_t_res_f_res_34568;
                            }
                            loopres_f_res_29176 = loopres_f_res_t_res_34492;
                            loopres_f_res_29177 = loopres_f_res_t_res_34493;
                        } else {
                            bool cond_29246 = first_spi_28960 == spi_28904;
                            int64_t loopres_f_res_f_res_29247;
                            int64_t loopres_f_res_f_res_29248;
                            
                            if (cond_29246) {
                                loopres_f_res_f_res_29247 = (int64_t) -1;
                                loopres_f_res_f_res_29248 = (int64_t) 0;
                            } else {
                                int32_t zm_rhs_29249 = sdiv32(prev_last_bit_28999, 8);
                                int32_t zm_lhs_29250 = sub32(i64_res_28947, zm_rhs_29249);
                                int32_t i32_arg0_29251 = sub32(zm_lhs_29250, 1);
                                int64_t i32_res_29252 = sext_i32_i64(i32_arg0_29251);
                                bool x_29268 = sle64((int64_t) 0, i32_res_29252);
                                bool y_29269 = slt64(i32_res_29252, b_23542);
                                bool bounds_check_29270 = x_29268 && y_29269;
                                bool index_certs_29271;
                                
                                if (!bounds_check_29270) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_29252, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:33:38-54\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int32_t lastBit_29253 = smod32(prev_last_bit_28999, 8);
                                int32_t zm_lhs_29254 = sub32(8, lastBit_29253);
                                int32_t i32_arg0_29255 = sub32(zm_lhs_29254, 1);
                                int8_t unsign_arg0_29256 = zext_i32_i8(i32_arg0_29255);
                                int8_t unsign_arg0_29257 = lshr8((int8_t) -1, unsign_arg0_29256);
                                
                                if (mem_35333_cached_sizze_36035 < b_23542) {
                                    err = lexical_realloc(ctx, &mem_35333, &mem_35333_cached_sizze_36035, b_23542);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                if (mem_35334_cached_sizze_36036 < b_23542) {
                                    err = lexical_realloc(ctx, &mem_35334, &mem_35334_cached_sizze_36036, b_23542);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                for (int64_t i_35116 = 0; i_35116 < b_23542; i_35116++) {
                                    int8_t eta_p_29973 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35116];
                                    int8_t eta_p_29974 = ((int8_t *) pS_mem_35254.mem)[ext_35290 + i_35116];
                                    bool cond_29976 = sle64(i_35116, i32_res_28949);
                                    bool cond_t_res_29977 = sle64(i32_res_29252, i_35116);
                                    bool x_29978 = cond_29976 && cond_t_res_29977;
                                    int8_t lifted_lambda_res_29979;
                                    
                                    if (x_29978) {
                                        lifted_lambda_res_29979 = eta_p_29973;
                                    } else {
                                        lifted_lambda_res_29979 = (int8_t) 0;
                                    }
                                    
                                    int8_t lifted_lambda_res_29984;
                                    
                                    if (x_29978) {
                                        lifted_lambda_res_29984 = eta_p_29974;
                                    } else {
                                        lifted_lambda_res_29984 = (int8_t) 0;
                                    }
                                    ((int8_t *) mem_35333)[i_35116] = lifted_lambda_res_29984;
                                    ((int8_t *) mem_35334)[i_35116] = lifted_lambda_res_29979;
                                }
                                
                                int8_t za_lhs_29265 = ((int8_t *) mem_35334)[i32_res_28949];
                                int8_t mod1_x_29266 = (int8_t) -1 & za_lhs_29265;
                                
                                ((int8_t *) mem_35334)[i32_res_28949] = mod1_x_29266;
                                
                                int8_t za_lhs_29272 = ((int8_t *) mem_35334)[i32_res_29252];
                                int8_t tmp_29273 = unsign_arg0_29257 & za_lhs_29272;
                                
                                ((int8_t *) mem_35334)[i32_res_29252] = tmp_29273;
                                
                                int8_t za_lhs_29282 = ((int8_t *) mem_35333)[i32_res_28949];
                                int8_t mod1_x_29283 = (int8_t) -1 & za_lhs_29282;
                                
                                ((int8_t *) mem_35333)[i32_res_28949] = mod1_x_29283;
                                
                                int8_t za_lhs_29285 = ((int8_t *) mem_35333)[i32_res_29252];
                                int8_t tmp_29286 = unsign_arg0_29257 & za_lhs_29285;
                                
                                ((int8_t *) mem_35333)[i32_res_29252] = tmp_29286;
                                
                                bool radix_gt_res_29288;
                                int64_t radix_gt_res_29289;
                                bool radix_gt_res_29290;
                                bool loop_while_29291;
                                int64_t p_29292;
                                bool p_29293;
                                
                                loop_while_29291 = loop_cond_t_res_29154;
                                p_29292 = (int64_t) 0;
                                p_29293 = 0;
                                while (loop_while_29291) {
                                    bool x_29294 = sle64((int64_t) 0, p_29292);
                                    bool y_29295 = slt64(p_29292, b_23542);
                                    bool bounds_check_29296 = x_29294 && y_29295;
                                    bool index_certs_29297;
                                    
                                    if (!bounds_check_29296) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_29292, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:104:17-27\n   #1  ftHashJoin.fut:408:23-60\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftHashJoin.fut:367:8-439:6\n   #4  ftHashJoin.fut:528:4-539:18\n   #5  ftHashJoin.fut:522:1-542:70\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int8_t zl_lhs_29298 = ((int8_t *) mem_35334)[p_29292];
                                    int8_t zl_rhs_29299 = ((int8_t *) mem_35333)[p_29292];
                                    bool dlt_29300 = ult8(zl_lhs_29298, zl_rhs_29299);
                                    bool dgt_29301 = ult8(zl_rhs_29299, zl_lhs_29298);
                                    bool tmp_29302 = dlt_29300 || dgt_29301;
                                    bool cond_29303 = !tmp_29302;
                                    int64_t tmp_29304;
                                    
                                    if (cond_29303) {
                                        int64_t tmp_t_res_34572 = add64((int64_t) 1, p_29292);
                                        
                                        tmp_29304 = tmp_t_res_34572;
                                    } else {
                                        tmp_29304 = b_23542;
                                    }
                                    
                                    bool cond_29306 = !dgt_29301;
                                    bool loop_cond_t_res_29307 = slt64(tmp_29304, b_23542);
                                    bool x_29308 = cond_29306 && loop_cond_t_res_29307;
                                    bool loop_while_tmp_35878 = x_29308;
                                    int64_t p_tmp_35879 = tmp_29304;
                                    bool p_tmp_35880 = dgt_29301;
                                    
                                    loop_while_29291 = loop_while_tmp_35878;
                                    p_29292 = p_tmp_35879;
                                    p_29293 = p_tmp_35880;
                                }
                                radix_gt_res_29288 = loop_while_29291;
                                radix_gt_res_29289 = p_29292;
                                radix_gt_res_29290 = p_29293;
                                
                                int64_t loopres_f_res_f_res_f_res_29309;
                                int64_t loopres_f_res_f_res_f_res_29310;
                                
                                if (radix_gt_res_29290) {
                                    loopres_f_res_f_res_f_res_29309 = (int64_t) -1;
                                    loopres_f_res_f_res_f_res_29310 = (int64_t) 0;
                                } else {
                                    int64_t tmp_29311 = sub64(first_spi_28960, step_28961);
                                    int64_t min_arg1_29312 = sdiv64(step_28961, (int64_t) 2);
                                    int64_t min_res_29313 = smin64((int64_t) 1, min_arg1_29312);
                                    
                                    loopres_f_res_f_res_f_res_29309 = tmp_29311;
                                    loopres_f_res_f_res_f_res_29310 = min_res_29313;
                                }
                                loopres_f_res_f_res_29247 = loopres_f_res_f_res_f_res_29309;
                                loopres_f_res_f_res_29248 = loopres_f_res_f_res_f_res_29310;
                            }
                            loopres_f_res_29176 = loopres_f_res_f_res_29247;
                            loopres_f_res_29177 = loopres_f_res_f_res_29248;
                        }
                        loopres_29125 = loopres_f_res_29176;
                        loopres_29126 = loopres_f_res_29177;
                    }
                    
                    bool loop_cond_29314 = slt64((int64_t) 0, loopres_29126);
                    bool loop_while_tmp_35857 = loop_cond_29314;
                    int64_t first_spi_tmp_35858 = loopres_29125;
                    int64_t step_tmp_35859 = loopres_29126;
                    
                    loop_while_28959 = loop_while_tmp_35857;
                    first_spi_28960 = first_spi_tmp_35858;
                    step_28961 = step_tmp_35859;
                }
                lifted_lambda_res_f_res_f_res_28956 = loop_while_28959;
                lifted_lambda_res_f_res_f_res_28957 = first_spi_28960;
                lifted_lambda_res_f_res_f_res_28958 = step_28961;
                
                bool cond_29315 = lifted_lambda_res_f_res_f_res_28957 == (int64_t) -1;
                int64_t lifted_lambda_res_f_res_f_res_29316;
                
                if (cond_29315) {
                    lifted_lambda_res_f_res_f_res_29316 = (int64_t) -1;
                } else {
                    int32_t min_arg0_29317;
                    
                    if (loop_cond_28941) {
                        int32_t x_34580 = ((int32_t *) depths_mem_35256.mem)[rpi_28903];
                        
                        min_arg0_29317 = x_34580;
                    } else {
                        min_arg0_29317 = 0;
                    }
                    if (mem_35364_cached_sizze_36039 < b_23542) {
                        err = lexical_realloc(ctx, &mem_35364, &mem_35364_cached_sizze_36039, b_23542);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_35365_cached_sizze_36040 < b_23542) {
                        err = lexical_realloc(ctx, &mem_35365, &mem_35365_cached_sizze_36040, b_23542);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    
                    bool lifted_lambda_res_f_res_f_res_f_res_29319;
                    int64_t lifted_lambda_res_f_res_f_res_f_res_29320;
                    int64_t lifted_lambda_res_f_res_f_res_f_res_29321;
                    bool loop_while_29322;
                    int64_t last_spi_29323;
                    int64_t step_29324;
                    
                    loop_while_29322 = loop_cond_28941;
                    last_spi_29323 = last_potential_spi_28937;
                    step_29324 = min_res_28940;
                    while (loop_while_29322) {
                        bool x_29325 = sle64((int64_t) 0, last_spi_29323);
                        bool y_29326 = slt64(last_spi_29323, dz2081U_23545);
                        bool bounds_check_29327 = x_29325 && y_29326;
                        bool index_certs_29328;
                        
                        if (!bounds_check_29327) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) last_spi_29323, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:414:32-50\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t cur_S_29329 = ((int64_t *) bounds_mem_35257.mem)[last_spi_29323];
                        bool x_29330 = sle64((int64_t) 0, cur_S_29329);
                        bool y_29331 = slt64(cur_S_29329, nS_23543);
                        bool bounds_check_29332 = x_29330 && y_29331;
                        bool index_certs_29333;
                        
                        if (!bounds_check_29332) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) cur_S_29329, "] out of bounds for array of shape [", (long long) nS_23543, "].", "-> #0  ftHashJoin.fut:414:29-51\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t min_arg1_29335 = ((int32_t *) depths_mem_35258.mem)[last_spi_29323];
                        int32_t min_res_29336 = smin32(min_arg0_29317, min_arg1_29335);
                        int32_t zm_lhs_29337 = mul32(radix_sizze_23547, min_res_29336);
                        int32_t last_bit_29338 = sub32(zm_lhs_29337, 1);
                        int32_t zm_rhs_29387 = sdiv32(last_bit_29338, 8);
                        int32_t zm_lhs_29388 = sub32(i64_res_28947, zm_rhs_29387);
                        int32_t i32_arg0_29389 = sub32(zm_lhs_29388, 1);
                        int64_t i32_res_29390 = sext_i32_i64(i32_arg0_29389);
                        bool y_29407 = slt64(i32_res_29390, b_23542);
                        bool x_29406 = sle64((int64_t) 0, i32_res_29390);
                        bool bounds_check_29408 = x_29406 && y_29407;
                        bool index_certs_29409;
                        
                        if (!bounds_check_29408) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_29390, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:33:38-54\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_29363 = slt64(last_spi_29323, last_potential_spi_28937);
                        int64_t tmp_34589 = add64((int64_t) 1, last_spi_29323);
                        bool x_34590 = sle64((int64_t) 0, tmp_34589);
                        bool y_34591 = slt64(tmp_34589, dz2081U_23545);
                        bool bounds_check_34592 = x_34590 && y_34591;
                        bool loop_not_taken_35799 = !cond_29363;
                        bool protect_assert_disj_35800 = bounds_check_34592 || loop_not_taken_35799;
                        bool index_certs_34593;
                        
                        if (!protect_assert_disj_35800) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34589, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:420:73-93\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_29339 = slt64(spi_28904, last_spi_29323);
                        
                        for (int64_t i_35123 = 0; i_35123 < b_23542; i_35123++) {
                            int8_t eta_p_30519 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35123];
                            int8_t eta_p_30520 = ((int8_t *) pS_mem_35254.mem)[cur_S_29329 * b_23542 + i_35123];
                            bool cond_30522 = sle64(i_35123, i32_res_28949);
                            bool cond_t_res_30523 = sle64(i32_res_29390, i_35123);
                            bool x_30524 = cond_30522 && cond_t_res_30523;
                            int8_t lifted_lambda_res_30525;
                            
                            if (x_30524) {
                                lifted_lambda_res_30525 = eta_p_30519;
                            } else {
                                lifted_lambda_res_30525 = (int8_t) 0;
                            }
                            
                            int8_t lifted_lambda_res_30530;
                            
                            if (x_30524) {
                                lifted_lambda_res_30530 = eta_p_30520;
                            } else {
                                lifted_lambda_res_30530 = (int8_t) 0;
                            }
                            ((int8_t *) mem_35364)[i_35123] = lifted_lambda_res_30530;
                            ((int8_t *) mem_35365)[i_35123] = lifted_lambda_res_30525;
                        }
                        
                        int8_t za_lhs_29420 = ((int8_t *) mem_35364)[i32_res_28949];
                        int8_t mod1_x_29421 = (int8_t) -1 & za_lhs_29420;
                        
                        ((int8_t *) mem_35364)[i32_res_28949] = mod1_x_29421;
                        
                        int8_t za_lhs_29423 = ((int8_t *) mem_35364)[i32_res_29390];
                        int32_t lastBit_29391 = smod32(last_bit_29338, 8);
                        int32_t zm_lhs_29392 = sub32(8, lastBit_29391);
                        int32_t i32_arg0_29393 = sub32(zm_lhs_29392, 1);
                        int8_t unsign_arg0_29394 = zext_i32_i8(i32_arg0_29393);
                        int8_t unsign_arg0_29395 = lshr8((int8_t) -1, unsign_arg0_29394);
                        int8_t tmp_29424 = unsign_arg0_29395 & za_lhs_29423;
                        
                        ((int8_t *) mem_35364)[i32_res_29390] = tmp_29424;
                        
                        int8_t za_lhs_29403 = ((int8_t *) mem_35365)[i32_res_28949];
                        int8_t mod1_x_29404 = (int8_t) -1 & za_lhs_29403;
                        
                        ((int8_t *) mem_35365)[i32_res_28949] = mod1_x_29404;
                        
                        int8_t za_lhs_29410 = ((int8_t *) mem_35365)[i32_res_29390];
                        int8_t tmp_29411 = unsign_arg0_29395 & za_lhs_29410;
                        
                        ((int8_t *) mem_35365)[i32_res_29390] = tmp_29411;
                        
                        bool defunc_0_reduce_res_34754;
                        bool redout_35126 = 1;
                        
                        for (int64_t i_35127 = 0; i_35127 < b_23542; i_35127++) {
                            int8_t eta_p_30513 = ((int8_t *) mem_35365)[i_35127];
                            int8_t eta_p_30514 = ((int8_t *) mem_35364)[i_35127];
                            bool defunc_0_f_res_30515 = eta_p_30513 == eta_p_30514;
                            bool x_29434 = defunc_0_f_res_30515 && redout_35126;
                            bool redout_tmp_35886 = x_29434;
                            
                            redout_35126 = redout_tmp_35886;
                        }
                        defunc_0_reduce_res_34754 = redout_35126;
                        
                        int32_t next_depth_29376;
                        
                        if (cond_29363) {
                            bool index_certs_34585;
                            
                            if (!bounds_check_34592) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34589, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:421:97-117\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t min_arg1_34586 = ((int32_t *) depths_mem_35258.mem)[tmp_34589];
                            int32_t min_arg0_34587 = ((int32_t *) depths_mem_35256.mem)[rpi_28903];
                            int32_t min_res_34588 = smin32(min_arg1_34586, min_arg0_34587);
                            
                            next_depth_29376 = min_res_34588;
                        } else {
                            next_depth_29376 = min_res_29336;
                        }
                        
                        int32_t zm_lhs_29385 = mul32(radix_sizze_23547, next_depth_29376);
                        int32_t next_last_bit_29386 = sub32(zm_lhs_29385, 1);
                        int64_t lmad_ext_35378 = b_23542 * cur_S_29329;
                        int64_t tmp_34594;
                        
                        if (cond_29363) {
                            int64_t x_35801 = ((int64_t *) bounds_mem_35257.mem)[tmp_34589];
                            
                            tmp_34594 = x_35801;
                        } else {
                            tmp_34594 = (int64_t) 0;
                        }
                        
                        int64_t lmad_ext_35379 = b_23542 * tmp_34594;
                        int64_t ext_35380;
                        
                        if (cond_29363) {
                            ext_35380 = lmad_ext_35379;
                        } else {
                            ext_35380 = lmad_ext_35378;
                        }
                        if (cond_29363) {
                            bool x_34595 = sle64((int64_t) 0, tmp_34594);
                            bool y_34596 = slt64(tmp_34594, nS_23543);
                            bool bounds_check_34597 = x_34595 && y_34596;
                            bool index_certs_34598;
                            
                            if (!bounds_check_34597) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34594, "] out of bounds for array of shape [", (long long) nS_23543, "].", "-> #0  ftHashJoin.fut:420:70-94\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                        }
                        
                        bool cond_29435;
                        
                        if (defunc_0_reduce_res_34754) {
                            bool cond_34603 = last_spi_29323 == last_potential_spi_28937;
                            bool cond_t_res_34604;
                            
                            if (cond_34603) {
                                cond_t_res_34604 = 1;
                            } else {
                                int32_t zm_rhs_34605 = sdiv32(next_last_bit_29386, 8);
                                int32_t zm_lhs_34606 = sub32(i64_res_28947, zm_rhs_34605);
                                int32_t i32_arg0_34607 = sub32(zm_lhs_34606, 1);
                                int64_t i32_res_34608 = sext_i32_i64(i32_arg0_34607);
                                bool index_certs_34629;
                                
                                if (!bounds_check_28953) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_28949, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:32:48-64\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_34633 = sle64((int64_t) 0, i32_res_34608);
                                bool y_34634 = slt64(i32_res_34608, b_23542);
                                bool bounds_check_34635 = x_34633 && y_34634;
                                bool index_certs_34636;
                                
                                if (!bounds_check_34635) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_34608, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:33:38-54\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int32_t lastBit_34609 = smod32(next_last_bit_29386, 8);
                                int32_t zm_lhs_34610 = sub32(8, lastBit_34609);
                                int32_t i32_arg0_34611 = sub32(zm_lhs_34610, 1);
                                int8_t unsign_arg0_34612 = zext_i32_i8(i32_arg0_34611);
                                int8_t unsign_arg0_34613 = lshr8((int8_t) -1, unsign_arg0_34612);
                                
                                if (mem_35381_cached_sizze_36041 < b_23542) {
                                    err = lexical_realloc(ctx, &mem_35381, &mem_35381_cached_sizze_36041, b_23542);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                if (mem_35382_cached_sizze_36042 < b_23542) {
                                    err = lexical_realloc(ctx, &mem_35382, &mem_35382_cached_sizze_36042, b_23542);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                for (int64_t i_35132 = 0; i_35132 < b_23542; i_35132++) {
                                    int8_t eta_p_34617 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35132];
                                    int8_t eta_p_34618 = ((int8_t *) pS_mem_35254.mem)[ext_35380 + i_35132];
                                    bool cond_34619 = sle64(i_35132, i32_res_28949);
                                    bool cond_t_res_34620 = sle64(i32_res_34608, i_35132);
                                    bool x_34621 = cond_34619 && cond_t_res_34620;
                                    int8_t lifted_lambda_res_34622;
                                    
                                    if (x_34621) {
                                        lifted_lambda_res_34622 = eta_p_34617;
                                    } else {
                                        lifted_lambda_res_34622 = (int8_t) 0;
                                    }
                                    
                                    int8_t lifted_lambda_res_34626;
                                    
                                    if (x_34621) {
                                        lifted_lambda_res_34626 = eta_p_34618;
                                    } else {
                                        lifted_lambda_res_34626 = (int8_t) 0;
                                    }
                                    ((int8_t *) mem_35381)[i_35132] = lifted_lambda_res_34626;
                                    ((int8_t *) mem_35382)[i_35132] = lifted_lambda_res_34622;
                                }
                                
                                int8_t za_lhs_34630 = ((int8_t *) mem_35382)[i32_res_28949];
                                int8_t mod1_x_34631 = (int8_t) -1 & za_lhs_34630;
                                
                                ((int8_t *) mem_35382)[i32_res_28949] = mod1_x_34631;
                                
                                int8_t za_lhs_34637 = ((int8_t *) mem_35382)[i32_res_34608];
                                int8_t tmp_34638 = unsign_arg0_34613 & za_lhs_34637;
                                
                                ((int8_t *) mem_35382)[i32_res_34608] = tmp_34638;
                                
                                int8_t za_lhs_34640 = ((int8_t *) mem_35381)[i32_res_28949];
                                int8_t mod1_x_34641 = (int8_t) -1 & za_lhs_34640;
                                
                                ((int8_t *) mem_35381)[i32_res_28949] = mod1_x_34641;
                                
                                int8_t za_lhs_34643 = ((int8_t *) mem_35381)[i32_res_34608];
                                int8_t tmp_34644 = unsign_arg0_34613 & za_lhs_34643;
                                
                                ((int8_t *) mem_35381)[i32_res_34608] = tmp_34644;
                                
                                bool defunc_0_reduce_res_34646;
                                bool redout_35135 = 0;
                                
                                for (int64_t i_35136 = 0; i_35136 < b_23542; i_35136++) {
                                    int8_t eta_p_34647 = ((int8_t *) mem_35382)[i_35136];
                                    int8_t eta_p_34648 = ((int8_t *) mem_35381)[i_35136];
                                    bool defunc_0_f_res_34649 = eta_p_34647 == eta_p_34648;
                                    bool defunc_0_f_res_34650 = !defunc_0_f_res_34649;
                                    bool defunc_0_op_res_34653 = defunc_0_f_res_34650 || redout_35135;
                                    bool redout_tmp_35889 = defunc_0_op_res_34653;
                                    
                                    redout_35135 = redout_tmp_35889;
                                }
                                defunc_0_reduce_res_34646 = redout_35135;
                                cond_t_res_34604 = defunc_0_reduce_res_34646;
                            }
                            cond_29435 = cond_t_res_34604;
                        } else {
                            cond_29435 = 0;
                        }
                        
                        int32_t prev_depth_29352;
                        
                        if (cond_29339) {
                            int64_t min_arg1_34655 = sub64(last_spi_29323, (int64_t) 1);
                            bool x_34656 = sle64((int64_t) 0, min_arg1_34655);
                            bool y_34657 = slt64(min_arg1_34655, dz2081U_23545);
                            bool bounds_check_34658 = x_34656 && y_34657;
                            bool index_certs_34659;
                            
                            if (!bounds_check_34658) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_arg1_34655, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:418:82-102\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t min_arg1_34660 = ((int32_t *) depths_mem_35258.mem)[min_arg1_34655];
                            int32_t min_arg0_34661 = ((int32_t *) depths_mem_35256.mem)[rpi_28903];
                            int32_t min_res_34662 = smin32(min_arg1_34660, min_arg0_34661);
                            
                            prev_depth_29352 = min_res_34662;
                        } else {
                            prev_depth_29352 = min_res_29336;
                        }
                        
                        int32_t zm_lhs_29361 = mul32(radix_sizze_23547, prev_depth_29352);
                        int32_t prev_last_bit_29362 = sub32(zm_lhs_29361, 1);
                        int64_t loopres_29488;
                        int64_t loopres_29489;
                        
                        if (cond_29435) {
                            loopres_29488 = last_spi_29323;
                            loopres_29489 = (int64_t) 0;
                        } else {
                            bool index_certs_29497;
                            
                            if (!bounds_check_28953) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_28949, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:32:48-64\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            bool loop_cond_t_res_29517 = slt64((int64_t) 0, b_23542);
                            
                            if (mem_35395_cached_sizze_36043 < b_23542) {
                                err = lexical_realloc(ctx, &mem_35395, &mem_35395_cached_sizze_36043, b_23542);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            if (mem_35396_cached_sizze_36044 < b_23542) {
                                err = lexical_realloc(ctx, &mem_35396, &mem_35396_cached_sizze_36044, b_23542);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            for (int64_t i_35141 = 0; i_35141 < b_23542; i_35141++) {
                                int8_t eta_p_30556 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35141];
                                int8_t eta_p_30557 = ((int8_t *) pS_mem_35254.mem)[cur_S_29329 * b_23542 + i_35141];
                                bool cond_30559 = sle64(i_35141, i32_res_28949);
                                bool cond_t_res_30560 = sle64(i32_res_29390, i_35141);
                                bool x_30561 = cond_30559 && cond_t_res_30560;
                                int8_t lifted_lambda_res_30562;
                                
                                if (x_30561) {
                                    lifted_lambda_res_30562 = eta_p_30556;
                                } else {
                                    lifted_lambda_res_30562 = (int8_t) 0;
                                }
                                
                                int8_t lifted_lambda_res_30567;
                                
                                if (x_30561) {
                                    lifted_lambda_res_30567 = eta_p_30557;
                                } else {
                                    lifted_lambda_res_30567 = (int8_t) 0;
                                }
                                ((int8_t *) mem_35395)[i_35141] = lifted_lambda_res_30567;
                                ((int8_t *) mem_35396)[i_35141] = lifted_lambda_res_30562;
                            }
                            
                            int8_t za_lhs_29511 = ((int8_t *) mem_35395)[i32_res_28949];
                            int8_t mod1_x_29512 = (int8_t) -1 & za_lhs_29511;
                            
                            ((int8_t *) mem_35395)[i32_res_28949] = mod1_x_29512;
                            
                            int8_t za_lhs_29514 = ((int8_t *) mem_35395)[i32_res_29390];
                            int8_t tmp_29515 = unsign_arg0_29395 & za_lhs_29514;
                            
                            ((int8_t *) mem_35395)[i32_res_29390] = tmp_29515;
                            
                            int8_t za_lhs_29498 = ((int8_t *) mem_35396)[i32_res_28949];
                            int8_t mod1_x_29499 = (int8_t) -1 & za_lhs_29498;
                            
                            ((int8_t *) mem_35396)[i32_res_28949] = mod1_x_29499;
                            
                            int8_t za_lhs_29501 = ((int8_t *) mem_35396)[i32_res_29390];
                            int8_t tmp_29502 = unsign_arg0_29395 & za_lhs_29501;
                            
                            ((int8_t *) mem_35396)[i32_res_29390] = tmp_29502;
                            
                            bool radix_gt_res_29518;
                            int64_t radix_gt_res_29519;
                            bool radix_gt_res_29520;
                            bool loop_while_29521;
                            int64_t p_29522;
                            bool p_29523;
                            
                            loop_while_29521 = loop_cond_t_res_29517;
                            p_29522 = (int64_t) 0;
                            p_29523 = 0;
                            while (loop_while_29521) {
                                bool x_29524 = sle64((int64_t) 0, p_29522);
                                bool y_29525 = slt64(p_29522, b_23542);
                                bool bounds_check_29526 = x_29524 && y_29525;
                                bool index_certs_29527;
                                
                                if (!bounds_check_29526) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_29522, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:104:17-27\n   #1  ftHashJoin.fut:428:20-51\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftHashJoin.fut:367:8-439:6\n   #4  ftHashJoin.fut:528:4-539:18\n   #5  ftHashJoin.fut:522:1-542:70\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int8_t zl_lhs_29528 = ((int8_t *) mem_35396)[p_29522];
                                int8_t zl_rhs_29529 = ((int8_t *) mem_35395)[p_29522];
                                bool dlt_29530 = ult8(zl_lhs_29528, zl_rhs_29529);
                                bool dgt_29531 = ult8(zl_rhs_29529, zl_lhs_29528);
                                bool tmp_29532 = dlt_29530 || dgt_29531;
                                bool cond_29533 = !tmp_29532;
                                int64_t tmp_29534;
                                
                                if (cond_29533) {
                                    int64_t tmp_t_res_34663 = add64((int64_t) 1, p_29522);
                                    
                                    tmp_29534 = tmp_t_res_34663;
                                } else {
                                    tmp_29534 = b_23542;
                                }
                                
                                bool cond_29536 = !dgt_29531;
                                bool loop_cond_t_res_29537 = slt64(tmp_29534, b_23542);
                                bool x_29538 = cond_29536 && loop_cond_t_res_29537;
                                bool loop_while_tmp_35892 = x_29538;
                                int64_t p_tmp_35893 = tmp_29534;
                                bool p_tmp_35894 = dgt_29531;
                                
                                loop_while_29521 = loop_while_tmp_35892;
                                p_29522 = p_tmp_35893;
                                p_29523 = p_tmp_35894;
                            }
                            radix_gt_res_29518 = loop_while_29521;
                            radix_gt_res_29519 = p_29522;
                            radix_gt_res_29520 = p_29523;
                            
                            int64_t loopres_f_res_29539;
                            int64_t loopres_f_res_29540;
                            
                            if (radix_gt_res_29520) {
                                bool cond_34667 = last_spi_29323 == last_potential_spi_28937;
                                int64_t loopres_f_res_t_res_34668;
                                int64_t loopres_f_res_t_res_34669;
                                
                                if (cond_34667) {
                                    loopres_f_res_t_res_34668 = (int64_t) -1;
                                    loopres_f_res_t_res_34669 = (int64_t) 0;
                                } else {
                                    int32_t zm_rhs_34670 = sdiv32(next_last_bit_29386, 8);
                                    int32_t zm_lhs_34671 = sub32(i64_res_28947, zm_rhs_34670);
                                    int32_t i32_arg0_34672 = sub32(zm_lhs_34671, 1);
                                    int64_t i32_res_34673 = sext_i32_i64(i32_arg0_34672);
                                    bool x_34697 = sle64((int64_t) 0, i32_res_34673);
                                    bool y_34698 = slt64(i32_res_34673, b_23542);
                                    bool bounds_check_34699 = x_34697 && y_34698;
                                    bool index_certs_34700;
                                    
                                    if (!bounds_check_34699) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_34673, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:33:38-54\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int32_t lastBit_34674 = smod32(next_last_bit_29386, 8);
                                    int32_t zm_lhs_34675 = sub32(8, lastBit_34674);
                                    int32_t i32_arg0_34676 = sub32(zm_lhs_34675, 1);
                                    int8_t unsign_arg0_34677 = zext_i32_i8(i32_arg0_34676);
                                    int8_t unsign_arg0_34678 = lshr8((int8_t) -1, unsign_arg0_34677);
                                    
                                    if (mem_35426_cached_sizze_36047 < b_23542) {
                                        err = lexical_realloc(ctx, &mem_35426, &mem_35426_cached_sizze_36047, b_23542);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    if (mem_35427_cached_sizze_36048 < b_23542) {
                                        err = lexical_realloc(ctx, &mem_35427, &mem_35427_cached_sizze_36048, b_23542);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    for (int64_t i_35148 = 0; i_35148 < b_23542; i_35148++) {
                                        int8_t eta_p_34682 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35148];
                                        int8_t eta_p_34683 = ((int8_t *) pS_mem_35254.mem)[ext_35380 + i_35148];
                                        bool cond_34684 = sle64(i_35148, i32_res_28949);
                                        bool cond_t_res_34685 = sle64(i32_res_34673, i_35148);
                                        bool x_34686 = cond_34684 && cond_t_res_34685;
                                        int8_t lifted_lambda_res_34687;
                                        
                                        if (x_34686) {
                                            lifted_lambda_res_34687 = eta_p_34682;
                                        } else {
                                            lifted_lambda_res_34687 = (int8_t) 0;
                                        }
                                        
                                        int8_t lifted_lambda_res_34691;
                                        
                                        if (x_34686) {
                                            lifted_lambda_res_34691 = eta_p_34683;
                                        } else {
                                            lifted_lambda_res_34691 = (int8_t) 0;
                                        }
                                        ((int8_t *) mem_35426)[i_35148] = lifted_lambda_res_34691;
                                        ((int8_t *) mem_35427)[i_35148] = lifted_lambda_res_34687;
                                    }
                                    
                                    int8_t za_lhs_34694 = ((int8_t *) mem_35427)[i32_res_28949];
                                    int8_t mod1_x_34695 = (int8_t) -1 & za_lhs_34694;
                                    
                                    ((int8_t *) mem_35427)[i32_res_28949] = mod1_x_34695;
                                    
                                    int8_t za_lhs_34701 = ((int8_t *) mem_35427)[i32_res_34673];
                                    int8_t tmp_34702 = unsign_arg0_34678 & za_lhs_34701;
                                    
                                    ((int8_t *) mem_35427)[i32_res_34673] = tmp_34702;
                                    
                                    int8_t za_lhs_34704 = ((int8_t *) mem_35426)[i32_res_28949];
                                    int8_t mod1_x_34705 = (int8_t) -1 & za_lhs_34704;
                                    
                                    ((int8_t *) mem_35426)[i32_res_28949] = mod1_x_34705;
                                    
                                    int8_t za_lhs_34707 = ((int8_t *) mem_35426)[i32_res_34673];
                                    int8_t tmp_34708 = unsign_arg0_34678 & za_lhs_34707;
                                    
                                    ((int8_t *) mem_35426)[i32_res_34673] = tmp_34708;
                                    
                                    bool radix_lt_res_34710;
                                    int64_t radix_lt_res_34711;
                                    bool radix_lt_res_34712;
                                    bool loop_while_34713;
                                    int64_t p_34714;
                                    bool p_34715;
                                    
                                    loop_while_34713 = loop_cond_t_res_29517;
                                    p_34714 = (int64_t) 0;
                                    p_34715 = 0;
                                    while (loop_while_34713) {
                                        bool x_34716 = sle64((int64_t) 0, p_34714);
                                        bool y_34717 = slt64(p_34714, b_23542);
                                        bool bounds_check_34718 = x_34716 && y_34717;
                                        bool index_certs_34719;
                                        
                                        if (!bounds_check_34718) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_34714, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:71:17-27\n   #1  ftHashJoin.fut:431:23-60\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftHashJoin.fut:367:8-439:6\n   #4  ftHashJoin.fut:528:4-539:18\n   #5  ftHashJoin.fut:522:1-542:70\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int8_t zl_lhs_34720 = ((int8_t *) mem_35427)[p_34714];
                                        int8_t zl_rhs_34721 = ((int8_t *) mem_35426)[p_34714];
                                        bool dlt_34722 = ult8(zl_lhs_34720, zl_rhs_34721);
                                        bool dgt_34723 = ult8(zl_rhs_34721, zl_lhs_34720);
                                        bool tmp_34724 = dlt_34722 || dgt_34723;
                                        bool cond_34725 = !tmp_34724;
                                        int64_t tmp_34726;
                                        
                                        if (cond_34725) {
                                            int64_t tmp_t_res_34727 = add64((int64_t) 1, p_34714);
                                            
                                            tmp_34726 = tmp_t_res_34727;
                                        } else {
                                            tmp_34726 = b_23542;
                                        }
                                        
                                        bool cond_34728 = !dlt_34722;
                                        bool loop_cond_t_res_34729 = slt64(tmp_34726, b_23542);
                                        bool x_34730 = cond_34728 && loop_cond_t_res_34729;
                                        bool loop_while_tmp_35897 = x_34730;
                                        int64_t p_tmp_35898 = tmp_34726;
                                        bool p_tmp_35899 = dlt_34722;
                                        
                                        loop_while_34713 = loop_while_tmp_35897;
                                        p_34714 = p_tmp_35898;
                                        p_34715 = p_tmp_35899;
                                    }
                                    radix_lt_res_34710 = loop_while_34713;
                                    radix_lt_res_34711 = p_34714;
                                    radix_lt_res_34712 = p_34715;
                                    
                                    int64_t loopres_f_res_t_res_f_res_34731;
                                    int64_t loopres_f_res_t_res_f_res_34732;
                                    
                                    if (radix_lt_res_34712) {
                                        loopres_f_res_t_res_f_res_34731 = (int64_t) -1;
                                        loopres_f_res_t_res_f_res_34732 = (int64_t) 0;
                                    } else {
                                        int64_t tmp_34733 = add64(last_spi_29323, step_29324);
                                        int64_t min_arg1_34734 = sdiv64(step_29324, (int64_t) 2);
                                        int64_t min_res_34735 = smin64((int64_t) 1, min_arg1_34734);
                                        
                                        loopres_f_res_t_res_f_res_34731 = tmp_34733;
                                        loopres_f_res_t_res_f_res_34732 = min_res_34735;
                                    }
                                    loopres_f_res_t_res_34668 = loopres_f_res_t_res_f_res_34731;
                                    loopres_f_res_t_res_34669 = loopres_f_res_t_res_f_res_34732;
                                }
                                loopres_f_res_29539 = loopres_f_res_t_res_34668;
                                loopres_f_res_29540 = loopres_f_res_t_res_34669;
                            } else {
                                bool cond_29609 = last_spi_29323 == spi_28904;
                                int64_t tmp_34736 = sub64(last_spi_29323, (int64_t) 1);
                                bool x_34737 = sle64((int64_t) 0, tmp_34736);
                                bool y_34738 = slt64(tmp_34736, dz2081U_23545);
                                bool bounds_check_34739 = x_34737 && y_34738;
                                bool loop_not_taken_35793 = !cond_29339;
                                bool protect_assert_disj_35794 = bounds_check_34739 || loop_not_taken_35793;
                                bool protect_assert_disj_35828 = cond_29609 || protect_assert_disj_35794;
                                bool index_certs_34740;
                                
                                if (!protect_assert_disj_35828) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34736, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:417:58-78\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_35825 = !cond_29609;
                                bool protect_cond_conj_35829 = cond_29339 && x_35825;
                                int64_t tmp_34741;
                                
                                if (protect_cond_conj_35829) {
                                    int64_t x_35795 = ((int64_t *) bounds_mem_35257.mem)[tmp_34736];
                                    
                                    tmp_34741 = x_35795;
                                } else {
                                    tmp_34741 = (int64_t) 0;
                                }
                                
                                int64_t lmad_ext_35410 = b_23542 * tmp_34741;
                                int64_t ext_35411;
                                
                                if (cond_29339) {
                                    ext_35411 = lmad_ext_35410;
                                } else {
                                    ext_35411 = lmad_ext_35378;
                                }
                                
                                int64_t loopres_f_res_f_res_29610;
                                int64_t loopres_f_res_f_res_29611;
                                
                                if (cond_29609) {
                                    loopres_f_res_f_res_29610 = (int64_t) -1;
                                    loopres_f_res_f_res_29611 = (int64_t) 0;
                                } else {
                                    int32_t zm_rhs_29612 = sdiv32(prev_last_bit_29362, 8);
                                    int32_t zm_lhs_29613 = sub32(i64_res_28947, zm_rhs_29612);
                                    int32_t i32_arg0_29614 = sub32(zm_lhs_29613, 1);
                                    int64_t i32_res_29615 = sext_i32_i64(i32_arg0_29614);
                                    bool x_29631 = sle64((int64_t) 0, i32_res_29615);
                                    bool y_29632 = slt64(i32_res_29615, b_23542);
                                    bool bounds_check_29633 = x_29631 && y_29632;
                                    bool index_certs_29634;
                                    
                                    if (!bounds_check_29633) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_29615, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:33:38-54\n   #1  ftHashJoin.fut:522:1-542:70\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    if (cond_29339) {
                                        bool x_34742 = sle64((int64_t) 0, tmp_34741);
                                        bool y_34743 = slt64(tmp_34741, nS_23543);
                                        bool bounds_check_34744 = x_34742 && y_34743;
                                        bool index_certs_34745;
                                        
                                        if (!bounds_check_34744) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_34741, "] out of bounds for array of shape [", (long long) nS_23543, "].", "-> #0  ftHashJoin.fut:417:55-79\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:367:8-439:6\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                    }
                                    
                                    int32_t lastBit_29616 = smod32(prev_last_bit_29362, 8);
                                    int32_t zm_lhs_29617 = sub32(8, lastBit_29616);
                                    int32_t i32_arg0_29618 = sub32(zm_lhs_29617, 1);
                                    int8_t unsign_arg0_29619 = zext_i32_i8(i32_arg0_29618);
                                    int8_t unsign_arg0_29620 = lshr8((int8_t) -1, unsign_arg0_29619);
                                    
                                    if (mem_35412_cached_sizze_36045 < b_23542) {
                                        err = lexical_realloc(ctx, &mem_35412, &mem_35412_cached_sizze_36045, b_23542);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    if (mem_35413_cached_sizze_36046 < b_23542) {
                                        err = lexical_realloc(ctx, &mem_35413, &mem_35413_cached_sizze_36046, b_23542);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    for (int64_t i_35155 = 0; i_35155 < b_23542; i_35155++) {
                                        int8_t eta_p_30719 = ((int8_t *) pR_mem_35253.mem)[cur_R_28931 * b_23542 + i_35155];
                                        int8_t eta_p_30720 = ((int8_t *) pS_mem_35254.mem)[ext_35411 + i_35155];
                                        bool cond_30722 = sle64(i_35155, i32_res_28949);
                                        bool cond_t_res_30723 = sle64(i32_res_29615, i_35155);
                                        bool x_30724 = cond_30722 && cond_t_res_30723;
                                        int8_t lifted_lambda_res_30725;
                                        
                                        if (x_30724) {
                                            lifted_lambda_res_30725 = eta_p_30719;
                                        } else {
                                            lifted_lambda_res_30725 = (int8_t) 0;
                                        }
                                        
                                        int8_t lifted_lambda_res_30730;
                                        
                                        if (x_30724) {
                                            lifted_lambda_res_30730 = eta_p_30720;
                                        } else {
                                            lifted_lambda_res_30730 = (int8_t) 0;
                                        }
                                        ((int8_t *) mem_35412)[i_35155] = lifted_lambda_res_30730;
                                        ((int8_t *) mem_35413)[i_35155] = lifted_lambda_res_30725;
                                    }
                                    
                                    int8_t za_lhs_29628 = ((int8_t *) mem_35413)[i32_res_28949];
                                    int8_t mod1_x_29629 = (int8_t) -1 & za_lhs_29628;
                                    
                                    ((int8_t *) mem_35413)[i32_res_28949] = mod1_x_29629;
                                    
                                    int8_t za_lhs_29635 = ((int8_t *) mem_35413)[i32_res_29615];
                                    int8_t tmp_29636 = unsign_arg0_29620 & za_lhs_29635;
                                    
                                    ((int8_t *) mem_35413)[i32_res_29615] = tmp_29636;
                                    
                                    int8_t za_lhs_29645 = ((int8_t *) mem_35412)[i32_res_28949];
                                    int8_t mod1_x_29646 = (int8_t) -1 & za_lhs_29645;
                                    
                                    ((int8_t *) mem_35412)[i32_res_28949] = mod1_x_29646;
                                    
                                    int8_t za_lhs_29648 = ((int8_t *) mem_35412)[i32_res_29615];
                                    int8_t tmp_29649 = unsign_arg0_29620 & za_lhs_29648;
                                    
                                    ((int8_t *) mem_35412)[i32_res_29615] = tmp_29649;
                                    
                                    bool radix_gt_res_29651;
                                    int64_t radix_gt_res_29652;
                                    bool radix_gt_res_29653;
                                    bool loop_while_29654;
                                    int64_t p_29655;
                                    bool p_29656;
                                    
                                    loop_while_29654 = loop_cond_t_res_29517;
                                    p_29655 = (int64_t) 0;
                                    p_29656 = 0;
                                    while (loop_while_29654) {
                                        bool x_29657 = sle64((int64_t) 0, p_29655);
                                        bool y_29658 = slt64(p_29655, b_23542);
                                        bool bounds_check_29659 = x_29657 && y_29658;
                                        bool index_certs_29660;
                                        
                                        if (!bounds_check_29659) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_29655, "] out of bounds for array of shape [", (long long) b_23542, "].", "-> #0  ftHashJoin.fut:104:17-27\n   #1  ftHashJoin.fut:435:23-60\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftHashJoin.fut:367:8-439:6\n   #4  ftHashJoin.fut:528:4-539:18\n   #5  ftHashJoin.fut:522:1-542:70\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int8_t zl_lhs_29661 = ((int8_t *) mem_35413)[p_29655];
                                        int8_t zl_rhs_29662 = ((int8_t *) mem_35412)[p_29655];
                                        bool dlt_29663 = ult8(zl_lhs_29661, zl_rhs_29662);
                                        bool dgt_29664 = ult8(zl_rhs_29662, zl_lhs_29661);
                                        bool tmp_29665 = dlt_29663 || dgt_29664;
                                        bool cond_29666 = !tmp_29665;
                                        int64_t tmp_29667;
                                        
                                        if (cond_29666) {
                                            int64_t tmp_t_res_34747 = add64((int64_t) 1, p_29655);
                                            
                                            tmp_29667 = tmp_t_res_34747;
                                        } else {
                                            tmp_29667 = b_23542;
                                        }
                                        
                                        bool cond_29669 = !dgt_29664;
                                        bool loop_cond_t_res_29670 = slt64(tmp_29667, b_23542);
                                        bool x_29671 = cond_29669 && loop_cond_t_res_29670;
                                        bool loop_while_tmp_35902 = x_29671;
                                        int64_t p_tmp_35903 = tmp_29667;
                                        bool p_tmp_35904 = dgt_29664;
                                        
                                        loop_while_29654 = loop_while_tmp_35902;
                                        p_29655 = p_tmp_35903;
                                        p_29656 = p_tmp_35904;
                                    }
                                    radix_gt_res_29651 = loop_while_29654;
                                    radix_gt_res_29652 = p_29655;
                                    radix_gt_res_29653 = p_29656;
                                    
                                    int64_t loopres_f_res_f_res_f_res_29672;
                                    int64_t loopres_f_res_f_res_f_res_29673;
                                    
                                    if (radix_gt_res_29653) {
                                        loopres_f_res_f_res_f_res_29672 = (int64_t) -1;
                                        loopres_f_res_f_res_f_res_29673 = (int64_t) 0;
                                    } else {
                                        int64_t tmp_29674 = sub64(last_spi_29323, step_29324);
                                        int64_t min_arg1_29675 = sdiv64(step_29324, (int64_t) 2);
                                        int64_t min_res_29676 = smin64((int64_t) 1, min_arg1_29675);
                                        
                                        loopres_f_res_f_res_f_res_29672 = tmp_29674;
                                        loopres_f_res_f_res_f_res_29673 = min_res_29676;
                                    }
                                    loopres_f_res_f_res_29610 = loopres_f_res_f_res_f_res_29672;
                                    loopres_f_res_f_res_29611 = loopres_f_res_f_res_f_res_29673;
                                }
                                loopres_f_res_29539 = loopres_f_res_f_res_29610;
                                loopres_f_res_29540 = loopres_f_res_f_res_29611;
                            }
                            loopres_29488 = loopres_f_res_29539;
                            loopres_29489 = loopres_f_res_29540;
                        }
                        
                        bool loop_cond_29677 = slt64((int64_t) 0, loopres_29489);
                        bool loop_while_tmp_35881 = loop_cond_29677;
                        int64_t last_spi_tmp_35882 = loopres_29488;
                        int64_t step_tmp_35883 = loopres_29489;
                        
                        loop_while_29322 = loop_while_tmp_35881;
                        last_spi_29323 = last_spi_tmp_35882;
                        step_29324 = step_tmp_35883;
                    }
                    lifted_lambda_res_f_res_f_res_f_res_29319 = loop_while_29322;
                    lifted_lambda_res_f_res_f_res_f_res_29320 = last_spi_29323;
                    lifted_lambda_res_f_res_f_res_f_res_29321 = step_29324;
                    lifted_lambda_res_f_res_f_res_29316 = lifted_lambda_res_f_res_f_res_f_res_29320;
                }
                lifted_lambda_res_f_res_28924 = lifted_lambda_res_f_res_f_res_28957;
                lifted_lambda_res_f_res_28925 = lifted_lambda_res_f_res_f_res_29316;
            }
            lifted_lambda_res_28910 = lifted_lambda_res_f_res_28924;
            lifted_lambda_res_28911 = lifted_lambda_res_f_res_28925;
        }
        
        bool cond_29681 = lifted_lambda_res_28910 == (int64_t) -1;
        bool cond_29682 = !cond_29681;
        bool lifted_lambda_res_t_res_29683 = lifted_lambda_res_28911 == (int64_t) -1;
        bool lifted_lambda_res_t_res_29684 = !lifted_lambda_res_t_res_29683;
        bool x_29685 = cond_29682 && lifted_lambda_res_t_res_29684;
        int64_t defunc_0_f_res_29686 = btoi_bool_i64(x_29685);
        int64_t defunc_0_op_res_26971 = add64(defunc_0_f_res_29686, scanacc_35163);
        
        ((int64_t *) mem_35264)[i_35169] = defunc_0_op_res_26971;
        ((int64_t *) mem_35266)[i_35169] = defunc_0_f_res_29686;
        ((int64_t *) mem_35268)[i_35169] = rpi_28903;
        ((int64_t *) mem_35270)[i_35169] = lifted_lambda_res_28910;
        ((int64_t *) mem_35272)[i_35169] = lifted_lambda_res_28911;
        
        int64_t scanacc_tmp_35851 = defunc_0_op_res_26971;
        
        scanacc_35163 = scanacc_tmp_35851;
    }
    discard_35175 = scanacc_35163;
    
    bool cond_26972 = i32_res_26569 == (int64_t) 0;
    bool x_26973 = !cond_26972;
    int64_t tmp_26974 = sub64(i32_res_26569, (int64_t) 1);
    bool x_26975 = sle64((int64_t) 0, tmp_26974);
    bool y_26976 = slt64(tmp_26974, i32_res_26569);
    bool bounds_check_26977 = x_26975 && y_26976;
    bool protect_assert_disj_26978 = cond_26972 || bounds_check_26977;
    bool index_certs_26979;
    
    if (!protect_assert_disj_26978) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_26974, "] out of bounds for array of shape [", (long long) i32_res_26569, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:440:8-53\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t m_f_res_26980;
    
    if (x_26973) {
        int64_t x_34755 = ((int64_t *) mem_35264)[tmp_26974];
        
        m_f_res_26980 = x_34755;
    } else {
        m_f_res_26980 = (int64_t) 0;
    }
    
    int64_t m_26982;
    
    if (cond_26972) {
        m_26982 = (int64_t) 0;
    } else {
        m_26982 = m_f_res_26980;
    }
    
    int64_t m_26992 = sub64(m_26982, (int64_t) 1);
    bool i_p_m_t_s_leq_w_26994 = slt64(m_26992, i32_res_26569);
    bool zzero_leq_i_p_m_t_s_26993 = sle64((int64_t) 0, m_26992);
    bool y_26996 = zzero_leq_i_p_m_t_s_26993 && i_p_m_t_s_leq_w_26994;
    bool i_lte_j_26995 = sle64((int64_t) 0, m_26982);
    bool forwards_ok_26997 = i_lte_j_26995 && y_26996;
    bool eq_x_zz_26989 = (int64_t) 0 == m_f_res_26980;
    bool p_and_eq_x_y_26990 = x_26973 && eq_x_zz_26989;
    bool empty_slice_26991 = cond_26972 || p_and_eq_x_y_26990;
    bool ok_or_empty_26998 = empty_slice_26991 || forwards_ok_26997;
    bool index_certs_26999;
    
    if (!ok_or_empty_26998) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_26982, "] out of bounds for array of shape [", (long long) i32_res_26569, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:440:8-53\n   #3  ftHashJoin.fut:528:4-539:18\n   #4  ftHashJoin.fut:522:1-542:70\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_35455 = (int64_t) 8 * m_26982;
    
    if (mem_35456_cached_sizze_36049 < bytes_35455) {
        err = lexical_realloc(ctx, &mem_35456, &mem_35456_cached_sizze_36049, bytes_35455);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35456, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35272, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_26982});
    if (mem_35458_cached_sizze_36050 < bytes_35455) {
        err = lexical_realloc(ctx, &mem_35458, &mem_35458_cached_sizze_36050, bytes_35455);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35458, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35270, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_26982});
    if (mem_35460_cached_sizze_36051 < bytes_35455) {
        err = lexical_realloc(ctx, &mem_35460, &mem_35460_cached_sizze_36051, bytes_35455);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35460, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35268, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_26982});
    for (int64_t write_iter_35176 = 0; write_iter_35176 < i32_res_26569; write_iter_35176++) {
        int64_t write_iv_35180 = ((int64_t *) mem_35266)[write_iter_35176];
        int64_t write_iv_35181 = ((int64_t *) mem_35264)[write_iter_35176];
        int64_t write_iv_35182 = ((int64_t *) mem_35268)[write_iter_35176];
        int64_t write_iv_35183 = ((int64_t *) mem_35270)[write_iter_35176];
        int64_t write_iv_35184 = ((int64_t *) mem_35272)[write_iter_35176];
        bool cond_28881 = write_iv_35180 == (int64_t) 1;
        int64_t lifted_lambda_res_28882;
        
        if (cond_28881) {
            int64_t lifted_lambda_res_t_res_34756 = sub64(write_iv_35181, (int64_t) 1);
            
            lifted_lambda_res_28882 = lifted_lambda_res_t_res_34756;
        } else {
            lifted_lambda_res_28882 = (int64_t) -1;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_28882) && slt64(lifted_lambda_res_28882, m_26982)) {
            ((int64_t *) mem_35460)[lifted_lambda_res_28882] = write_iv_35182;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_28882) && slt64(lifted_lambda_res_28882, m_26982)) {
            ((int64_t *) mem_35458)[lifted_lambda_res_28882] = write_iv_35183;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_28882) && slt64(lifted_lambda_res_28882, m_26982)) {
            ((int64_t *) mem_35456)[lifted_lambda_res_28882] = write_iv_35184;
        }
    }
    if (memblock_alloc(ctx, &mem_35479, (int64_t) 0, "mem_35479")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_35480, (int64_t) 0, "mem_35480")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_35481, (int64_t) 0, "mem_35481")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t zl_rhs_27016 = sub64(dz2081U_23544, (int64_t) 1);
    
    if (memblock_alloc(ctx, &mem_35482, (int64_t) 0, "mem_35482")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_35483, (int64_t) 0, "mem_35483")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t zl_rhs_27019 = sub64(dz2081U_23545, (int64_t) 1);
    int64_t join_hashPartitions_res_27020;
    int64_t join_hashPartitions_res_27021;
    int64_t join_hashPartitions_res_27022;
    int64_t loop_dz2081Uz2080U_27027;
    int64_t loop_dz2081Uz2081U_27028;
    int64_t loop_dz2081Uz2082U_27029;
    
    if (memblock_set(ctx, &mem_param_35486, &mem_35480, "mem_35480") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_35489, &mem_35481, "mem_35481") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_35493, &mem_35479, "mem_35479") != 0)
        return 1;
    loop_dz2081Uz2080U_27027 = (int64_t) 0;
    loop_dz2081Uz2081U_27028 = (int64_t) 0;
    loop_dz2081Uz2082U_27029 = (int64_t) 0;
    for (int64_t i_27026 = 0; i_27026 < m_26982; i_27026++) {
        int64_t p_match_27033 = ((int64_t *) mem_35460)[i_27026];
        int64_t p_match_27034 = ((int64_t *) mem_35458)[i_27026];
        int64_t p_match_27035 = ((int64_t *) mem_35456)[i_27026];
        bool x_27036 = sle64((int64_t) 0, p_match_27033);
        bool y_27037 = slt64(p_match_27033, dz2081U_23544);
        bool bounds_check_27038 = x_27036 && y_27037;
        bool index_certs_27039;
        
        if (!bounds_check_27038) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_match_27033, "] out of bounds for array of shape [", (long long) dz2081U_23544, "].", "-> #0  ftHashJoin.fut:509:18-42\n   #1  ftHashJoin.fut:526:4-542:70\n   #2  ftHashJoin.fut:522:1-542:70\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t r_lb_27040 = ((int64_t *) bounds_mem_35255.mem)[p_match_27033];
        bool cond_27041 = slt64(p_match_27033, zl_rhs_27016);
        int64_t tmp_27042 = add64((int64_t) 1, p_match_27033);
        bool x_27043 = sle64((int64_t) 0, tmp_27042);
        bool y_27044 = slt64(tmp_27042, dz2081U_23544);
        bool bounds_check_27045 = x_27043 && y_27044;
        bool loop_not_taken_27046 = !cond_27041;
        bool protect_assert_disj_27047 = bounds_check_27045 || loop_not_taken_27046;
        bool index_certs_27048;
        
        if (!protect_assert_disj_27047) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_27042, "] out of bounds for array of shape [", (long long) dz2081U_23544, "].", "-> #0  ftHashJoin.fut:510:49-77\n   #1  ftHashJoin.fut:526:4-542:70\n   #2  ftHashJoin.fut:522:1-542:70\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t r_ub_t_res_27049;
        
        if (cond_27041) {
            int64_t x_34757 = ((int64_t *) bounds_mem_35255.mem)[tmp_27042];
            
            r_ub_t_res_27049 = x_34757;
        } else {
            r_ub_t_res_27049 = (int64_t) 0;
        }
        
        int64_t r_ub_27051;
        
        if (cond_27041) {
            r_ub_27051 = r_ub_t_res_27049;
        } else {
            r_ub_27051 = nR_23541;
        }
        
        int64_t j_m_i_27052 = sub64(r_ub_27051, r_lb_27040);
        bool empty_slice_27053 = j_m_i_27052 == (int64_t) 0;
        int64_t m_27054 = sub64(j_m_i_27052, (int64_t) 1);
        int64_t i_p_m_t_s_27055 = add64(r_lb_27040, m_27054);
        bool zzero_leq_i_p_m_t_s_27056 = sle64((int64_t) 0, i_p_m_t_s_27055);
        bool i_p_m_t_s_leq_w_27057 = slt64(i_p_m_t_s_27055, nR_23541);
        bool zzero_lte_i_27058 = sle64((int64_t) 0, r_lb_27040);
        bool i_lte_j_27059 = sle64(r_lb_27040, r_ub_27051);
        bool y_27060 = i_p_m_t_s_leq_w_27057 && zzero_lte_i_27058;
        bool y_27061 = zzero_leq_i_p_m_t_s_27056 && y_27060;
        bool forwards_ok_27062 = i_lte_j_27059 && y_27061;
        bool ok_or_empty_27063 = empty_slice_27053 || forwards_ok_27062;
        bool index_certs_27064;
        
        if (!ok_or_empty_27063) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) r_lb_27040, ":", (long long) r_ub_27051, "] out of bounds for array of shape [", (long long) nR_23541, "].", "-> #0  ftHashJoin.fut:511:20-33\n   #1  ftHashJoin.fut:526:4-542:70\n   #2  ftHashJoin.fut:522:1-542:70\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool bounds_invalid_upwards_27066 = slt64(p_match_27035, p_match_27034);
        int64_t distance_upwards_exclusive_27067 = sub64(p_match_27035, p_match_27034);
        int64_t distance_27068 = add64((int64_t) 1, distance_upwards_exclusive_27067);
        bool valid_27069 = !bounds_invalid_upwards_27066;
        bool range_valid_c_27070;
        
        if (!valid_27069) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) p_match_27034, "...", (long long) p_match_27035, " is invalid.", "-> #0  ftHashJoin.fut:514:27-52\n   #1  ftHashJoin.fut:526:4-542:70\n   #2  ftHashJoin.fut:522:1-542:70\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool cond_28239 = slt64((int64_t) 6, j_m_i_27052);
        int64_t bytes_35659 = (int64_t) 8 * j_m_i_27052;
        int64_t loopres_27071;
        int64_t loopres_27072;
        int64_t loopres_27073;
        int64_t loop_dz2083Uz2084U_27078;
        int64_t loop_dz2083Uz2085U_27079;
        int64_t loop_dz2083Uz2086U_27080;
        
        if (memblock_set(ctx, &mem_param_35496, &mem_35483, "mem_35483") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35499, &mem_35483, "mem_35483") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35503, &mem_35482, "mem_35482") != 0)
            return 1;
        loop_dz2083Uz2084U_27078 = (int64_t) 0;
        loop_dz2083Uz2085U_27079 = (int64_t) 0;
        loop_dz2083Uz2086U_27080 = (int64_t) 0;
        for (int64_t i_27077 = 0; i_27077 < distance_27068; i_27077++) {
            int64_t index_primexp_27084 = add64(p_match_27034, i_27077);
            bool x_27085 = sle64((int64_t) 0, index_primexp_27084);
            bool y_27086 = slt64(index_primexp_27084, dz2081U_23545);
            bool bounds_check_27087 = x_27085 && y_27086;
            bool index_certs_27088;
            
            if (!bounds_check_27087) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_primexp_27084, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:515:22-46\n   #1  ftHashJoin.fut:526:4-542:70\n   #2  ftHashJoin.fut:522:1-542:70\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t s_lb_27089 = ((int64_t *) bounds_mem_35257.mem)[index_primexp_27084];
            bool cond_27090 = slt64(index_primexp_27084, zl_rhs_27019);
            int64_t tmp_27091 = add64((int64_t) 1, index_primexp_27084);
            bool x_27092 = sle64((int64_t) 0, tmp_27091);
            bool y_27093 = slt64(tmp_27091, dz2081U_23545);
            bool bounds_check_27094 = x_27092 && y_27093;
            bool loop_not_taken_27095 = !cond_27090;
            bool protect_assert_disj_27096 = bounds_check_27094 || loop_not_taken_27095;
            bool index_certs_27097;
            
            if (!protect_assert_disj_27096) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_27091, "] out of bounds for array of shape [", (long long) dz2081U_23545, "].", "-> #0  ftHashJoin.fut:516:53-79\n   #1  ftHashJoin.fut:526:4-542:70\n   #2  ftHashJoin.fut:522:1-542:70\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t s_ub_t_res_27098;
            
            if (cond_27090) {
                int64_t x_34758 = ((int64_t *) bounds_mem_35257.mem)[tmp_27091];
                
                s_ub_t_res_27098 = x_34758;
            } else {
                s_ub_t_res_27098 = (int64_t) 0;
            }
            
            int64_t s_ub_27100;
            
            if (cond_27090) {
                s_ub_27100 = s_ub_t_res_27098;
            } else {
                s_ub_27100 = nS_23543;
            }
            
            int64_t j_m_i_27101 = sub64(s_ub_27100, s_lb_27089);
            bool empty_slice_27102 = j_m_i_27101 == (int64_t) 0;
            int64_t m_27103 = sub64(j_m_i_27101, (int64_t) 1);
            int64_t i_p_m_t_s_27104 = add64(s_lb_27089, m_27103);
            bool zzero_leq_i_p_m_t_s_27105 = sle64((int64_t) 0, i_p_m_t_s_27104);
            bool i_p_m_t_s_leq_w_27106 = slt64(i_p_m_t_s_27104, nS_23543);
            bool zzero_lte_i_27107 = sle64((int64_t) 0, s_lb_27089);
            bool i_lte_j_27108 = sle64(s_lb_27089, s_ub_27100);
            bool y_27109 = i_p_m_t_s_leq_w_27106 && zzero_lte_i_27107;
            bool y_27110 = zzero_leq_i_p_m_t_s_27105 && y_27109;
            bool forwards_ok_27111 = i_lte_j_27108 && y_27110;
            bool ok_or_empty_27112 = empty_slice_27102 || forwards_ok_27111;
            bool index_certs_27113;
            
            if (!ok_or_empty_27112) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) s_lb_27089, ":", (long long) s_ub_27100, "] out of bounds for array of shape [", (long long) nS_23543, "].", "-> #0  ftHashJoin.fut:517:24-37\n   #1  ftHashJoin.fut:526:4-542:70\n   #2  ftHashJoin.fut:522:1-542:70\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool cond_28368 = slt64((int64_t) 6, j_m_i_27101);
            bool cond_27115 = sle64(j_m_i_27101, j_m_i_27052);
            int64_t bytes_35546 = (int64_t) 8 * j_m_i_27101;
            int64_t find_joinPairs_res_27116;
            int64_t find_joinPairs_res_27117;
            int64_t find_joinPairs_res_27118;
            
            if (cond_27115) {
                int64_t do_find_joinPairs_res_34848;
                int64_t do_find_joinPairs_res_34849;
                int64_t do_find_joinPairs_res_34850;
                
                if (cond_28239) {
                    if (memblock_alloc(ctx, &mem_35660, bytes_35659, "mem_35660")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t i_35926 = 0; i_35926 < j_m_i_27052; i_35926++) {
                        int64_t x_35927 = (int64_t) 0 + i_35926 * (int64_t) 1;
                        
                        ((int64_t *) mem_35660.mem)[i_35926] = x_35927;
                    }
                    if (mem_35672_cached_sizze_36055 < bytes_35659) {
                        err = lexical_realloc(ctx, &mem_35672, &mem_35672_cached_sizze_36055, bytes_35659);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_35673_cached_sizze_36056 < j_m_i_27052) {
                        err = lexical_realloc(ctx, &mem_35673, &mem_35673_cached_sizze_36056, j_m_i_27052);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_35687_cached_sizze_36057 < bytes_35659) {
                        err = lexical_realloc(ctx, &mem_35687, &mem_35687_cached_sizze_36057, bytes_35659);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (memblock_alloc(ctx, &mem_35701, bytes_35659, "mem_35701")) {
                        err = 1;
                        goto cleanup;
                    }
                    
                    int64_t do_find_joinPairs_res_t_res_34855;
                    int64_t do_find_joinPairs_res_t_res_34856;
                    int64_t do_find_joinPairs_res_t_res_34857;
                    int64_t loop_dz2085U_34862;
                    int64_t loop_dz2086U_34863;
                    int64_t loop_dz2087U_34864;
                    
                    if (memblock_set(ctx, &mem_param_35664, &mem_35482, "mem_35482") != 0)
                        return 1;
                    if (memblock_set(ctx, &mem_param_35667, &mem_35483, "mem_35483") != 0)
                        return 1;
                    if (memblock_set(ctx, &mem_param_35670, &mem_35483, "mem_35483") != 0)
                        return 1;
                    loop_dz2085U_34862 = (int64_t) 0;
                    loop_dz2086U_34863 = (int64_t) 0;
                    loop_dz2087U_34864 = (int64_t) 0;
                    for (int64_t i_34861 = 0; i_34861 < j_m_i_27101; i_34861++) {
                        int64_t slice_34868 = s_lb_27089 + i_34861;
                        int64_t discard_35199;
                        int64_t defunc_res_34871;
                        int64_t scanacc_35192;
                        int64_t redout_35194;
                        
                        scanacc_35192 = (int64_t) 0;
                        redout_35194 = (int64_t) 0;
                        for (int64_t i_35196 = 0; i_35196 < j_m_i_27052; i_35196++) {
                            int64_t slice_35226 = r_lb_27040 + i_35196;
                            bool defunc_0_reduce_res_34874;
                            bool redout_35188 = 1;
                            
                            for (int64_t i_35189 = 0; i_35189 < b_23542; i_35189++) {
                                int8_t eta_p_34875 = ((int8_t *) pR_mem_35253.mem)[slice_35226 * b_23542 + i_35189];
                                int8_t eta_p_34876 = ((int8_t *) pS_mem_35254.mem)[slice_34868 * b_23542 + i_35189];
                                bool defunc_0_f_res_34877 = eta_p_34875 == eta_p_34876;
                                bool x_34880 = defunc_0_f_res_34877 && redout_35188;
                                bool redout_tmp_35941 = x_34880;
                                
                                redout_35188 = redout_tmp_35941;
                            }
                            defunc_0_reduce_res_34874 = redout_35188;
                            
                            int64_t bool_res_34882 = btoi_bool_i64(defunc_0_reduce_res_34874);
                            int64_t defunc_0_op_res_34886 = add64(bool_res_34882, scanacc_35192);
                            int64_t zp_res_34889 = add64(bool_res_34882, redout_35194);
                            
                            ((int64_t *) mem_35672)[i_35196] = defunc_0_op_res_34886;
                            ((bool *) mem_35673)[i_35196] = defunc_0_reduce_res_34874;
                            
                            int64_t scanacc_tmp_35937 = defunc_0_op_res_34886;
                            int64_t redout_tmp_35939 = zp_res_34889;
                            
                            scanacc_35192 = scanacc_tmp_35937;
                            redout_35194 = redout_tmp_35939;
                        }
                        discard_35199 = scanacc_35192;
                        defunc_res_34871 = redout_35194;
                        
                        int64_t bytes_35696 = (int64_t) 8 * defunc_res_34871;
                        int64_t conc_tmp_34927 = loop_dz2085U_34862 + defunc_res_34871;
                        int64_t bytes_35704 = b_23542 * conc_tmp_34927;
                        int64_t conc_tmp_34929 = loop_dz2086U_34863 + defunc_res_34871;
                        int64_t bytes_35706 = (int64_t) 8 * conc_tmp_34929;
                        int64_t conc_tmp_34931 = loop_dz2087U_34864 + defunc_res_34871;
                        int64_t bytes_35708 = (int64_t) 8 * conc_tmp_34931;
                        
                        for (int64_t i_35202 = 0; i_35202 < j_m_i_27052; i_35202++) {
                            bool eta_p_34910 = ((bool *) mem_35673)[i_35202];
                            int64_t zv_lhs_34911 = add64((int64_t) -1, i_35202);
                            int64_t tmp_34912 = smod64(zv_lhs_34911, j_m_i_27052);
                            int64_t lifted_lambda_res_34913 = ((int64_t *) mem_35672)[tmp_34912];
                            bool cond_34914 = i_35202 == (int64_t) 0;
                            int64_t lifted_lambda_res_34915;
                            
                            if (cond_34914) {
                                lifted_lambda_res_34915 = (int64_t) 0;
                            } else {
                                lifted_lambda_res_34915 = lifted_lambda_res_34913;
                            }
                            
                            int64_t lifted_lambda_res_34916;
                            
                            if (eta_p_34910) {
                                lifted_lambda_res_34916 = lifted_lambda_res_34915;
                            } else {
                                lifted_lambda_res_34916 = (int64_t) -1;
                            }
                            ((int64_t *) mem_35687)[i_35202] = lifted_lambda_res_34916;
                        }
                        if (memblock_alloc(ctx, &mem_35705, bytes_35704, "mem_35705")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_35943 = 0; nest_i_35943 < defunc_res_34871; nest_i_35943++) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_35705.mem, b_23542 * loop_dz2085U_34862 + nest_i_35943 * b_23542, (int64_t []) {(int64_t) 1}, (uint8_t *) pS_mem_35254.mem, slice_34868 * b_23542, (int64_t []) {(int64_t) 1}, (int64_t []) {b_23542});
                        }
                        if (memblock_alloc(ctx, &mem_35709, bytes_35708, "mem_35709")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_35944 = 0; nest_i_35944 < defunc_res_34871; nest_i_35944++) {
                            ((int64_t *) mem_35709.mem)[loop_dz2087U_34864 + nest_i_35944] = i_34861;
                        }
                        if (memblock_alloc(ctx, &mem_35699, bytes_35696, "mem_35699")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_35945 = 0; nest_i_35945 < defunc_res_34871; nest_i_35945++) {
                            ((int64_t *) mem_35699.mem)[nest_i_35945] = (int64_t) 0;
                        }
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35701.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35687, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_27052});
                        if (futrts_partitioned_scatter_8506(ctx, &ext_mem_35703, mem_35699, mem_35701, mem_35660, defunc_res_34871, j_m_i_27052, scatter_psizze_23564) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        if (memblock_unref(ctx, &mem_35699, "mem_35699") != 0)
                            return 1;
                        
                        int64_t tmp_offs_35946 = (int64_t) 0;
                        
                        lmad_copy_1b(ctx, 2, (uint8_t *) mem_35705.mem, b_23542 * tmp_offs_35946, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_param_35664.mem, (int64_t) 0, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {loop_dz2085U_34862, b_23542});
                        tmp_offs_35946 += loop_dz2085U_34862;
                        if (!(b_23542 * tmp_offs_35946 == b_23542 * loop_dz2085U_34862)) {
                            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35705.mem, b_23542 * tmp_offs_35946, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_35705.mem, b_23542 * loop_dz2085U_34862, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {defunc_res_34871, b_23542});
                        }
                        tmp_offs_35946 += defunc_res_34871;
                        if (memblock_alloc(ctx, &mem_35707, bytes_35706, "mem_35707")) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        int64_t tmp_offs_35947 = (int64_t) 0;
                        
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35707.mem, tmp_offs_35947, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35667.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2086U_34863});
                        tmp_offs_35947 += loop_dz2086U_34863;
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35707.mem, tmp_offs_35947, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_35703.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {defunc_res_34871});
                        tmp_offs_35947 += defunc_res_34871;
                        if (memblock_unref(ctx, &ext_mem_35703, "ext_mem_35703") != 0)
                            return 1;
                        
                        int64_t tmp_offs_35948 = (int64_t) 0;
                        
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35709.mem, tmp_offs_35948, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35670.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2087U_34864});
                        tmp_offs_35948 += loop_dz2087U_34864;
                        if (!(tmp_offs_35948 == loop_dz2087U_34864)) {
                            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35709.mem, tmp_offs_35948, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35709.mem, loop_dz2087U_34864, (int64_t []) {(int64_t) 1}, (int64_t []) {defunc_res_34871});
                        }
                        tmp_offs_35948 += defunc_res_34871;
                        if (memblock_set(ctx, &mem_param_tmp_35928, &mem_35705, "mem_35705") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35929, &mem_35707, "mem_35707") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35930, &mem_35709, "mem_35709") != 0)
                            return 1;
                        
                        int64_t loop_dz2085U_tmp_35931 = conc_tmp_34927;
                        int64_t loop_dz2086U_tmp_35932 = conc_tmp_34929;
                        int64_t loop_dz2087U_tmp_35933 = conc_tmp_34931;
                        
                        if (memblock_set(ctx, &mem_param_35664, &mem_param_tmp_35928, "mem_param_tmp_35928") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_35667, &mem_param_tmp_35929, "mem_param_tmp_35929") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_35670, &mem_param_tmp_35930, "mem_param_tmp_35930") != 0)
                            return 1;
                        loop_dz2085U_34862 = loop_dz2085U_tmp_35931;
                        loop_dz2086U_34863 = loop_dz2086U_tmp_35932;
                        loop_dz2087U_34864 = loop_dz2087U_tmp_35933;
                    }
                    if (memblock_set(ctx, &ext_mem_35719, &mem_param_35664, "mem_param_35664") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35718, &mem_param_35667, "mem_param_35667") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35717, &mem_param_35670, "mem_param_35670") != 0)
                        return 1;
                    do_find_joinPairs_res_t_res_34855 = loop_dz2085U_34862;
                    do_find_joinPairs_res_t_res_34856 = loop_dz2086U_34863;
                    do_find_joinPairs_res_t_res_34857 = loop_dz2087U_34864;
                    if (memblock_unref(ctx, &mem_35660, "mem_35660") != 0)
                        return 1;
                    if (memblock_unref(ctx, &mem_35701, "mem_35701") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35729, &ext_mem_35718, "ext_mem_35718") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35726, &ext_mem_35717, "ext_mem_35717") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35723, &ext_mem_35719, "ext_mem_35719") != 0)
                        return 1;
                    do_find_joinPairs_res_34848 = do_find_joinPairs_res_t_res_34856;
                    do_find_joinPairs_res_34849 = do_find_joinPairs_res_t_res_34857;
                    do_find_joinPairs_res_34850 = do_find_joinPairs_res_t_res_34855;
                } else {
                    int64_t do_find_joinPairs_res_f_res_34933;
                    int64_t do_find_joinPairs_res_f_res_34934;
                    int64_t do_find_joinPairs_res_f_res_34935;
                    int64_t loop_dz2088Uz2087U_34940;
                    int64_t loop_dz2088Uz2088U_34941;
                    int64_t loop_dz2088Uz2089U_34942;
                    
                    if (memblock_set(ctx, &mem_param_35620, &mem_35482, "mem_35482") != 0)
                        return 1;
                    if (memblock_set(ctx, &mem_param_35623, &mem_35483, "mem_35483") != 0)
                        return 1;
                    if (memblock_set(ctx, &mem_param_35626, &mem_35483, "mem_35483") != 0)
                        return 1;
                    loop_dz2088Uz2087U_34940 = (int64_t) 0;
                    loop_dz2088Uz2088U_34941 = (int64_t) 0;
                    loop_dz2088Uz2089U_34942 = (int64_t) 0;
                    for (int64_t i_34939 = 0; i_34939 < j_m_i_27052; i_34939++) {
                        int64_t slice_34946 = r_lb_27040 + i_34939;
                        int64_t matches_34948;
                        int64_t loop_dz2089Uz2088U_34951;
                        
                        if (memblock_set(ctx, &mem_param_35629, &mem_35483, "mem_35483") != 0)
                            return 1;
                        loop_dz2089Uz2088U_34951 = (int64_t) 0;
                        for (int64_t i_34950 = 0; i_34950 < j_m_i_27101; i_34950++) {
                            int64_t slice_34953 = s_lb_27089 + i_34950;
                            bool defunc_0_reduce_res_34955;
                            bool redout_35204 = 1;
                            
                            for (int64_t i_35205 = 0; i_35205 < b_23542; i_35205++) {
                                int8_t eta_p_34956 = ((int8_t *) pR_mem_35253.mem)[slice_34946 * b_23542 + i_35205];
                                int8_t eta_p_34957 = ((int8_t *) pS_mem_35254.mem)[slice_34953 * b_23542 + i_35205];
                                bool defunc_0_f_res_34958 = eta_p_34956 == eta_p_34957;
                                bool x_34961 = defunc_0_f_res_34958 && redout_35204;
                                bool redout_tmp_35961 = x_34961;
                                
                                redout_35204 = redout_tmp_35961;
                            }
                            defunc_0_reduce_res_34955 = redout_35204;
                            
                            int64_t conc_tmp_34969 = (int64_t) 1 + loop_dz2089Uz2088U_34951;
                            int64_t loopres_34970;
                            
                            if (defunc_0_reduce_res_34955) {
                                loopres_34970 = conc_tmp_34969;
                            } else {
                                loopres_34970 = loop_dz2089Uz2088U_34951;
                            }
                            
                            int64_t bytes_35631 = (int64_t) 8 * loopres_34970;
                            
                            if (defunc_0_reduce_res_34955) {
                                if (memblock_alloc(ctx, &mem_35632, bytes_35631, "mem_35632")) {
                                    err = 1;
                                    goto cleanup;
                                }
                                for (int64_t nest_i_35962 = 0; nest_i_35962 < (int64_t) 1; nest_i_35962++) {
                                    ((int64_t *) mem_35632.mem)[loop_dz2089Uz2088U_34951 + nest_i_35962] = i_34950;
                                }
                                
                                int64_t tmp_offs_35963 = (int64_t) 0;
                                
                                lmad_copy_8b(ctx, 1, (uint64_t *) mem_35632.mem, tmp_offs_35963, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35629.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2089Uz2088U_34951});
                                tmp_offs_35963 += loop_dz2089Uz2088U_34951;
                                if (!(tmp_offs_35963 == loop_dz2089Uz2088U_34951)) {
                                    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35632.mem, tmp_offs_35963, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35632.mem, loop_dz2089Uz2088U_34951, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
                                }
                                tmp_offs_35963 += (int64_t) 1;
                                if (memblock_set(ctx, &ext_mem_35635, &mem_35632, "mem_35632") != 0)
                                    return 1;
                            } else if (memblock_set(ctx, &ext_mem_35635, &mem_param_35629, "mem_param_35629") != 0)
                                return 1;
                            if (memblock_set(ctx, &mem_param_tmp_35958, &ext_mem_35635, "ext_mem_35635") != 0)
                                return 1;
                            
                            int64_t loop_dz2089Uz2088U_tmp_35959 = loopres_34970;
                            
                            if (memblock_set(ctx, &mem_param_35629, &mem_param_tmp_35958, "mem_param_tmp_35958") != 0)
                                return 1;
                            loop_dz2089Uz2088U_34951 = loop_dz2089Uz2088U_tmp_35959;
                        }
                        if (memblock_set(ctx, &ext_mem_35638, &mem_param_35629, "mem_param_35629") != 0)
                            return 1;
                        matches_34948 = loop_dz2089Uz2088U_34951;
                        
                        int64_t conc_tmp_34977 = loop_dz2088Uz2087U_34940 + matches_34948;
                        int64_t bytes_35643 = b_23542 * conc_tmp_34977;
                        int64_t conc_tmp_34979 = loop_dz2088Uz2088U_34941 + matches_34948;
                        int64_t bytes_35645 = (int64_t) 8 * conc_tmp_34979;
                        int64_t conc_tmp_34981 = loop_dz2088Uz2089U_34942 + matches_34948;
                        int64_t bytes_35647 = (int64_t) 8 * conc_tmp_34981;
                        
                        if (memblock_alloc(ctx, &mem_35644, bytes_35643, "mem_35644")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_35964 = 0; nest_i_35964 < matches_34948; nest_i_35964++) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_35644.mem, b_23542 * loop_dz2088Uz2087U_34940 + nest_i_35964 * b_23542, (int64_t []) {(int64_t) 1}, (uint8_t *) pR_mem_35253.mem, slice_34946 * b_23542, (int64_t []) {(int64_t) 1}, (int64_t []) {b_23542});
                        }
                        if (memblock_alloc(ctx, &mem_35646, bytes_35645, "mem_35646")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_35965 = 0; nest_i_35965 < matches_34948; nest_i_35965++) {
                            ((int64_t *) mem_35646.mem)[loop_dz2088Uz2088U_34941 + nest_i_35965] = i_34939;
                        }
                        
                        int64_t tmp_offs_35966 = (int64_t) 0;
                        
                        lmad_copy_1b(ctx, 2, (uint8_t *) mem_35644.mem, b_23542 * tmp_offs_35966, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_param_35620.mem, (int64_t) 0, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {loop_dz2088Uz2087U_34940, b_23542});
                        tmp_offs_35966 += loop_dz2088Uz2087U_34940;
                        if (!(b_23542 * tmp_offs_35966 == b_23542 * loop_dz2088Uz2087U_34940)) {
                            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35644.mem, b_23542 * tmp_offs_35966, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_35644.mem, b_23542 * loop_dz2088Uz2087U_34940, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {matches_34948, b_23542});
                        }
                        tmp_offs_35966 += matches_34948;
                        
                        int64_t tmp_offs_35967 = (int64_t) 0;
                        
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35646.mem, tmp_offs_35967, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35623.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2088Uz2088U_34941});
                        tmp_offs_35967 += loop_dz2088Uz2088U_34941;
                        if (!(tmp_offs_35967 == loop_dz2088Uz2088U_34941)) {
                            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35646.mem, tmp_offs_35967, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35646.mem, loop_dz2088Uz2088U_34941, (int64_t []) {(int64_t) 1}, (int64_t []) {matches_34948});
                        }
                        tmp_offs_35967 += matches_34948;
                        if (memblock_alloc(ctx, &mem_35648, bytes_35647, "mem_35648")) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        int64_t tmp_offs_35968 = (int64_t) 0;
                        
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35648.mem, tmp_offs_35968, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35626.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2088Uz2089U_34942});
                        tmp_offs_35968 += loop_dz2088Uz2089U_34942;
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35648.mem, tmp_offs_35968, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_35638.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {matches_34948});
                        tmp_offs_35968 += matches_34948;
                        if (memblock_unref(ctx, &ext_mem_35638, "ext_mem_35638") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35949, &mem_35644, "mem_35644") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35950, &mem_35646, "mem_35646") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35951, &mem_35648, "mem_35648") != 0)
                            return 1;
                        
                        int64_t loop_dz2088Uz2087U_tmp_35952 = conc_tmp_34977;
                        int64_t loop_dz2088Uz2088U_tmp_35953 = conc_tmp_34979;
                        int64_t loop_dz2088Uz2089U_tmp_35954 = conc_tmp_34981;
                        
                        if (memblock_set(ctx, &mem_param_35620, &mem_param_tmp_35949, "mem_param_tmp_35949") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_35623, &mem_param_tmp_35950, "mem_param_tmp_35950") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_35626, &mem_param_tmp_35951, "mem_param_tmp_35951") != 0)
                            return 1;
                        loop_dz2088Uz2087U_34940 = loop_dz2088Uz2087U_tmp_35952;
                        loop_dz2088Uz2088U_34941 = loop_dz2088Uz2088U_tmp_35953;
                        loop_dz2088Uz2089U_34942 = loop_dz2088Uz2089U_tmp_35954;
                    }
                    if (memblock_set(ctx, &ext_mem_35658, &mem_param_35620, "mem_param_35620") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35657, &mem_param_35623, "mem_param_35623") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35656, &mem_param_35626, "mem_param_35626") != 0)
                        return 1;
                    do_find_joinPairs_res_f_res_34933 = loop_dz2088Uz2087U_34940;
                    do_find_joinPairs_res_f_res_34934 = loop_dz2088Uz2088U_34941;
                    do_find_joinPairs_res_f_res_34935 = loop_dz2088Uz2089U_34942;
                    if (memblock_set(ctx, &ext_mem_35729, &ext_mem_35657, "ext_mem_35657") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35726, &ext_mem_35656, "ext_mem_35656") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35723, &ext_mem_35658, "ext_mem_35658") != 0)
                        return 1;
                    do_find_joinPairs_res_34848 = do_find_joinPairs_res_f_res_34934;
                    do_find_joinPairs_res_34849 = do_find_joinPairs_res_f_res_34935;
                    do_find_joinPairs_res_34850 = do_find_joinPairs_res_f_res_34933;
                }
                if (memblock_set(ctx, &ext_mem_35739, &ext_mem_35729, "ext_mem_35729") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_35736, &ext_mem_35726, "ext_mem_35726") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_35733, &ext_mem_35723, "ext_mem_35723") != 0)
                    return 1;
                find_joinPairs_res_27116 = do_find_joinPairs_res_34848;
                find_joinPairs_res_27117 = do_find_joinPairs_res_34849;
                find_joinPairs_res_27118 = do_find_joinPairs_res_34850;
            } else {
                int64_t do_find_joinPairs_res_28369;
                int64_t do_find_joinPairs_res_28370;
                int64_t do_find_joinPairs_res_28371;
                
                if (cond_28368) {
                    if (memblock_alloc(ctx, &mem_35547, bytes_35546, "mem_35547")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t i_35969 = 0; i_35969 < j_m_i_27101; i_35969++) {
                        int64_t x_35970 = (int64_t) 0 + i_35969 * (int64_t) 1;
                        
                        ((int64_t *) mem_35547.mem)[i_35969] = x_35970;
                    }
                    if (mem_35559_cached_sizze_36052 < bytes_35546) {
                        err = lexical_realloc(ctx, &mem_35559, &mem_35559_cached_sizze_36052, bytes_35546);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_35560_cached_sizze_36053 < j_m_i_27101) {
                        err = lexical_realloc(ctx, &mem_35560, &mem_35560_cached_sizze_36053, j_m_i_27101);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_35574_cached_sizze_36054 < bytes_35546) {
                        err = lexical_realloc(ctx, &mem_35574, &mem_35574_cached_sizze_36054, bytes_35546);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (memblock_alloc(ctx, &mem_35588, bytes_35546, "mem_35588")) {
                        err = 1;
                        goto cleanup;
                    }
                    
                    int64_t do_find_joinPairs_res_t_res_34990;
                    int64_t do_find_joinPairs_res_t_res_34991;
                    int64_t do_find_joinPairs_res_t_res_34992;
                    int64_t loop_dz2085U_34997;
                    int64_t loop_dz2086U_34998;
                    int64_t loop_dz2087U_34999;
                    
                    if (memblock_set(ctx, &mem_param_35551, &mem_35482, "mem_35482") != 0)
                        return 1;
                    if (memblock_set(ctx, &mem_param_35554, &mem_35483, "mem_35483") != 0)
                        return 1;
                    if (memblock_set(ctx, &mem_param_35557, &mem_35483, "mem_35483") != 0)
                        return 1;
                    loop_dz2085U_34997 = (int64_t) 0;
                    loop_dz2086U_34998 = (int64_t) 0;
                    loop_dz2087U_34999 = (int64_t) 0;
                    for (int64_t i_34996 = 0; i_34996 < j_m_i_27052; i_34996++) {
                        int64_t slice_35003 = r_lb_27040 + i_34996;
                        int64_t discard_35217;
                        int64_t defunc_res_35006;
                        int64_t scanacc_35210;
                        int64_t redout_35212;
                        
                        scanacc_35210 = (int64_t) 0;
                        redout_35212 = (int64_t) 0;
                        for (int64_t i_35214 = 0; i_35214 < j_m_i_27101; i_35214++) {
                            int64_t slice_35229 = s_lb_27089 + i_35214;
                            bool defunc_0_reduce_res_35009;
                            bool redout_35206 = 1;
                            
                            for (int64_t i_35207 = 0; i_35207 < b_23542; i_35207++) {
                                int8_t eta_p_35010 = ((int8_t *) pS_mem_35254.mem)[slice_35229 * b_23542 + i_35207];
                                int8_t eta_p_35011 = ((int8_t *) pR_mem_35253.mem)[slice_35003 * b_23542 + i_35207];
                                bool defunc_0_f_res_35012 = eta_p_35010 == eta_p_35011;
                                bool x_35015 = defunc_0_f_res_35012 && redout_35206;
                                bool redout_tmp_35984 = x_35015;
                                
                                redout_35206 = redout_tmp_35984;
                            }
                            defunc_0_reduce_res_35009 = redout_35206;
                            
                            int64_t bool_res_35017 = btoi_bool_i64(defunc_0_reduce_res_35009);
                            int64_t defunc_0_op_res_35021 = add64(bool_res_35017, scanacc_35210);
                            int64_t zp_res_35024 = add64(bool_res_35017, redout_35212);
                            
                            ((int64_t *) mem_35559)[i_35214] = defunc_0_op_res_35021;
                            ((bool *) mem_35560)[i_35214] = defunc_0_reduce_res_35009;
                            
                            int64_t scanacc_tmp_35980 = defunc_0_op_res_35021;
                            int64_t redout_tmp_35982 = zp_res_35024;
                            
                            scanacc_35210 = scanacc_tmp_35980;
                            redout_35212 = redout_tmp_35982;
                        }
                        discard_35217 = scanacc_35210;
                        defunc_res_35006 = redout_35212;
                        
                        int64_t bytes_35583 = (int64_t) 8 * defunc_res_35006;
                        int64_t conc_tmp_35062 = loop_dz2085U_34997 + defunc_res_35006;
                        int64_t bytes_35591 = b_23542 * conc_tmp_35062;
                        int64_t conc_tmp_35064 = loop_dz2086U_34998 + defunc_res_35006;
                        int64_t bytes_35593 = (int64_t) 8 * conc_tmp_35064;
                        int64_t conc_tmp_35066 = loop_dz2087U_34999 + defunc_res_35006;
                        int64_t bytes_35595 = (int64_t) 8 * conc_tmp_35066;
                        
                        for (int64_t i_35220 = 0; i_35220 < j_m_i_27101; i_35220++) {
                            bool eta_p_35045 = ((bool *) mem_35560)[i_35220];
                            int64_t zv_lhs_35046 = add64((int64_t) -1, i_35220);
                            int64_t tmp_35047 = smod64(zv_lhs_35046, j_m_i_27101);
                            int64_t lifted_lambda_res_35048 = ((int64_t *) mem_35559)[tmp_35047];
                            bool cond_35049 = i_35220 == (int64_t) 0;
                            int64_t lifted_lambda_res_35050;
                            
                            if (cond_35049) {
                                lifted_lambda_res_35050 = (int64_t) 0;
                            } else {
                                lifted_lambda_res_35050 = lifted_lambda_res_35048;
                            }
                            
                            int64_t lifted_lambda_res_35051;
                            
                            if (eta_p_35045) {
                                lifted_lambda_res_35051 = lifted_lambda_res_35050;
                            } else {
                                lifted_lambda_res_35051 = (int64_t) -1;
                            }
                            ((int64_t *) mem_35574)[i_35220] = lifted_lambda_res_35051;
                        }
                        if (memblock_alloc(ctx, &mem_35592, bytes_35591, "mem_35592")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_35986 = 0; nest_i_35986 < defunc_res_35006; nest_i_35986++) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_35592.mem, b_23542 * loop_dz2085U_34997 + nest_i_35986 * b_23542, (int64_t []) {(int64_t) 1}, (uint8_t *) pR_mem_35253.mem, slice_35003 * b_23542, (int64_t []) {(int64_t) 1}, (int64_t []) {b_23542});
                        }
                        if (memblock_alloc(ctx, &mem_35596, bytes_35595, "mem_35596")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_35987 = 0; nest_i_35987 < defunc_res_35006; nest_i_35987++) {
                            ((int64_t *) mem_35596.mem)[loop_dz2087U_34999 + nest_i_35987] = i_34996;
                        }
                        if (memblock_alloc(ctx, &mem_35586, bytes_35583, "mem_35586")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_35988 = 0; nest_i_35988 < defunc_res_35006; nest_i_35988++) {
                            ((int64_t *) mem_35586.mem)[nest_i_35988] = (int64_t) 0;
                        }
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35588.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35574, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_27101});
                        if (futrts_partitioned_scatter_8506(ctx, &ext_mem_35590, mem_35586, mem_35588, mem_35547, defunc_res_35006, j_m_i_27101, scatter_psizze_23564) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        if (memblock_unref(ctx, &mem_35586, "mem_35586") != 0)
                            return 1;
                        
                        int64_t tmp_offs_35989 = (int64_t) 0;
                        
                        lmad_copy_1b(ctx, 2, (uint8_t *) mem_35592.mem, b_23542 * tmp_offs_35989, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_param_35551.mem, (int64_t) 0, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {loop_dz2085U_34997, b_23542});
                        tmp_offs_35989 += loop_dz2085U_34997;
                        if (!(b_23542 * tmp_offs_35989 == b_23542 * loop_dz2085U_34997)) {
                            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35592.mem, b_23542 * tmp_offs_35989, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_35592.mem, b_23542 * loop_dz2085U_34997, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {defunc_res_35006, b_23542});
                        }
                        tmp_offs_35989 += defunc_res_35006;
                        if (memblock_alloc(ctx, &mem_35594, bytes_35593, "mem_35594")) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        int64_t tmp_offs_35990 = (int64_t) 0;
                        
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35594.mem, tmp_offs_35990, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35554.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2086U_34998});
                        tmp_offs_35990 += loop_dz2086U_34998;
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35594.mem, tmp_offs_35990, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_35590.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {defunc_res_35006});
                        tmp_offs_35990 += defunc_res_35006;
                        if (memblock_unref(ctx, &ext_mem_35590, "ext_mem_35590") != 0)
                            return 1;
                        
                        int64_t tmp_offs_35991 = (int64_t) 0;
                        
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35596.mem, tmp_offs_35991, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35557.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2087U_34999});
                        tmp_offs_35991 += loop_dz2087U_34999;
                        if (!(tmp_offs_35991 == loop_dz2087U_34999)) {
                            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35596.mem, tmp_offs_35991, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35596.mem, loop_dz2087U_34999, (int64_t []) {(int64_t) 1}, (int64_t []) {defunc_res_35006});
                        }
                        tmp_offs_35991 += defunc_res_35006;
                        if (memblock_set(ctx, &mem_param_tmp_35971, &mem_35592, "mem_35592") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35972, &mem_35594, "mem_35594") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35973, &mem_35596, "mem_35596") != 0)
                            return 1;
                        
                        int64_t loop_dz2085U_tmp_35974 = conc_tmp_35062;
                        int64_t loop_dz2086U_tmp_35975 = conc_tmp_35064;
                        int64_t loop_dz2087U_tmp_35976 = conc_tmp_35066;
                        
                        if (memblock_set(ctx, &mem_param_35551, &mem_param_tmp_35971, "mem_param_tmp_35971") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_35554, &mem_param_tmp_35972, "mem_param_tmp_35972") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_35557, &mem_param_tmp_35973, "mem_param_tmp_35973") != 0)
                            return 1;
                        loop_dz2085U_34997 = loop_dz2085U_tmp_35974;
                        loop_dz2086U_34998 = loop_dz2086U_tmp_35975;
                        loop_dz2087U_34999 = loop_dz2087U_tmp_35976;
                    }
                    if (memblock_set(ctx, &ext_mem_35606, &mem_param_35551, "mem_param_35551") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35605, &mem_param_35554, "mem_param_35554") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35604, &mem_param_35557, "mem_param_35557") != 0)
                        return 1;
                    do_find_joinPairs_res_t_res_34990 = loop_dz2085U_34997;
                    do_find_joinPairs_res_t_res_34991 = loop_dz2086U_34998;
                    do_find_joinPairs_res_t_res_34992 = loop_dz2087U_34999;
                    if (memblock_unref(ctx, &mem_35547, "mem_35547") != 0)
                        return 1;
                    if (memblock_unref(ctx, &mem_35588, "mem_35588") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35616, &ext_mem_35605, "ext_mem_35605") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35613, &ext_mem_35604, "ext_mem_35604") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35610, &ext_mem_35606, "ext_mem_35606") != 0)
                        return 1;
                    do_find_joinPairs_res_28369 = do_find_joinPairs_res_t_res_34991;
                    do_find_joinPairs_res_28370 = do_find_joinPairs_res_t_res_34992;
                    do_find_joinPairs_res_28371 = do_find_joinPairs_res_t_res_34990;
                } else {
                    int64_t do_find_joinPairs_res_f_res_28448;
                    int64_t do_find_joinPairs_res_f_res_28449;
                    int64_t do_find_joinPairs_res_f_res_28450;
                    int64_t loop_dz2088Uz2087U_28455;
                    int64_t loop_dz2088Uz2088U_28456;
                    int64_t loop_dz2088Uz2089U_28457;
                    
                    if (memblock_set(ctx, &mem_param_35507, &mem_35482, "mem_35482") != 0)
                        return 1;
                    if (memblock_set(ctx, &mem_param_35510, &mem_35483, "mem_35483") != 0)
                        return 1;
                    if (memblock_set(ctx, &mem_param_35513, &mem_35483, "mem_35483") != 0)
                        return 1;
                    loop_dz2088Uz2087U_28455 = (int64_t) 0;
                    loop_dz2088Uz2088U_28456 = (int64_t) 0;
                    loop_dz2088Uz2089U_28457 = (int64_t) 0;
                    for (int64_t i_28454 = 0; i_28454 < j_m_i_27101; i_28454++) {
                        int64_t slice_28866 = s_lb_27089 + i_28454;
                        int64_t matches_28462;
                        int64_t loop_dz2089Uz2088U_28465;
                        
                        if (memblock_set(ctx, &mem_param_35516, &mem_35483, "mem_35483") != 0)
                            return 1;
                        loop_dz2089Uz2088U_28465 = (int64_t) 0;
                        for (int64_t i_28464 = 0; i_28464 < j_m_i_27052; i_28464++) {
                            int64_t slice_28865 = r_lb_27040 + i_28464;
                            bool defunc_0_reduce_res_35070;
                            bool redout_35222 = 1;
                            
                            for (int64_t i_35223 = 0; i_35223 < b_23542; i_35223++) {
                                int8_t eta_p_33707 = ((int8_t *) pS_mem_35254.mem)[slice_28866 * b_23542 + i_35223];
                                int8_t eta_p_33708 = ((int8_t *) pR_mem_35253.mem)[slice_28865 * b_23542 + i_35223];
                                bool defunc_0_f_res_33709 = eta_p_33707 == eta_p_33708;
                                bool x_28476 = defunc_0_f_res_33709 && redout_35222;
                                bool redout_tmp_36004 = x_28476;
                                
                                redout_35222 = redout_tmp_36004;
                            }
                            defunc_0_reduce_res_35070 = redout_35222;
                            
                            int64_t conc_tmp_28477 = (int64_t) 1 + loop_dz2089Uz2088U_28465;
                            int64_t loopres_28478;
                            
                            if (defunc_0_reduce_res_35070) {
                                loopres_28478 = conc_tmp_28477;
                            } else {
                                loopres_28478 = loop_dz2089Uz2088U_28465;
                            }
                            
                            int64_t bytes_35518 = (int64_t) 8 * loopres_28478;
                            
                            if (defunc_0_reduce_res_35070) {
                                if (memblock_alloc(ctx, &mem_35519, bytes_35518, "mem_35519")) {
                                    err = 1;
                                    goto cleanup;
                                }
                                for (int64_t nest_i_36005 = 0; nest_i_36005 < (int64_t) 1; nest_i_36005++) {
                                    ((int64_t *) mem_35519.mem)[loop_dz2089Uz2088U_28465 + nest_i_36005] = i_28464;
                                }
                                
                                int64_t tmp_offs_36006 = (int64_t) 0;
                                
                                lmad_copy_8b(ctx, 1, (uint64_t *) mem_35519.mem, tmp_offs_36006, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35516.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2089Uz2088U_28465});
                                tmp_offs_36006 += loop_dz2089Uz2088U_28465;
                                if (!(tmp_offs_36006 == loop_dz2089Uz2088U_28465)) {
                                    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35519.mem, tmp_offs_36006, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35519.mem, loop_dz2089Uz2088U_28465, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
                                }
                                tmp_offs_36006 += (int64_t) 1;
                                if (memblock_set(ctx, &ext_mem_35522, &mem_35519, "mem_35519") != 0)
                                    return 1;
                            } else if (memblock_set(ctx, &ext_mem_35522, &mem_param_35516, "mem_param_35516") != 0)
                                return 1;
                            if (memblock_set(ctx, &mem_param_tmp_36001, &ext_mem_35522, "ext_mem_35522") != 0)
                                return 1;
                            
                            int64_t loop_dz2089Uz2088U_tmp_36002 = loopres_28478;
                            
                            if (memblock_set(ctx, &mem_param_35516, &mem_param_tmp_36001, "mem_param_tmp_36001") != 0)
                                return 1;
                            loop_dz2089Uz2088U_28465 = loop_dz2089Uz2088U_tmp_36002;
                        }
                        if (memblock_set(ctx, &ext_mem_35525, &mem_param_35516, "mem_param_35516") != 0)
                            return 1;
                        matches_28462 = loop_dz2089Uz2088U_28465;
                        
                        int64_t conc_tmp_28485 = loop_dz2088Uz2087U_28455 + matches_28462;
                        int64_t bytes_35530 = b_23542 * conc_tmp_28485;
                        int64_t conc_tmp_28487 = loop_dz2088Uz2088U_28456 + matches_28462;
                        int64_t bytes_35532 = (int64_t) 8 * conc_tmp_28487;
                        int64_t conc_tmp_28489 = loop_dz2088Uz2089U_28457 + matches_28462;
                        int64_t bytes_35534 = (int64_t) 8 * conc_tmp_28489;
                        
                        if (memblock_alloc(ctx, &mem_35531, bytes_35530, "mem_35531")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_36007 = 0; nest_i_36007 < matches_28462; nest_i_36007++) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_35531.mem, b_23542 * loop_dz2088Uz2087U_28455 + nest_i_36007 * b_23542, (int64_t []) {(int64_t) 1}, (uint8_t *) pS_mem_35254.mem, slice_28866 * b_23542, (int64_t []) {(int64_t) 1}, (int64_t []) {b_23542});
                        }
                        if (memblock_alloc(ctx, &mem_35533, bytes_35532, "mem_35533")) {
                            err = 1;
                            goto cleanup;
                        }
                        for (int64_t nest_i_36008 = 0; nest_i_36008 < matches_28462; nest_i_36008++) {
                            ((int64_t *) mem_35533.mem)[loop_dz2088Uz2088U_28456 + nest_i_36008] = i_28454;
                        }
                        
                        int64_t tmp_offs_36009 = (int64_t) 0;
                        
                        lmad_copy_1b(ctx, 2, (uint8_t *) mem_35531.mem, b_23542 * tmp_offs_36009, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_param_35507.mem, (int64_t) 0, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {loop_dz2088Uz2087U_28455, b_23542});
                        tmp_offs_36009 += loop_dz2088Uz2087U_28455;
                        if (!(b_23542 * tmp_offs_36009 == b_23542 * loop_dz2088Uz2087U_28455)) {
                            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35531.mem, b_23542 * tmp_offs_36009, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_35531.mem, b_23542 * loop_dz2088Uz2087U_28455, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {matches_28462, b_23542});
                        }
                        tmp_offs_36009 += matches_28462;
                        
                        int64_t tmp_offs_36010 = (int64_t) 0;
                        
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35533.mem, tmp_offs_36010, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35510.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2088Uz2088U_28456});
                        tmp_offs_36010 += loop_dz2088Uz2088U_28456;
                        if (!(tmp_offs_36010 == loop_dz2088Uz2088U_28456)) {
                            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35533.mem, tmp_offs_36010, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35533.mem, loop_dz2088Uz2088U_28456, (int64_t []) {(int64_t) 1}, (int64_t []) {matches_28462});
                        }
                        tmp_offs_36010 += matches_28462;
                        if (memblock_alloc(ctx, &mem_35535, bytes_35534, "mem_35535")) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        int64_t tmp_offs_36011 = (int64_t) 0;
                        
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35535.mem, tmp_offs_36011, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35513.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2088Uz2089U_28457});
                        tmp_offs_36011 += loop_dz2088Uz2089U_28457;
                        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35535.mem, tmp_offs_36011, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_35525.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {matches_28462});
                        tmp_offs_36011 += matches_28462;
                        if (memblock_unref(ctx, &ext_mem_35525, "ext_mem_35525") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35992, &mem_35531, "mem_35531") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35993, &mem_35533, "mem_35533") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_tmp_35994, &mem_35535, "mem_35535") != 0)
                            return 1;
                        
                        int64_t loop_dz2088Uz2087U_tmp_35995 = conc_tmp_28485;
                        int64_t loop_dz2088Uz2088U_tmp_35996 = conc_tmp_28487;
                        int64_t loop_dz2088Uz2089U_tmp_35997 = conc_tmp_28489;
                        
                        if (memblock_set(ctx, &mem_param_35507, &mem_param_tmp_35992, "mem_param_tmp_35992") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_35510, &mem_param_tmp_35993, "mem_param_tmp_35993") != 0)
                            return 1;
                        if (memblock_set(ctx, &mem_param_35513, &mem_param_tmp_35994, "mem_param_tmp_35994") != 0)
                            return 1;
                        loop_dz2088Uz2087U_28455 = loop_dz2088Uz2087U_tmp_35995;
                        loop_dz2088Uz2088U_28456 = loop_dz2088Uz2088U_tmp_35996;
                        loop_dz2088Uz2089U_28457 = loop_dz2088Uz2089U_tmp_35997;
                    }
                    if (memblock_set(ctx, &ext_mem_35545, &mem_param_35507, "mem_param_35507") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35544, &mem_param_35510, "mem_param_35510") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35543, &mem_param_35513, "mem_param_35513") != 0)
                        return 1;
                    do_find_joinPairs_res_f_res_28448 = loop_dz2088Uz2087U_28455;
                    do_find_joinPairs_res_f_res_28449 = loop_dz2088Uz2088U_28456;
                    do_find_joinPairs_res_f_res_28450 = loop_dz2088Uz2089U_28457;
                    if (memblock_set(ctx, &ext_mem_35616, &ext_mem_35544, "ext_mem_35544") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35613, &ext_mem_35543, "ext_mem_35543") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_35610, &ext_mem_35545, "ext_mem_35545") != 0)
                        return 1;
                    do_find_joinPairs_res_28369 = do_find_joinPairs_res_f_res_28449;
                    do_find_joinPairs_res_28370 = do_find_joinPairs_res_f_res_28450;
                    do_find_joinPairs_res_28371 = do_find_joinPairs_res_f_res_28448;
                }
                if (memblock_set(ctx, &ext_mem_35739, &ext_mem_35613, "ext_mem_35613") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_35736, &ext_mem_35616, "ext_mem_35616") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_35733, &ext_mem_35610, "ext_mem_35610") != 0)
                    return 1;
                find_joinPairs_res_27116 = do_find_joinPairs_res_28370;
                find_joinPairs_res_27117 = do_find_joinPairs_res_28369;
                find_joinPairs_res_27118 = do_find_joinPairs_res_28371;
            }
            
            int64_t conc_tmp_27134 = loop_dz2083Uz2086U_27080 + find_joinPairs_res_27118;
            int64_t bytes_35740 = b_23542 * conc_tmp_27134;
            int64_t conc_tmp_27136 = loop_dz2083Uz2084U_27078 + find_joinPairs_res_27116;
            int64_t bytes_35742 = (int64_t) 8 * conc_tmp_27136;
            int64_t conc_tmp_27138 = loop_dz2083Uz2085U_27079 + find_joinPairs_res_27117;
            int64_t bytes_35744 = (int64_t) 8 * conc_tmp_27138;
            
            if (memblock_alloc(ctx, &mem_35741, bytes_35740, "mem_35741")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t tmp_offs_36012 = (int64_t) 0;
            
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35741.mem, b_23542 * tmp_offs_36012, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_param_35503.mem, (int64_t) 0, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {loop_dz2083Uz2086U_27080, b_23542});
            tmp_offs_36012 += loop_dz2083Uz2086U_27080;
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35741.mem, b_23542 * tmp_offs_36012, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) ext_mem_35733.mem, (int64_t) 0, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {find_joinPairs_res_27118, b_23542});
            tmp_offs_36012 += find_joinPairs_res_27118;
            if (memblock_unref(ctx, &ext_mem_35733, "ext_mem_35733") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_35743, bytes_35742, "mem_35743")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t tmp_offs_36013 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35743.mem, tmp_offs_36013, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35496.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2083Uz2084U_27078});
            tmp_offs_36013 += loop_dz2083Uz2084U_27078;
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35743.mem, tmp_offs_36013, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_35739.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {find_joinPairs_res_27116});
            tmp_offs_36013 += find_joinPairs_res_27116;
            if (memblock_unref(ctx, &ext_mem_35739, "ext_mem_35739") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_35745, bytes_35744, "mem_35745")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t tmp_offs_36014 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35745.mem, tmp_offs_36014, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35499.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2083Uz2085U_27079});
            tmp_offs_36014 += loop_dz2083Uz2085U_27079;
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35745.mem, tmp_offs_36014, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_35736.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {find_joinPairs_res_27117});
            tmp_offs_36014 += find_joinPairs_res_27117;
            if (memblock_unref(ctx, &ext_mem_35736, "ext_mem_35736") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35917, &mem_35743, "mem_35743") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35918, &mem_35745, "mem_35745") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35919, &mem_35741, "mem_35741") != 0)
                return 1;
            
            int64_t loop_dz2083Uz2084U_tmp_35920 = conc_tmp_27136;
            int64_t loop_dz2083Uz2085U_tmp_35921 = conc_tmp_27138;
            int64_t loop_dz2083Uz2086U_tmp_35922 = conc_tmp_27134;
            
            if (memblock_set(ctx, &mem_param_35496, &mem_param_tmp_35917, "mem_param_tmp_35917") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35499, &mem_param_tmp_35918, "mem_param_tmp_35918") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35503, &mem_param_tmp_35919, "mem_param_tmp_35919") != 0)
                return 1;
            loop_dz2083Uz2084U_27078 = loop_dz2083Uz2084U_tmp_35920;
            loop_dz2083Uz2085U_27079 = loop_dz2083Uz2085U_tmp_35921;
            loop_dz2083Uz2086U_27080 = loop_dz2083Uz2086U_tmp_35922;
        }
        if (memblock_set(ctx, &ext_mem_35755, &mem_param_35496, "mem_param_35496") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35754, &mem_param_35499, "mem_param_35499") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35753, &mem_param_35503, "mem_param_35503") != 0)
            return 1;
        loopres_27071 = loop_dz2083Uz2084U_27078;
        loopres_27072 = loop_dz2083Uz2085U_27079;
        loopres_27073 = loop_dz2083Uz2086U_27080;
        
        int64_t conc_tmp_27140 = loop_dz2081Uz2082U_27029 + loopres_27073;
        int64_t bytes_35756 = b_23542 * conc_tmp_27140;
        int64_t conc_tmp_27142 = loop_dz2081Uz2080U_27027 + loopres_27071;
        int64_t bytes_35758 = (int64_t) 8 * conc_tmp_27142;
        int64_t conc_tmp_27144 = loop_dz2081Uz2081U_27028 + loopres_27072;
        int64_t bytes_35760 = (int64_t) 8 * conc_tmp_27144;
        
        if (memblock_alloc(ctx, &mem_35757, bytes_35756, "mem_35757")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t tmp_offs_36015 = (int64_t) 0;
        
        lmad_copy_1b(ctx, 2, (uint8_t *) mem_35757.mem, b_23542 * tmp_offs_36015, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) mem_param_35493.mem, (int64_t) 0, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {loop_dz2081Uz2082U_27029, b_23542});
        tmp_offs_36015 += loop_dz2081Uz2082U_27029;
        lmad_copy_1b(ctx, 2, (uint8_t *) mem_35757.mem, b_23542 * tmp_offs_36015, (int64_t []) {b_23542, (int64_t) 1}, (uint8_t *) ext_mem_35753.mem, (int64_t) 0, (int64_t []) {b_23542, (int64_t) 1}, (int64_t []) {loopres_27073, b_23542});
        tmp_offs_36015 += loopres_27073;
        if (memblock_unref(ctx, &ext_mem_35753, "ext_mem_35753") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_35759, bytes_35758, "mem_35759")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t tmp_offs_36016 = (int64_t) 0;
        
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35759.mem, tmp_offs_36016, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35486.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2080U_27027});
        tmp_offs_36016 += loop_dz2081Uz2080U_27027;
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35759.mem, tmp_offs_36016, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_35755.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loopres_27071});
        tmp_offs_36016 += loopres_27071;
        if (memblock_unref(ctx, &ext_mem_35755, "ext_mem_35755") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_35761, bytes_35760, "mem_35761")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t tmp_offs_36017 = (int64_t) 0;
        
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35761.mem, tmp_offs_36017, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35489.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2081U_27028});
        tmp_offs_36017 += loop_dz2081Uz2081U_27028;
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35761.mem, tmp_offs_36017, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_35754.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loopres_27072});
        tmp_offs_36017 += loopres_27072;
        if (memblock_unref(ctx, &ext_mem_35754, "ext_mem_35754") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35908, &mem_35759, "mem_35759") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35909, &mem_35761, "mem_35761") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35910, &mem_35757, "mem_35757") != 0)
            return 1;
        
        int64_t loop_dz2081Uz2080U_tmp_35911 = conc_tmp_27142;
        int64_t loop_dz2081Uz2081U_tmp_35912 = conc_tmp_27144;
        int64_t loop_dz2081Uz2082U_tmp_35913 = conc_tmp_27140;
        
        if (memblock_set(ctx, &mem_param_35486, &mem_param_tmp_35908, "mem_param_tmp_35908") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35489, &mem_param_tmp_35909, "mem_param_tmp_35909") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35493, &mem_param_tmp_35910, "mem_param_tmp_35910") != 0)
            return 1;
        loop_dz2081Uz2080U_27027 = loop_dz2081Uz2080U_tmp_35911;
        loop_dz2081Uz2081U_27028 = loop_dz2081Uz2081U_tmp_35912;
        loop_dz2081Uz2082U_27029 = loop_dz2081Uz2082U_tmp_35913;
    }
    if (memblock_set(ctx, &ext_mem_35771, &mem_param_35486, "mem_param_35486") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_35770, &mem_param_35489, "mem_param_35489") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_35769, &mem_param_35493, "mem_param_35493") != 0)
        return 1;
    join_hashPartitions_res_27020 = loop_dz2081Uz2080U_27027;
    join_hashPartitions_res_27021 = loop_dz2081Uz2081U_27028;
    join_hashPartitions_res_27022 = loop_dz2081Uz2082U_27029;
    if (memblock_unref(ctx, &mem_35479, "mem_35479") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35480, "mem_35480") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35481, "mem_35481") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35482, "mem_35482") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35483, "mem_35483") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35845, &ext_mem_35771, "ext_mem_35771") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35846, &ext_mem_35770, "ext_mem_35770") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35847, &ext_mem_35769, "ext_mem_35769") != 0)
        return 1;
    prim_out_35848 = join_hashPartitions_res_27020;
    prim_out_35849 = join_hashPartitions_res_27021;
    prim_out_35850 = join_hashPartitions_res_27022;
    if (memblock_set(ctx, &*mem_out_p_36018, &mem_out_35845, "mem_out_35845") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36019, &mem_out_35846, "mem_out_35846") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36020, &mem_out_35847, "mem_out_35847") != 0)
        return 1;
    *out_prim_out_36021 = prim_out_35848;
    *out_prim_out_36022 = prim_out_35849;
    *out_prim_out_36023 = prim_out_35850;
    
  cleanup:
    {
        free(mem_35264);
        free(mem_35266);
        free(mem_35268);
        free(mem_35270);
        free(mem_35272);
        free(mem_35291);
        free(mem_35292);
        free(mem_35305);
        free(mem_35306);
        free(mem_35319);
        free(mem_35320);
        free(mem_35333);
        free(mem_35334);
        free(mem_35350);
        free(mem_35351);
        free(mem_35364);
        free(mem_35365);
        free(mem_35381);
        free(mem_35382);
        free(mem_35395);
        free(mem_35396);
        free(mem_35412);
        free(mem_35413);
        free(mem_35426);
        free(mem_35427);
        free(mem_35456);
        free(mem_35458);
        free(mem_35460);
        free(mem_35559);
        free(mem_35560);
        free(mem_35574);
        free(mem_35672);
        free(mem_35673);
        free(mem_35687);
        if (memblock_unref(ctx, &mem_param_tmp_35910, "mem_param_tmp_35910") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35909, "mem_param_tmp_35909") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35908, "mem_param_tmp_35908") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35761, "mem_35761") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35759, "mem_35759") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35757, "mem_35757") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35919, "mem_param_tmp_35919") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35918, "mem_param_tmp_35918") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35917, "mem_param_tmp_35917") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35745, "mem_35745") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35743, "mem_35743") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35741, "mem_35741") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35994, "mem_param_tmp_35994") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35993, "mem_param_tmp_35993") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35992, "mem_param_tmp_35992") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35535, "mem_35535") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35533, "mem_35533") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35531, "mem_35531") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_36001, "mem_param_tmp_36001") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35519, "mem_35519") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35522, "ext_mem_35522") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35516, "mem_param_35516") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35525, "ext_mem_35525") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35513, "mem_param_35513") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35510, "mem_param_35510") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35507, "mem_param_35507") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35543, "ext_mem_35543") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35544, "ext_mem_35544") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35545, "ext_mem_35545") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35973, "mem_param_tmp_35973") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35972, "mem_param_tmp_35972") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35971, "mem_param_tmp_35971") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35594, "mem_35594") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35590, "ext_mem_35590") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35586, "mem_35586") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35596, "mem_35596") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35592, "mem_35592") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35557, "mem_param_35557") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35554, "mem_param_35554") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35551, "mem_param_35551") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35604, "ext_mem_35604") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35605, "ext_mem_35605") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35606, "ext_mem_35606") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35588, "mem_35588") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35547, "mem_35547") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35610, "ext_mem_35610") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35613, "ext_mem_35613") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35616, "ext_mem_35616") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35951, "mem_param_tmp_35951") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35950, "mem_param_tmp_35950") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35949, "mem_param_tmp_35949") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35648, "mem_35648") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35646, "mem_35646") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35644, "mem_35644") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35958, "mem_param_tmp_35958") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35632, "mem_35632") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35635, "ext_mem_35635") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35629, "mem_param_35629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35638, "ext_mem_35638") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35626, "mem_param_35626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35623, "mem_param_35623") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35620, "mem_param_35620") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35656, "ext_mem_35656") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35657, "ext_mem_35657") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35658, "ext_mem_35658") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35930, "mem_param_tmp_35930") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35929, "mem_param_tmp_35929") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35928, "mem_param_tmp_35928") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35707, "mem_35707") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35703, "ext_mem_35703") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35699, "mem_35699") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35709, "mem_35709") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35705, "mem_35705") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35670, "mem_param_35670") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35667, "mem_param_35667") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35664, "mem_param_35664") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35717, "ext_mem_35717") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35718, "ext_mem_35718") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35719, "ext_mem_35719") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35701, "mem_35701") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35660, "mem_35660") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35723, "ext_mem_35723") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35726, "ext_mem_35726") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35729, "ext_mem_35729") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35733, "ext_mem_35733") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35736, "ext_mem_35736") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35739, "ext_mem_35739") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35503, "mem_param_35503") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35499, "mem_param_35499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35496, "mem_param_35496") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35753, "ext_mem_35753") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35754, "ext_mem_35754") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35755, "ext_mem_35755") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35493, "mem_param_35493") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35489, "mem_param_35489") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35486, "mem_param_35486") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35769, "ext_mem_35769") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35770, "ext_mem_35770") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35771, "ext_mem_35771") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35483, "mem_35483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35482, "mem_35482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35481, "mem_35481") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35480, "mem_35480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35479, "mem_35479") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35847, "mem_out_35847") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35846, "mem_out_35846") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35845, "mem_out_35845") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_calc_partitions_from_partitioned_set(struct futhark_context *ctx, struct memblock *mem_out_p_36058, struct memblock *mem_out_p_36059, int64_t *out_prim_out_36060, int64_t *out_prim_out_36061, int32_t *out_prim_out_36062, int32_t *out_prim_out_36063, int32_t *out_prim_out_36064, struct memblock pXs_mem_35253, int64_t n_20311, int64_t b_20312, int32_t radix_sizze_20313, int64_t offset_20315, int64_t sizze_thresh_20316, int32_t max_depth_20317)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_35263_cached_sizze_36065 = 0;
    unsigned char *mem_35263 = NULL;
    int64_t mem_35265_cached_sizze_36066 = 0;
    unsigned char *mem_35265 = NULL;
    int64_t mem_35267_cached_sizze_36067 = 0;
    unsigned char *mem_35267 = NULL;
    int64_t mem_35269_cached_sizze_36068 = 0;
    unsigned char *mem_35269 = NULL;
    int64_t mem_35295_cached_sizze_36069 = 0;
    unsigned char *mem_35295 = NULL;
    int64_t mem_35297_cached_sizze_36070 = 0;
    unsigned char *mem_35297 = NULL;
    int64_t mem_35299_cached_sizze_36071 = 0;
    unsigned char *mem_35299 = NULL;
    struct memblock mem_35354;
    
    mem_35354.references = NULL;
    
    struct memblock mem_param_tmp_35853;
    
    mem_param_tmp_35853.references = NULL;
    
    struct memblock mem_param_tmp_35852;
    
    mem_param_tmp_35852.references = NULL;
    
    struct memblock mem_param_tmp_35873;
    
    mem_param_tmp_35873.references = NULL;
    
    struct memblock mem_param_tmp_35872;
    
    mem_param_tmp_35872.references = NULL;
    
    struct memblock mem_35340;
    
    mem_35340.references = NULL;
    
    struct memblock mem_35338;
    
    mem_35338.references = NULL;
    
    struct memblock ext_mem_35327;
    
    ext_mem_35327.references = NULL;
    
    struct memblock ext_mem_35328;
    
    ext_mem_35328.references = NULL;
    
    struct memblock mem_35325;
    
    mem_35325.references = NULL;
    
    struct memblock mem_param_35323;
    
    mem_param_35323.references = NULL;
    
    struct memblock mem_param_35320;
    
    mem_param_35320.references = NULL;
    
    struct memblock ext_mem_35345;
    
    ext_mem_35345.references = NULL;
    
    struct memblock ext_mem_35346;
    
    ext_mem_35346.references = NULL;
    
    struct memblock mem_param_35261;
    
    mem_param_35261.references = NULL;
    
    struct memblock mem_param_35258;
    
    mem_param_35258.references = NULL;
    
    struct memblock ext_mem_35351;
    
    ext_mem_35351.references = NULL;
    
    struct memblock ext_mem_35352;
    
    ext_mem_35352.references = NULL;
    
    struct memblock ext_mem_35254;
    
    ext_mem_35254.references = NULL;
    
    struct memblock ext_mem_35255;
    
    ext_mem_35255.references = NULL;
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    int64_t prim_out_35847;
    int64_t prim_out_35848;
    int32_t prim_out_35849;
    int32_t prim_out_35850;
    int32_t prim_out_35851;
    int32_t getPartitionBounds_arg3_26070 = sub32(radix_sizze_20313, 1);
    int64_t calc_partitions_from_partitioned_set_res_26071;
    int64_t calc_partitions_from_partitioned_set_res_26072;
    int32_t calc_partitions_from_partitioned_set_res_26075;
    int32_t calc_partitions_from_partitioned_set_res_26076;
    int32_t calc_partitions_from_partitioned_set_res_26077;
    
    if (futrts_getPartitionBounds_8373(ctx, &ext_mem_35255, &ext_mem_35254, &calc_partitions_from_partitioned_set_res_26071, &calc_partitions_from_partitioned_set_res_26072, &calc_partitions_from_partitioned_set_res_26075, &calc_partitions_from_partitioned_set_res_26076, &calc_partitions_from_partitioned_set_res_26077, pXs_mem_35253, n_20311, b_20312, 1, 0, getPartitionBounds_arg3_26070) != 0) {
        err = 1;
        goto cleanup;
    }
    
    bool cond_26078 = slt32(calc_partitions_from_partitioned_set_res_26075, max_depth_20317);
    int32_t i64_res_26079 = sext_i64_i32(b_20312);
    int64_t calc_partitions_from_partitioned_set_res_26080;
    int64_t calc_partitions_from_partitioned_set_res_26081;
    bool calc_partitions_from_partitioned_set_res_26082;
    int32_t calc_partitions_from_partitioned_set_res_26085;
    int32_t calc_partitions_from_partitioned_set_res_26086;
    int32_t calc_partitions_from_partitioned_set_res_26087;
    int64_t loop_dz2088U_26088;
    int64_t loop_dz2089U_26089;
    bool loop_while_26090;
    int32_t p_26093;
    int32_t p_26094;
    int32_t p_26095;
    
    if (memblock_set(ctx, &mem_param_35258, &ext_mem_35255, "ext_mem_35255") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_35261, &ext_mem_35254, "ext_mem_35254") != 0)
        return 1;
    loop_dz2088U_26088 = calc_partitions_from_partitioned_set_res_26071;
    loop_dz2089U_26089 = calc_partitions_from_partitioned_set_res_26072;
    loop_while_26090 = cond_26078;
    p_26093 = calc_partitions_from_partitioned_set_res_26075;
    p_26094 = calc_partitions_from_partitioned_set_res_26076;
    p_26095 = calc_partitions_from_partitioned_set_res_26077;
    while (loop_while_26090) {
        int64_t zl_rhs_26098 = sub64(loop_dz2088U_26088, (int64_t) 1);
        int64_t bytes_35262 = (int64_t) 8 * loop_dz2088U_26088;
        
        if (mem_35263_cached_sizze_36065 < bytes_35262) {
            err = lexical_realloc(ctx, &mem_35263, &mem_35263_cached_sizze_36065, bytes_35262);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_35265_cached_sizze_36066 < bytes_35262) {
            err = lexical_realloc(ctx, &mem_35265, &mem_35265_cached_sizze_36066, bytes_35262);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_35267_cached_sizze_36067 < bytes_35262) {
            err = lexical_realloc(ctx, &mem_35267, &mem_35267_cached_sizze_36067, bytes_35262);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_35269_cached_sizze_36068 < bytes_35262) {
            err = lexical_realloc(ctx, &mem_35269, &mem_35269_cached_sizze_36068, bytes_35262);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        
        int64_t discard_35094;
        int64_t scanacc_35084 = (int64_t) 0;
        
        for (int64_t i_35089 = 0; i_35089 < loop_dz2088U_26088; i_35089++) {
            int64_t tmp_28899 = ((int64_t *) mem_param_35258.mem)[i_35089];
            bool cond_28900 = slt64(i_35089, zl_rhs_26098);
            int64_t tmp_28901;
            
            if (cond_28900) {
                int64_t tmp_28939 = add64((int64_t) 1, i_35089);
                bool x_28940 = sle64((int64_t) 0, tmp_28939);
                bool y_28941 = slt64(tmp_28939, loop_dz2088U_26088);
                bool bounds_check_28942 = x_28940 && y_28941;
                bool index_certs_28943;
                
                if (!bounds_check_28942) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_28939, "] out of bounds for array of shape [", (long long) loop_dz2088U_26088, "].", "-> #0  ftHashJoin.fut:274:55-62\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:262:1-302:32\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t tmp_t_res_28944 = ((int64_t *) mem_param_35258.mem)[tmp_28939];
                
                tmp_28901 = tmp_t_res_28944;
            } else {
                tmp_28901 = n_20311;
            }
            
            int64_t zg_lhs_28910 = sub64(tmp_28901, tmp_28899);
            bool lifted_lambda_res_28911 = slt64(sizze_thresh_20316, zg_lhs_28910);
            int64_t defunc_0_f_res_28912 = btoi_bool_i64(lifted_lambda_res_28911);
            int64_t defunc_0_op_res_26130 = add64(defunc_0_f_res_28912, scanacc_35084);
            
            ((int64_t *) mem_35263)[i_35089] = defunc_0_op_res_26130;
            ((int64_t *) mem_35265)[i_35089] = defunc_0_f_res_28912;
            ((int64_t *) mem_35267)[i_35089] = tmp_28899;
            ((int64_t *) mem_35269)[i_35089] = tmp_28901;
            
            int64_t scanacc_tmp_35862 = defunc_0_op_res_26130;
            
            scanacc_35084 = scanacc_tmp_35862;
        }
        discard_35094 = scanacc_35084;
        
        bool cond_26131 = loop_dz2088U_26088 == (int64_t) 0;
        bool x_26132 = !cond_26131;
        bool x_26134 = sle64((int64_t) 0, zl_rhs_26098);
        bool y_26135 = slt64(zl_rhs_26098, loop_dz2088U_26088);
        bool bounds_check_26136 = x_26134 && y_26135;
        bool protect_assert_disj_26137 = cond_26131 || bounds_check_26136;
        bool index_certs_26138;
        
        if (!protect_assert_disj_26137) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zl_rhs_26098, "] out of bounds for array of shape [", (long long) loop_dz2088U_26088, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:262:1-302:32\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t m_f_res_26139;
        
        if (x_26132) {
            int64_t x_28945 = ((int64_t *) mem_35263)[zl_rhs_26098];
            
            m_f_res_26139 = x_28945;
        } else {
            m_f_res_26139 = (int64_t) 0;
        }
        
        int64_t m_26141;
        
        if (cond_26131) {
            m_26141 = (int64_t) 0;
        } else {
            m_26141 = m_f_res_26139;
        }
        
        int64_t m_26151 = sub64(m_26141, (int64_t) 1);
        bool i_p_m_t_s_leq_w_26153 = slt64(m_26151, loop_dz2088U_26088);
        bool zzero_leq_i_p_m_t_s_26152 = sle64((int64_t) 0, m_26151);
        bool y_26155 = zzero_leq_i_p_m_t_s_26152 && i_p_m_t_s_leq_w_26153;
        bool i_lte_j_26154 = sle64((int64_t) 0, m_26141);
        bool forwards_ok_26156 = i_lte_j_26154 && y_26155;
        bool eq_x_zz_26148 = (int64_t) 0 == m_f_res_26139;
        bool p_and_eq_x_y_26149 = x_26132 && eq_x_zz_26148;
        bool empty_slice_26150 = cond_26131 || p_and_eq_x_y_26149;
        bool ok_or_empty_26157 = empty_slice_26150 || forwards_ok_26156;
        bool index_certs_26158;
        
        if (!ok_or_empty_26157) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_26141, "] out of bounds for array of shape [", (long long) loop_dz2088U_26088, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:262:1-302:32\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t bytes_35294 = (int64_t) 8 * m_26141;
        
        if (mem_35295_cached_sizze_36069 < bytes_35294) {
            err = lexical_realloc(ctx, &mem_35295, &mem_35295_cached_sizze_36069, bytes_35294);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_35867 = 0; i_35867 < m_26141; i_35867++) {
            int64_t x_35868 = (int64_t) 0 + i_35867 * (int64_t) 1;
            
            ((int64_t *) mem_35295)[i_35867] = x_35868;
        }
        if (mem_35297_cached_sizze_36070 < bytes_35294) {
            err = lexical_realloc(ctx, &mem_35297, &mem_35297_cached_sizze_36070, bytes_35294);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35297, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35269, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_26141});
        if (mem_35299_cached_sizze_36071 < bytes_35294) {
            err = lexical_realloc(ctx, &mem_35299, &mem_35299_cached_sizze_36071, bytes_35294);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35299, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35267, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_26141});
        for (int64_t write_iter_35095 = 0; write_iter_35095 < loop_dz2088U_26088; write_iter_35095++) {
            int64_t write_iv_35099 = ((int64_t *) mem_35265)[write_iter_35095];
            int64_t write_iv_35100 = ((int64_t *) mem_35263)[write_iter_35095];
            int64_t write_iv_35101 = ((int64_t *) mem_35267)[write_iter_35095];
            int64_t write_iv_35102 = ((int64_t *) mem_35269)[write_iter_35095];
            bool cond_28881 = write_iv_35099 == (int64_t) 1;
            int64_t lifted_lambda_res_28882;
            
            if (cond_28881) {
                int64_t lifted_lambda_res_t_res_28946 = sub64(write_iv_35100, (int64_t) 1);
                
                lifted_lambda_res_28882 = lifted_lambda_res_t_res_28946;
            } else {
                lifted_lambda_res_28882 = (int64_t) -1;
            }
            if (sle64((int64_t) 0, lifted_lambda_res_28882) && slt64(lifted_lambda_res_28882, m_26141)) {
                ((int64_t *) mem_35299)[lifted_lambda_res_28882] = write_iv_35101;
            }
            if (sle64((int64_t) 0, lifted_lambda_res_28882) && slt64(lifted_lambda_res_28882, m_26141)) {
                ((int64_t *) mem_35297)[lifted_lambda_res_28882] = write_iv_35102;
            }
            if (sle64((int64_t) 0, lifted_lambda_res_28882) && slt64(lifted_lambda_res_28882, m_26141)) {
                ((int64_t *) mem_35295)[lifted_lambda_res_28882] = write_iter_35095;
            }
        }
        
        int32_t new_i_26172 = mul32(radix_sizze_20313, p_26093);
        int32_t zt_rhs_26173 = add32(1, p_26093);
        int32_t zm_lhs_26174 = mul32(radix_sizze_20313, zt_rhs_26173);
        int32_t new_j_26175 = sub32(zm_lhs_26174, 1);
        int64_t loopres_26176;
        int64_t loopres_26177;
        int32_t loopres_26180;
        int32_t loopres_26181;
        int32_t loopres_26182;
        int64_t loopres_26183;
        int64_t loopres_26184;
        int64_t loop_dz2084Uz2089U_26186;
        int64_t loop_dz2085Uz2080U_26187;
        int32_t q_26190;
        int32_t q_26191;
        int32_t q_26192;
        int64_t ad_26193;
        int64_t ox_26194;
        
        if (memblock_set(ctx, &mem_param_35320, &mem_param_35258, "mem_param_35258") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35323, &mem_param_35261, "mem_param_35261") != 0)
            return 1;
        loop_dz2084Uz2089U_26186 = loop_dz2088U_26088;
        loop_dz2085Uz2080U_26187 = loop_dz2089U_26089;
        q_26190 = p_26093;
        q_26191 = p_26094;
        q_26192 = p_26095;
        ad_26193 = (int64_t) 0;
        ox_26194 = (int64_t) 0;
        for (int64_t i_26185 = 0; i_26185 < m_26141; i_26185++) {
            int64_t bounds_26195 = ((int64_t *) mem_35299)[i_26185];
            int64_t bounds_26196 = ((int64_t *) mem_35297)[i_26185];
            int64_t bounds_26197 = ((int64_t *) mem_35295)[i_26185];
            int64_t dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_26198 = sub64(bounds_26196, bounds_26195);
            bool empty_slice_26199 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_26198 == (int64_t) 0;
            int64_t m_26200 = sub64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_26198, (int64_t) 1);
            int64_t i_p_m_t_s_26201 = add64(bounds_26195, m_26200);
            bool zzero_leq_i_p_m_t_s_26202 = sle64((int64_t) 0, i_p_m_t_s_26201);
            bool i_p_m_t_s_leq_w_26203 = slt64(i_p_m_t_s_26201, n_20311);
            bool zzero_lte_i_26204 = sle64((int64_t) 0, bounds_26195);
            bool i_lte_j_26205 = sle64(bounds_26195, bounds_26196);
            bool y_26206 = i_p_m_t_s_leq_w_26203 && zzero_lte_i_26204;
            bool y_26207 = zzero_leq_i_p_m_t_s_26202 && y_26206;
            bool forwards_ok_26208 = i_lte_j_26205 && y_26207;
            bool ok_or_empty_26209 = empty_slice_26199 || forwards_ok_26208;
            bool index_certs_26210;
            
            if (!ok_or_empty_26209) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) bounds_26195, ":", (long long) bounds_26196, "] out of bounds for array of shape [", (long long) n_20311, "].", "-> #0  ftHashJoin.fut:280:21-43\n   #1  ftHashJoin.fut:262:1-302:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_35324 = b_20312 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_26198;
            
            if (memblock_alloc(ctx, &mem_35325, bytes_35324, "mem_35325")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35325.mem, (int64_t) 0, (int64_t []) {b_20312, (int64_t) 1}, (uint8_t *) pXs_mem_35253.mem, b_20312 * bounds_26195, (int64_t []) {b_20312, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_26198, b_20312});
            
            int64_t loopres_26214;
            int64_t loopres_26215;
            int32_t loopres_26218;
            int32_t loopres_26219;
            int32_t loopres_26220;
            
            if (futrts_getPartitionBounds_8373(ctx, &ext_mem_35328, &ext_mem_35327, &loopres_26214, &loopres_26215, &loopres_26218, &loopres_26219, &loopres_26220, mem_35325, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_26198, b_20312, zt_rhs_26173, new_i_26172, new_j_26175) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref(ctx, &mem_35325, "mem_35325") != 0)
                return 1;
            
            int64_t zm_lhs_26221 = add64(ox_26194, bounds_26197);
            int64_t stitch_26222 = sub64(zm_lhs_26221, ad_26193);
            bool empty_slice_26223 = stitch_26222 == (int64_t) 0;
            int64_t m_26224 = sub64(stitch_26222, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_26225 = sle64((int64_t) 0, m_26224);
            bool i_p_m_t_s_leq_w_26226 = slt64(m_26224, loop_dz2084Uz2089U_26186);
            bool i_lte_j_26227 = sle64((int64_t) 0, stitch_26222);
            bool y_26228 = zzero_leq_i_p_m_t_s_26225 && i_p_m_t_s_leq_w_26226;
            bool forwards_ok_26229 = i_lte_j_26227 && y_26228;
            bool ok_or_empty_26230 = empty_slice_26223 || forwards_ok_26229;
            bool index_certs_26231;
            
            if (!ok_or_empty_26230) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) stitch_26222, "] out of bounds for array of shape [", (long long) loop_dz2084Uz2089U_26186, "].", "-> #0  ftHashJoin.fut:290:18-36\n   #1  ftHashJoin.fut:262:1-302:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t conc_tmp_26236 = loopres_26214 + stitch_26222;
            int64_t zpzp_rhs_26237 = add64((int64_t) 1, stitch_26222);
            int64_t j_m_i_26238 = sub64(loop_dz2084Uz2089U_26186, zpzp_rhs_26237);
            bool empty_slice_26239 = j_m_i_26238 == (int64_t) 0;
            int64_t m_26240 = sub64(j_m_i_26238, (int64_t) 1);
            int64_t i_p_m_t_s_26241 = add64(zpzp_rhs_26237, m_26240);
            bool zzero_leq_i_p_m_t_s_26242 = sle64((int64_t) 0, i_p_m_t_s_26241);
            bool i_p_m_t_s_leq_w_26243 = slt64(i_p_m_t_s_26241, loop_dz2084Uz2089U_26186);
            bool zzero_lte_i_26244 = sle64((int64_t) 0, zpzp_rhs_26237);
            bool i_lte_j_26245 = sle64(zpzp_rhs_26237, loop_dz2084Uz2089U_26186);
            bool y_26246 = i_p_m_t_s_leq_w_26243 && zzero_lte_i_26244;
            bool y_26247 = zzero_leq_i_p_m_t_s_26242 && y_26246;
            bool forwards_ok_26248 = i_lte_j_26245 && y_26247;
            bool ok_or_empty_26249 = empty_slice_26239 || forwards_ok_26248;
            bool index_certs_26250;
            
            if (!ok_or_empty_26249) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zpzp_rhs_26237, ":", (long long) loop_dz2084Uz2089U_26186, "] out of bounds for array of shape [", (long long) loop_dz2084Uz2089U_26186, "].", "-> #0  ftHashJoin.fut:290:90-126\n   #1  ftHashJoin.fut:262:1-302:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t conc_tmp_26252 = conc_tmp_26236 + j_m_i_26238;
            int64_t bytes_35337 = (int64_t) 8 * conc_tmp_26252;
            bool i_p_m_t_s_leq_w_26254 = slt64(m_26224, loop_dz2085Uz2080U_26187);
            bool y_26255 = zzero_leq_i_p_m_t_s_26225 && i_p_m_t_s_leq_w_26254;
            bool ok_or_empty_26256 = empty_slice_26223 || y_26255;
            bool index_certs_26257;
            
            if (!ok_or_empty_26256) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) stitch_26222, "] out of bounds for array of shape [", (long long) loop_dz2085Uz2080U_26187, "].", "-> #0  ftHashJoin.fut:291:18-36\n   #1  ftHashJoin.fut:262:1-302:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t conc_tmp_26259 = loopres_26215 + stitch_26222;
            int64_t j_m_i_26260 = sub64(loop_dz2085Uz2080U_26187, zpzp_rhs_26237);
            bool empty_slice_26261 = j_m_i_26260 == (int64_t) 0;
            int64_t m_26262 = sub64(j_m_i_26260, (int64_t) 1);
            int64_t i_p_m_t_s_26263 = add64(zpzp_rhs_26237, m_26262);
            bool zzero_leq_i_p_m_t_s_26264 = sle64((int64_t) 0, i_p_m_t_s_26263);
            bool i_p_m_t_s_leq_w_26265 = slt64(i_p_m_t_s_26263, loop_dz2085Uz2080U_26187);
            bool i_lte_j_26266 = sle64(zpzp_rhs_26237, loop_dz2085Uz2080U_26187);
            bool y_26267 = zzero_lte_i_26244 && i_p_m_t_s_leq_w_26265;
            bool y_26268 = zzero_leq_i_p_m_t_s_26264 && y_26267;
            bool forwards_ok_26269 = i_lte_j_26266 && y_26268;
            bool ok_or_empty_26270 = empty_slice_26261 || forwards_ok_26269;
            bool index_certs_26271;
            
            if (!ok_or_empty_26270) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zpzp_rhs_26237, ":", (long long) loop_dz2085Uz2080U_26187, "] out of bounds for array of shape [", (long long) loop_dz2085Uz2080U_26187, "].", "-> #0  ftHashJoin.fut:291:62-98\n   #1  ftHashJoin.fut:262:1-302:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t conc_tmp_26273 = conc_tmp_26259 + j_m_i_26260;
            int64_t bytes_35339 = (int64_t) 4 * conc_tmp_26273;
            
            if (memblock_alloc(ctx, &mem_35338, bytes_35337, "mem_35338")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t i_35109 = 0; i_35109 < loopres_26214; i_35109++) {
                int64_t eta_p_26234 = ((int64_t *) ext_mem_35328.mem)[i_35109];
                int64_t lifted_lambda_res_26235 = add64(bounds_26195, eta_p_26234);
                
                ((int64_t *) mem_35338.mem)[stitch_26222 + i_35109] = lifted_lambda_res_26235;
            }
            if (memblock_unref(ctx, &ext_mem_35328, "ext_mem_35328") != 0)
                return 1;
            
            int64_t tmp_offs_35884 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35338.mem, tmp_offs_35884, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35320.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {stitch_26222});
            tmp_offs_35884 += stitch_26222;
            if (!(tmp_offs_35884 == stitch_26222)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_35338.mem, tmp_offs_35884, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35338.mem, stitch_26222, (int64_t []) {(int64_t) 1}, (int64_t []) {loopres_26214});
            }
            tmp_offs_35884 += loopres_26214;
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35338.mem, tmp_offs_35884, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35320.mem, (int64_t) 0 + (int64_t) 1 * zpzp_rhs_26237, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_26238});
            tmp_offs_35884 += j_m_i_26238;
            if (memblock_alloc(ctx, &mem_35340, bytes_35339, "mem_35340")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t tmp_offs_35885 = (int64_t) 0;
            
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_35340.mem, tmp_offs_35885, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_param_35323.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {stitch_26222});
            tmp_offs_35885 += stitch_26222;
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_35340.mem, tmp_offs_35885, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_35327.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loopres_26215});
            tmp_offs_35885 += loopres_26215;
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_35340.mem, tmp_offs_35885, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_param_35323.mem, (int64_t) 0 + (int64_t) 1 * zpzp_rhs_26237, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_26260});
            tmp_offs_35885 += j_m_i_26260;
            if (memblock_unref(ctx, &ext_mem_35327, "ext_mem_35327") != 0)
                return 1;
            
            int64_t tmp_26275 = add64((int64_t) 1, ad_26193);
            int64_t tmp_26276 = add64(ox_26194, loopres_26214);
            
            if (memblock_set(ctx, &mem_param_tmp_35872, &mem_35338, "mem_35338") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35873, &mem_35340, "mem_35340") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2089U_tmp_35874 = conc_tmp_26252;
            int64_t loop_dz2085Uz2080U_tmp_35875 = conc_tmp_26273;
            int32_t q_tmp_35878 = zt_rhs_26173;
            int32_t q_tmp_35879 = radix_sizze_20313;
            int32_t q_tmp_35880 = i64_res_26079;
            int64_t ad_tmp_35881 = tmp_26275;
            int64_t ox_tmp_35882 = tmp_26276;
            
            if (memblock_set(ctx, &mem_param_35320, &mem_param_tmp_35872, "mem_param_tmp_35872") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35323, &mem_param_tmp_35873, "mem_param_tmp_35873") != 0)
                return 1;
            loop_dz2084Uz2089U_26186 = loop_dz2084Uz2089U_tmp_35874;
            loop_dz2085Uz2080U_26187 = loop_dz2085Uz2080U_tmp_35875;
            q_26190 = q_tmp_35878;
            q_26191 = q_tmp_35879;
            q_26192 = q_tmp_35880;
            ad_26193 = ad_tmp_35881;
            ox_26194 = ox_tmp_35882;
        }
        if (memblock_set(ctx, &ext_mem_35346, &mem_param_35320, "mem_param_35320") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35345, &mem_param_35323, "mem_param_35323") != 0)
            return 1;
        loopres_26176 = loop_dz2084Uz2089U_26186;
        loopres_26177 = loop_dz2085Uz2080U_26187;
        loopres_26180 = q_26190;
        loopres_26181 = q_26191;
        loopres_26182 = q_26192;
        loopres_26183 = ad_26193;
        loopres_26184 = ox_26194;
        
        bool tmp_26277 = slt64((int64_t) 0, m_26141);
        bool cond_26278 = slt32(loopres_26180, max_depth_20317);
        bool x_26279 = tmp_26277 && cond_26278;
        
        if (memblock_set(ctx, &mem_param_tmp_35852, &ext_mem_35346, "ext_mem_35346") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35853, &ext_mem_35345, "ext_mem_35345") != 0)
            return 1;
        
        int64_t loop_dz2088U_tmp_35854 = loopres_26176;
        int64_t loop_dz2089U_tmp_35855 = loopres_26177;
        bool loop_while_tmp_35856 = x_26279;
        int32_t p_tmp_35859 = loopres_26180;
        int32_t p_tmp_35860 = loopres_26181;
        int32_t p_tmp_35861 = loopres_26182;
        
        if (memblock_set(ctx, &mem_param_35258, &mem_param_tmp_35852, "mem_param_tmp_35852") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35261, &mem_param_tmp_35853, "mem_param_tmp_35853") != 0)
            return 1;
        loop_dz2088U_26088 = loop_dz2088U_tmp_35854;
        loop_dz2089U_26089 = loop_dz2089U_tmp_35855;
        loop_while_26090 = loop_while_tmp_35856;
        p_26093 = p_tmp_35859;
        p_26094 = p_tmp_35860;
        p_26095 = p_tmp_35861;
    }
    if (memblock_set(ctx, &ext_mem_35352, &mem_param_35258, "mem_param_35258") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_35351, &mem_param_35261, "mem_param_35261") != 0)
        return 1;
    calc_partitions_from_partitioned_set_res_26080 = loop_dz2088U_26088;
    calc_partitions_from_partitioned_set_res_26081 = loop_dz2089U_26089;
    calc_partitions_from_partitioned_set_res_26082 = loop_while_26090;
    calc_partitions_from_partitioned_set_res_26085 = p_26093;
    calc_partitions_from_partitioned_set_res_26086 = p_26094;
    calc_partitions_from_partitioned_set_res_26087 = p_26095;
    if (memblock_unref(ctx, &ext_mem_35254, "ext_mem_35254") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_35255, "ext_mem_35255") != 0)
        return 1;
    
    int64_t bytes_35353 = (int64_t) 8 * calc_partitions_from_partitioned_set_res_26080;
    
    if (memblock_alloc(ctx, &mem_35354, bytes_35353, "mem_35354")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_35113 = 0; i_35113 < calc_partitions_from_partitioned_set_res_26080; i_35113++) {
        int64_t eta_p_26281 = ((int64_t *) ext_mem_35352.mem)[i_35113];
        int64_t lifted_lambda_res_26282 = add64(offset_20315, eta_p_26281);
        
        ((int64_t *) mem_35354.mem)[i_35113] = lifted_lambda_res_26282;
    }
    if (memblock_unref(ctx, &ext_mem_35352, "ext_mem_35352") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35845, &mem_35354, "mem_35354") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35846, &ext_mem_35351, "ext_mem_35351") != 0)
        return 1;
    prim_out_35847 = calc_partitions_from_partitioned_set_res_26080;
    prim_out_35848 = calc_partitions_from_partitioned_set_res_26081;
    prim_out_35849 = calc_partitions_from_partitioned_set_res_26085;
    prim_out_35850 = calc_partitions_from_partitioned_set_res_26086;
    prim_out_35851 = calc_partitions_from_partitioned_set_res_26087;
    if (memblock_set(ctx, &*mem_out_p_36058, &mem_out_35845, "mem_out_35845") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36059, &mem_out_35846, "mem_out_35846") != 0)
        return 1;
    *out_prim_out_36060 = prim_out_35847;
    *out_prim_out_36061 = prim_out_35848;
    *out_prim_out_36062 = prim_out_35849;
    *out_prim_out_36063 = prim_out_35850;
    *out_prim_out_36064 = prim_out_35851;
    
  cleanup:
    {
        free(mem_35263);
        free(mem_35265);
        free(mem_35267);
        free(mem_35269);
        free(mem_35295);
        free(mem_35297);
        free(mem_35299);
        if (memblock_unref(ctx, &mem_35354, "mem_35354") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35853, "mem_param_tmp_35853") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35852, "mem_param_tmp_35852") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35873, "mem_param_tmp_35873") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35872, "mem_param_tmp_35872") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35340, "mem_35340") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35338, "mem_35338") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35327, "ext_mem_35327") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35328, "ext_mem_35328") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35325, "mem_35325") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35323, "mem_param_35323") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35320, "mem_param_35320") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35345, "ext_mem_35345") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35346, "ext_mem_35346") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35261, "mem_param_35261") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35258, "mem_param_35258") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35351, "ext_mem_35351") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35352, "ext_mem_35352") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35254, "ext_mem_35254") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35255, "ext_mem_35255") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35846, "mem_out_35846") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35845, "mem_out_35845") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_create_hash_table_from_partitioned_set(struct futhark_context *ctx, struct memblock *mem_out_p_36072, struct memblock *mem_out_p_36073, int64_t *out_prim_out_36074, struct memblock pXs_mem_35253, struct memblock bounds_mem_35254, struct memblock depths_mem_35255, int64_t n_21066, int64_t b_21067, int64_t dz2080U_21068, int64_t dz2081U_21069, int32_t maxDepth_21073, int32_t radixSizze_21074, int32_t totalBytes_21075, int64_t scatter_psizze_21076)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_35259_cached_sizze_36075 = 0;
    unsigned char *mem_35259 = NULL;
    int64_t mem_35288_cached_sizze_36076 = 0;
    unsigned char *mem_35288 = NULL;
    int64_t mem_35290_cached_sizze_36077 = 0;
    unsigned char *mem_35290 = NULL;
    struct memblock ext_mem_35314;
    
    ext_mem_35314.references = NULL;
    
    struct memblock mem_35312;
    
    mem_35312.references = NULL;
    
    struct memblock mem_35310;
    
    mem_35310.references = NULL;
    
    struct memblock ext_mem_35308;
    
    ext_mem_35308.references = NULL;
    
    struct memblock mem_35306;
    
    mem_35306.references = NULL;
    
    struct memblock mem_35304;
    
    mem_35304.references = NULL;
    
    struct memblock mem_35267;
    
    mem_35267.references = NULL;
    
    struct memblock mem_35266;
    
    mem_35266.references = NULL;
    
    struct memblock mem_35280;
    
    mem_35280.references = NULL;
    
    struct memblock ext_mem_35283;
    
    ext_mem_35283.references = NULL;
    
    struct memblock ext_mem_35286;
    
    ext_mem_35286.references = NULL;
    
    struct memblock mem_35257;
    
    mem_35257.references = NULL;
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    int64_t prim_out_35847;
    int64_t bytes_35256 = (int64_t) 8 * dz2080U_21068;
    int64_t i32_res_25941 = sext_i32_i64(radixSizze_21074);
    bool nonnegative_25942 = sle64((int64_t) 0, i32_res_25941);
    bool nonzzero_cert_25943;
    
    if (!nonnegative_25942) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  ftHashJoin.fut:329:78-83\n   #1  ftHashJoin.fut:304:1-331:86\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t dzlz7bUZLztztZRz20U2z20Ursz7dUzg_25944 = shl64((int64_t) 1, i32_res_25941);
    int32_t get_radix_arg1_25946 = sub32(radixSizze_21074, 1);
    int64_t tmp_25947 = sext_i32_i64(get_radix_arg1_25946);
    bool bounds_invalid_upwards_25948 = slt32(get_radix_arg1_25946, 0);
    bool valid_25950 = !bounds_invalid_upwards_25948;
    bool range_valid_c_25951;
    
    if (!valid_25950) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_25947, " is invalid.", "-> #0  ftbasics.fut:113:17-26\n   #1  ftHashJoin.fut:313:63-86\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftHashJoin.fut:304:1-331:86\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_35303 = (int64_t) 8 * dzlz7bUZLztztZRz20U2z20Ursz7dUzg_25944;
    
    if (memblock_alloc(ctx, &mem_35257, bytes_35256, "mem_35257")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_35848 = 0; i_35848 < dz2080U_21068; i_35848++) {
        int64_t x_35849 = (int64_t) 0 + i_35848 * (int64_t) 1;
        
        ((int64_t *) mem_35257.mem)[i_35848] = x_35849;
    }
    
    int64_t distance_25949 = add64((int64_t) 1, tmp_25947);
    int32_t i64_res_28494 = sext_i64_i32(b_21067);
    
    if (mem_35259_cached_sizze_36075 < bytes_35256) {
        err = lexical_realloc(ctx, &mem_35259, &mem_35259_cached_sizze_36075, bytes_35256);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_35082 = 0; i_35082 < dz2080U_21068; i_35082++) {
        int64_t get_radix_arg3_28881 = ((int64_t *) bounds_mem_35254.mem)[i_35082];
        bool x_28882 = sle64((int64_t) 0, get_radix_arg3_28881);
        bool y_28883 = slt64(get_radix_arg3_28881, n_21066);
        bool bounds_check_28884 = x_28882 && y_28883;
        bool index_certs_28885;
        
        if (!bounds_check_28884) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) get_radix_arg3_28881, "] out of bounds for array of shape [", (long long) n_21066, "].", "-> #0  ftHashJoin.fut:313:63-86\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:304:1-331:86\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int8_t defunc_0_get_radix_res_28886;
        int8_t y_28888 = (int8_t) 0;
        
        for (int64_t i_28887 = 0; i_28887 < distance_25949; i_28887++) {
            int32_t binop_x_28889 = sext_i64_i32(i_28887);
            int32_t zm_rhs_28890 = sdiv32(binop_x_28889, 8);
            int32_t zm_lhs_28891 = sub32(i64_res_28494, zm_rhs_28890);
            int32_t whichByte_28892 = sub32(zm_lhs_28891, 1);
            int64_t whichByte_28894 = sext_i32_i64(whichByte_28892);
            bool x_28895 = sle64((int64_t) 0, whichByte_28894);
            bool y_28896 = slt64(whichByte_28894, b_21067);
            bool bounds_check_28897 = x_28895 && y_28896;
            bool index_certs_28898;
            
            if (!bounds_check_28897) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) whichByte_28894, "] out of bounds for array of shape [", (long long) b_21067, "].", "-> #0  ftHashJoin.fut:17:6-18\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:304:1-331:86\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int32_t whichBit_28893 = smod32(binop_x_28889, 8);
            int8_t zbzg_lhs_28899 = ((int8_t *) pXs_mem_35253.mem)[get_radix_arg3_28881 * b_21067 + whichByte_28894];
            int8_t unsign_arg0_28900 = zext_i32_i8(whichBit_28893);
            int8_t unsign_arg0_28901 = ashr8(zbzg_lhs_28899, unsign_arg0_28900);
            int8_t unsign_arg0_28902 = (int8_t) 1 & unsign_arg0_28901;
            int32_t to_i32_res_28903 = zext_i8_i32(unsign_arg0_28902);
            int8_t loopres_28904;
            
            if (futrts_set_bit_2464(ctx, &loopres_28904, binop_x_28889, y_28888, to_i32_res_28903) != 0) {
                err = 1;
                goto cleanup;
            }
            
            int8_t y_tmp_35851 = loopres_28904;
            
            y_28888 = y_tmp_35851;
        }
        defunc_0_get_radix_res_28886 = y_28888;
        
        int64_t u8_res_28906 = zext_i8_i64(defunc_0_get_radix_res_28886);
        
        ((int64_t *) mem_35259)[i_35082] = u8_res_28906;
    }
    
    bool cond_25976 = maxDepth_21073 == 1;
    
    if (cond_25976) {
        if (memblock_alloc(ctx, &mem_35280, dz2080U_21068, "mem_35280")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_35852 = 0; nest_i_35852 < dz2080U_21068; nest_i_35852++) {
            ((bool *) mem_35280.mem)[nest_i_35852] = 1;
        }
        if (memblock_set(ctx, &ext_mem_35286, &mem_35280, "mem_35280") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35283, &mem_35280, "mem_35280") != 0)
            return 1;
    } else {
        int64_t zeze_rhs_25980 = sub64(dz2080U_21068, (int64_t) 1);
        
        if (memblock_alloc(ctx, &mem_35266, dz2080U_21068, "mem_35266")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_35267, dz2080U_21068, "mem_35267")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_35088 = 0; i_35088 < dz2080U_21068; i_35088++) {
            int64_t cur_i_25988 = ((int64_t *) mem_35259)[i_35088];
            bool cond_25989 = i_35088 == (int64_t) 0;
            int64_t pre_i_25990;
            
            if (cond_25989) {
                pre_i_25990 = (int64_t) -1;
            } else {
                int64_t tmp_25991 = sub64(i_35088, (int64_t) 1);
                bool x_25992 = sle64((int64_t) 0, tmp_25991);
                bool y_25993 = slt64(tmp_25991, dz2080U_21068);
                bool bounds_check_25994 = x_25992 && y_25993;
                bool index_certs_25995;
                
                if (!bounds_check_25994) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_25991, "] out of bounds for array of shape [", (long long) dz2080U_21068, "].", "-> #0  ftHashJoin.fut:321:42-74\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:319:10-326:8\n   #3  ftHashJoin.fut:304:1-331:86\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t pre_i_f_res_25996 = ((int64_t *) mem_35259)[tmp_25991];
                
                pre_i_25990 = pre_i_f_res_25996;
            }
            
            bool is_first_25997 = cur_i_25988 == pre_i_25990;
            bool is_first_25998 = !is_first_25997;
            bool cond_25999 = i_35088 == zeze_rhs_25980;
            int64_t pos_i_26000;
            
            if (cond_25999) {
                pos_i_26000 = (int64_t) -1;
            } else {
                int64_t tmp_26001 = add64((int64_t) 1, i_35088);
                bool x_26002 = sle64((int64_t) 0, tmp_26001);
                bool y_26003 = slt64(tmp_26001, dz2080U_21068);
                bool bounds_check_26004 = x_26002 && y_26003;
                bool index_certs_26005;
                
                if (!bounds_check_26004) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_26001, "] out of bounds for array of shape [", (long long) dz2080U_21068, "].", "-> #0  ftHashJoin.fut:323:46-78\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:319:10-326:8\n   #3  ftHashJoin.fut:304:1-331:86\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t pos_i_f_res_26006 = ((int64_t *) mem_35259)[tmp_26001];
                
                pos_i_26000 = pos_i_f_res_26006;
            }
            
            bool is_last_26007 = cur_i_25988 == pos_i_26000;
            bool is_last_26008 = !is_last_26007;
            
            ((bool *) mem_35266.mem)[i_35088] = is_first_25998;
            ((bool *) mem_35267.mem)[i_35088] = is_last_26008;
        }
        if (memblock_set(ctx, &ext_mem_35286, &mem_35266, "mem_35266") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35283, &mem_35267, "mem_35267") != 0)
            return 1;
    }
    if (mem_35288_cached_sizze_36076 < bytes_35256) {
        err = lexical_realloc(ctx, &mem_35288, &mem_35288_cached_sizze_36076, bytes_35256);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_35290_cached_sizze_36077 < bytes_35256) {
        err = lexical_realloc(ctx, &mem_35290, &mem_35290_cached_sizze_36077, bytes_35256);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_35095 = 0; i_35095 < dz2080U_21068; i_35095++) {
        bool eta_p_28908 = ((bool *) ext_mem_35286.mem)[i_35095];
        bool eta_p_28910 = ((bool *) ext_mem_35283.mem)[i_35095];
        int64_t lifted_lambda_res_28912;
        
        if (eta_p_28908) {
            int64_t lifted_lambda_res_t_res_28945 = ((int64_t *) mem_35259)[i_35095];
            
            lifted_lambda_res_28912 = lifted_lambda_res_t_res_28945;
        } else {
            lifted_lambda_res_28912 = (int64_t) -1;
        }
        
        int64_t lifted_lambda_res_28919;
        
        if (eta_p_28910) {
            int64_t lifted_lambda_res_t_res_28950 = ((int64_t *) mem_35259)[i_35095];
            
            lifted_lambda_res_28919 = lifted_lambda_res_t_res_28950;
        } else {
            lifted_lambda_res_28919 = (int64_t) -1;
        }
        ((int64_t *) mem_35288)[i_35095] = lifted_lambda_res_28919;
        ((int64_t *) mem_35290)[i_35095] = lifted_lambda_res_28912;
    }
    if (memblock_unref(ctx, &ext_mem_35283, "ext_mem_35283") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_35286, "ext_mem_35286") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_35304, bytes_35303, "mem_35304")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_35857 = 0; nest_i_35857 < dzlz7bUZLztztZRz20U2z20Ursz7dUzg_25944; nest_i_35857++) {
        ((int64_t *) mem_35304.mem)[nest_i_35857] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_35306, bytes_35256, "mem_35306")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35306.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35290, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {dz2080U_21068});
    if (futrts_partitioned_scatter_8506(ctx, &ext_mem_35308, mem_35304, mem_35306, mem_35257, dzlz7bUZLztztZRz20U2z20Ursz7dUzg_25944, dz2080U_21068, scatter_psizze_21076) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref(ctx, &mem_35304, "mem_35304") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35306, "mem_35306") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_35310, bytes_35303, "mem_35310")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_35858 = 0; nest_i_35858 < dzlz7bUZLztztZRz20U2z20Ursz7dUzg_25944; nest_i_35858++) {
        ((int64_t *) mem_35310.mem)[nest_i_35858] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_35312, bytes_35256, "mem_35312")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35312.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35288, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {dz2080U_21068});
    if (futrts_partitioned_scatter_8506(ctx, &ext_mem_35314, mem_35310, mem_35312, mem_35257, dzlz7bUZLztztZRz20U2z20Ursz7dUzg_25944, dz2080U_21068, scatter_psizze_21076) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref(ctx, &mem_35257, "mem_35257") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35310, "mem_35310") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35312, "mem_35312") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35845, &ext_mem_35308, "ext_mem_35308") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35846, &ext_mem_35314, "ext_mem_35314") != 0)
        return 1;
    prim_out_35847 = dzlz7bUZLztztZRz20U2z20Ursz7dUzg_25944;
    if (memblock_set(ctx, &*mem_out_p_36072, &mem_out_35845, "mem_out_35845") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36073, &mem_out_35846, "mem_out_35846") != 0)
        return 1;
    *out_prim_out_36074 = prim_out_35847;
    
  cleanup:
    {
        free(mem_35259);
        free(mem_35288);
        free(mem_35290);
        if (memblock_unref(ctx, &ext_mem_35314, "ext_mem_35314") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35312, "mem_35312") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35310, "mem_35310") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35308, "ext_mem_35308") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35306, "mem_35306") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35304, "mem_35304") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35267, "mem_35267") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35266, "mem_35266") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35280, "mem_35280") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35283, "ext_mem_35283") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35286, "ext_mem_35286") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35257, "mem_35257") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35846, "mem_out_35846") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35845, "mem_out_35845") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_partition_and_deepen_GFTR(struct futhark_context *ctx, struct memblock *mem_out_p_36078, struct memblock *mem_out_p_36079, struct memblock xs_mem_35253, struct memblock pL_mem_35254, int64_t n_18088, int64_t b_18089, int64_t pL_b_18090, int16_t block_sizze_18091, int64_t gather_psizze_18092, int32_t radix_sizze_18093, int64_t sizze_thresh_18096, int32_t max_depth_18097)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_35300_cached_sizze_36080 = 0;
    unsigned char *mem_35300 = NULL;
    int64_t mem_35334_cached_sizze_36081 = 0;
    unsigned char *mem_35334 = NULL;
    int64_t mem_35336_cached_sizze_36082 = 0;
    unsigned char *mem_35336 = NULL;
    int64_t mem_35345_cached_sizze_36083 = 0;
    unsigned char *mem_35345 = NULL;
    int64_t mem_35346_cached_sizze_36084 = 0;
    unsigned char *mem_35346 = NULL;
    int64_t mem_35377_cached_sizze_36085 = 0;
    unsigned char *mem_35377 = NULL;
    int64_t mem_35379_cached_sizze_36086 = 0;
    unsigned char *mem_35379 = NULL;
    int64_t mem_35381_cached_sizze_36087 = 0;
    unsigned char *mem_35381 = NULL;
    int64_t mem_35383_cached_sizze_36088 = 0;
    unsigned char *mem_35383 = NULL;
    int64_t mem_35409_cached_sizze_36089 = 0;
    unsigned char *mem_35409 = NULL;
    int64_t mem_35411_cached_sizze_36090 = 0;
    unsigned char *mem_35411 = NULL;
    struct memblock mem_param_tmp_35852;
    
    mem_param_tmp_35852.references = NULL;
    
    struct memblock mem_param_tmp_35851;
    
    mem_param_tmp_35851.references = NULL;
    
    struct memblock mem_param_tmp_35850;
    
    mem_param_tmp_35850.references = NULL;
    
    struct memblock mem_param_tmp_35849;
    
    mem_param_tmp_35849.references = NULL;
    
    struct memblock mem_param_tmp_35863;
    
    mem_param_tmp_35863.references = NULL;
    
    struct memblock mem_param_tmp_35862;
    
    mem_param_tmp_35862.references = NULL;
    
    struct memblock mem_param_tmp_35861;
    
    mem_param_tmp_35861.references = NULL;
    
    struct memblock mem_param_tmp_35860;
    
    mem_param_tmp_35860.references = NULL;
    
    struct memblock mem_35447;
    
    mem_35447.references = NULL;
    
    struct memblock mem_35445;
    
    mem_35445.references = NULL;
    
    struct memblock mem_35427;
    
    mem_35427.references = NULL;
    
    struct memblock mem_35425;
    
    mem_35425.references = NULL;
    
    struct memblock ext_mem_35374;
    
    ext_mem_35374.references = NULL;
    
    struct memblock ext_mem_35375;
    
    ext_mem_35375.references = NULL;
    
    struct memblock mem_35372;
    
    mem_35372.references = NULL;
    
    struct memblock mem_param_tmp_35871;
    
    mem_param_tmp_35871.references = NULL;
    
    struct memblock mem_param_tmp_35870;
    
    mem_param_tmp_35870.references = NULL;
    
    struct memblock mem_35324;
    
    mem_35324.references = NULL;
    
    struct memblock mem_35322;
    
    mem_35322.references = NULL;
    
    struct memblock mem_param_tmp_35878;
    
    mem_param_tmp_35878.references = NULL;
    
    struct memblock mem_35311;
    
    mem_35311.references = NULL;
    
    struct memblock mem_param_35309;
    
    mem_param_35309.references = NULL;
    
    struct memblock ext_mem_35320;
    
    ext_mem_35320.references = NULL;
    
    struct memblock mem_param_35295;
    
    mem_param_35295.references = NULL;
    
    struct memblock mem_param_35291;
    
    mem_param_35291.references = NULL;
    
    struct memblock ext_mem_35369;
    
    ext_mem_35369.references = NULL;
    
    struct memblock ext_mem_35370;
    
    ext_mem_35370.references = NULL;
    
    struct memblock mem_35287;
    
    mem_35287.references = NULL;
    
    struct memblock mem_param_35285;
    
    mem_param_35285.references = NULL;
    
    struct memblock mem_param_35281;
    
    mem_param_35281.references = NULL;
    
    struct memblock mem_param_35277;
    
    mem_param_35277.references = NULL;
    
    struct memblock mem_param_35274;
    
    mem_param_35274.references = NULL;
    
    struct memblock ext_mem_35458;
    
    ext_mem_35458.references = NULL;
    
    struct memblock ext_mem_35459;
    
    ext_mem_35459.references = NULL;
    
    struct memblock ext_mem_35460;
    
    ext_mem_35460.references = NULL;
    
    struct memblock ext_mem_35461;
    
    ext_mem_35461.references = NULL;
    
    struct memblock mem_param_35271;
    
    mem_param_35271.references = NULL;
    
    struct memblock mem_param_35268;
    
    mem_param_35268.references = NULL;
    
    struct memblock mem_param_35265;
    
    mem_param_35265.references = NULL;
    
    struct memblock mem_param_35261;
    
    mem_param_35261.references = NULL;
    
    struct memblock ext_mem_35472;
    
    ext_mem_35472.references = NULL;
    
    struct memblock ext_mem_35473;
    
    ext_mem_35473.references = NULL;
    
    struct memblock ext_mem_35474;
    
    ext_mem_35474.references = NULL;
    
    struct memblock ext_mem_35475;
    
    ext_mem_35475.references = NULL;
    
    struct memblock mem_35257;
    
    mem_35257.references = NULL;
    
    struct memblock mem_35256;
    
    mem_35256.references = NULL;
    
    struct memblock mem_35255;
    
    mem_35255.references = NULL;
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    if (memblock_alloc(ctx, &mem_35255, (int64_t) 8, "mem_35255")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_35847 = 0; nest_i_35847 < (int64_t) 1; nest_i_35847++) {
        ((int64_t *) mem_35255.mem)[nest_i_35847] = (int64_t) 0;
    }
    if (memblock_alloc(ctx, &mem_35256, (int64_t) 8, "mem_35256")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_35848 = 0; nest_i_35848 < (int64_t) 1; nest_i_35848++) {
        ((int64_t *) mem_35256.mem)[nest_i_35848] = n_18088;
    }
    
    bool loop_cond_t_res_27439 = slt32(0, max_depth_18097);
    
    if (memblock_alloc(ctx, &mem_35257, (int64_t) 0, "mem_35257")) {
        err = 1;
        goto cleanup;
    }
    
    bool zzero_27507 = gather_psizze_18092 == (int64_t) 0;
    bool nonzzero_27508 = !zzero_27507;
    int32_t i64_res_28494 = sext_i64_i32(b_18089);
    int64_t bytes_35424 = n_18088 * b_18089;
    int64_t bytes_35426 = n_18088 * pL_b_18090;
    
    if (mem_35345_cached_sizze_36083 < b_18089) {
        err = lexical_realloc(ctx, &mem_35345, &mem_35345_cached_sizze_36083, b_18089);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_35346_cached_sizze_36084 < pL_b_18090) {
        err = lexical_realloc(ctx, &mem_35346, &mem_35346_cached_sizze_36084, pL_b_18090);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t partition_and_deepen_res_27441;
    bool partition_and_deepen_res_27442;
    int32_t partition_and_deepen_res_27443;
    int64_t loop_dz2087U_27448;
    bool loop_while_27449;
    int32_t p_27450;
    
    if (memblock_set(ctx, &mem_param_35261, &pL_mem_35254, "pL_mem_35254") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_35265, &xs_mem_35253, "xs_mem_35253") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_35268, &mem_35255, "mem_35255") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_35271, &mem_35256, "mem_35256") != 0)
        return 1;
    loop_dz2087U_27448 = (int64_t) 1;
    loop_while_27449 = loop_cond_t_res_27439;
    p_27450 = 0;
    while (loop_while_27449) {
        bool loop_nonempty_27712 = slt64((int64_t) 0, loop_dz2087U_27448);
        int32_t newDepth_27486 = add32(1, p_27450);
        int32_t new_i_27487 = mul32(radix_sizze_18093, p_27450);
        int32_t zm_lhs_27488 = mul32(radix_sizze_18093, newDepth_27486);
        int32_t new_j_27489 = sub32(zm_lhs_27488, 1);
        int32_t tmp_27490 = add32(2, new_i_27487);
        int64_t i_27491 = sext_i32_i64(new_i_27487);
        int64_t j_27492 = sext_i32_i64(new_j_27489);
        int64_t tmp_27493 = sext_i32_i64(tmp_27490);
        bool step_zzero_27494 = new_i_27487 == tmp_27490;
        bool bounds_invalid_upwards_27495 = slt32(new_j_27489, new_i_27487);
        int32_t distance_upwards_exclusive_27496 = sub32(new_j_27489, new_i_27487);
        int64_t distance_exclusive_27497 = sext_i32_i64(distance_upwards_exclusive_27496);
        int64_t distance_27498 = add64((int64_t) 1, distance_exclusive_27497);
        bool range_invalid_27499 = step_zzero_27494 || bounds_invalid_upwards_27495;
        bool valid_27500 = !range_invalid_27499;
        bool loop_not_taken_27713 = !loop_nonempty_27712;
        bool protect_assert_disj_27714 = valid_27500 || loop_not_taken_27713;
        bool range_valid_c_27501;
        
        if (!protect_assert_disj_27714) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) i_27491, "..", (long long) tmp_27493, "...", (long long) j_27492, " is invalid.", "-> #0  ftHashJoin.fut:133:15-34\n   #1  ftHashJoin.fut:180:20-186:6\n   #2  ftHashJoin.fut:245:5-88\n   #3  ftHashJoin.fut:235:1-246:30\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t num_elems_27502 = sdiv_up64(distance_27498, (int64_t) 2);
        bool loop_nonempty_27503 = slt64((int64_t) 0, num_elems_27502);
        bool loop_not_taken_27509 = !loop_nonempty_27503;
        bool protect_assert_disj_27510 = nonzzero_27508 || loop_not_taken_27509;
        bool protect_assert_disj_27716 = protect_assert_disj_27510 || loop_not_taken_27713;
        bool nonzzero_cert_27511;
        
        if (!protect_assert_disj_27716) {
            set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftHashJoin.fut:121:87-90\n   #2  ftHashJoin.fut:134:6-70\n   #3  ftHashJoin.fut:180:20-186:6\n   #4  ftHashJoin.fut:245:5-88\n   #5  ftHashJoin.fut:235:1-246:30\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t loopres_27455;
        int64_t loop_dz2081Uz2089U_27461;
        
        if (memblock_set(ctx, &mem_param_35274, &mem_35257, "mem_35257") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35277, &mem_35257, "mem_35257") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35281, &mem_param_35261, "mem_param_35261") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35285, &mem_param_35265, "mem_param_35265") != 0)
            return 1;
        loop_dz2081Uz2089U_27461 = (int64_t) 0;
        for (int64_t i_27460 = 0; i_27460 < loop_dz2087U_27448; i_27460++) {
            int64_t bounds_27466 = ((int64_t *) mem_param_35268.mem)[i_27460];
            int64_t bounds_27467 = ((int64_t *) mem_param_35271.mem)[i_27460];
            int64_t dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468 = sub64(bounds_27467, bounds_27466);
            bool empty_slice_27469 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468 == (int64_t) 0;
            int64_t m_27470 = sub64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468, (int64_t) 1);
            int64_t i_p_m_t_s_27471 = add64(bounds_27466, m_27470);
            bool zzero_leq_i_p_m_t_s_27472 = sle64((int64_t) 0, i_p_m_t_s_27471);
            bool i_p_m_t_s_leq_w_27473 = slt64(i_p_m_t_s_27471, n_18088);
            bool zzero_lte_i_27474 = sle64((int64_t) 0, bounds_27466);
            bool i_lte_j_27475 = sle64(bounds_27466, bounds_27467);
            bool y_27476 = i_p_m_t_s_leq_w_27473 && zzero_lte_i_27474;
            bool y_27477 = zzero_leq_i_p_m_t_s_27472 && y_27476;
            bool forwards_ok_27478 = i_lte_j_27475 && y_27477;
            bool ok_or_empty_27479 = empty_slice_27469 || forwards_ok_27478;
            bool index_certs_27480;
            
            if (!ok_or_empty_27479) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) bounds_27466, ":", (long long) bounds_27467, "] out of bounds for array of shape [", (long long) n_18088, "].", "-> #0  ftHashJoin.fut:213:21-47\n   #1  ftHashJoin.fut:245:5-88\n   #2  ftHashJoin.fut:235:1-246:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_35286 = (int64_t) 8 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468;
            
            if (memblock_alloc(ctx, &mem_35287, bytes_35286, "mem_35287")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t nest_i_35869 = 0; nest_i_35869 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468; nest_i_35869++) {
                ((int64_t *) mem_35287.mem)[nest_i_35869] = (int64_t) 0;
            }
            
            int64_t zm_lhs_27505 = add64(gather_psizze_18092, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468);
            int64_t zs_lhs_27506 = sub64(zm_lhs_27505, (int64_t) 1);
            int64_t m_27512 = sdiv_safe64(zs_lhs_27506, gather_psizze_18092);
            bool loop_cond_27513 = slt64((int64_t) 0, m_27512);
            int64_t binop_y_35296 = b_18089 * bounds_27466;
            int64_t binop_y_35298 = pL_b_18090 * bounds_27466;
            int64_t bytes_35321 = b_18089 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468;
            int64_t bytes_35323 = pL_b_18090 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468;
            
            if (mem_35300_cached_sizze_36080 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468) {
                err = lexical_realloc(ctx, &mem_35300, &mem_35300_cached_sizze_36080, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t ext_35368;
            int64_t ext_35365;
            int64_t ctx_param_ext_35288;
            int64_t ctx_param_ext_35292;
            
            if (memblock_set(ctx, &mem_param_35291, &mem_param_35285, "mem_param_35285") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35295, &mem_param_35281, "mem_param_35281") != 0)
                return 1;
            ctx_param_ext_35288 = binop_y_35296;
            ctx_param_ext_35292 = binop_y_35298;
            for (int64_t i_27516 = 0; i_27516 < num_elems_27502; i_27516++) {
                int32_t binop_x_27519 = sext_i64_i32(i_27516);
                int32_t binop_x_27520 = mul32(2, binop_x_27519);
                int32_t index_primexp_27521 = add32(new_i_27487, binop_x_27520);
                int32_t zm_lhs_27522 = add32(2, index_primexp_27521);
                int32_t min_arg1_27523 = sub32(zm_lhs_27522, 1);
                int32_t min_res_27524 = smin32(new_j_27489, min_arg1_27523);
                int32_t zp_lhs_27525 = sub32(min_res_27524, index_primexp_27521);
                int32_t ij_bits_27526 = add32(1, zp_lhs_27525);
                int32_t up_to_27527 = shl32(1, ij_bits_27526);
                int64_t tmp_27528 = sext_i32_i64(zp_lhs_27525);
                bool bounds_invalid_upwards_27529 = slt32(zp_lhs_27525, 0);
                bool valid_27531 = !bounds_invalid_upwards_27529;
                bool range_valid_c_27532;
                
                if (!valid_27531) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_27528, " is invalid.", "-> #0  ftbasics.fut:113:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:121:87-90\n   #3  ftHashJoin.fut:134:6-70\n   #4  ftHashJoin.fut:180:20-186:6\n   #5  ftHashJoin.fut:245:5-88\n   #6  ftHashJoin.fut:235:1-246:30\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t up_to_27542 = sext_i32_i64(up_to_27527);
                bool bounds_invalid_upwards_27543 = slt32(up_to_27527, 0);
                bool valid_27544 = !bounds_invalid_upwards_27543;
                bool range_valid_c_27545;
                
                if (!valid_27544) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_27542, " is invalid.", "-> #0  ftbasics.fut:137:21-30\n   #1  ftHashJoin.fut:121:87-90\n   #2  ftHashJoin.fut:134:6-70\n   #3  ftHashJoin.fut:180:20-186:6\n   #4  ftHashJoin.fut:245:5-88\n   #5  ftHashJoin.fut:235:1-246:30\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t distance_27530 = add64((int64_t) 1, tmp_27528);
                
                for (int64_t i_35082 = 0; i_35082 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468; i_35082++) {
                    int8_t defunc_0_f_res_27535;
                    int8_t y_27537 = (int8_t) 0;
                    
                    for (int64_t i_27536 = 0; i_27536 < distance_27530; i_27536++) {
                        int32_t binop_x_27538 = sext_i64_i32(i_27536);
                        int32_t get_bit_arg0_27539 = add32(index_primexp_27521, binop_x_27538);
                        int32_t zm_rhs_28495 = sdiv32(get_bit_arg0_27539, 8);
                        int32_t zm_lhs_28496 = sub32(i64_res_28494, zm_rhs_28495);
                        int32_t whichByte_28497 = sub32(zm_lhs_28496, 1);
                        int64_t whichByte_28499 = sext_i32_i64(whichByte_28497);
                        bool x_28500 = sle64((int64_t) 0, whichByte_28499);
                        bool y_28501 = slt64(whichByte_28499, b_18089);
                        bool bounds_check_28502 = x_28500 && y_28501;
                        bool index_certs_28503;
                        
                        if (!bounds_check_28502) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) whichByte_28499, "] out of bounds for array of shape [", (long long) b_18089, "].", "-> #0  ftHashJoin.fut:17:6-18\n   #1  ftHashJoin.fut:245:5-88\n   #2  ftHashJoin.fut:235:1-246:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t whichBit_28498 = smod32(get_bit_arg0_27539, 8);
                        int8_t zbzg_lhs_28504 = ((int8_t *) mem_param_35291.mem)[ctx_param_ext_35288 + (i_35082 * b_18089 + whichByte_28499)];
                        int8_t unsign_arg0_28505 = zext_i32_i8(whichBit_28498);
                        int8_t unsign_arg0_28506 = ashr8(zbzg_lhs_28504, unsign_arg0_28505);
                        int8_t unsign_arg0_28507 = (int8_t) 1 & unsign_arg0_28506;
                        int32_t to_i32_res_28508 = zext_i8_i32(unsign_arg0_28507);
                        int8_t loopres_27541;
                        
                        if (futrts_set_bit_2464(ctx, &loopres_27541, binop_x_27538, y_27537, to_i32_res_28508) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        int8_t y_tmp_35877 = loopres_27541;
                        
                        y_27537 = y_tmp_35877;
                    }
                    defunc_0_f_res_27535 = y_27537;
                    ((int8_t *) mem_35300)[i_35082] = defunc_0_f_res_27535;
                }
                
                int64_t defunc_0_radix_sort_multistep_res_27546;
                int64_t offs_27549;
                
                if (memblock_set(ctx, &mem_param_35309, &mem_35287, "mem_35287") != 0)
                    return 1;
                offs_27549 = (int64_t) 0;
                for (int64_t i_27548 = 0; i_27548 < up_to_27542; i_27548++) {
                    int32_t binop_x_27551 = sext_i64_i32(i_27548);
                    int8_t index_primexp_27552 = zext_i32_i8(binop_x_27551);
                    
                    if (memblock_alloc(ctx, &mem_35311, bytes_35286, "mem_35311")) {
                        err = 1;
                        goto cleanup;
                    }
                    
                    int64_t inpacc_29288;
                    int64_t defunc_0_reduce_res_29289;
                    int64_t inpacc_29109;
                    int64_t inpacc_29110;
                    
                    inpacc_29109 = (int64_t) 0;
                    inpacc_29110 = (int64_t) 0;
                    for (int64_t i_35100 = 0; i_35100 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468; i_35100++) {
                        int8_t eta_p_35231 = ((int8_t *) mem_35300)[i_35100];
                        bool lifted_lambda_res_35232 = eta_p_35231 == index_primexp_27552;
                        int64_t bool_res_35233 = btoi_bool_i64(lifted_lambda_res_35232);
                        int64_t eta_p_35246 = ((int64_t *) mem_param_35309.mem)[i_35100];
                        int64_t defunc_0_op_res_35247 = add64(inpacc_29109, bool_res_35233);
                        int64_t zm_lhs_35248 = add64(offs_27549, defunc_0_op_res_35247);
                        int64_t lifted_lambda_res_35249 = sub64(zm_lhs_35248, (int64_t) 1);
                        int64_t defunc_0_f_res_35250 = mul64(bool_res_35233, lifted_lambda_res_35249);
                        int64_t defunc_0_f_res_35251 = add64(eta_p_35246, defunc_0_f_res_35250);
                        int64_t defunc_0_op_res_29158 = add64(inpacc_29110, bool_res_35233);
                        
                        ((int64_t *) mem_35311.mem)[i_35100] = defunc_0_f_res_35251;
                        
                        int64_t inpacc_tmp_35881 = defunc_0_op_res_35247;
                        int64_t inpacc_tmp_35882 = defunc_0_op_res_29158;
                        
                        inpacc_29109 = inpacc_tmp_35881;
                        inpacc_29110 = inpacc_tmp_35882;
                    }
                    inpacc_29288 = inpacc_29109;
                    defunc_0_reduce_res_29289 = inpacc_29110;
                    
                    int64_t tmp_27577 = add64(offs_27549, defunc_0_reduce_res_29289);
                    
                    if (memblock_set(ctx, &mem_param_tmp_35878, &mem_35311, "mem_35311") != 0)
                        return 1;
                    
                    int64_t offs_tmp_35879 = tmp_27577;
                    
                    if (memblock_set(ctx, &mem_param_35309, &mem_param_tmp_35878, "mem_param_tmp_35878") != 0)
                        return 1;
                    offs_27549 = offs_tmp_35879;
                }
                if (memblock_set(ctx, &ext_mem_35320, &mem_param_35309, "mem_param_35309") != 0)
                    return 1;
                defunc_0_radix_sort_multistep_res_27546 = offs_27549;
                if (memblock_alloc(ctx, &mem_35322, bytes_35321, "mem_35322")) {
                    err = 1;
                    goto cleanup;
                }
                lmad_copy_1b(ctx, 2, (uint8_t *) mem_35322.mem, (int64_t) 0, (int64_t []) {b_18089, (int64_t) 1}, (uint8_t *) mem_param_35291.mem, ctx_param_ext_35288, (int64_t []) {b_18089, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468, b_18089});
                if (memblock_alloc(ctx, &mem_35324, bytes_35323, "mem_35324")) {
                    err = 1;
                    goto cleanup;
                }
                lmad_copy_1b(ctx, 2, (uint8_t *) mem_35324.mem, (int64_t) 0, (int64_t []) {pL_b_18090, (int64_t) 1}, (uint8_t *) mem_param_35295.mem, ctx_param_ext_35292, (int64_t []) {pL_b_18090, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468, pL_b_18090});
                
                bool partitioned_scatter_res_27584;
                int64_t partitioned_scatter_res_27587;
                bool loop_while_27588;
                int64_t p_27591;
                
                loop_while_27588 = loop_cond_27513;
                p_27591 = (int64_t) 0;
                while (loop_while_27588) {
                    int64_t lower_bound_27592 = mul64(gather_psizze_18092, p_27591);
                    int64_t min_arg1_27593 = add64(gather_psizze_18092, lower_bound_27592);
                    int64_t min_res_27594 = smin64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468, min_arg1_27593);
                    int64_t j_m_i_27595 = sub64(min_res_27594, lower_bound_27592);
                    bool empty_slice_27596 = j_m_i_27595 == (int64_t) 0;
                    int64_t m_27597 = sub64(j_m_i_27595, (int64_t) 1);
                    int64_t i_p_m_t_s_27598 = add64(lower_bound_27592, m_27597);
                    bool zzero_leq_i_p_m_t_s_27599 = sle64((int64_t) 0, i_p_m_t_s_27598);
                    bool i_p_m_t_s_leq_w_27600 = slt64(i_p_m_t_s_27598, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468);
                    bool zzero_lte_i_27601 = sle64((int64_t) 0, lower_bound_27592);
                    bool i_lte_j_27602 = sle64(lower_bound_27592, min_res_27594);
                    bool y_27603 = i_p_m_t_s_leq_w_27600 && zzero_lte_i_27601;
                    bool y_27604 = zzero_leq_i_p_m_t_s_27599 && y_27603;
                    bool forwards_ok_27605 = i_lte_j_27602 && y_27604;
                    bool ok_or_empty_27606 = empty_slice_27596 || forwards_ok_27605;
                    bool index_certs_27607;
                    
                    if (!ok_or_empty_27606) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_27592, ":", (long long) min_res_27594, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftHashJoin.fut:121:87-90\n   #2  ftHashJoin.fut:134:6-70\n   #3  ftHashJoin.fut:180:20-186:6\n   #4  ftHashJoin.fut:245:5-88\n   #5  ftHashJoin.fut:235:1-246:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t bytes_35333 = b_18089 * j_m_i_27595;
                    int64_t bytes_35335 = pL_b_18090 * j_m_i_27595;
                    
                    if (mem_35334_cached_sizze_36081 < bytes_35333) {
                        err = lexical_realloc(ctx, &mem_35334, &mem_35334_cached_sizze_36081, bytes_35333);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_35334, (int64_t) 0, (int64_t []) {b_18089, (int64_t) 1}, (uint8_t *) mem_35322.mem, (int64_t) 0 + b_18089 * lower_bound_27592, (int64_t []) {b_18089, (int64_t) 1}, (int64_t []) {j_m_i_27595, b_18089});
                    if (mem_35336_cached_sizze_36082 < bytes_35335) {
                        err = lexical_realloc(ctx, &mem_35336, &mem_35336_cached_sizze_36082, bytes_35335);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_35336, (int64_t) 0, (int64_t []) {pL_b_18090, (int64_t) 1}, (uint8_t *) mem_35324.mem, (int64_t) 0 + pL_b_18090 * lower_bound_27592, (int64_t []) {pL_b_18090, (int64_t) 1}, (int64_t []) {j_m_i_27595, pL_b_18090});
                    for (int64_t write_iter_35102 = 0; write_iter_35102 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468; write_iter_35102++) {
                        int64_t write_iv_35105 = ((int64_t *) ext_mem_35320.mem)[write_iter_35102];
                        
                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_35345, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_35291.mem, ctx_param_ext_35288 + write_iter_35102 * b_18089, (int64_t []) {(int64_t) 1}, (int64_t []) {b_18089});
                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_35346, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_35295.mem, ctx_param_ext_35292 + write_iter_35102 * pL_b_18090, (int64_t []) {(int64_t) 1}, (int64_t []) {pL_b_18090});
                        
                        bool cond_29201 = sle64(lower_bound_27592, write_iv_35105);
                        bool cond_t_res_29202 = slt64(write_iv_35105, min_res_27594);
                        bool x_29203 = cond_29201 && cond_t_res_29202;
                        int64_t lifted_lambda_res_29204;
                        
                        if (x_29203) {
                            int64_t lifted_lambda_res_t_res_29291 = sub64(write_iv_35105, lower_bound_27592);
                            
                            lifted_lambda_res_29204 = lifted_lambda_res_t_res_29291;
                        } else {
                            lifted_lambda_res_29204 = (int64_t) -1;
                        }
                        if ((sle64((int64_t) 0, lifted_lambda_res_29204) && slt64(lifted_lambda_res_29204, j_m_i_27595)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(b_18089 - (int64_t) 1, b_18089))) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_35334, lifted_lambda_res_29204 * b_18089, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_35345, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_18089});
                        }
                        if ((sle64((int64_t) 0, lifted_lambda_res_29204) && slt64(lifted_lambda_res_29204, j_m_i_27595)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(pL_b_18090 - (int64_t) 1, pL_b_18090))) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_35336, lifted_lambda_res_29204 * pL_b_18090, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_35346, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {pL_b_18090});
                        }
                    }
                    
                    int64_t tmp_27619 = add64((int64_t) 1, p_27591);
                    
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_35322.mem, b_18089 * lower_bound_27592, (int64_t []) {b_18089, (int64_t) 1}, (uint8_t *) mem_35334, (int64_t) 0, (int64_t []) {b_18089, (int64_t) 1}, (int64_t []) {j_m_i_27595, b_18089});
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_35324.mem, pL_b_18090 * lower_bound_27592, (int64_t []) {pL_b_18090, (int64_t) 1}, (uint8_t *) mem_35336, (int64_t) 0, (int64_t []) {pL_b_18090, (int64_t) 1}, (int64_t []) {j_m_i_27595, pL_b_18090});
                    
                    bool loop_cond_27627 = slt64(tmp_27619, m_27512);
                    bool loop_while_tmp_35884 = loop_cond_27627;
                    int64_t p_tmp_35887 = tmp_27619;
                    
                    loop_while_27588 = loop_while_tmp_35884;
                    p_27591 = p_tmp_35887;
                }
                partitioned_scatter_res_27584 = loop_while_27588;
                partitioned_scatter_res_27587 = p_27591;
                if (memblock_unref(ctx, &ext_mem_35320, "ext_mem_35320") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_tmp_35870, &mem_35322, "mem_35322") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_tmp_35871, &mem_35324, "mem_35324") != 0)
                    return 1;
                
                int64_t ctx_param_ext_tmp_35872 = (int64_t) 0;
                int64_t ctx_param_ext_tmp_35873 = (int64_t) 0;
                
                if (memblock_set(ctx, &mem_param_35291, &mem_param_tmp_35870, "mem_param_tmp_35870") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_35295, &mem_param_tmp_35871, "mem_param_tmp_35871") != 0)
                    return 1;
                ctx_param_ext_35288 = ctx_param_ext_tmp_35872;
                ctx_param_ext_35292 = ctx_param_ext_tmp_35873;
            }
            if (memblock_set(ctx, &ext_mem_35370, &mem_param_35291, "mem_param_35291") != 0)
                return 1;
            if (memblock_set(ctx, &ext_mem_35369, &mem_param_35295, "mem_param_35295") != 0)
                return 1;
            ext_35368 = ctx_param_ext_35288;
            ext_35365 = ctx_param_ext_35292;
            if (memblock_unref(ctx, &mem_35287, "mem_35287") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_35372, bytes_35321, "mem_35372")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35372.mem, (int64_t) 0, (int64_t []) {b_18089, (int64_t) 1}, (uint8_t *) ext_mem_35370.mem, ext_35368, (int64_t []) {b_18089, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468, b_18089});
            
            int64_t deepen_step_res_27628;
            int64_t deepen_step_res_27629;
            int32_t deepen_step_res_27632;
            int32_t deepen_step_res_27633;
            int32_t deepen_step_res_27634;
            
            if (futrts_getPartitionBounds_8373(ctx, &ext_mem_35375, &ext_mem_35374, &deepen_step_res_27628, &deepen_step_res_27629, &deepen_step_res_27632, &deepen_step_res_27633, &deepen_step_res_27634, mem_35372, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468, b_18089, newDepth_27486, new_i_27487, new_j_27489) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref(ctx, &mem_35372, "mem_35372") != 0)
                return 1;
            
            int64_t zl_rhs_27726 = sub64(deepen_step_res_27628, (int64_t) 1);
            int64_t bytes_35376 = (int64_t) 8 * deepen_step_res_27628;
            
            if (mem_35377_cached_sizze_36085 < bytes_35376) {
                err = lexical_realloc(ctx, &mem_35377, &mem_35377_cached_sizze_36085, bytes_35376);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_35379_cached_sizze_36086 < bytes_35376) {
                err = lexical_realloc(ctx, &mem_35379, &mem_35379_cached_sizze_36086, bytes_35376);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_35381_cached_sizze_36087 < bytes_35376) {
                err = lexical_realloc(ctx, &mem_35381, &mem_35381_cached_sizze_36087, bytes_35376);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_35383_cached_sizze_36088 < bytes_35376) {
                err = lexical_realloc(ctx, &mem_35383, &mem_35383_cached_sizze_36088, bytes_35376);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t discard_35124;
            int64_t scanacc_35114 = (int64_t) 0;
            
            for (int64_t i_35119 = 0; i_35119 < deepen_step_res_27628; i_35119++) {
                int64_t tmp_28898 = ((int64_t *) ext_mem_35375.mem)[i_35119];
                bool cond_28899 = slt64(i_35119, zl_rhs_27726);
                int64_t tmp_28900;
                
                if (cond_28899) {
                    int64_t tmp_29295 = add64((int64_t) 1, i_35119);
                    bool x_29296 = sle64((int64_t) 0, tmp_29295);
                    bool y_29297 = slt64(tmp_29295, deepen_step_res_27628);
                    bool bounds_check_29298 = x_29296 && y_29297;
                    bool index_certs_29299;
                    
                    if (!bounds_check_29298) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_29295, "] out of bounds for array of shape [", (long long) deepen_step_res_27628, "].", "-> #0  ftHashJoin.fut:190:67-81\n   #1  ftHashJoin.fut:245:5-88\n   #2  ftHashJoin.fut:235:1-246:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t tmp_t_res_29300 = ((int64_t *) ext_mem_35375.mem)[tmp_29295];
                    
                    tmp_28900 = tmp_t_res_29300;
                } else {
                    tmp_28900 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468;
                }
                
                int64_t zg_lhs_28909 = sub64(tmp_28900, tmp_28898);
                bool lifted_lambda_res_28910 = slt64(sizze_thresh_18096, zg_lhs_28909);
                int64_t defunc_0_f_res_28911 = btoi_bool_i64(lifted_lambda_res_28910);
                int64_t defunc_0_op_res_27651 = add64(defunc_0_f_res_28911, scanacc_35114);
                
                ((int64_t *) mem_35377)[i_35119] = defunc_0_op_res_27651;
                ((int64_t *) mem_35379)[i_35119] = defunc_0_f_res_28911;
                ((int64_t *) mem_35381)[i_35119] = tmp_28898;
                ((int64_t *) mem_35383)[i_35119] = tmp_28900;
                
                int64_t scanacc_tmp_35890 = defunc_0_op_res_27651;
                
                scanacc_35114 = scanacc_tmp_35890;
            }
            discard_35124 = scanacc_35114;
            if (memblock_unref(ctx, &ext_mem_35375, "ext_mem_35375") != 0)
                return 1;
            
            bool cond_27652 = deepen_step_res_27628 == (int64_t) 0;
            bool x_27653 = !cond_27652;
            bool x_27655 = sle64((int64_t) 0, zl_rhs_27726);
            bool y_27656 = slt64(zl_rhs_27726, deepen_step_res_27628);
            bool bounds_check_27657 = x_27655 && y_27656;
            bool protect_assert_disj_27658 = cond_27652 || bounds_check_27657;
            bool index_certs_27659;
            
            if (!protect_assert_disj_27658) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zl_rhs_27726, "] out of bounds for array of shape [", (long long) deepen_step_res_27628, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:191:8-49\n   #3  ftHashJoin.fut:245:5-88\n   #4  ftHashJoin.fut:235:1-246:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_f_res_27660;
            
            if (x_27653) {
                int64_t x_29301 = ((int64_t *) mem_35377)[zl_rhs_27726];
                
                m_f_res_27660 = x_29301;
            } else {
                m_f_res_27660 = (int64_t) 0;
            }
            
            int64_t m_27662;
            
            if (cond_27652) {
                m_27662 = (int64_t) 0;
            } else {
                m_27662 = m_f_res_27660;
            }
            
            int64_t m_27672 = sub64(m_27662, (int64_t) 1);
            bool i_p_m_t_s_leq_w_27674 = slt64(m_27672, deepen_step_res_27628);
            bool zzero_leq_i_p_m_t_s_27673 = sle64((int64_t) 0, m_27672);
            bool y_27676 = zzero_leq_i_p_m_t_s_27673 && i_p_m_t_s_leq_w_27674;
            bool i_lte_j_27675 = sle64((int64_t) 0, m_27662);
            bool forwards_ok_27677 = i_lte_j_27675 && y_27676;
            bool eq_x_zz_27669 = (int64_t) 0 == m_f_res_27660;
            bool p_and_eq_x_y_27670 = x_27653 && eq_x_zz_27669;
            bool empty_slice_27671 = cond_27652 || p_and_eq_x_y_27670;
            bool ok_or_empty_27678 = empty_slice_27671 || forwards_ok_27677;
            bool index_certs_27679;
            
            if (!ok_or_empty_27678) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_27662, "] out of bounds for array of shape [", (long long) deepen_step_res_27628, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:191:8-49\n   #3  ftHashJoin.fut:245:5-88\n   #4  ftHashJoin.fut:235:1-246:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_35408 = (int64_t) 8 * m_27662;
            int64_t conc_tmp_27701 = loop_dz2081Uz2089U_27461 + m_27662;
            int64_t bytes_35444 = (int64_t) 8 * conc_tmp_27701;
            
            if (mem_35409_cached_sizze_36089 < bytes_35408) {
                err = lexical_realloc(ctx, &mem_35409, &mem_35409_cached_sizze_36089, bytes_35408);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35409, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35383, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_27662});
            if (mem_35411_cached_sizze_36090 < bytes_35408) {
                err = lexical_realloc(ctx, &mem_35411, &mem_35411_cached_sizze_36090, bytes_35408);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35411, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35381, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_27662});
            for (int64_t write_iter_35125 = 0; write_iter_35125 < deepen_step_res_27628; write_iter_35125++) {
                int64_t write_iv_35128 = ((int64_t *) mem_35379)[write_iter_35125];
                int64_t write_iv_35129 = ((int64_t *) mem_35377)[write_iter_35125];
                int64_t write_iv_35130 = ((int64_t *) mem_35381)[write_iter_35125];
                int64_t write_iv_35131 = ((int64_t *) mem_35383)[write_iter_35125];
                bool cond_28880 = write_iv_35128 == (int64_t) 1;
                int64_t lifted_lambda_res_28881;
                
                if (cond_28880) {
                    int64_t lifted_lambda_res_t_res_29302 = sub64(write_iv_35129, (int64_t) 1);
                    
                    lifted_lambda_res_28881 = lifted_lambda_res_t_res_29302;
                } else {
                    lifted_lambda_res_28881 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_28881) && slt64(lifted_lambda_res_28881, m_27662)) {
                    ((int64_t *) mem_35411)[lifted_lambda_res_28881] = write_iv_35130;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_28881) && slt64(lifted_lambda_res_28881, m_27662)) {
                    ((int64_t *) mem_35409)[lifted_lambda_res_28881] = write_iv_35131;
                }
            }
            if (memblock_alloc(ctx, &mem_35425, bytes_35424, "mem_35425")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35425.mem, (int64_t) 0, (int64_t []) {b_18089, (int64_t) 1}, (uint8_t *) mem_param_35285.mem, (int64_t) 0, (int64_t []) {b_18089, (int64_t) 1}, (int64_t []) {n_18088, b_18089});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35425.mem, b_18089 * bounds_27466, (int64_t []) {b_18089, (int64_t) 1}, (uint8_t *) ext_mem_35370.mem, ext_35368, (int64_t []) {b_18089, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468, b_18089});
            if (memblock_unref(ctx, &ext_mem_35370, "ext_mem_35370") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_35427, bytes_35426, "mem_35427")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35427.mem, (int64_t) 0, (int64_t []) {pL_b_18090, (int64_t) 1}, (uint8_t *) mem_param_35281.mem, (int64_t) 0, (int64_t []) {pL_b_18090, (int64_t) 1}, (int64_t []) {n_18088, pL_b_18090});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35427.mem, pL_b_18090 * bounds_27466, (int64_t []) {pL_b_18090, (int64_t) 1}, (uint8_t *) ext_mem_35369.mem, ext_35365, (int64_t []) {pL_b_18090, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27468, pL_b_18090});
            if (memblock_unref(ctx, &ext_mem_35369, "ext_mem_35369") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_35445, bytes_35444, "mem_35445")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_35447, bytes_35444, "mem_35447")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t i_35138 = 0; i_35138 < m_27662; i_35138++) {
                int64_t eta_p_27697 = ((int64_t *) mem_35411)[i_35138];
                int64_t eta_p_27698 = ((int64_t *) mem_35409)[i_35138];
                int64_t tmp_27699 = add64(bounds_27466, eta_p_27697);
                int64_t tmp_27700 = add64(bounds_27466, eta_p_27698);
                
                ((int64_t *) mem_35445.mem)[loop_dz2081Uz2089U_27461 + i_35138] = tmp_27699;
                ((int64_t *) mem_35447.mem)[loop_dz2081Uz2089U_27461 + i_35138] = tmp_27700;
            }
            
            int64_t tmp_offs_35899 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35445.mem, tmp_offs_35899, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35274.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2089U_27461});
            tmp_offs_35899 += loop_dz2081Uz2089U_27461;
            if (!(tmp_offs_35899 == loop_dz2081Uz2089U_27461)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_35445.mem, tmp_offs_35899, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35445.mem, loop_dz2081Uz2089U_27461, (int64_t []) {(int64_t) 1}, (int64_t []) {m_27662});
            }
            tmp_offs_35899 += m_27662;
            
            int64_t tmp_offs_35900 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35447.mem, tmp_offs_35900, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35277.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2089U_27461});
            tmp_offs_35900 += loop_dz2081Uz2089U_27461;
            if (!(tmp_offs_35900 == loop_dz2081Uz2089U_27461)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_35447.mem, tmp_offs_35900, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35447.mem, loop_dz2081Uz2089U_27461, (int64_t []) {(int64_t) 1}, (int64_t []) {m_27662});
            }
            tmp_offs_35900 += m_27662;
            if (memblock_set(ctx, &mem_param_tmp_35860, &mem_35445, "mem_35445") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35861, &mem_35447, "mem_35447") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35862, &mem_35427, "mem_35427") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35863, &mem_35425, "mem_35425") != 0)
                return 1;
            
            int64_t loop_dz2081Uz2089U_tmp_35864 = conc_tmp_27701;
            
            if (memblock_set(ctx, &mem_param_35274, &mem_param_tmp_35860, "mem_param_tmp_35860") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35277, &mem_param_tmp_35861, "mem_param_tmp_35861") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35281, &mem_param_tmp_35862, "mem_param_tmp_35862") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35285, &mem_param_tmp_35863, "mem_param_tmp_35863") != 0)
                return 1;
            loop_dz2081Uz2089U_27461 = loop_dz2081Uz2089U_tmp_35864;
        }
        if (memblock_set(ctx, &ext_mem_35461, &mem_param_35274, "mem_param_35274") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35460, &mem_param_35277, "mem_param_35277") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35459, &mem_param_35281, "mem_param_35281") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35458, &mem_param_35285, "mem_param_35285") != 0)
            return 1;
        loopres_27455 = loop_dz2081Uz2089U_27461;
        
        bool cond_27705 = slt64((int64_t) 0, loopres_27455);
        bool loop_cond_t_res_27706 = slt32(newDepth_27486, max_depth_18097);
        bool x_27707 = cond_27705 && loop_cond_t_res_27706;
        
        if (memblock_set(ctx, &mem_param_tmp_35849, &ext_mem_35459, "ext_mem_35459") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35850, &ext_mem_35458, "ext_mem_35458") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35851, &ext_mem_35461, "ext_mem_35461") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35852, &ext_mem_35460, "ext_mem_35460") != 0)
            return 1;
        
        int64_t loop_dz2087U_tmp_35853 = loopres_27455;
        bool loop_while_tmp_35854 = x_27707;
        int32_t p_tmp_35855 = newDepth_27486;
        
        if (memblock_set(ctx, &mem_param_35261, &mem_param_tmp_35849, "mem_param_tmp_35849") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35265, &mem_param_tmp_35850, "mem_param_tmp_35850") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35268, &mem_param_tmp_35851, "mem_param_tmp_35851") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35271, &mem_param_tmp_35852, "mem_param_tmp_35852") != 0)
            return 1;
        loop_dz2087U_27448 = loop_dz2087U_tmp_35853;
        loop_while_27449 = loop_while_tmp_35854;
        p_27450 = p_tmp_35855;
    }
    if (memblock_set(ctx, &ext_mem_35475, &mem_param_35261, "mem_param_35261") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_35474, &mem_param_35265, "mem_param_35265") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_35473, &mem_param_35268, "mem_param_35268") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_35472, &mem_param_35271, "mem_param_35271") != 0)
        return 1;
    partition_and_deepen_res_27441 = loop_dz2087U_27448;
    partition_and_deepen_res_27442 = loop_while_27449;
    partition_and_deepen_res_27443 = p_27450;
    if (memblock_unref(ctx, &mem_35255, "mem_35255") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35256, "mem_35256") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35257, "mem_35257") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35845, &ext_mem_35474, "ext_mem_35474") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35846, &ext_mem_35475, "ext_mem_35475") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36078, &mem_out_35845, "mem_out_35845") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36079, &mem_out_35846, "mem_out_35846") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_35300);
        free(mem_35334);
        free(mem_35336);
        free(mem_35345);
        free(mem_35346);
        free(mem_35377);
        free(mem_35379);
        free(mem_35381);
        free(mem_35383);
        free(mem_35409);
        free(mem_35411);
        if (memblock_unref(ctx, &mem_param_tmp_35852, "mem_param_tmp_35852") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35851, "mem_param_tmp_35851") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35850, "mem_param_tmp_35850") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35849, "mem_param_tmp_35849") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35863, "mem_param_tmp_35863") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35862, "mem_param_tmp_35862") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35861, "mem_param_tmp_35861") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35860, "mem_param_tmp_35860") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35447, "mem_35447") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35445, "mem_35445") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35427, "mem_35427") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35425, "mem_35425") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35374, "ext_mem_35374") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35375, "ext_mem_35375") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35372, "mem_35372") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35871, "mem_param_tmp_35871") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35870, "mem_param_tmp_35870") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35324, "mem_35324") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35322, "mem_35322") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35878, "mem_param_tmp_35878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35311, "mem_35311") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35309, "mem_param_35309") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35320, "ext_mem_35320") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35295, "mem_param_35295") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35291, "mem_param_35291") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35369, "ext_mem_35369") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35370, "ext_mem_35370") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35287, "mem_35287") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35285, "mem_param_35285") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35281, "mem_param_35281") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35277, "mem_param_35277") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35274, "mem_param_35274") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35458, "ext_mem_35458") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35459, "ext_mem_35459") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35460, "ext_mem_35460") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35461, "ext_mem_35461") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35271, "mem_param_35271") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35268, "mem_param_35268") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35265, "mem_param_35265") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35261, "mem_param_35261") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35472, "ext_mem_35472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35473, "ext_mem_35473") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35474, "ext_mem_35474") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35475, "ext_mem_35475") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35257, "mem_35257") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35256, "mem_35256") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35255, "mem_35255") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35846, "mem_out_35846") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35845, "mem_out_35845") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_partition_and_deepen_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_36091, struct memblock *mem_out_p_36092, struct memblock xs_mem_35253, int64_t n_19460, int64_t b_19461, int16_t block_sizze_19462, int64_t gather_psizze_19463, int32_t radix_sizze_19464, int64_t offset_19466, int64_t sizze_thresh_19467, int32_t max_depth_19468)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_35298_cached_sizze_36093 = 0;
    unsigned char *mem_35298 = NULL;
    int64_t mem_35331_cached_sizze_36094 = 0;
    unsigned char *mem_35331 = NULL;
    int64_t mem_35333_cached_sizze_36095 = 0;
    unsigned char *mem_35333 = NULL;
    int64_t mem_35341_cached_sizze_36096 = 0;
    unsigned char *mem_35341 = NULL;
    int64_t mem_35369_cached_sizze_36097 = 0;
    unsigned char *mem_35369 = NULL;
    int64_t mem_35371_cached_sizze_36098 = 0;
    unsigned char *mem_35371 = NULL;
    int64_t mem_35373_cached_sizze_36099 = 0;
    unsigned char *mem_35373 = NULL;
    int64_t mem_35375_cached_sizze_36100 = 0;
    unsigned char *mem_35375 = NULL;
    int64_t mem_35401_cached_sizze_36101 = 0;
    unsigned char *mem_35401 = NULL;
    int64_t mem_35403_cached_sizze_36102 = 0;
    unsigned char *mem_35403 = NULL;
    struct memblock mem_param_tmp_35854;
    
    mem_param_tmp_35854.references = NULL;
    
    struct memblock mem_param_tmp_35853;
    
    mem_param_tmp_35853.references = NULL;
    
    struct memblock mem_param_tmp_35852;
    
    mem_param_tmp_35852.references = NULL;
    
    struct memblock mem_param_tmp_35851;
    
    mem_param_tmp_35851.references = NULL;
    
    struct memblock mem_param_tmp_35865;
    
    mem_param_tmp_35865.references = NULL;
    
    struct memblock mem_param_tmp_35864;
    
    mem_param_tmp_35864.references = NULL;
    
    struct memblock mem_param_tmp_35863;
    
    mem_param_tmp_35863.references = NULL;
    
    struct memblock mem_param_tmp_35862;
    
    mem_param_tmp_35862.references = NULL;
    
    struct memblock mem_35439;
    
    mem_35439.references = NULL;
    
    struct memblock mem_35437;
    
    mem_35437.references = NULL;
    
    struct memblock mem_35419;
    
    mem_35419.references = NULL;
    
    struct memblock mem_35417;
    
    mem_35417.references = NULL;
    
    struct memblock ext_mem_35366;
    
    ext_mem_35366.references = NULL;
    
    struct memblock ext_mem_35367;
    
    ext_mem_35367.references = NULL;
    
    struct memblock mem_35364;
    
    mem_35364.references = NULL;
    
    struct memblock mem_param_tmp_35873;
    
    mem_param_tmp_35873.references = NULL;
    
    struct memblock mem_param_tmp_35872;
    
    mem_param_tmp_35872.references = NULL;
    
    struct memblock mem_35322;
    
    mem_35322.references = NULL;
    
    struct memblock mem_35320;
    
    mem_35320.references = NULL;
    
    struct memblock mem_param_tmp_35880;
    
    mem_param_tmp_35880.references = NULL;
    
    struct memblock mem_35309;
    
    mem_35309.references = NULL;
    
    struct memblock mem_param_35307;
    
    mem_param_35307.references = NULL;
    
    struct memblock ext_mem_35318;
    
    ext_mem_35318.references = NULL;
    
    struct memblock mem_param_35293;
    
    mem_param_35293.references = NULL;
    
    struct memblock mem_param_35290;
    
    mem_param_35290.references = NULL;
    
    struct memblock ext_mem_35361;
    
    ext_mem_35361.references = NULL;
    
    struct memblock ext_mem_35362;
    
    ext_mem_35362.references = NULL;
    
    struct memblock mem_35286;
    
    mem_35286.references = NULL;
    
    struct memblock mem_param_35284;
    
    mem_param_35284.references = NULL;
    
    struct memblock mem_param_35280;
    
    mem_param_35280.references = NULL;
    
    struct memblock mem_param_35277;
    
    mem_param_35277.references = NULL;
    
    struct memblock mem_param_35274;
    
    mem_param_35274.references = NULL;
    
    struct memblock ext_mem_35449;
    
    ext_mem_35449.references = NULL;
    
    struct memblock ext_mem_35450;
    
    ext_mem_35450.references = NULL;
    
    struct memblock ext_mem_35451;
    
    ext_mem_35451.references = NULL;
    
    struct memblock ext_mem_35452;
    
    ext_mem_35452.references = NULL;
    
    struct memblock mem_param_35271;
    
    mem_param_35271.references = NULL;
    
    struct memblock mem_param_35268;
    
    mem_param_35268.references = NULL;
    
    struct memblock mem_param_35265;
    
    mem_param_35265.references = NULL;
    
    struct memblock mem_param_35261;
    
    mem_param_35261.references = NULL;
    
    struct memblock ext_mem_35462;
    
    ext_mem_35462.references = NULL;
    
    struct memblock ext_mem_35463;
    
    ext_mem_35463.references = NULL;
    
    struct memblock ext_mem_35464;
    
    ext_mem_35464.references = NULL;
    
    struct memblock ext_mem_35465;
    
    ext_mem_35465.references = NULL;
    
    struct memblock mem_35258;
    
    mem_35258.references = NULL;
    
    struct memblock mem_35257;
    
    mem_35257.references = NULL;
    
    struct memblock mem_35256;
    
    mem_35256.references = NULL;
    
    struct memblock mem_35255;
    
    mem_35255.references = NULL;
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    int64_t is_27436 = add64(n_19460, offset_19466);
    bool bounds_invalid_upwards_27437 = slt64(is_27436, offset_19466);
    bool valid_27438 = !bounds_invalid_upwards_27437;
    bool range_valid_c_27439;
    
    if (!valid_27438) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) offset_19466, "..<", (long long) is_27436, " is invalid.", "-> #0  ftHashJoin.fut:257:13-32\n   #1  ftHashJoin.fut:248:1-260:31\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_35254 = (int64_t) 8 * n_19460;
    
    if (memblock_alloc(ctx, &mem_35255, bytes_35254, "mem_35255")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_35847 = 0; i_35847 < n_19460; i_35847++) {
        int64_t x_35848 = offset_19466 + i_35847 * (int64_t) 1;
        
        ((int64_t *) mem_35255.mem)[i_35847] = x_35848;
    }
    if (memblock_alloc(ctx, &mem_35256, (int64_t) 8, "mem_35256")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_35849 = 0; nest_i_35849 < (int64_t) 1; nest_i_35849++) {
        ((int64_t *) mem_35256.mem)[nest_i_35849] = (int64_t) 0;
    }
    if (memblock_alloc(ctx, &mem_35257, (int64_t) 8, "mem_35257")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_35850 = 0; nest_i_35850 < (int64_t) 1; nest_i_35850++) {
        ((int64_t *) mem_35257.mem)[nest_i_35850] = n_19460;
    }
    
    bool loop_cond_t_res_27443 = slt32(0, max_depth_19468);
    
    if (memblock_alloc(ctx, &mem_35258, (int64_t) 0, "mem_35258")) {
        err = 1;
        goto cleanup;
    }
    
    bool zzero_27511 = gather_psizze_19463 == (int64_t) 0;
    bool nonzzero_27512 = !zzero_27511;
    int32_t i64_res_28494 = sext_i64_i32(b_19461);
    int64_t bytes_35416 = n_19460 * b_19461;
    
    if (mem_35341_cached_sizze_36096 < b_19461) {
        err = lexical_realloc(ctx, &mem_35341, &mem_35341_cached_sizze_36096, b_19461);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t partition_and_deepen_res_27445;
    bool partition_and_deepen_res_27446;
    int32_t partition_and_deepen_res_27447;
    int64_t loop_dz2087U_27452;
    bool loop_while_27453;
    int32_t p_27454;
    
    if (memblock_set(ctx, &mem_param_35261, &mem_35255, "mem_35255") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_35265, &xs_mem_35253, "xs_mem_35253") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_35268, &mem_35256, "mem_35256") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_35271, &mem_35257, "mem_35257") != 0)
        return 1;
    loop_dz2087U_27452 = (int64_t) 1;
    loop_while_27453 = loop_cond_t_res_27443;
    p_27454 = 0;
    while (loop_while_27453) {
        bool loop_nonempty_27712 = slt64((int64_t) 0, loop_dz2087U_27452);
        int32_t newDepth_27490 = add32(1, p_27454);
        int32_t new_i_27491 = mul32(radix_sizze_19464, p_27454);
        int32_t zm_lhs_27492 = mul32(radix_sizze_19464, newDepth_27490);
        int32_t new_j_27493 = sub32(zm_lhs_27492, 1);
        int32_t tmp_27494 = add32(2, new_i_27491);
        int64_t i_27495 = sext_i32_i64(new_i_27491);
        int64_t j_27496 = sext_i32_i64(new_j_27493);
        int64_t tmp_27497 = sext_i32_i64(tmp_27494);
        bool step_zzero_27498 = new_i_27491 == tmp_27494;
        bool bounds_invalid_upwards_27499 = slt32(new_j_27493, new_i_27491);
        int32_t distance_upwards_exclusive_27500 = sub32(new_j_27493, new_i_27491);
        int64_t distance_exclusive_27501 = sext_i32_i64(distance_upwards_exclusive_27500);
        int64_t distance_27502 = add64((int64_t) 1, distance_exclusive_27501);
        bool range_invalid_27503 = step_zzero_27498 || bounds_invalid_upwards_27499;
        bool valid_27504 = !range_invalid_27503;
        bool loop_not_taken_27713 = !loop_nonempty_27712;
        bool protect_assert_disj_27714 = valid_27504 || loop_not_taken_27713;
        bool range_valid_c_27505;
        
        if (!protect_assert_disj_27714) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) i_27495, "..", (long long) tmp_27497, "...", (long long) j_27496, " is invalid.", "-> #0  ftHashJoin.fut:133:15-34\n   #1  ftHashJoin.fut:180:20-186:6\n   #2  ftHashJoin.fut:259:5-88\n   #3  ftHashJoin.fut:248:1-260:31\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t num_elems_27506 = sdiv_up64(distance_27502, (int64_t) 2);
        bool loop_nonempty_27507 = slt64((int64_t) 0, num_elems_27506);
        bool loop_not_taken_27513 = !loop_nonempty_27507;
        bool protect_assert_disj_27514 = nonzzero_27512 || loop_not_taken_27513;
        bool protect_assert_disj_27716 = protect_assert_disj_27514 || loop_not_taken_27713;
        bool nonzzero_cert_27515;
        
        if (!protect_assert_disj_27716) {
            set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftHashJoin.fut:121:87-90\n   #2  ftHashJoin.fut:134:6-70\n   #3  ftHashJoin.fut:180:20-186:6\n   #4  ftHashJoin.fut:259:5-88\n   #5  ftHashJoin.fut:248:1-260:31\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t loopres_27459;
        int64_t loop_dz2081Uz2089U_27465;
        
        if (memblock_set(ctx, &mem_param_35274, &mem_35258, "mem_35258") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35277, &mem_35258, "mem_35258") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35280, &mem_param_35261, "mem_param_35261") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35284, &mem_param_35265, "mem_param_35265") != 0)
            return 1;
        loop_dz2081Uz2089U_27465 = (int64_t) 0;
        for (int64_t i_27464 = 0; i_27464 < loop_dz2087U_27452; i_27464++) {
            int64_t bounds_27470 = ((int64_t *) mem_param_35268.mem)[i_27464];
            int64_t bounds_27471 = ((int64_t *) mem_param_35271.mem)[i_27464];
            int64_t dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472 = sub64(bounds_27471, bounds_27470);
            bool empty_slice_27473 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472 == (int64_t) 0;
            int64_t m_27474 = sub64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472, (int64_t) 1);
            int64_t i_p_m_t_s_27475 = add64(bounds_27470, m_27474);
            bool zzero_leq_i_p_m_t_s_27476 = sle64((int64_t) 0, i_p_m_t_s_27475);
            bool i_p_m_t_s_leq_w_27477 = slt64(i_p_m_t_s_27475, n_19460);
            bool zzero_lte_i_27478 = sle64((int64_t) 0, bounds_27470);
            bool i_lte_j_27479 = sle64(bounds_27470, bounds_27471);
            bool y_27480 = i_p_m_t_s_leq_w_27477 && zzero_lte_i_27478;
            bool y_27481 = zzero_leq_i_p_m_t_s_27476 && y_27480;
            bool forwards_ok_27482 = i_lte_j_27479 && y_27481;
            bool ok_or_empty_27483 = empty_slice_27473 || forwards_ok_27482;
            bool index_certs_27484;
            
            if (!ok_or_empty_27483) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) bounds_27470, ":", (long long) bounds_27471, "] out of bounds for array of shape [", (long long) n_19460, "].", "-> #0  ftHashJoin.fut:213:21-47\n   #1  ftHashJoin.fut:259:5-88\n   #2  ftHashJoin.fut:248:1-260:31\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_35285 = (int64_t) 8 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472;
            
            if (memblock_alloc(ctx, &mem_35286, bytes_35285, "mem_35286")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t nest_i_35871 = 0; nest_i_35871 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472; nest_i_35871++) {
                ((int64_t *) mem_35286.mem)[nest_i_35871] = (int64_t) 0;
            }
            
            int64_t zm_lhs_27509 = add64(gather_psizze_19463, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472);
            int64_t zs_lhs_27510 = sub64(zm_lhs_27509, (int64_t) 1);
            int64_t m_27516 = sdiv_safe64(zs_lhs_27510, gather_psizze_19463);
            bool loop_cond_27517 = slt64((int64_t) 0, m_27516);
            int64_t binop_y_35294 = b_19461 * bounds_27470;
            int64_t bytes_35319 = b_19461 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472;
            
            if (mem_35298_cached_sizze_36093 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472) {
                err = lexical_realloc(ctx, &mem_35298, &mem_35298_cached_sizze_36093, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t ext_35360;
            int64_t ext_35357;
            int64_t ctx_param_ext_35287;
            int64_t ctx_param_ext_35291;
            
            if (memblock_set(ctx, &mem_param_35290, &mem_param_35284, "mem_param_35284") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35293, &mem_param_35280, "mem_param_35280") != 0)
                return 1;
            ctx_param_ext_35287 = binop_y_35294;
            ctx_param_ext_35291 = bounds_27470;
            for (int64_t i_27520 = 0; i_27520 < num_elems_27506; i_27520++) {
                int32_t binop_x_27523 = sext_i64_i32(i_27520);
                int32_t binop_x_27524 = mul32(2, binop_x_27523);
                int32_t index_primexp_27525 = add32(new_i_27491, binop_x_27524);
                int32_t zm_lhs_27526 = add32(2, index_primexp_27525);
                int32_t min_arg1_27527 = sub32(zm_lhs_27526, 1);
                int32_t min_res_27528 = smin32(new_j_27493, min_arg1_27527);
                int32_t zp_lhs_27529 = sub32(min_res_27528, index_primexp_27525);
                int32_t ij_bits_27530 = add32(1, zp_lhs_27529);
                int32_t up_to_27531 = shl32(1, ij_bits_27530);
                int64_t tmp_27532 = sext_i32_i64(zp_lhs_27529);
                bool bounds_invalid_upwards_27533 = slt32(zp_lhs_27529, 0);
                bool valid_27535 = !bounds_invalid_upwards_27533;
                bool range_valid_c_27536;
                
                if (!valid_27535) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_27532, " is invalid.", "-> #0  ftbasics.fut:113:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:121:87-90\n   #3  ftHashJoin.fut:134:6-70\n   #4  ftHashJoin.fut:180:20-186:6\n   #5  ftHashJoin.fut:259:5-88\n   #6  ftHashJoin.fut:248:1-260:31\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t up_to_27546 = sext_i32_i64(up_to_27531);
                bool bounds_invalid_upwards_27547 = slt32(up_to_27531, 0);
                bool valid_27548 = !bounds_invalid_upwards_27547;
                bool range_valid_c_27549;
                
                if (!valid_27548) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_27546, " is invalid.", "-> #0  ftbasics.fut:137:21-30\n   #1  ftHashJoin.fut:121:87-90\n   #2  ftHashJoin.fut:134:6-70\n   #3  ftHashJoin.fut:180:20-186:6\n   #4  ftHashJoin.fut:259:5-88\n   #5  ftHashJoin.fut:248:1-260:31\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t distance_27534 = add64((int64_t) 1, tmp_27532);
                
                for (int64_t i_35082 = 0; i_35082 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472; i_35082++) {
                    int8_t defunc_0_f_res_27539;
                    int8_t y_27541 = (int8_t) 0;
                    
                    for (int64_t i_27540 = 0; i_27540 < distance_27534; i_27540++) {
                        int32_t binop_x_27542 = sext_i64_i32(i_27540);
                        int32_t get_bit_arg0_27543 = add32(index_primexp_27525, binop_x_27542);
                        int32_t zm_rhs_28495 = sdiv32(get_bit_arg0_27543, 8);
                        int32_t zm_lhs_28496 = sub32(i64_res_28494, zm_rhs_28495);
                        int32_t whichByte_28497 = sub32(zm_lhs_28496, 1);
                        int64_t whichByte_28499 = sext_i32_i64(whichByte_28497);
                        bool x_28500 = sle64((int64_t) 0, whichByte_28499);
                        bool y_28501 = slt64(whichByte_28499, b_19461);
                        bool bounds_check_28502 = x_28500 && y_28501;
                        bool index_certs_28503;
                        
                        if (!bounds_check_28502) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) whichByte_28499, "] out of bounds for array of shape [", (long long) b_19461, "].", "-> #0  ftHashJoin.fut:17:6-18\n   #1  ftHashJoin.fut:259:5-88\n   #2  ftHashJoin.fut:248:1-260:31\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t whichBit_28498 = smod32(get_bit_arg0_27543, 8);
                        int8_t zbzg_lhs_28504 = ((int8_t *) mem_param_35290.mem)[ctx_param_ext_35287 + (i_35082 * b_19461 + whichByte_28499)];
                        int8_t unsign_arg0_28505 = zext_i32_i8(whichBit_28498);
                        int8_t unsign_arg0_28506 = ashr8(zbzg_lhs_28504, unsign_arg0_28505);
                        int8_t unsign_arg0_28507 = (int8_t) 1 & unsign_arg0_28506;
                        int32_t to_i32_res_28508 = zext_i8_i32(unsign_arg0_28507);
                        int8_t loopres_27545;
                        
                        if (futrts_set_bit_2464(ctx, &loopres_27545, binop_x_27542, y_27541, to_i32_res_28508) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        int8_t y_tmp_35879 = loopres_27545;
                        
                        y_27541 = y_tmp_35879;
                    }
                    defunc_0_f_res_27539 = y_27541;
                    ((int8_t *) mem_35298)[i_35082] = defunc_0_f_res_27539;
                }
                
                int64_t defunc_0_radix_sort_multistep_res_27550;
                int64_t offs_27553;
                
                if (memblock_set(ctx, &mem_param_35307, &mem_35286, "mem_35286") != 0)
                    return 1;
                offs_27553 = (int64_t) 0;
                for (int64_t i_27552 = 0; i_27552 < up_to_27546; i_27552++) {
                    int32_t binop_x_27555 = sext_i64_i32(i_27552);
                    int8_t index_primexp_27556 = zext_i32_i8(binop_x_27555);
                    
                    if (memblock_alloc(ctx, &mem_35309, bytes_35285, "mem_35309")) {
                        err = 1;
                        goto cleanup;
                    }
                    
                    int64_t inpacc_29288;
                    int64_t defunc_0_reduce_res_29289;
                    int64_t inpacc_29109;
                    int64_t inpacc_29110;
                    
                    inpacc_29109 = (int64_t) 0;
                    inpacc_29110 = (int64_t) 0;
                    for (int64_t i_35100 = 0; i_35100 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472; i_35100++) {
                        int8_t eta_p_35231 = ((int8_t *) mem_35298)[i_35100];
                        bool lifted_lambda_res_35232 = eta_p_35231 == index_primexp_27556;
                        int64_t bool_res_35233 = btoi_bool_i64(lifted_lambda_res_35232);
                        int64_t eta_p_35246 = ((int64_t *) mem_param_35307.mem)[i_35100];
                        int64_t defunc_0_op_res_35247 = add64(inpacc_29109, bool_res_35233);
                        int64_t zm_lhs_35248 = add64(offs_27553, defunc_0_op_res_35247);
                        int64_t lifted_lambda_res_35249 = sub64(zm_lhs_35248, (int64_t) 1);
                        int64_t defunc_0_f_res_35250 = mul64(bool_res_35233, lifted_lambda_res_35249);
                        int64_t defunc_0_f_res_35251 = add64(eta_p_35246, defunc_0_f_res_35250);
                        int64_t defunc_0_op_res_29158 = add64(inpacc_29110, bool_res_35233);
                        
                        ((int64_t *) mem_35309.mem)[i_35100] = defunc_0_f_res_35251;
                        
                        int64_t inpacc_tmp_35883 = defunc_0_op_res_35247;
                        int64_t inpacc_tmp_35884 = defunc_0_op_res_29158;
                        
                        inpacc_29109 = inpacc_tmp_35883;
                        inpacc_29110 = inpacc_tmp_35884;
                    }
                    inpacc_29288 = inpacc_29109;
                    defunc_0_reduce_res_29289 = inpacc_29110;
                    
                    int64_t tmp_27581 = add64(offs_27553, defunc_0_reduce_res_29289);
                    
                    if (memblock_set(ctx, &mem_param_tmp_35880, &mem_35309, "mem_35309") != 0)
                        return 1;
                    
                    int64_t offs_tmp_35881 = tmp_27581;
                    
                    if (memblock_set(ctx, &mem_param_35307, &mem_param_tmp_35880, "mem_param_tmp_35880") != 0)
                        return 1;
                    offs_27553 = offs_tmp_35881;
                }
                if (memblock_set(ctx, &ext_mem_35318, &mem_param_35307, "mem_param_35307") != 0)
                    return 1;
                defunc_0_radix_sort_multistep_res_27550 = offs_27553;
                if (memblock_alloc(ctx, &mem_35320, bytes_35319, "mem_35320")) {
                    err = 1;
                    goto cleanup;
                }
                lmad_copy_1b(ctx, 2, (uint8_t *) mem_35320.mem, (int64_t) 0, (int64_t []) {b_19461, (int64_t) 1}, (uint8_t *) mem_param_35290.mem, ctx_param_ext_35287, (int64_t []) {b_19461, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472, b_19461});
                if (memblock_alloc(ctx, &mem_35322, bytes_35285, "mem_35322")) {
                    err = 1;
                    goto cleanup;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_35322.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35293.mem, ctx_param_ext_35291, (int64_t []) {(int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472});
                
                bool partitioned_scatter_res_27588;
                int64_t partitioned_scatter_res_27591;
                bool loop_while_27592;
                int64_t p_27595;
                
                loop_while_27592 = loop_cond_27517;
                p_27595 = (int64_t) 0;
                while (loop_while_27592) {
                    int64_t lower_bound_27596 = mul64(gather_psizze_19463, p_27595);
                    int64_t min_arg1_27597 = add64(gather_psizze_19463, lower_bound_27596);
                    int64_t min_res_27598 = smin64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472, min_arg1_27597);
                    int64_t j_m_i_27599 = sub64(min_res_27598, lower_bound_27596);
                    bool empty_slice_27600 = j_m_i_27599 == (int64_t) 0;
                    int64_t m_27601 = sub64(j_m_i_27599, (int64_t) 1);
                    int64_t i_p_m_t_s_27602 = add64(lower_bound_27596, m_27601);
                    bool zzero_leq_i_p_m_t_s_27603 = sle64((int64_t) 0, i_p_m_t_s_27602);
                    bool i_p_m_t_s_leq_w_27604 = slt64(i_p_m_t_s_27602, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472);
                    bool zzero_lte_i_27605 = sle64((int64_t) 0, lower_bound_27596);
                    bool i_lte_j_27606 = sle64(lower_bound_27596, min_res_27598);
                    bool y_27607 = i_p_m_t_s_leq_w_27604 && zzero_lte_i_27605;
                    bool y_27608 = zzero_leq_i_p_m_t_s_27603 && y_27607;
                    bool forwards_ok_27609 = i_lte_j_27606 && y_27608;
                    bool ok_or_empty_27610 = empty_slice_27600 || forwards_ok_27609;
                    bool index_certs_27611;
                    
                    if (!ok_or_empty_27610) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_27596, ":", (long long) min_res_27598, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftHashJoin.fut:121:87-90\n   #2  ftHashJoin.fut:134:6-70\n   #3  ftHashJoin.fut:180:20-186:6\n   #4  ftHashJoin.fut:259:5-88\n   #5  ftHashJoin.fut:248:1-260:31\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t bytes_35330 = b_19461 * j_m_i_27599;
                    int64_t bytes_35332 = (int64_t) 8 * j_m_i_27599;
                    
                    if (mem_35331_cached_sizze_36094 < bytes_35330) {
                        err = lexical_realloc(ctx, &mem_35331, &mem_35331_cached_sizze_36094, bytes_35330);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_35331, (int64_t) 0, (int64_t []) {b_19461, (int64_t) 1}, (uint8_t *) mem_35320.mem, (int64_t) 0 + b_19461 * lower_bound_27596, (int64_t []) {b_19461, (int64_t) 1}, (int64_t []) {j_m_i_27599, b_19461});
                    if (mem_35333_cached_sizze_36095 < bytes_35332) {
                        err = lexical_realloc(ctx, &mem_35333, &mem_35333_cached_sizze_36095, bytes_35332);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35333, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35322.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_27596, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_27599});
                    for (int64_t write_iter_35102 = 0; write_iter_35102 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472; write_iter_35102++) {
                        int64_t write_iv_35105 = ((int64_t *) ext_mem_35318.mem)[write_iter_35102];
                        int64_t write_iv_35107 = ((int64_t *) mem_param_35293.mem)[ctx_param_ext_35291 + write_iter_35102];
                        
                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_35341, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_35290.mem, ctx_param_ext_35287 + write_iter_35102 * b_19461, (int64_t []) {(int64_t) 1}, (int64_t []) {b_19461});
                        
                        bool cond_29201 = sle64(lower_bound_27596, write_iv_35105);
                        bool cond_t_res_29202 = slt64(write_iv_35105, min_res_27598);
                        bool x_29203 = cond_29201 && cond_t_res_29202;
                        int64_t lifted_lambda_res_29204;
                        
                        if (x_29203) {
                            int64_t lifted_lambda_res_t_res_29291 = sub64(write_iv_35105, lower_bound_27596);
                            
                            lifted_lambda_res_29204 = lifted_lambda_res_t_res_29291;
                        } else {
                            lifted_lambda_res_29204 = (int64_t) -1;
                        }
                        if ((sle64((int64_t) 0, lifted_lambda_res_29204) && slt64(lifted_lambda_res_29204, j_m_i_27599)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(b_19461 - (int64_t) 1, b_19461))) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_35331, lifted_lambda_res_29204 * b_19461, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_35341, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_19461});
                        }
                        if (sle64((int64_t) 0, lifted_lambda_res_29204) && slt64(lifted_lambda_res_29204, j_m_i_27599)) {
                            ((int64_t *) mem_35333)[lifted_lambda_res_29204] = write_iv_35107;
                        }
                    }
                    
                    int64_t tmp_27623 = add64((int64_t) 1, p_27595);
                    
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_35320.mem, b_19461 * lower_bound_27596, (int64_t []) {b_19461, (int64_t) 1}, (uint8_t *) mem_35331, (int64_t) 0, (int64_t []) {b_19461, (int64_t) 1}, (int64_t []) {j_m_i_27599, b_19461});
                    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35322.mem, lower_bound_27596, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35333, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_27599});
                    
                    bool loop_cond_27631 = slt64(tmp_27623, m_27516);
                    bool loop_while_tmp_35886 = loop_cond_27631;
                    int64_t p_tmp_35889 = tmp_27623;
                    
                    loop_while_27592 = loop_while_tmp_35886;
                    p_27595 = p_tmp_35889;
                }
                partitioned_scatter_res_27588 = loop_while_27592;
                partitioned_scatter_res_27591 = p_27595;
                if (memblock_unref(ctx, &ext_mem_35318, "ext_mem_35318") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_tmp_35872, &mem_35320, "mem_35320") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_tmp_35873, &mem_35322, "mem_35322") != 0)
                    return 1;
                
                int64_t ctx_param_ext_tmp_35874 = (int64_t) 0;
                int64_t ctx_param_ext_tmp_35875 = (int64_t) 0;
                
                if (memblock_set(ctx, &mem_param_35290, &mem_param_tmp_35872, "mem_param_tmp_35872") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_35293, &mem_param_tmp_35873, "mem_param_tmp_35873") != 0)
                    return 1;
                ctx_param_ext_35287 = ctx_param_ext_tmp_35874;
                ctx_param_ext_35291 = ctx_param_ext_tmp_35875;
            }
            if (memblock_set(ctx, &ext_mem_35362, &mem_param_35290, "mem_param_35290") != 0)
                return 1;
            if (memblock_set(ctx, &ext_mem_35361, &mem_param_35293, "mem_param_35293") != 0)
                return 1;
            ext_35360 = ctx_param_ext_35287;
            ext_35357 = ctx_param_ext_35291;
            if (memblock_unref(ctx, &mem_35286, "mem_35286") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_35364, bytes_35319, "mem_35364")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35364.mem, (int64_t) 0, (int64_t []) {b_19461, (int64_t) 1}, (uint8_t *) ext_mem_35362.mem, ext_35360, (int64_t []) {b_19461, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472, b_19461});
            
            int64_t deepen_step_res_27632;
            int64_t deepen_step_res_27633;
            int32_t deepen_step_res_27636;
            int32_t deepen_step_res_27637;
            int32_t deepen_step_res_27638;
            
            if (futrts_getPartitionBounds_8373(ctx, &ext_mem_35367, &ext_mem_35366, &deepen_step_res_27632, &deepen_step_res_27633, &deepen_step_res_27636, &deepen_step_res_27637, &deepen_step_res_27638, mem_35364, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472, b_19461, newDepth_27490, new_i_27491, new_j_27493) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref(ctx, &mem_35364, "mem_35364") != 0)
                return 1;
            
            int64_t zl_rhs_27726 = sub64(deepen_step_res_27632, (int64_t) 1);
            int64_t bytes_35368 = (int64_t) 8 * deepen_step_res_27632;
            
            if (mem_35369_cached_sizze_36097 < bytes_35368) {
                err = lexical_realloc(ctx, &mem_35369, &mem_35369_cached_sizze_36097, bytes_35368);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_35371_cached_sizze_36098 < bytes_35368) {
                err = lexical_realloc(ctx, &mem_35371, &mem_35371_cached_sizze_36098, bytes_35368);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_35373_cached_sizze_36099 < bytes_35368) {
                err = lexical_realloc(ctx, &mem_35373, &mem_35373_cached_sizze_36099, bytes_35368);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_35375_cached_sizze_36100 < bytes_35368) {
                err = lexical_realloc(ctx, &mem_35375, &mem_35375_cached_sizze_36100, bytes_35368);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t discard_35124;
            int64_t scanacc_35114 = (int64_t) 0;
            
            for (int64_t i_35119 = 0; i_35119 < deepen_step_res_27632; i_35119++) {
                int64_t tmp_28898 = ((int64_t *) ext_mem_35367.mem)[i_35119];
                bool cond_28899 = slt64(i_35119, zl_rhs_27726);
                int64_t tmp_28900;
                
                if (cond_28899) {
                    int64_t tmp_29295 = add64((int64_t) 1, i_35119);
                    bool x_29296 = sle64((int64_t) 0, tmp_29295);
                    bool y_29297 = slt64(tmp_29295, deepen_step_res_27632);
                    bool bounds_check_29298 = x_29296 && y_29297;
                    bool index_certs_29299;
                    
                    if (!bounds_check_29298) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_29295, "] out of bounds for array of shape [", (long long) deepen_step_res_27632, "].", "-> #0  ftHashJoin.fut:190:67-81\n   #1  ftHashJoin.fut:259:5-88\n   #2  ftHashJoin.fut:248:1-260:31\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t tmp_t_res_29300 = ((int64_t *) ext_mem_35367.mem)[tmp_29295];
                    
                    tmp_28900 = tmp_t_res_29300;
                } else {
                    tmp_28900 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472;
                }
                
                int64_t zg_lhs_28909 = sub64(tmp_28900, tmp_28898);
                bool lifted_lambda_res_28910 = slt64(sizze_thresh_19467, zg_lhs_28909);
                int64_t defunc_0_f_res_28911 = btoi_bool_i64(lifted_lambda_res_28910);
                int64_t defunc_0_op_res_27655 = add64(defunc_0_f_res_28911, scanacc_35114);
                
                ((int64_t *) mem_35369)[i_35119] = defunc_0_op_res_27655;
                ((int64_t *) mem_35371)[i_35119] = defunc_0_f_res_28911;
                ((int64_t *) mem_35373)[i_35119] = tmp_28898;
                ((int64_t *) mem_35375)[i_35119] = tmp_28900;
                
                int64_t scanacc_tmp_35892 = defunc_0_op_res_27655;
                
                scanacc_35114 = scanacc_tmp_35892;
            }
            discard_35124 = scanacc_35114;
            if (memblock_unref(ctx, &ext_mem_35367, "ext_mem_35367") != 0)
                return 1;
            
            bool cond_27656 = deepen_step_res_27632 == (int64_t) 0;
            bool x_27657 = !cond_27656;
            bool x_27659 = sle64((int64_t) 0, zl_rhs_27726);
            bool y_27660 = slt64(zl_rhs_27726, deepen_step_res_27632);
            bool bounds_check_27661 = x_27659 && y_27660;
            bool protect_assert_disj_27662 = cond_27656 || bounds_check_27661;
            bool index_certs_27663;
            
            if (!protect_assert_disj_27662) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zl_rhs_27726, "] out of bounds for array of shape [", (long long) deepen_step_res_27632, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:191:8-49\n   #3  ftHashJoin.fut:259:5-88\n   #4  ftHashJoin.fut:248:1-260:31\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_f_res_27664;
            
            if (x_27657) {
                int64_t x_29301 = ((int64_t *) mem_35369)[zl_rhs_27726];
                
                m_f_res_27664 = x_29301;
            } else {
                m_f_res_27664 = (int64_t) 0;
            }
            
            int64_t m_27666;
            
            if (cond_27656) {
                m_27666 = (int64_t) 0;
            } else {
                m_27666 = m_f_res_27664;
            }
            
            int64_t m_27676 = sub64(m_27666, (int64_t) 1);
            bool i_p_m_t_s_leq_w_27678 = slt64(m_27676, deepen_step_res_27632);
            bool zzero_leq_i_p_m_t_s_27677 = sle64((int64_t) 0, m_27676);
            bool y_27680 = zzero_leq_i_p_m_t_s_27677 && i_p_m_t_s_leq_w_27678;
            bool i_lte_j_27679 = sle64((int64_t) 0, m_27666);
            bool forwards_ok_27681 = i_lte_j_27679 && y_27680;
            bool eq_x_zz_27673 = (int64_t) 0 == m_f_res_27664;
            bool p_and_eq_x_y_27674 = x_27657 && eq_x_zz_27673;
            bool empty_slice_27675 = cond_27656 || p_and_eq_x_y_27674;
            bool ok_or_empty_27682 = empty_slice_27675 || forwards_ok_27681;
            bool index_certs_27683;
            
            if (!ok_or_empty_27682) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_27666, "] out of bounds for array of shape [", (long long) deepen_step_res_27632, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:191:8-49\n   #3  ftHashJoin.fut:259:5-88\n   #4  ftHashJoin.fut:248:1-260:31\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_35400 = (int64_t) 8 * m_27666;
            int64_t conc_tmp_27705 = loop_dz2081Uz2089U_27465 + m_27666;
            int64_t bytes_35436 = (int64_t) 8 * conc_tmp_27705;
            
            if (mem_35401_cached_sizze_36101 < bytes_35400) {
                err = lexical_realloc(ctx, &mem_35401, &mem_35401_cached_sizze_36101, bytes_35400);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35401, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35375, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_27666});
            if (mem_35403_cached_sizze_36102 < bytes_35400) {
                err = lexical_realloc(ctx, &mem_35403, &mem_35403_cached_sizze_36102, bytes_35400);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35403, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35373, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_27666});
            for (int64_t write_iter_35125 = 0; write_iter_35125 < deepen_step_res_27632; write_iter_35125++) {
                int64_t write_iv_35128 = ((int64_t *) mem_35371)[write_iter_35125];
                int64_t write_iv_35129 = ((int64_t *) mem_35369)[write_iter_35125];
                int64_t write_iv_35130 = ((int64_t *) mem_35373)[write_iter_35125];
                int64_t write_iv_35131 = ((int64_t *) mem_35375)[write_iter_35125];
                bool cond_28880 = write_iv_35128 == (int64_t) 1;
                int64_t lifted_lambda_res_28881;
                
                if (cond_28880) {
                    int64_t lifted_lambda_res_t_res_29302 = sub64(write_iv_35129, (int64_t) 1);
                    
                    lifted_lambda_res_28881 = lifted_lambda_res_t_res_29302;
                } else {
                    lifted_lambda_res_28881 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_28881) && slt64(lifted_lambda_res_28881, m_27666)) {
                    ((int64_t *) mem_35403)[lifted_lambda_res_28881] = write_iv_35130;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_28881) && slt64(lifted_lambda_res_28881, m_27666)) {
                    ((int64_t *) mem_35401)[lifted_lambda_res_28881] = write_iv_35131;
                }
            }
            if (memblock_alloc(ctx, &mem_35417, bytes_35416, "mem_35417")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35417.mem, (int64_t) 0, (int64_t []) {b_19461, (int64_t) 1}, (uint8_t *) mem_param_35284.mem, (int64_t) 0, (int64_t []) {b_19461, (int64_t) 1}, (int64_t []) {n_19460, b_19461});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_35417.mem, b_19461 * bounds_27470, (int64_t []) {b_19461, (int64_t) 1}, (uint8_t *) ext_mem_35362.mem, ext_35360, (int64_t []) {b_19461, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472, b_19461});
            if (memblock_unref(ctx, &ext_mem_35362, "ext_mem_35362") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_35419, bytes_35254, "mem_35419")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35419.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35280.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_19460});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35419.mem, bounds_27470, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_35361.mem, ext_35357, (int64_t []) {(int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_27472});
            if (memblock_unref(ctx, &ext_mem_35361, "ext_mem_35361") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_35437, bytes_35436, "mem_35437")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_35439, bytes_35436, "mem_35439")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t i_35138 = 0; i_35138 < m_27666; i_35138++) {
                int64_t eta_p_27701 = ((int64_t *) mem_35403)[i_35138];
                int64_t eta_p_27702 = ((int64_t *) mem_35401)[i_35138];
                int64_t tmp_27703 = add64(bounds_27470, eta_p_27701);
                int64_t tmp_27704 = add64(bounds_27470, eta_p_27702);
                
                ((int64_t *) mem_35437.mem)[loop_dz2081Uz2089U_27465 + i_35138] = tmp_27703;
                ((int64_t *) mem_35439.mem)[loop_dz2081Uz2089U_27465 + i_35138] = tmp_27704;
            }
            
            int64_t tmp_offs_35901 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35437.mem, tmp_offs_35901, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35274.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2089U_27465});
            tmp_offs_35901 += loop_dz2081Uz2089U_27465;
            if (!(tmp_offs_35901 == loop_dz2081Uz2089U_27465)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_35437.mem, tmp_offs_35901, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35437.mem, loop_dz2081Uz2089U_27465, (int64_t []) {(int64_t) 1}, (int64_t []) {m_27666});
            }
            tmp_offs_35901 += m_27666;
            
            int64_t tmp_offs_35902 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_35439.mem, tmp_offs_35902, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_35277.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2089U_27465});
            tmp_offs_35902 += loop_dz2081Uz2089U_27465;
            if (!(tmp_offs_35902 == loop_dz2081Uz2089U_27465)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_35439.mem, tmp_offs_35902, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35439.mem, loop_dz2081Uz2089U_27465, (int64_t []) {(int64_t) 1}, (int64_t []) {m_27666});
            }
            tmp_offs_35902 += m_27666;
            if (memblock_set(ctx, &mem_param_tmp_35862, &mem_35437, "mem_35437") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35863, &mem_35439, "mem_35439") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35864, &mem_35419, "mem_35419") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_35865, &mem_35417, "mem_35417") != 0)
                return 1;
            
            int64_t loop_dz2081Uz2089U_tmp_35866 = conc_tmp_27705;
            
            if (memblock_set(ctx, &mem_param_35274, &mem_param_tmp_35862, "mem_param_tmp_35862") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35277, &mem_param_tmp_35863, "mem_param_tmp_35863") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35280, &mem_param_tmp_35864, "mem_param_tmp_35864") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_35284, &mem_param_tmp_35865, "mem_param_tmp_35865") != 0)
                return 1;
            loop_dz2081Uz2089U_27465 = loop_dz2081Uz2089U_tmp_35866;
        }
        if (memblock_set(ctx, &ext_mem_35452, &mem_param_35274, "mem_param_35274") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35451, &mem_param_35277, "mem_param_35277") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35450, &mem_param_35280, "mem_param_35280") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_35449, &mem_param_35284, "mem_param_35284") != 0)
            return 1;
        loopres_27459 = loop_dz2081Uz2089U_27465;
        
        bool cond_27709 = slt64((int64_t) 0, loopres_27459);
        bool loop_cond_t_res_27710 = slt32(newDepth_27490, max_depth_19468);
        bool x_27711 = cond_27709 && loop_cond_t_res_27710;
        
        if (memblock_set(ctx, &mem_param_tmp_35851, &ext_mem_35450, "ext_mem_35450") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35852, &ext_mem_35449, "ext_mem_35449") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35853, &ext_mem_35452, "ext_mem_35452") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_35854, &ext_mem_35451, "ext_mem_35451") != 0)
            return 1;
        
        int64_t loop_dz2087U_tmp_35855 = loopres_27459;
        bool loop_while_tmp_35856 = x_27711;
        int32_t p_tmp_35857 = newDepth_27490;
        
        if (memblock_set(ctx, &mem_param_35261, &mem_param_tmp_35851, "mem_param_tmp_35851") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35265, &mem_param_tmp_35852, "mem_param_tmp_35852") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35268, &mem_param_tmp_35853, "mem_param_tmp_35853") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_35271, &mem_param_tmp_35854, "mem_param_tmp_35854") != 0)
            return 1;
        loop_dz2087U_27452 = loop_dz2087U_tmp_35855;
        loop_while_27453 = loop_while_tmp_35856;
        p_27454 = p_tmp_35857;
    }
    if (memblock_set(ctx, &ext_mem_35465, &mem_param_35261, "mem_param_35261") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_35464, &mem_param_35265, "mem_param_35265") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_35463, &mem_param_35268, "mem_param_35268") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_35462, &mem_param_35271, "mem_param_35271") != 0)
        return 1;
    partition_and_deepen_res_27445 = loop_dz2087U_27452;
    partition_and_deepen_res_27446 = loop_while_27453;
    partition_and_deepen_res_27447 = p_27454;
    if (memblock_unref(ctx, &mem_35255, "mem_35255") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35256, "mem_35256") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35257, "mem_35257") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_35258, "mem_35258") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35845, &ext_mem_35465, "ext_mem_35465") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35846, &ext_mem_35464, "ext_mem_35464") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36091, &mem_out_35845, "mem_out_35845") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36092, &mem_out_35846, "mem_out_35846") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_35298);
        free(mem_35331);
        free(mem_35333);
        free(mem_35341);
        free(mem_35369);
        free(mem_35371);
        free(mem_35373);
        free(mem_35375);
        free(mem_35401);
        free(mem_35403);
        if (memblock_unref(ctx, &mem_param_tmp_35854, "mem_param_tmp_35854") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35853, "mem_param_tmp_35853") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35852, "mem_param_tmp_35852") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35851, "mem_param_tmp_35851") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35865, "mem_param_tmp_35865") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35864, "mem_param_tmp_35864") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35863, "mem_param_tmp_35863") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35862, "mem_param_tmp_35862") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35439, "mem_35439") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35437, "mem_35437") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35419, "mem_35419") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35417, "mem_35417") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35366, "ext_mem_35366") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35367, "ext_mem_35367") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35364, "mem_35364") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35873, "mem_param_tmp_35873") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35872, "mem_param_tmp_35872") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35322, "mem_35322") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35320, "mem_35320") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_35880, "mem_param_tmp_35880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35309, "mem_35309") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35307, "mem_param_35307") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35318, "ext_mem_35318") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35293, "mem_param_35293") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35290, "mem_param_35290") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35361, "ext_mem_35361") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35362, "ext_mem_35362") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35286, "mem_35286") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35284, "mem_param_35284") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35280, "mem_param_35280") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35277, "mem_param_35277") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35274, "mem_param_35274") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35449, "ext_mem_35449") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35450, "ext_mem_35450") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35451, "ext_mem_35451") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35452, "ext_mem_35452") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35271, "mem_param_35271") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35268, "mem_param_35268") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35265, "mem_param_35265") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_35261, "mem_param_35261") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35462, "ext_mem_35462") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35463, "ext_mem_35463") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35464, "ext_mem_35464") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_35465, "ext_mem_35465") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35258, "mem_35258") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35257, "mem_35257") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35256, "mem_35256") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35255, "mem_35255") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35846, "mem_out_35846") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35845, "mem_out_35845") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_getPartitionBounds_8373(struct futhark_context *ctx, struct memblock *mem_out_p_36103, struct memblock *mem_out_p_36104, int64_t *out_prim_out_36105, int64_t *out_prim_out_36106, int32_t *out_prim_out_36107, int32_t *out_prim_out_36108, int32_t *out_prim_out_36109, struct memblock pXs_mem_35253, int64_t n_17191, int64_t b_17192, int32_t curDepth_17193, int32_t i_17195, int32_t j_17196)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_35255_cached_sizze_36110 = 0;
    unsigned char *mem_35255 = NULL;
    int64_t mem_35257_cached_sizze_36111 = 0;
    unsigned char *mem_35257 = NULL;
    int64_t mem_35264_cached_sizze_36112 = 0;
    unsigned char *mem_35264 = NULL;
    int64_t mem_35265_cached_sizze_36113 = 0;
    unsigned char *mem_35265 = NULL;
    int64_t mem_35285_cached_sizze_36114 = 0;
    unsigned char *mem_35285 = NULL;
    struct memblock mem_35296;
    
    mem_35296.references = NULL;
    
    struct memblock mem_35294;
    
    mem_35294.references = NULL;
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    int64_t prim_out_35847;
    int64_t prim_out_35848;
    int32_t prim_out_35849;
    int32_t prim_out_35850;
    int32_t prim_out_35851;
    int64_t dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197 = sub64(n_17191, (int64_t) 1);
    bool bounds_invalid_upwards_17201 = slt64(n_17191, (int64_t) 1);
    bool valid_17206 = !bounds_invalid_upwards_17201;
    bool range_valid_c_17207;
    
    if (!valid_17206) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 1, "..<", (long long) n_17191, " is invalid.", "-> #0  ftHashJoin.fut:142:23-28\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int32_t zm_rhs_27726 = sdiv32(j_17196, 8);
    int32_t i64_res_27721 = sext_i64_i32(b_17192);
    int32_t zm_lhs_27727 = sub32(i64_res_27721, zm_rhs_27726);
    int32_t i32_arg0_27728 = sub32(zm_lhs_27727, 1);
    int64_t i32_res_27729 = sext_i32_i64(i32_arg0_27728);
    bool y_27754 = slt64(i32_res_27729, b_17192);
    bool x_27753 = sle64((int64_t) 0, i32_res_27729);
    bool bounds_check_27755 = x_27753 && y_27754;
    bool index_certs_27756;
    
    if (!bounds_check_27755) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_27729, "] out of bounds for array of shape [", (long long) b_17192, "].", "-> #0  ftHashJoin.fut:33:38-54\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int32_t zm_rhs_27722 = sdiv32(i_17195, 8);
    int32_t zm_lhs_27723 = sub32(i64_res_27721, zm_rhs_27722);
    int32_t i32_arg0_27724 = sub32(zm_lhs_27723, 1);
    int64_t i32_res_27725 = sext_i32_i64(i32_arg0_27724);
    bool y_27747 = slt64(i32_res_27725, b_17192);
    bool x_27746 = sle64((int64_t) 0, i32_res_27725);
    bool bounds_check_27748 = x_27746 && y_27747;
    bool index_certs_27749;
    
    if (!bounds_check_27748) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_27725, "] out of bounds for array of shape [", (long long) b_17192, "].", "-> #0  ftHashJoin.fut:32:48-64\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int32_t lastBit_27731 = smod32(j_17196, 8);
    int32_t zm_lhs_27734 = sub32(8, lastBit_27731);
    int32_t i32_arg0_27735 = sub32(zm_lhs_27734, 1);
    int8_t unsign_arg0_27736 = zext_i32_i8(i32_arg0_27735);
    int8_t unsign_arg0_27737 = lshr8((int8_t) -1, unsign_arg0_27736);
    int32_t firstBit_27730 = smod32(i_17195, 8);
    int8_t unsign_arg0_27732 = zext_i32_i8(firstBit_27730);
    int8_t first_bitMask_27733 = shl8((int8_t) -1, unsign_arg0_27732);
    int64_t bytes_35254 = (int64_t) 8 * dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197;
    
    if (mem_35255_cached_sizze_36110 < bytes_35254) {
        err = lexical_realloc(ctx, &mem_35255, &mem_35255_cached_sizze_36110, bytes_35254);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_35257_cached_sizze_36111 < bytes_35254) {
        err = lexical_realloc(ctx, &mem_35257, &mem_35257_cached_sizze_36111, bytes_35254);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_35264_cached_sizze_36112 < b_17192) {
        err = lexical_realloc(ctx, &mem_35264, &mem_35264_cached_sizze_36112, b_17192);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_35265_cached_sizze_36113 < b_17192) {
        err = lexical_realloc(ctx, &mem_35265, &mem_35265_cached_sizze_36113, b_17192);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t discard_35097;
    int64_t scanacc_35091 = (int64_t) 0;
    
    for (int64_t i_35094 = 0; i_35094 < dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197; i_35094++) {
        int64_t index_primexp_35229 = add64((int64_t) 1, i_35094);
        bool x_28945 = sle64((int64_t) 0, index_primexp_35229);
        bool y_28946 = slt64(index_primexp_35229, n_17191);
        bool bounds_check_28947 = x_28945 && y_28946;
        bool index_certs_28948;
        
        if (!bounds_check_28947) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_primexp_35229, "] out of bounds for array of shape [", (long long) n_17191, "].", "-> #0  ftHashJoin.fut:143:22-30\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:143:8-44\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool y_28952 = slt64(i_35094, n_17191);
        bool index_certs_28954;
        
        if (!y_28952) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_35094, "] out of bounds for array of shape [", (long long) n_17191, "].", "-> #0  ftHashJoin.fut:143:32-42\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:143:8-44\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        for (int64_t i_35084 = 0; i_35084 < b_17192; i_35084++) {
            int8_t eta_p_29006 = ((int8_t *) pXs_mem_35253.mem)[index_primexp_35229 * b_17192 + i_35084];
            int8_t eta_p_29007 = ((int8_t *) pXs_mem_35253.mem)[i_35094 * b_17192 + i_35084];
            bool cond_29009 = sle64(i_35084, i32_res_27725);
            bool cond_t_res_29010 = sle64(i32_res_27729, i_35084);
            bool x_29011 = cond_29009 && cond_t_res_29010;
            int8_t lifted_lambda_res_29012;
            
            if (x_29011) {
                lifted_lambda_res_29012 = eta_p_29006;
            } else {
                lifted_lambda_res_29012 = (int8_t) 0;
            }
            
            int8_t lifted_lambda_res_29017;
            
            if (x_29011) {
                lifted_lambda_res_29017 = eta_p_29007;
            } else {
                lifted_lambda_res_29017 = (int8_t) 0;
            }
            ((int8_t *) mem_35264)[i_35084] = lifted_lambda_res_29017;
            ((int8_t *) mem_35265)[i_35084] = lifted_lambda_res_29012;
        }
        
        int8_t za_lhs_28965 = ((int8_t *) mem_35265)[i32_res_27725];
        int8_t mod1_x_28966 = first_bitMask_27733 & za_lhs_28965;
        
        ((int8_t *) mem_35265)[i32_res_27725] = mod1_x_28966;
        
        int8_t za_lhs_28968 = ((int8_t *) mem_35265)[i32_res_27729];
        int8_t tmp_28969 = unsign_arg0_27737 & za_lhs_28968;
        
        ((int8_t *) mem_35265)[i32_res_27729] = tmp_28969;
        
        int8_t za_lhs_28978 = ((int8_t *) mem_35264)[i32_res_27725];
        int8_t mod1_x_28979 = first_bitMask_27733 & za_lhs_28978;
        
        ((int8_t *) mem_35264)[i32_res_27725] = mod1_x_28979;
        
        int8_t za_lhs_28981 = ((int8_t *) mem_35264)[i32_res_27729];
        int8_t tmp_28982 = unsign_arg0_27737 & za_lhs_28981;
        
        ((int8_t *) mem_35264)[i32_res_27729] = tmp_28982;
        
        bool defunc_0_reduce_res_29029;
        bool redout_35087 = 0;
        
        for (int64_t i_35088 = 0; i_35088 < b_17192; i_35088++) {
            int8_t eta_p_28999 = ((int8_t *) mem_35265)[i_35088];
            int8_t eta_p_29000 = ((int8_t *) mem_35264)[i_35088];
            bool lifted_lambda_res_29001 = eta_p_28999 == eta_p_29000;
            bool lifted_lambda_res_29002 = !lifted_lambda_res_29001;
            bool defunc_0_op_res_28995 = lifted_lambda_res_29002 || redout_35087;
            bool redout_tmp_35857 = defunc_0_op_res_28995;
            
            redout_35087 = redout_tmp_35857;
        }
        defunc_0_reduce_res_29029 = redout_35087;
        
        int64_t defunc_0_f_res_28996 = btoi_bool_i64(defunc_0_reduce_res_29029);
        int64_t defunc_0_op_res_27171 = add64(defunc_0_f_res_28996, scanacc_35091);
        
        ((int64_t *) mem_35255)[i_35094] = defunc_0_op_res_27171;
        ((int64_t *) mem_35257)[i_35094] = defunc_0_f_res_28996;
        
        int64_t scanacc_tmp_35852 = defunc_0_op_res_27171;
        
        scanacc_35091 = scanacc_tmp_35852;
    }
    discard_35097 = scanacc_35091;
    
    bool cond_27172 = dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197 == (int64_t) 0;
    bool x_27173 = !cond_27172;
    int64_t tmp_27174 = sub64(dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197, (int64_t) 1);
    bool x_27175 = sle64((int64_t) 0, tmp_27174);
    bool y_27176 = slt64(tmp_27174, dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197);
    bool bounds_check_27177 = x_27175 && y_27176;
    bool protect_assert_disj_27178 = cond_27172 || bounds_check_27177;
    bool index_certs_27179;
    
    if (!protect_assert_disj_27178) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_27174, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t m_f_res_27180;
    
    if (x_27173) {
        int64_t x_29030 = ((int64_t *) mem_35255)[tmp_27174];
        
        m_f_res_27180 = x_29030;
    } else {
        m_f_res_27180 = (int64_t) 0;
    }
    
    int64_t m_27182;
    
    if (cond_27172) {
        m_27182 = (int64_t) 0;
    } else {
        m_27182 = m_f_res_27180;
    }
    
    int64_t m_27192 = sub64(m_27182, (int64_t) 1);
    bool i_p_m_t_s_leq_w_27194 = slt64(m_27192, dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197);
    bool zzero_leq_i_p_m_t_s_27193 = sle64((int64_t) 0, m_27192);
    bool y_27196 = zzero_leq_i_p_m_t_s_27193 && i_p_m_t_s_leq_w_27194;
    bool i_lte_j_27195 = sle64((int64_t) 0, m_27182);
    bool forwards_ok_27197 = i_lte_j_27195 && y_27196;
    bool eq_x_zz_27189 = (int64_t) 0 == m_f_res_27180;
    bool p_and_eq_x_y_27190 = x_27173 && eq_x_zz_27189;
    bool empty_slice_27191 = cond_27172 || p_and_eq_x_y_27190;
    bool ok_or_empty_27198 = empty_slice_27191 || forwards_ok_27197;
    bool index_certs_27199;
    
    if (!ok_or_empty_27198) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_27182, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_35284 = (int64_t) 8 * m_27182;
    int64_t conc_tmp_23695 = (int64_t) 1 + m_27182;
    int64_t bytes_35293 = (int64_t) 8 * conc_tmp_23695;
    int64_t bytes_35295 = (int64_t) 4 * conc_tmp_23695;
    
    if (mem_35285_cached_sizze_36114 < bytes_35284) {
        err = lexical_realloc(ctx, &mem_35285, &mem_35285_cached_sizze_36114, bytes_35284);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_35858 = 0; i_35858 < m_27182; i_35858++) {
        int64_t x_35859 = (int64_t) 1 + i_35858 * (int64_t) 1;
        
        ((int64_t *) mem_35285)[i_35858] = x_35859;
    }
    for (int64_t write_iter_35098 = 0; write_iter_35098 < dzlz7bUZLzmZRz20Unz20U1z7dUzg_17197; write_iter_35098++) {
        int64_t write_iv_35100 = ((int64_t *) mem_35257)[write_iter_35098];
        int64_t write_iv_35101 = ((int64_t *) mem_35255)[write_iter_35098];
        int64_t index_primexp_35225 = add64((int64_t) 1, write_iter_35098);
        bool cond_28879 = write_iv_35100 == (int64_t) 1;
        int64_t lifted_lambda_res_28880;
        
        if (cond_28879) {
            int64_t lifted_lambda_res_t_res_29031 = sub64(write_iv_35101, (int64_t) 1);
            
            lifted_lambda_res_28880 = lifted_lambda_res_t_res_29031;
        } else {
            lifted_lambda_res_28880 = (int64_t) -1;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_28880) && slt64(lifted_lambda_res_28880, m_27182)) {
            ((int64_t *) mem_35285)[lifted_lambda_res_28880] = index_primexp_35225;
        }
    }
    
    int32_t zp_lhs_17331 = sub32(j_17196, i_17195);
    int32_t tmp_17333 = add32(1, zp_lhs_17331);
    
    if (memblock_alloc(ctx, &mem_35294, bytes_35293, "mem_35294")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_35861 = 0; nest_i_35861 < (int64_t) 1; nest_i_35861++) {
        ((int64_t *) mem_35294.mem)[nest_i_35861] = (int64_t) 0;
    }
    
    int64_t tmp_offs_35862 = (int64_t) 0;
    
    if (!(tmp_offs_35862 == (int64_t) 0)) {
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35294.mem, tmp_offs_35862, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35294.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    }
    tmp_offs_35862 += (int64_t) 1;
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_35294.mem, tmp_offs_35862, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35285, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_27182});
    tmp_offs_35862 += m_27182;
    if (memblock_alloc(ctx, &mem_35296, bytes_35295, "mem_35296")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_35863 = 0; nest_i_35863 < conc_tmp_23695; nest_i_35863++) {
        ((int32_t *) mem_35296.mem)[nest_i_35863] = curDepth_17193;
    }
    if (memblock_set(ctx, &mem_out_35845, &mem_35294, "mem_35294") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_35846, &mem_35296, "mem_35296") != 0)
        return 1;
    prim_out_35847 = conc_tmp_23695;
    prim_out_35848 = conc_tmp_23695;
    prim_out_35849 = curDepth_17193;
    prim_out_35850 = tmp_17333;
    prim_out_35851 = i64_res_27721;
    if (memblock_set(ctx, &*mem_out_p_36103, &mem_out_35845, "mem_out_35845") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36104, &mem_out_35846, "mem_out_35846") != 0)
        return 1;
    *out_prim_out_36105 = prim_out_35847;
    *out_prim_out_36106 = prim_out_35848;
    *out_prim_out_36107 = prim_out_35849;
    *out_prim_out_36108 = prim_out_35850;
    *out_prim_out_36109 = prim_out_35851;
    
  cleanup:
    {
        free(mem_35255);
        free(mem_35257);
        free(mem_35264);
        free(mem_35265);
        free(mem_35285);
        if (memblock_unref(ctx, &mem_35296, "mem_35296") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_35294, "mem_35294") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35846, "mem_out_35846") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_35845, "mem_out_35845") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_partitioned_scatter_8506(struct futhark_context *ctx, struct memblock *mem_out_p_36115, struct memblock dest_mem_35253, struct memblock is_mem_35254, struct memblock vs_mem_35255, int64_t nd_20572, int64_t n_20573, int64_t psizze_20574)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_35260_cached_sizze_36116 = 0;
    unsigned char *mem_35260 = NULL;
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    bool zzero_20582 = psizze_20574 == (int64_t) 0;
    bool nonzzero_20583 = !zzero_20582;
    bool nonzzero_cert_20584;
    
    if (!nonzzero_20583) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zm_lhs_20578 = add64(nd_20572, psizze_20574);
    int64_t zs_lhs_20580 = sub64(zm_lhs_20578, (int64_t) 1);
    int64_t m_20585 = sdiv64(zs_lhs_20580, psizze_20574);
    bool loop_cond_20589 = slt64((int64_t) 0, m_20585);
    bool partitioned_scatter_res_20590;
    int64_t partitioned_scatter_res_20592;
    bool loop_while_20593;
    int64_t p_20595;
    
    loop_while_20593 = loop_cond_20589;
    p_20595 = (int64_t) 0;
    while (loop_while_20593) {
        int64_t lower_bound_20596 = mul64(psizze_20574, p_20595);
        int64_t min_arg1_20598 = add64(psizze_20574, lower_bound_20596);
        int64_t min_res_23887 = smin64(nd_20572, min_arg1_20598);
        int64_t j_m_i_20607 = sub64(min_res_23887, lower_bound_20596);
        bool empty_slice_20614 = j_m_i_20607 == (int64_t) 0;
        int64_t m_20615 = sub64(j_m_i_20607, (int64_t) 1);
        int64_t i_p_m_t_s_20617 = add64(lower_bound_20596, m_20615);
        bool zzero_leq_i_p_m_t_s_20618 = sle64((int64_t) 0, i_p_m_t_s_20617);
        bool i_p_m_t_s_leq_w_20620 = slt64(i_p_m_t_s_20617, nd_20572);
        bool zzero_lte_i_20621 = sle64((int64_t) 0, lower_bound_20596);
        bool i_lte_j_20622 = sle64(lower_bound_20596, min_res_23887);
        bool y_20623 = i_p_m_t_s_leq_w_20620 && zzero_lte_i_20621;
        bool y_20624 = zzero_leq_i_p_m_t_s_20618 && y_20623;
        bool forwards_ok_20625 = i_lte_j_20622 && y_20624;
        bool ok_or_empty_20632 = empty_slice_20614 || forwards_ok_20625;
        bool index_certs_20634;
        
        if (!ok_or_empty_20632) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_20596, ":", (long long) min_res_23887, "] out of bounds for array of shape [", (long long) nd_20572, "].", "-> #0  ftbasics.fut:72:25-56\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t bytes_35259 = (int64_t) 8 * j_m_i_20607;
        
        if (mem_35260_cached_sizze_36116 < bytes_35259) {
            err = lexical_realloc(ctx, &mem_35260, &mem_35260_cached_sizze_36116, bytes_35259);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_35260, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) dest_mem_35253.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_20596, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_20607});
        for (int64_t write_iter_35080 = 0; write_iter_35080 < n_20573; write_iter_35080++) {
            int64_t write_iv_35082 = ((int64_t *) vs_mem_35255.mem)[write_iter_35080];
            int64_t write_iv_35083 = ((int64_t *) is_mem_35254.mem)[write_iter_35080];
            bool cond_28878 = sle64(lower_bound_20596, write_iv_35083);
            bool cond_t_res_28879 = slt64(write_iv_35083, min_res_23887);
            bool x_28880 = cond_28878 && cond_t_res_28879;
            int64_t lifted_lambda_res_28881;
            
            if (x_28880) {
                int64_t lifted_lambda_res_t_res_28887 = sub64(write_iv_35083, lower_bound_20596);
                
                lifted_lambda_res_28881 = lifted_lambda_res_t_res_28887;
            } else {
                lifted_lambda_res_28881 = (int64_t) -1;
            }
            if (sle64((int64_t) 0, lifted_lambda_res_28881) && slt64(lifted_lambda_res_28881, j_m_i_20607)) {
                ((int64_t *) mem_35260)[lifted_lambda_res_28881] = write_iv_35082;
            }
        }
        
        int64_t tmp_20652 = add64((int64_t) 1, p_20595);
        
        lmad_copy_8b(ctx, 1, (uint64_t *) dest_mem_35253.mem, lower_bound_20596, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_35260, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_20607});
        
        bool loop_cond_20697 = slt64(tmp_20652, m_20585);
        bool loop_while_tmp_35846 = loop_cond_20697;
        int64_t p_tmp_35848 = tmp_20652;
        
        loop_while_20593 = loop_while_tmp_35846;
        p_20595 = p_tmp_35848;
    }
    partitioned_scatter_res_20590 = loop_while_20593;
    partitioned_scatter_res_20592 = p_20595;
    if (memblock_set(ctx, &mem_out_35845, &dest_mem_35253, "dest_mem_35253") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_36115, &mem_out_35845, "mem_out_35845") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_35260);
        if (memblock_unref(ctx, &mem_out_35845, "mem_out_35845") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_set_bit_2464(struct futhark_context *ctx, int8_t *out_prim_out_36117, int32_t bit_15397, int8_t x_15398, int32_t b_15399)
{
    (void) ctx;
    
    int err = 0;
    int8_t prim_out_35845;
    int32_t i32_arg0_15400 = shl32(1, bit_15397);
    int32_t i32_arg_15402 = ~i32_arg0_15400;
    int8_t unsign_arg0_23886 = zext_i32_i8(i32_arg_15402);
    int8_t unsign_arg0_27719 = x_15398 & unsign_arg0_23886;
    int32_t i32_arg0_15407 = shl32(b_15399, bit_15397);
    int8_t unsign_arg0_23888 = zext_i32_i8(i32_arg0_15407);
    int8_t unsign_arg0_23891 = unsign_arg0_23888 | unsign_arg0_27719;
    
    prim_out_35845 = unsign_arg0_23891;
    *out_prim_out_36117 = prim_out_35845;
    
  cleanup:
    { }
    return err;
}

int futhark_entry_Inner_Radix_Hash_Join(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq **out0, const int32_t in0, const struct futhark_u8_2d *in1, const struct futhark_u8_2d *in2, const struct futhark_opaque_partitionInfo *in3, const struct futhark_opaque_partitionInfo *in4, const struct futhark_opaque_radix_hashTable *in5, const struct futhark_opaque_radix_hashTable *in6, const int64_t in7)
{
    int64_t nR_23541 = (int64_t) 0;
    int64_t b_23542 = (int64_t) 0;
    int64_t nS_23543 = (int64_t) 0;
    int64_t dz2081U_23544 = (int64_t) 0;
    int64_t dz2081U_23545 = (int64_t) 0;
    int64_t dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546 = (int64_t) 0;
    int32_t radix_sizze_23547 = 0;
    int32_t maxDepth_23552 = 0;
    int32_t radixSizze_23553 = 0;
    int32_t totalBytes_23554 = 0;
    int32_t maxDepth_23557 = 0;
    int32_t radixSizze_23558 = 0;
    int32_t totalBytes_23559 = 0;
    int64_t scatter_psizze_23564 = (int64_t) 0;
    int64_t prim_out_35848 = (int64_t) 0;
    int64_t prim_out_35849 = (int64_t) 0;
    int64_t prim_out_35850 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_35847;
    
    mem_out_35847.references = NULL;
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    struct memblock last_info_idx_mem_35262;
    
    last_info_idx_mem_35262.references = NULL;
    
    struct memblock first_info_idx_mem_35261;
    
    first_info_idx_mem_35261.references = NULL;
    
    struct memblock last_info_idx_mem_35260;
    
    last_info_idx_mem_35260.references = NULL;
    
    struct memblock first_info_idx_mem_35259;
    
    first_info_idx_mem_35259.references = NULL;
    
    struct memblock depths_mem_35258;
    
    depths_mem_35258.references = NULL;
    
    struct memblock bounds_mem_35257;
    
    bounds_mem_35257.references = NULL;
    
    struct memblock depths_mem_35256;
    
    depths_mem_35256.references = NULL;
    
    struct memblock bounds_mem_35255;
    
    bounds_mem_35255.references = NULL;
    
    struct memblock pS_mem_35254;
    
    pS_mem_35254.references = NULL;
    
    struct memblock pR_mem_35253;
    
    pR_mem_35253.references = NULL;
    radix_sizze_23547 = in0;
    pR_mem_35253 = in1->mem;
    nR_23541 = in1->shape[0];
    b_23542 = in1->shape[1];
    pS_mem_35254 = in2->mem;
    nS_23543 = in2->shape[0];
    b_23542 = in2->shape[1];
    bounds_mem_35255 = in3->v0->mem;
    dz2081U_23544 = in3->v0->shape[0];
    depths_mem_35256 = in3->v1->mem;
    dz2081U_23544 = in3->v1->shape[0];
    maxDepth_23552 = in3->v2;
    radixSizze_23553 = in3->v3;
    totalBytes_23554 = in3->v4;
    bounds_mem_35257 = in4->v0->mem;
    dz2081U_23545 = in4->v0->shape[0];
    depths_mem_35258 = in4->v1->mem;
    dz2081U_23545 = in4->v1->shape[0];
    maxDepth_23557 = in4->v2;
    radixSizze_23558 = in4->v3;
    totalBytes_23559 = in4->v4;
    first_info_idx_mem_35259 = in5->v0->mem;
    dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546 = in5->v0->shape[0];
    last_info_idx_mem_35260 = in5->v1->mem;
    dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546 = in5->v1->shape[0];
    first_info_idx_mem_35261 = in6->v0->mem;
    dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546 = in6->v0->shape[0];
    last_info_idx_mem_35262 = in6->v1->mem;
    dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546 = in6->v1->shape[0];
    scatter_psizze_23564 = in7;
    if (!((nR_23541 == in1->shape[0] && b_23542 == in1->shape[1]) && ((nS_23543 == in2->shape[0] && b_23542 == in2->shape[1]) && ((dz2081U_23544 == in3->v0->shape[0] && dz2081U_23544 == in3->v1->shape[0]) && ((dz2081U_23545 == in4->v0->shape[0] && dz2081U_23545 == in4->v1->shape[0]) && ((dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546 == in5->v0->shape[0] && dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546 == in5->v1->shape[0]) && (dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546 == in6->v0->shape[0] && dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546 == in6->v1->shape[0]))))))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_Inner_Radix_Hash_Join(ctx, &mem_out_35845, &mem_out_35846, &mem_out_35847, &prim_out_35848, &prim_out_35849, &prim_out_35850, pR_mem_35253, pS_mem_35254, bounds_mem_35255, depths_mem_35256, bounds_mem_35257, depths_mem_35258, first_info_idx_mem_35259, last_info_idx_mem_35260, first_info_idx_mem_35261, last_info_idx_mem_35262, nR_23541, b_23542, nS_23543, dz2081U_23544, dz2081U_23545, dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_23546, radix_sizze_23547, maxDepth_23552, radixSizze_23553, totalBytes_23554, maxDepth_23557, radixSizze_23558, totalBytes_23559, scatter_psizze_23564);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_joinPairs_bsq *) malloc(sizeof(struct futhark_opaque_joinPairs_bsq))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_35845;
            (*out0)->v0->shape[0] = prim_out_35848;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_35846;
            (*out0)->v1->shape[0] = prim_out_35849;
            assert(((*out0)->v2 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v2->mem = mem_out_35847;
            (*out0)->v2->shape[0] = prim_out_35850;
            (*out0)->v2->shape[1] = b_23542;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_calc_partitions_from_partitioned_set(struct futhark_context *ctx, struct futhark_opaque_partitionInfo **out0, const int32_t in0, const struct futhark_u8_2d *in1, const int64_t in2, const int64_t in3, const int32_t in4)
{
    int64_t n_20311 = (int64_t) 0;
    int64_t b_20312 = (int64_t) 0;
    int32_t radix_sizze_20313 = 0;
    int64_t offset_20315 = (int64_t) 0;
    int64_t sizze_thresh_20316 = (int64_t) 0;
    int32_t max_depth_20317 = 0;
    int64_t prim_out_35847 = (int64_t) 0;
    int64_t prim_out_35848 = (int64_t) 0;
    int32_t prim_out_35849 = 0;
    int32_t prim_out_35850 = 0;
    int32_t prim_out_35851 = 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    struct memblock pXs_mem_35253;
    
    pXs_mem_35253.references = NULL;
    radix_sizze_20313 = in0;
    pXs_mem_35253 = in1->mem;
    n_20311 = in1->shape[0];
    b_20312 = in1->shape[1];
    offset_20315 = in2;
    sizze_thresh_20316 = in3;
    max_depth_20317 = in4;
    if (!(n_20311 == in1->shape[0] && b_20312 == in1->shape[1])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_calc_partitions_from_partitioned_set(ctx, &mem_out_35845, &mem_out_35846, &prim_out_35847, &prim_out_35848, &prim_out_35849, &prim_out_35850, &prim_out_35851, pXs_mem_35253, n_20311, b_20312, radix_sizze_20313, offset_20315, sizze_thresh_20316, max_depth_20317);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_partitionInfo *) malloc(sizeof(struct futhark_opaque_partitionInfo))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_35845;
            (*out0)->v0->shape[0] = prim_out_35847;
            assert(((*out0)->v1 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->v1->mem = mem_out_35846;
            (*out0)->v1->shape[0] = prim_out_35848;
            (*out0)->v2 = prim_out_35849;
            (*out0)->v3 = prim_out_35850;
            (*out0)->v4 = prim_out_35851;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_create_hash_table_from_partitioned_set(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable **out0, const struct futhark_u8_2d *in0, const struct futhark_opaque_partitionInfo *in1, const int64_t in2)
{
    int64_t n_21066 = (int64_t) 0;
    int64_t b_21067 = (int64_t) 0;
    int64_t dz2080U_21068 = (int64_t) 0;
    int64_t dz2081U_21069 = (int64_t) 0;
    int32_t maxDepth_21073 = 0;
    int32_t radixSizze_21074 = 0;
    int32_t totalBytes_21075 = 0;
    int64_t scatter_psizze_21076 = (int64_t) 0;
    int64_t prim_out_35847 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    struct memblock depths_mem_35255;
    
    depths_mem_35255.references = NULL;
    
    struct memblock bounds_mem_35254;
    
    bounds_mem_35254.references = NULL;
    
    struct memblock pXs_mem_35253;
    
    pXs_mem_35253.references = NULL;
    pXs_mem_35253 = in0->mem;
    n_21066 = in0->shape[0];
    b_21067 = in0->shape[1];
    bounds_mem_35254 = in1->v0->mem;
    dz2080U_21068 = in1->v0->shape[0];
    depths_mem_35255 = in1->v1->mem;
    dz2081U_21069 = in1->v1->shape[0];
    maxDepth_21073 = in1->v2;
    radixSizze_21074 = in1->v3;
    totalBytes_21075 = in1->v4;
    scatter_psizze_21076 = in2;
    if (!((n_21066 == in0->shape[0] && b_21067 == in0->shape[1]) && (dz2080U_21068 == in1->v0->shape[0] && dz2081U_21069 == in1->v1->shape[0]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_create_hash_table_from_partitioned_set(ctx, &mem_out_35845, &mem_out_35846, &prim_out_35847, pXs_mem_35253, bounds_mem_35254, depths_mem_35255, n_21066, b_21067, dz2080U_21068, dz2081U_21069, maxDepth_21073, radixSizze_21074, totalBytes_21075, scatter_psizze_21076);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_radix_hashTable *) malloc(sizeof(struct futhark_opaque_radix_hashTable))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_35845;
            (*out0)->v0->shape[0] = prim_out_35847;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_35846;
            (*out0)->v1->shape[0] = prim_out_35847;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_partition_and_deepen_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR **out0, const int16_t in0, const int64_t in1, const int32_t in2, const struct futhark_u8_2d *in3, const struct futhark_u8_2d *in4, const int64_t in5, const int32_t in6)
{
    int64_t n_18088 = (int64_t) 0;
    int64_t b_18089 = (int64_t) 0;
    int64_t pL_b_18090 = (int64_t) 0;
    int16_t block_sizze_18091 = (int16_t) 0;
    int64_t gather_psizze_18092 = (int64_t) 0;
    int32_t radix_sizze_18093 = 0;
    int64_t sizze_thresh_18096 = (int64_t) 0;
    int32_t max_depth_18097 = 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    struct memblock pL_mem_35254;
    
    pL_mem_35254.references = NULL;
    
    struct memblock xs_mem_35253;
    
    xs_mem_35253.references = NULL;
    block_sizze_18091 = in0;
    gather_psizze_18092 = in1;
    radix_sizze_18093 = in2;
    xs_mem_35253 = in3->mem;
    n_18088 = in3->shape[0];
    b_18089 = in3->shape[1];
    pL_mem_35254 = in4->mem;
    n_18088 = in4->shape[0];
    pL_b_18090 = in4->shape[1];
    sizze_thresh_18096 = in5;
    max_depth_18097 = in6;
    if (!((n_18088 == in3->shape[0] && b_18089 == in3->shape[1]) && (n_18088 == in4->shape[0] && pL_b_18090 == in4->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_partition_and_deepen_GFTR(ctx, &mem_out_35845, &mem_out_35846, xs_mem_35253, pL_mem_35254, n_18088, b_18089, pL_b_18090, block_sizze_18091, gather_psizze_18092, radix_sizze_18093, sizze_thresh_18096, max_depth_18097);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_partitionedSet_GFTR *) malloc(sizeof(struct futhark_opaque_partitionedSet_GFTR))) != NULL);
            assert(((*out0)->v0 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v0->mem = mem_out_35845;
            (*out0)->v0->shape[0] = n_18088;
            (*out0)->v0->shape[1] = b_18089;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_35846;
            (*out0)->v1->shape[0] = n_18088;
            (*out0)->v1->shape[1] = pL_b_18090;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_partition_and_deepen_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR **out0, const int16_t in0, const int64_t in1, const int32_t in2, const struct futhark_u8_2d *in3, const int64_t in4, const int64_t in5, const int32_t in6)
{
    int64_t n_19460 = (int64_t) 0;
    int64_t b_19461 = (int64_t) 0;
    int16_t block_sizze_19462 = (int16_t) 0;
    int64_t gather_psizze_19463 = (int64_t) 0;
    int32_t radix_sizze_19464 = 0;
    int64_t offset_19466 = (int64_t) 0;
    int64_t sizze_thresh_19467 = (int64_t) 0;
    int32_t max_depth_19468 = 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_35846;
    
    mem_out_35846.references = NULL;
    
    struct memblock mem_out_35845;
    
    mem_out_35845.references = NULL;
    
    struct memblock xs_mem_35253;
    
    xs_mem_35253.references = NULL;
    block_sizze_19462 = in0;
    gather_psizze_19463 = in1;
    radix_sizze_19464 = in2;
    xs_mem_35253 = in3->mem;
    n_19460 = in3->shape[0];
    b_19461 = in3->shape[1];
    offset_19466 = in4;
    sizze_thresh_19467 = in5;
    max_depth_19468 = in6;
    if (!(n_19460 == in3->shape[0] && b_19461 == in3->shape[1])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_partition_and_deepen_GFUR(ctx, &mem_out_35845, &mem_out_35846, xs_mem_35253, n_19460, b_19461, block_sizze_19462, gather_psizze_19463, radix_sizze_19464, offset_19466, sizze_thresh_19467, max_depth_19468);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_partitionedSet_GFUR *) malloc(sizeof(struct futhark_opaque_partitionedSet_GFUR))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_35845;
            (*out0)->v0->shape[0] = n_19460;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_35846;
            (*out0)->v1->shape[0] = n_19460;
            (*out0)->v1->shape[1] = b_19461;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
  
