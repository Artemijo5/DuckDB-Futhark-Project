// Generated by Futhark 0.26.0 (prerelease - include info below when reporting bugs).
// git: 1de4f0c (Fri Jan 24 11:10:52 2025 +0100)
// Compiled with GHC 9.4.8.

// We need to define _GNU_SOURCE before
// _any_ headers files are imported to get
// the usage statistics of a thread (i.e. have RUSAGE_THREAD) on GNU/Linux
// https://manpages.courier-mta.org/htmlman2/getrusage.2.html
#ifndef _GNU_SOURCE // Avoid possible double-definition warning.
#define _GNU_SOURCE
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-const-variable"
#pragma clang diagnostic ignored "-Wparentheses"
#pragma clang diagnostic ignored "-Wunused-label"
#pragma clang diagnostic ignored "-Wunused-but-set-variable"
#elif __GNUC__
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-const-variable"
#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif

// Headers
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

// Initialisation
struct futhark_context_config;
struct futhark_context_config *futhark_context_config_new(void);
void futhark_context_config_free(struct futhark_context_config *cfg);
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg, const char *param_name, size_t new_value);
struct futhark_context;
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg);
void futhark_context_free(struct futhark_context *cfg);
void futhark_context_config_set_debugging(struct futhark_context_config *cfg, int flag);
void futhark_context_config_set_profiling(struct futhark_context_config *cfg, int flag);
void futhark_context_config_set_logging(struct futhark_context_config *cfg, int flag);
int futhark_get_tuning_param_count(void);
const char *futhark_get_tuning_param_name(int);
const char *futhark_get_tuning_param_class(int);

// Arrays
struct futhark_f32_1d;
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const float *data, int64_t dim0);
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0);
int futhark_free_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr);
int futhark_values_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr, float *data);
int futhark_index_f32_1d(struct futhark_context *ctx, float *out, struct futhark_f32_1d *arr, int64_t i0);
unsigned char *futhark_values_raw_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr);
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr);
struct futhark_f64_1d;
struct futhark_f64_1d *futhark_new_f64_1d(struct futhark_context *ctx, const double *data, int64_t dim0);
struct futhark_f64_1d *futhark_new_raw_f64_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0);
int futhark_free_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr);
int futhark_values_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr, double *data);
int futhark_index_f64_1d(struct futhark_context *ctx, double *out, struct futhark_f64_1d *arr, int64_t i0);
unsigned char *futhark_values_raw_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr);
const int64_t *futhark_shape_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr);
struct futhark_i16_1d;
struct futhark_i16_1d *futhark_new_i16_1d(struct futhark_context *ctx, const int16_t *data, int64_t dim0);
struct futhark_i16_1d *futhark_new_raw_i16_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0);
int futhark_free_i16_1d(struct futhark_context *ctx, struct futhark_i16_1d *arr);
int futhark_values_i16_1d(struct futhark_context *ctx, struct futhark_i16_1d *arr, int16_t *data);
int futhark_index_i16_1d(struct futhark_context *ctx, int16_t *out, struct futhark_i16_1d *arr, int64_t i0);
unsigned char *futhark_values_raw_i16_1d(struct futhark_context *ctx, struct futhark_i16_1d *arr);
const int64_t *futhark_shape_i16_1d(struct futhark_context *ctx, struct futhark_i16_1d *arr);
struct futhark_i32_1d;
struct futhark_i32_1d *futhark_new_i32_1d(struct futhark_context *ctx, const int32_t *data, int64_t dim0);
struct futhark_i32_1d *futhark_new_raw_i32_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0);
int futhark_free_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr);
int futhark_values_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr, int32_t *data);
int futhark_index_i32_1d(struct futhark_context *ctx, int32_t *out, struct futhark_i32_1d *arr, int64_t i0);
unsigned char *futhark_values_raw_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr);
const int64_t *futhark_shape_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr);
struct futhark_i64_1d;
struct futhark_i64_1d *futhark_new_i64_1d(struct futhark_context *ctx, const int64_t *data, int64_t dim0);
struct futhark_i64_1d *futhark_new_raw_i64_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0);
int futhark_free_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr);
int futhark_values_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr, int64_t *data);
int futhark_index_i64_1d(struct futhark_context *ctx, int64_t *out, struct futhark_i64_1d *arr, int64_t i0);
unsigned char *futhark_values_raw_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr);
const int64_t *futhark_shape_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr);
struct futhark_u8_2d;
struct futhark_u8_2d *futhark_new_u8_2d(struct futhark_context *ctx, const uint8_t *data, int64_t dim0, int64_t dim1);
struct futhark_u8_2d *futhark_new_raw_u8_2d(struct futhark_context *ctx, unsigned char *data, int64_t dim0, int64_t dim1);
int futhark_free_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr);
int futhark_values_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr, uint8_t *data);
int futhark_index_u8_2d(struct futhark_context *ctx, uint8_t *out, struct futhark_u8_2d *arr, int64_t i0, int64_t i1);
unsigned char *futhark_values_raw_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr);
const int64_t *futhark_shape_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr);

// Opaque values
struct futhark_opaque_joinPairs_bsq;
struct futhark_opaque_joinPairs_double;
struct futhark_opaque_joinPairs_float;
struct futhark_opaque_joinPairs_int;
struct futhark_opaque_joinPairs_long;
struct futhark_opaque_joinPairs_short;
struct futhark_opaque_partitionInfo;
struct futhark_opaque_partitionedSet_GFTR;
struct futhark_opaque_partitionedSet_GFUR;
struct futhark_opaque_radix_hashTable;
struct futhark_opaque_sortInfo_double;
struct futhark_opaque_sortInfo_float;
struct futhark_opaque_sortInfo_int;
struct futhark_opaque_sortInfo_long;
struct futhark_opaque_sortInfo_short;
struct futhark_opaque_sortStruct_double;
struct futhark_opaque_sortStruct_float;
struct futhark_opaque_sortStruct_int;
struct futhark_opaque_sortStruct_long;
struct futhark_opaque_sortStruct_short;
int futhark_free_opaque_joinPairs_bsq(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq *obj);
int futhark_store_opaque_joinPairs_bsq(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_bsq *obj, void **p, size_t *n);
struct futhark_opaque_joinPairs_bsq *futhark_restore_opaque_joinPairs_bsq(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_joinPairs_bsq_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_bsq *obj);
int futhark_project_opaque_joinPairs_bsq_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_bsq *obj);
int futhark_project_opaque_joinPairs_bsq_vs(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_joinPairs_bsq *obj);
int futhark_new_opaque_joinPairs_bsq(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_u8_2d *f_vs);
int futhark_free_opaque_joinPairs_double(struct futhark_context *ctx, struct futhark_opaque_joinPairs_double *obj);
int futhark_store_opaque_joinPairs_double(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_double *obj, void **p, size_t *n);
struct futhark_opaque_joinPairs_double *futhark_restore_opaque_joinPairs_double(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_joinPairs_double_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_double *obj);
int futhark_project_opaque_joinPairs_double_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_double *obj);
int futhark_project_opaque_joinPairs_double_vs(struct futhark_context *ctx, struct futhark_f64_1d **out, const struct futhark_opaque_joinPairs_double *obj);
int futhark_new_opaque_joinPairs_double(struct futhark_context *ctx, struct futhark_opaque_joinPairs_double **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_f64_1d *f_vs);
int futhark_free_opaque_joinPairs_float(struct futhark_context *ctx, struct futhark_opaque_joinPairs_float *obj);
int futhark_store_opaque_joinPairs_float(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_float *obj, void **p, size_t *n);
struct futhark_opaque_joinPairs_float *futhark_restore_opaque_joinPairs_float(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_joinPairs_float_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_float *obj);
int futhark_project_opaque_joinPairs_float_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_float *obj);
int futhark_project_opaque_joinPairs_float_vs(struct futhark_context *ctx, struct futhark_f32_1d **out, const struct futhark_opaque_joinPairs_float *obj);
int futhark_new_opaque_joinPairs_float(struct futhark_context *ctx, struct futhark_opaque_joinPairs_float **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_f32_1d *f_vs);
int futhark_free_opaque_joinPairs_int(struct futhark_context *ctx, struct futhark_opaque_joinPairs_int *obj);
int futhark_store_opaque_joinPairs_int(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_int *obj, void **p, size_t *n);
struct futhark_opaque_joinPairs_int *futhark_restore_opaque_joinPairs_int(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_joinPairs_int_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_int *obj);
int futhark_project_opaque_joinPairs_int_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_int *obj);
int futhark_project_opaque_joinPairs_int_vs(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_joinPairs_int *obj);
int futhark_new_opaque_joinPairs_int(struct futhark_context *ctx, struct futhark_opaque_joinPairs_int **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_i32_1d *f_vs);
int futhark_free_opaque_joinPairs_long(struct futhark_context *ctx, struct futhark_opaque_joinPairs_long *obj);
int futhark_store_opaque_joinPairs_long(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_long *obj, void **p, size_t *n);
struct futhark_opaque_joinPairs_long *futhark_restore_opaque_joinPairs_long(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_joinPairs_long_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_long *obj);
int futhark_project_opaque_joinPairs_long_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_long *obj);
int futhark_project_opaque_joinPairs_long_vs(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_long *obj);
int futhark_new_opaque_joinPairs_long(struct futhark_context *ctx, struct futhark_opaque_joinPairs_long **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_i64_1d *f_vs);
int futhark_free_opaque_joinPairs_short(struct futhark_context *ctx, struct futhark_opaque_joinPairs_short *obj);
int futhark_store_opaque_joinPairs_short(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_short *obj, void **p, size_t *n);
struct futhark_opaque_joinPairs_short *futhark_restore_opaque_joinPairs_short(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_joinPairs_short_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_short *obj);
int futhark_project_opaque_joinPairs_short_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_short *obj);
int futhark_project_opaque_joinPairs_short_vs(struct futhark_context *ctx, struct futhark_i16_1d **out, const struct futhark_opaque_joinPairs_short *obj);
int futhark_new_opaque_joinPairs_short(struct futhark_context *ctx, struct futhark_opaque_joinPairs_short **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_i16_1d *f_vs);
int futhark_free_opaque_partitionInfo(struct futhark_context *ctx, struct futhark_opaque_partitionInfo *obj);
int futhark_store_opaque_partitionInfo(struct futhark_context *ctx, const struct futhark_opaque_partitionInfo *obj, void **p, size_t *n);
struct futhark_opaque_partitionInfo *futhark_restore_opaque_partitionInfo(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_partitionInfo_bounds(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_partitionInfo *obj);
int futhark_project_opaque_partitionInfo_depths(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_partitionInfo *obj);
int futhark_project_opaque_partitionInfo_maxDepth(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_partitionInfo *obj);
int futhark_new_opaque_partitionInfo(struct futhark_context *ctx, struct futhark_opaque_partitionInfo **out, const struct futhark_i64_1d *f_bounds, const struct futhark_i32_1d *f_depths, const int32_t f_maxDepth);
int futhark_free_opaque_partitionedSet_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR *obj);
int futhark_store_opaque_partitionedSet_GFTR(struct futhark_context *ctx, const struct futhark_opaque_partitionedSet_GFTR *obj, void **p, size_t *n);
struct futhark_opaque_partitionedSet_GFTR *futhark_restore_opaque_partitionedSet_GFTR(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_partitionedSet_GFTR_ks(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFTR *obj);
int futhark_project_opaque_partitionedSet_GFTR_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFTR *obj);
int futhark_new_opaque_partitionedSet_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR **out, const struct futhark_u8_2d *f_ks, const struct futhark_u8_2d *f_pL);
int futhark_free_opaque_partitionedSet_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR *obj);
int futhark_store_opaque_partitionedSet_GFUR(struct futhark_context *ctx, const struct futhark_opaque_partitionedSet_GFUR *obj, void **p, size_t *n);
struct futhark_opaque_partitionedSet_GFUR *futhark_restore_opaque_partitionedSet_GFUR(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_partitionedSet_GFUR_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_partitionedSet_GFUR *obj);
int futhark_project_opaque_partitionedSet_GFUR_ks(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFUR *obj);
int futhark_new_opaque_partitionedSet_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR **out, const struct futhark_i64_1d *f_idx, const struct futhark_u8_2d *f_ks);
int futhark_free_opaque_radix_hashTable(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable *obj);
int futhark_store_opaque_radix_hashTable(struct futhark_context *ctx, const struct futhark_opaque_radix_hashTable *obj, void **p, size_t *n);
struct futhark_opaque_radix_hashTable *futhark_restore_opaque_radix_hashTable(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_radix_hashTable_first_info_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_radix_hashTable *obj);
int futhark_project_opaque_radix_hashTable_last_info_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_radix_hashTable *obj);
int futhark_new_opaque_radix_hashTable(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable **out, const struct futhark_i64_1d *f_first_info_idx, const struct futhark_i64_1d *f_last_info_idx);
int futhark_free_opaque_sortInfo_double(struct futhark_context *ctx, struct futhark_opaque_sortInfo_double *obj);
int futhark_store_opaque_sortInfo_double(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_double *obj, void **p, size_t *n);
struct futhark_opaque_sortInfo_double *futhark_restore_opaque_sortInfo_double(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortInfo_double_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_double *obj);
int futhark_project_opaque_sortInfo_double_xs(struct futhark_context *ctx, struct futhark_f64_1d **out, const struct futhark_opaque_sortInfo_double *obj);
int futhark_new_opaque_sortInfo_double(struct futhark_context *ctx, struct futhark_opaque_sortInfo_double **out, const struct futhark_i64_1d *f_is, const struct futhark_f64_1d *f_xs);
int futhark_free_opaque_sortInfo_float(struct futhark_context *ctx, struct futhark_opaque_sortInfo_float *obj);
int futhark_store_opaque_sortInfo_float(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_float *obj, void **p, size_t *n);
struct futhark_opaque_sortInfo_float *futhark_restore_opaque_sortInfo_float(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortInfo_float_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_float *obj);
int futhark_project_opaque_sortInfo_float_xs(struct futhark_context *ctx, struct futhark_f32_1d **out, const struct futhark_opaque_sortInfo_float *obj);
int futhark_new_opaque_sortInfo_float(struct futhark_context *ctx, struct futhark_opaque_sortInfo_float **out, const struct futhark_i64_1d *f_is, const struct futhark_f32_1d *f_xs);
int futhark_free_opaque_sortInfo_int(struct futhark_context *ctx, struct futhark_opaque_sortInfo_int *obj);
int futhark_store_opaque_sortInfo_int(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_int *obj, void **p, size_t *n);
struct futhark_opaque_sortInfo_int *futhark_restore_opaque_sortInfo_int(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortInfo_int_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_int *obj);
int futhark_project_opaque_sortInfo_int_xs(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_sortInfo_int *obj);
int futhark_new_opaque_sortInfo_int(struct futhark_context *ctx, struct futhark_opaque_sortInfo_int **out, const struct futhark_i64_1d *f_is, const struct futhark_i32_1d *f_xs);
int futhark_free_opaque_sortInfo_long(struct futhark_context *ctx, struct futhark_opaque_sortInfo_long *obj);
int futhark_store_opaque_sortInfo_long(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_long *obj, void **p, size_t *n);
struct futhark_opaque_sortInfo_long *futhark_restore_opaque_sortInfo_long(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortInfo_long_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_long *obj);
int futhark_project_opaque_sortInfo_long_xs(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_long *obj);
int futhark_new_opaque_sortInfo_long(struct futhark_context *ctx, struct futhark_opaque_sortInfo_long **out, const struct futhark_i64_1d *f_is, const struct futhark_i64_1d *f_xs);
int futhark_free_opaque_sortInfo_short(struct futhark_context *ctx, struct futhark_opaque_sortInfo_short *obj);
int futhark_store_opaque_sortInfo_short(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_short *obj, void **p, size_t *n);
struct futhark_opaque_sortInfo_short *futhark_restore_opaque_sortInfo_short(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortInfo_short_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_short *obj);
int futhark_project_opaque_sortInfo_short_xs(struct futhark_context *ctx, struct futhark_i16_1d **out, const struct futhark_opaque_sortInfo_short *obj);
int futhark_new_opaque_sortInfo_short(struct futhark_context *ctx, struct futhark_opaque_sortInfo_short **out, const struct futhark_i64_1d *f_is, const struct futhark_i16_1d *f_xs);
int futhark_free_opaque_sortStruct_double(struct futhark_context *ctx, struct futhark_opaque_sortStruct_double *obj);
int futhark_store_opaque_sortStruct_double(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_double *obj, void **p, size_t *n);
struct futhark_opaque_sortStruct_double *futhark_restore_opaque_sortStruct_double(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortStruct_double_k(struct futhark_context *ctx, struct futhark_f64_1d **out, const struct futhark_opaque_sortStruct_double *obj);
int futhark_project_opaque_sortStruct_double_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_double *obj);
int futhark_new_opaque_sortStruct_double(struct futhark_context *ctx, struct futhark_opaque_sortStruct_double **out, const struct futhark_f64_1d *f_k, const struct futhark_u8_2d *f_pL);
int futhark_free_opaque_sortStruct_float(struct futhark_context *ctx, struct futhark_opaque_sortStruct_float *obj);
int futhark_store_opaque_sortStruct_float(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_float *obj, void **p, size_t *n);
struct futhark_opaque_sortStruct_float *futhark_restore_opaque_sortStruct_float(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortStruct_float_k(struct futhark_context *ctx, struct futhark_f32_1d **out, const struct futhark_opaque_sortStruct_float *obj);
int futhark_project_opaque_sortStruct_float_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_float *obj);
int futhark_new_opaque_sortStruct_float(struct futhark_context *ctx, struct futhark_opaque_sortStruct_float **out, const struct futhark_f32_1d *f_k, const struct futhark_u8_2d *f_pL);
int futhark_free_opaque_sortStruct_int(struct futhark_context *ctx, struct futhark_opaque_sortStruct_int *obj);
int futhark_store_opaque_sortStruct_int(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_int *obj, void **p, size_t *n);
struct futhark_opaque_sortStruct_int *futhark_restore_opaque_sortStruct_int(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortStruct_int_k(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_sortStruct_int *obj);
int futhark_project_opaque_sortStruct_int_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_int *obj);
int futhark_new_opaque_sortStruct_int(struct futhark_context *ctx, struct futhark_opaque_sortStruct_int **out, const struct futhark_i32_1d *f_k, const struct futhark_u8_2d *f_pL);
int futhark_free_opaque_sortStruct_long(struct futhark_context *ctx, struct futhark_opaque_sortStruct_long *obj);
int futhark_store_opaque_sortStruct_long(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_long *obj, void **p, size_t *n);
struct futhark_opaque_sortStruct_long *futhark_restore_opaque_sortStruct_long(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortStruct_long_k(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortStruct_long *obj);
int futhark_project_opaque_sortStruct_long_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_long *obj);
int futhark_new_opaque_sortStruct_long(struct futhark_context *ctx, struct futhark_opaque_sortStruct_long **out, const struct futhark_i64_1d *f_k, const struct futhark_u8_2d *f_pL);
int futhark_free_opaque_sortStruct_short(struct futhark_context *ctx, struct futhark_opaque_sortStruct_short *obj);
int futhark_store_opaque_sortStruct_short(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_short *obj, void **p, size_t *n);
struct futhark_opaque_sortStruct_short *futhark_restore_opaque_sortStruct_short(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_sortStruct_short_k(struct futhark_context *ctx, struct futhark_i16_1d **out, const struct futhark_opaque_sortStruct_short *obj);
int futhark_project_opaque_sortStruct_short_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_short *obj);
int futhark_new_opaque_sortStruct_short(struct futhark_context *ctx, struct futhark_opaque_sortStruct_short **out, const struct futhark_i16_1d *f_k, const struct futhark_u8_2d *f_pL);

// Entry points
int futhark_entry_Inner_Radix_Hash_Join(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq **out0, const int32_t in0, const struct futhark_u8_2d *in1, const struct futhark_u8_2d *in2, const struct futhark_opaque_partitionInfo *in3, const struct futhark_opaque_radix_hashTable *in4);
int futhark_entry_argmin_double(struct futhark_context *ctx, int64_t *out0, const struct futhark_f64_1d *in0);
int futhark_entry_argmin_float(struct futhark_context *ctx, int64_t *out0, const struct futhark_f32_1d *in0);
int futhark_entry_argmin_int(struct futhark_context *ctx, int64_t *out0, const struct futhark_i32_1d *in0);
int futhark_entry_argmin_long(struct futhark_context *ctx, int64_t *out0, const struct futhark_i64_1d *in0);
int futhark_entry_argmin_short(struct futhark_context *ctx, int64_t *out0, const struct futhark_i16_1d *in0);
int futhark_entry_calc_partitions_from_partitioned_set(struct futhark_context *ctx, struct futhark_opaque_partitionInfo **out0, const int32_t in0, const struct futhark_u8_2d *in1, const int64_t in2, const int64_t in3, const int32_t in4);
int futhark_entry_create_hash_table_from_partitioned_set(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable **out0, const int32_t in0, const struct futhark_u8_2d *in1, const struct futhark_opaque_partitionInfo *in2, const int64_t in3);
int futhark_entry_gather_payloads_GFTR(struct futhark_context *ctx, struct futhark_u8_2d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const int64_t in3, const struct futhark_u8_2d *in4);
int futhark_entry_gather_payloads_double(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_f64_1d *in3);
int futhark_entry_gather_payloads_double_GFUR(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_f64_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_f64_1d *in4);
int futhark_entry_gather_payloads_float(struct futhark_context *ctx, struct futhark_f32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_f32_1d *in3);
int futhark_entry_gather_payloads_float_GFUR(struct futhark_context *ctx, struct futhark_f32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_f32_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_f32_1d *in4);
int futhark_entry_gather_payloads_int(struct futhark_context *ctx, struct futhark_i32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i32_1d *in3);
int futhark_entry_gather_payloads_int_GFUR(struct futhark_context *ctx, struct futhark_i32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i32_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_i32_1d *in4);
int futhark_entry_gather_payloads_long(struct futhark_context *ctx, struct futhark_i64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i64_1d *in3);
int futhark_entry_gather_payloads_long_GFUR(struct futhark_context *ctx, struct futhark_i64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_i64_1d *in4);
int futhark_entry_gather_payloads_short(struct futhark_context *ctx, struct futhark_i16_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i16_1d *in3);
int futhark_entry_gather_payloads_short_GFUR(struct futhark_context *ctx, struct futhark_i16_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i16_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_i16_1d *in4);
int futhark_entry_inner_SMJ_double(struct futhark_context *ctx, struct futhark_opaque_joinPairs_double **out0, const struct futhark_f64_1d *in0, const struct futhark_f64_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5);
int futhark_entry_inner_SMJ_float(struct futhark_context *ctx, struct futhark_opaque_joinPairs_float **out0, const struct futhark_f32_1d *in0, const struct futhark_f32_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5);
int futhark_entry_inner_SMJ_int(struct futhark_context *ctx, struct futhark_opaque_joinPairs_int **out0, const struct futhark_i32_1d *in0, const struct futhark_i32_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5);
int futhark_entry_inner_SMJ_long(struct futhark_context *ctx, struct futhark_opaque_joinPairs_long **out0, const struct futhark_i64_1d *in0, const struct futhark_i64_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5);
int futhark_entry_inner_SMJ_short(struct futhark_context *ctx, struct futhark_opaque_joinPairs_short **out0, const struct futhark_i16_1d *in0, const struct futhark_i16_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5);
int futhark_entry_max_idx(struct futhark_context *ctx, int64_t *out0, const struct futhark_i64_1d *in0);
int futhark_entry_mergeSortColumn_double(struct futhark_context *ctx, struct futhark_opaque_sortInfo_double **out0, const int64_t in0, const struct futhark_f64_1d *in1);
int futhark_entry_mergeSortColumn_float(struct futhark_context *ctx, struct futhark_opaque_sortInfo_float **out0, const int64_t in0, const struct futhark_f32_1d *in1);
int futhark_entry_mergeSortColumn_int(struct futhark_context *ctx, struct futhark_opaque_sortInfo_int **out0, const int64_t in0, const struct futhark_i32_1d *in1);
int futhark_entry_mergeSortColumn_long(struct futhark_context *ctx, struct futhark_opaque_sortInfo_long **out0, const int64_t in0, const struct futhark_i64_1d *in1);
int futhark_entry_mergeSortColumn_short(struct futhark_context *ctx, struct futhark_opaque_sortInfo_short **out0, const int64_t in0, const struct futhark_i16_1d *in1);
int futhark_entry_mergeSortRelation_double(struct futhark_context *ctx, struct futhark_opaque_sortStruct_double **out0, const struct futhark_opaque_sortStruct_double *in0);
int futhark_entry_mergeSortRelation_float(struct futhark_context *ctx, struct futhark_opaque_sortStruct_float **out0, const struct futhark_opaque_sortStruct_float *in0);
int futhark_entry_mergeSortRelation_int(struct futhark_context *ctx, struct futhark_opaque_sortStruct_int **out0, const struct futhark_opaque_sortStruct_int *in0);
int futhark_entry_mergeSortRelation_long(struct futhark_context *ctx, struct futhark_opaque_sortStruct_long **out0, const struct futhark_opaque_sortStruct_long *in0);
int futhark_entry_mergeSortRelation_short(struct futhark_context *ctx, struct futhark_opaque_sortStruct_short **out0, const struct futhark_opaque_sortStruct_short *in0);
int futhark_entry_min_idx(struct futhark_context *ctx, int64_t *out0, const struct futhark_i64_1d *in0);
int futhark_entry_orderByIndices_double(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_f64_1d *in3);
int futhark_entry_orderByIndices_float(struct futhark_context *ctx, struct futhark_f32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_f32_1d *in3);
int futhark_entry_orderByIndices_int(struct futhark_context *ctx, struct futhark_i32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i32_1d *in3);
int futhark_entry_orderByIndices_long(struct futhark_context *ctx, struct futhark_i64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i64_1d *in3);
int futhark_entry_orderByIndices_short(struct futhark_context *ctx, struct futhark_i16_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i16_1d *in3);
int futhark_entry_partition_and_deepen_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR **out0, const int16_t in0, const int64_t in1, const int32_t in2, const struct futhark_u8_2d *in3, const struct futhark_u8_2d *in4, const int64_t in5, const int32_t in6);
int futhark_entry_partition_and_deepen_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR **out0, const int16_t in0, const int64_t in1, const int32_t in2, const struct futhark_u8_2d *in3, const int64_t in4, const int64_t in5, const int32_t in6);
int futhark_entry_radixSortColumn_double(struct futhark_context *ctx, struct futhark_opaque_sortInfo_double **out0, const int64_t in0, const int16_t in1, const struct futhark_f64_1d *in2);
int futhark_entry_radixSortColumn_float(struct futhark_context *ctx, struct futhark_opaque_sortInfo_float **out0, const int64_t in0, const int16_t in1, const struct futhark_f32_1d *in2);
int futhark_entry_radixSortColumn_int(struct futhark_context *ctx, struct futhark_opaque_sortInfo_int **out0, const int64_t in0, const int16_t in1, const struct futhark_i32_1d *in2);
int futhark_entry_radixSortColumn_long(struct futhark_context *ctx, struct futhark_opaque_sortInfo_long **out0, const int64_t in0, const int16_t in1, const struct futhark_i64_1d *in2);
int futhark_entry_radixSortColumn_short(struct futhark_context *ctx, struct futhark_opaque_sortInfo_short **out0, const int64_t in0, const int16_t in1, const struct futhark_i16_1d *in2);
int futhark_entry_radixSortRelation_double(struct futhark_context *ctx, struct futhark_opaque_sortStruct_double **out0, const int16_t in0, const struct futhark_opaque_sortStruct_double *in1);
int futhark_entry_radixSortRelation_float(struct futhark_context *ctx, struct futhark_opaque_sortStruct_float **out0, const int16_t in0, const struct futhark_opaque_sortStruct_float *in1);
int futhark_entry_radixSortRelation_int(struct futhark_context *ctx, struct futhark_opaque_sortStruct_int **out0, const int16_t in0, const struct futhark_opaque_sortStruct_int *in1);
int futhark_entry_radixSortRelation_long(struct futhark_context *ctx, struct futhark_opaque_sortStruct_long **out0, const int16_t in0, const struct futhark_opaque_sortStruct_long *in1);
int futhark_entry_radixSortRelation_short(struct futhark_context *ctx, struct futhark_opaque_sortStruct_short **out0, const int16_t in0, const struct futhark_opaque_sortStruct_short *in1);

// Miscellaneous
int futhark_context_sync(struct futhark_context *ctx);
void futhark_context_config_set_cache_file(struct futhark_context_config *cfg, const char *f);
char *futhark_context_get_error(struct futhark_context *ctx);
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f);
void futhark_context_pause_profiling(struct futhark_context *ctx);
void futhark_context_unpause_profiling(struct futhark_context *ctx);
char *futhark_context_report(struct futhark_context *ctx);
int futhark_context_clear_caches(struct futhark_context *ctx);
#define FUTHARK_BACKEND_c
#define FUTHARK_SUCCESS 0
#define FUTHARK_PROGRAM_ERROR 2
#define FUTHARK_OUT_OF_MEMORY 3

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <stdint.h>
// If NDEBUG is set, the assert() macro will do nothing. Since Futhark
// (unfortunately) makes use of assert() for error detection (and even some
// side effects), we want to avoid that.
#undef NDEBUG
#include <assert.h>
#include <stdarg.h>
#define SCALAR_FUN_ATTR static inline
// Start of util.h.
//
// Various helper functions that are useful in all generated C code.

#include <errno.h>
#include <string.h>

static const char *fut_progname = "(embedded Futhark)";

static void futhark_panic(int eval, const char *fmt, ...) __attribute__((noreturn));
static char* msgprintf(const char *s, ...);
static void* slurp_file(const char *filename, size_t *size);
static int dump_file(const char *file, const void *buf, size_t n);
struct str_builder;
static void str_builder_init(struct str_builder *b);
static void str_builder(struct str_builder *b, const char *s, ...);
static char *strclone(const char *str);

static void futhark_panic(int eval, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  fprintf(stderr, "%s: ", fut_progname);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  exit(eval);
}

// For generating arbitrary-sized error messages.  It is the callers
// responsibility to free the buffer at some point.
static char* msgprintf(const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = 1 + (size_t)vsnprintf(NULL, 0, s, vl);
  char *buffer = (char*) malloc(needed);
  va_start(vl, s); // Must re-init.
  vsnprintf(buffer, needed, s, vl);
  return buffer;
}

static inline void check_err(int errval, int sets_errno, const char *fun, int line,
                             const char *msg, ...) {
  if (errval) {
    char errnum[10];

    va_list vl;
    va_start(vl, msg);

    fprintf(stderr, "ERROR: ");
    vfprintf(stderr, msg, vl);
    fprintf(stderr, " in %s() at line %d with error code %s\n",
            fun, line,
            sets_errno ? strerror(errno) : errnum);
    exit(errval);
  }
}

#define CHECK_ERR(err, ...) check_err(err, 0, __func__, __LINE__, __VA_ARGS__)
#define CHECK_ERRNO(err, ...) check_err(err, 1, __func__, __LINE__, __VA_ARGS__)

// Read the rest of an open file into a NUL-terminated string; returns
// NULL on error.
static void* fslurp_file(FILE *f, size_t *size) {
  long start = ftell(f);
  fseek(f, 0, SEEK_END);
  long src_size = ftell(f)-start;
  fseek(f, start, SEEK_SET);
  unsigned char *s = (unsigned char*) malloc((size_t)src_size + 1);
  if (fread(s, 1, (size_t)src_size, f) != (size_t)src_size) {
    free(s);
    s = NULL;
  } else {
    s[src_size] = '\0';
  }

  if (size) {
    *size = (size_t)src_size;
  }

  return s;
}

// Read a file into a NUL-terminated string; returns NULL on error.
static void* slurp_file(const char *filename, size_t *size) {
  FILE *f = fopen(filename, "rb"); // To avoid Windows messing with linebreaks.
  if (f == NULL) return NULL;
  unsigned char *s = fslurp_file(f, size);
  fclose(f);
  return s;
}

// Dump 'n' bytes from 'buf' into the file at the designated location.
// Returns 0 on success.
static int dump_file(const char *file, const void *buf, size_t n) {
  FILE *f = fopen(file, "w");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(buf, sizeof(char), n, f) != n) {
    return 1;
  }

  if (fclose(f) != 0) {
    return 1;
  }

  return 0;
}

struct str_builder {
  char *str;
  size_t capacity; // Size of buffer.
  size_t used; // Bytes used, *not* including final zero.
};

static void str_builder_init(struct str_builder *b) {
  b->capacity = 10;
  b->used = 0;
  b->str = malloc(b->capacity);
  b->str[0] = 0;
}

static void str_builder(struct str_builder *b, const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = (size_t)vsnprintf(NULL, 0, s, vl);

  while (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }

  va_start(vl, s); // Must re-init.
  vsnprintf(b->str+b->used, b->capacity-b->used, s, vl);
  b->used += needed;
}

static void str_builder_str(struct str_builder *b, const char *s) {
  size_t needed = strlen(s);
  if (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }
  strcpy(b->str+b->used, s);
  b->used += needed;
}

static void str_builder_char(struct str_builder *b, char c) {
  size_t needed = 1;
  if (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }
  b->str[b->used] = c;
  b->str[b->used+1] = 0;
  b->used += needed;
}

static void str_builder_json_str(struct str_builder* sb, const char* s) {
  str_builder_char(sb, '"');
  for (int j = 0; s[j]; j++) {
    char c = s[j];
    switch (c) {
    case '\n':
      str_builder_str(sb, "\\n");
      break;
    case '"':
      str_builder_str(sb, "\\\"");
      break;
    default:
      str_builder_char(sb, c);
    }
  }
  str_builder_char(sb, '"');
}

static char *strclone(const char *str) {
  size_t size = strlen(str) + 1;
  char *copy = (char*) malloc(size);
  if (copy == NULL) {
    return NULL;
  }

  memcpy(copy, str, size);
  return copy;
}

// Assumes NULL-terminated.
static char *strconcat(const char *src_fragments[]) {
  size_t src_len = 0;
  const char **p;

  for (p = src_fragments; *p; p++) {
    src_len += strlen(*p);
  }

  char *src = (char*) malloc(src_len + 1);
  size_t n = 0;
  for (p = src_fragments; *p; p++) {
    strcpy(src + n, *p);
    n += strlen(*p);
  }

  return src;
}

// End of util.h.
// Start of cache.h

#define CACHE_HASH_SIZE 8 // In 32-bit words.

struct cache_hash {
  uint32_t hash[CACHE_HASH_SIZE];
};

// Initialise a blank cache.
static void cache_hash_init(struct cache_hash *c);

// Hash some bytes and add them to the accumulated hash.
static void cache_hash(struct cache_hash *out, const char *in, size_t n);

// Try to restore cache contents from a file with the given name.
// Assumes the cache is invalid if it contains the given hash.
// Allocates memory and reads the cache conents, which is returned in
// *buf with size *buflen.  If the cache is successfully loaded, this
// function returns 0.  Otherwise it returns nonzero.  Errno is set if
// the failure to load the cache is due to anything except invalid
// cache conents.  Note that failing to restore the cache is not
// necessarily a problem: it might just be invalid or not created yet.
static int cache_restore(const char *fname, const struct cache_hash *hash,
                         unsigned char **buf, size_t *buflen);

// Store cache contents in the given file, with the given hash.
static int cache_store(const char *fname, const struct cache_hash *hash,
                       const unsigned char *buf, size_t buflen);

// Now for the implementation.

static void cache_hash_init(struct cache_hash *c) {
  memset(c->hash, 0, CACHE_HASH_SIZE * sizeof(uint32_t));
}

static void cache_hash(struct cache_hash *out, const char *in, size_t n) {
  // Adaptation of djb2 for larger output size by storing intermediate
  // states.
  uint32_t hash = 5381;
  for (size_t i = 0; i < n; i++) {
    hash = ((hash << 5) + hash) + in[i];
    out->hash[i % CACHE_HASH_SIZE] ^= hash;
  }
}

#define CACHE_HEADER_SIZE 8
static const char cache_header[CACHE_HEADER_SIZE] = "FUTHARK\0";

static int cache_restore(const char *fname, const struct cache_hash *hash,
                         unsigned char **buf, size_t *buflen) {
  FILE *f = fopen(fname, "rb");

  if (f == NULL) {
    return 1;
  }

  char f_header[CACHE_HEADER_SIZE];

  if (fread(f_header, sizeof(char), CACHE_HEADER_SIZE, f) != CACHE_HEADER_SIZE) {
    goto error;
  }

  if (memcmp(f_header, cache_header, CACHE_HEADER_SIZE) != 0) {
    goto error;
  }

  if (fseek(f, 0, SEEK_END) != 0) {
    goto error;
  }
  int64_t f_size = (int64_t)ftell(f);
  if (fseek(f, CACHE_HEADER_SIZE, SEEK_SET) != 0) {
    goto error;
  }

  int64_t expected_size;

  if (fread(&expected_size, sizeof(int64_t), 1, f) != 1) {
    goto error;
  }

  if (f_size != expected_size) {
    errno = 0;
    goto error;
  }

  int32_t f_hash[CACHE_HASH_SIZE];

  if (fread(f_hash, sizeof(int32_t), CACHE_HASH_SIZE, f) != CACHE_HASH_SIZE) {
    goto error;
  }

  if (memcmp(f_hash, hash->hash, CACHE_HASH_SIZE) != 0) {
    errno = 0;
    goto error;
  }

  *buflen = f_size - CACHE_HEADER_SIZE - sizeof(int64_t) - CACHE_HASH_SIZE*sizeof(int32_t);
  *buf = malloc(*buflen);
  if (fread(*buf, sizeof(char), *buflen, f) != *buflen) {
    free(*buf);
    goto error;
  }

  fclose(f);

  return 0;

 error:
  fclose(f);
  return 1;
}

static int cache_store(const char *fname, const struct cache_hash *hash,
                       const unsigned char *buf, size_t buflen) {
  FILE *f = fopen(fname, "wb");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(cache_header, CACHE_HEADER_SIZE, 1, f) != 1) {
    goto error;
  }

  int64_t size = CACHE_HEADER_SIZE + sizeof(int64_t) + CACHE_HASH_SIZE*sizeof(int32_t) + buflen;

  if (fwrite(&size, sizeof(size), 1, f) != 1) {
    goto error;
  }

  if (fwrite(hash->hash, sizeof(int32_t), CACHE_HASH_SIZE, f) != CACHE_HASH_SIZE) {
    goto error;
  }

  if (fwrite(buf, sizeof(unsigned char), buflen, f) != buflen) {
    goto error;
  }

  fclose(f);

  return 0;

 error:
  fclose(f);
  return 1;
}

// End of cache.h
// Start of half.h.

// Conversion functions are from http://half.sourceforge.net/, but
// translated to C.
//
// Copyright (c) 2012-2021 Christian Rau
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef __OPENCL_VERSION__
#define __constant
#endif

__constant static const uint16_t base_table[512] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };

__constant static const unsigned char shift_table[512] = {
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };

__constant static const uint32_t mantissa_table[2048] = {
  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
  0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
  0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
__constant static const uint32_t exponent_table[64] = {
  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
__constant static const unsigned short offset_table[64] = {
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };

SCALAR_FUN_ATTR uint16_t float2halfbits(float value) {
  union { float x; uint32_t y; } u;
  u.x = value;
  uint32_t bits = u.y;

  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;

  return hbits;
}

SCALAR_FUN_ATTR float halfbits2float(uint16_t value) {
  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];

  union { uint32_t x; float y; } u;
  u.x = bits;
  return u.y;
}

SCALAR_FUN_ATTR uint16_t halfbitsnextafter(uint16_t from, uint16_t to) {
  int fabs = from & 0x7FFF, tabs = to & 0x7FFF;
  if(fabs > 0x7C00 || tabs > 0x7C00) {
    return ((from&0x7FFF)>0x7C00) ? (from|0x200) : (to|0x200);
  }
  if(from == to || !(fabs|tabs)) {
    return to;
  }
  if(!fabs) {
    return (to&0x8000)+1;
  }
  unsigned int out =
    from +
    (((from>>15)^(unsigned int)((from^(0x8000|(0x8000-(from>>15))))<(to^(0x8000|(0x8000-(to>>15))))))<<1)
    - 1;
  return out;
}

// End of half.h.
// Start of timing.h.

// The function get_wall_time() returns the wall time in microseconds
// (with an unspecified offset).

#ifdef _WIN32

#include <windows.h>

static int64_t get_wall_time(void) {
  LARGE_INTEGER time,freq;
  assert(QueryPerformanceFrequency(&freq));
  assert(QueryPerformanceCounter(&time));
  return ((double)time.QuadPart / freq.QuadPart) * 1000000;
}

static int64_t get_wall_time_ns(void) {
  return get_wall_time() * 1000;
}

#else
// Assuming POSIX

#include <time.h>
#include <sys/time.h>

static int64_t get_wall_time(void) {
  struct timeval time;
  assert(gettimeofday(&time,NULL) == 0);
  return time.tv_sec * 1000000 + time.tv_usec;
}

static int64_t get_wall_time_ns(void) {
  struct timespec time;
  assert(clock_gettime(CLOCK_REALTIME, &time) == 0);
  return time.tv_sec * 1000000000 + time.tv_nsec;
}

#endif

// End of timing.h.
// Start of lock.h.

// A very simple cross-platform implementation of locks.  Uses
// pthreads on Unix and some Windows thing there.  Futhark's
// host-level code is not multithreaded, but user code may be, so we
// need some mechanism for ensuring atomic access to API functions.
// This is that mechanism.  It is not exposed to user code at all, so
// we do not have to worry about name collisions.

#ifdef _WIN32

typedef HANDLE lock_t;

static void create_lock(lock_t *lock) {
  *lock = CreateMutex(NULL,  // Default security attributes.
                      FALSE, // Initially unlocked.
                      NULL); // Unnamed.
}

static void lock_lock(lock_t *lock) {
  assert(WaitForSingleObject(*lock, INFINITE) == WAIT_OBJECT_0);
}

static void lock_unlock(lock_t *lock) {
  assert(ReleaseMutex(*lock));
}

static void free_lock(lock_t *lock) {
  CloseHandle(*lock);
}

#else
// Assuming POSIX

#include <pthread.h>

typedef pthread_mutex_t lock_t;

static void create_lock(lock_t *lock) {
  int r = pthread_mutex_init(lock, NULL);
  assert(r == 0);
}

static void lock_lock(lock_t *lock) {
  int r = pthread_mutex_lock(lock);
  assert(r == 0);
}

static void lock_unlock(lock_t *lock) {
  int r = pthread_mutex_unlock(lock);
  assert(r == 0);
}

static void free_lock(lock_t *lock) {
  // Nothing to do for pthreads.
  (void)lock;
}

#endif

// End of lock.h.
// Start of free_list.h.

typedef uintptr_t fl_mem;

// An entry in the free list.  May be invalid, to avoid having to
// deallocate entries as soon as they are removed.  There is also a
// tag, to help with memory reuse.
struct free_list_entry {
  size_t size;
  fl_mem mem;
  const char *tag;
  unsigned char valid;
};

struct free_list {
  struct free_list_entry *entries; // Pointer to entries.
  int capacity;                    // Number of entries.
  int used;                        // Number of valid entries.
  lock_t lock;                     // Thread safety.
};

static void free_list_init(struct free_list *l) {
  l->capacity = 30; // Picked arbitrarily.
  l->used = 0;
  l->entries = (struct free_list_entry*) malloc(sizeof(struct free_list_entry) * l->capacity);
  for (int i = 0; i < l->capacity; i++) {
    l->entries[i].valid = 0;
  }
  create_lock(&l->lock);
}

// Remove invalid entries from the free list.
static void free_list_pack(struct free_list *l) {
  lock_lock(&l->lock);
  int p = 0;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[p] = l->entries[i];
      if (i > p) {
        l->entries[i].valid = 0;
      }
      p++;
    }
  }

  // Now p is the number of used elements.  We don't want it to go
  // less than the default capacity (although in practice it's OK as
  // long as it doesn't become 1).
  if (p < 30) {
    p = 30;
  }
  l->entries = realloc(l->entries, p * sizeof(struct free_list_entry));
  l->capacity = p;
  lock_unlock(&l->lock);
}

static void free_list_destroy(struct free_list *l) {
  assert(l->used == 0);
  free(l->entries);
  free_lock(&l->lock);
}

// Not part of the interface, so no locking.
static int free_list_find_invalid(struct free_list *l) {
  int i;
  for (i = 0; i < l->capacity; i++) {
    if (!l->entries[i].valid) {
      break;
    }
  }
  return i;
}

static void free_list_insert(struct free_list *l, size_t size, fl_mem mem, const char *tag) {
  lock_lock(&l->lock);
  int i = free_list_find_invalid(l);

  if (i == l->capacity) {
    // List is full; so we have to grow it.
    int new_capacity = l->capacity * 2 * sizeof(struct free_list_entry);
    l->entries = realloc(l->entries, new_capacity);
    for (int j = 0; j < l->capacity; j++) {
      l->entries[j+l->capacity].valid = 0;
    }
    l->capacity *= 2;
  }

  // Now 'i' points to the first invalid entry.
  l->entries[i].valid = 1;
  l->entries[i].size = size;
  l->entries[i].mem = mem;
  l->entries[i].tag = tag;

  l->used++;
  lock_unlock(&l->lock);
}

// Determine whether this entry in the free list is acceptable for
// satisfying the request.  Not public, so no locking.
static bool free_list_acceptable(size_t size, const char* tag, struct free_list_entry *entry) {
  // We check not just the hard requirement (is the entry acceptable
  // and big enough?) but also put a cap on how much wasted space
  // (internal fragmentation) we allow.  This is necessarily a
  // heuristic, and a crude one.

  if (!entry->valid) {
    return false;
  }

  if (size > entry->size) {
    return false;
  }

  // We know the block fits.  Now the question is whether it is too
  // big.  Our policy is as follows:
  //
  // 1) We don't care about wasted space below 4096 bytes (to avoid
  // churn in tiny allocations).
  //
  // 2) If the tag matches, we allow _any_ amount of wasted space.
  //
  // 3) Otherwise we allow up to 50% wasted space.

  if (entry->size < 4096) {
    return true;
  }

  if (entry->tag == tag) {
    return true;
  }

  if (entry->size < size * 2) {
    return true;
  }

  return false;
}

// Find and remove a memory block of the indicated tag, or if that
// does not exist, another memory block with exactly the desired size.
// Returns 0 on success.
static int free_list_find(struct free_list *l, size_t size, const char *tag,
                          size_t *size_out, fl_mem *mem_out) {
  lock_lock(&l->lock);
  int size_match = -1;
  int i;
  int ret = 1;
  for (i = 0; i < l->capacity; i++) {
    if (free_list_acceptable(size, tag, &l->entries[i]) &&
        (size_match < 0 || l->entries[i].size < l->entries[size_match].size)) {
      // If this entry is valid, has sufficient size, and is smaller than the
      // best entry found so far, use this entry.
      size_match = i;
    }
  }

  if (size_match >= 0) {
    l->entries[size_match].valid = 0;
    *size_out = l->entries[size_match].size;
    *mem_out = l->entries[size_match].mem;
    l->used--;
    ret = 0;
  }
  lock_unlock(&l->lock);
  return ret;
}

// Remove the first block in the free list.  Returns 0 if a block was
// removed, and nonzero if the free list was already empty.
static int free_list_first(struct free_list *l, fl_mem *mem_out) {
  lock_lock(&l->lock);
  int ret = 1;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[i].valid = 0;
      *mem_out = l->entries[i].mem;
      l->used--;
      ret = 0;
      break;
    }
  }
  lock_unlock(&l->lock);
  return ret;
}

// End of free_list.h.
// Start of event_list.h

typedef int (*event_report_fn)(struct str_builder*, void*);

struct event {
  void* data;
  event_report_fn f;
  const char* name;
  char *description;
};

struct event_list {
  struct event *events;
  int num_events;
  int capacity;
};

static void event_list_init(struct event_list *l) {
  l->capacity = 100;
  l->num_events = 0;
  l->events = calloc(l->capacity, sizeof(struct event));
}

static void event_list_free(struct event_list *l) {
  free(l->events);
}

static void add_event_to_list(struct event_list *l,
                              const char* name,
                              char* description,
                              void* data,
                              event_report_fn f) {
  if (l->num_events == l->capacity) {
    l->capacity *= 2;
    l->events = realloc(l->events, l->capacity * sizeof(struct event));
  }
  l->events[l->num_events].name = name;
  l->events[l->num_events].description = description;
  l->events[l->num_events].data = data;
  l->events[l->num_events].f = f;
  l->num_events++;
}

static int report_events_in_list(struct event_list *l,
                                 struct str_builder* sb) {
  int ret = 0;
  for (int i = 0; i < l->num_events; i++) {
    if (i != 0) {
      str_builder_str(sb, ",");
    }
    str_builder_str(sb, "{\"name\":");
    str_builder_json_str(sb, l->events[i].name);
    str_builder_str(sb, ",\"description\":");
    str_builder_json_str(sb, l->events[i].description);
    free(l->events[i].description);
    if (l->events[i].f(sb, l->events[i].data) != 0) {
      ret = 1;
      break;
    }
    str_builder(sb, "}");
  }
  event_list_free(l);
  event_list_init(l);
  return ret;
}

// End of event_list.h

#ifdef _MSC_VER
#define inline __inline
#endif
#include <string.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <ctype.h>



#define FUTHARK_F64_ENABLED

// Start of scalar.h.

// Implementation of the primitive scalar operations.  Very
// repetitive.  This code is inserted directly into both CUDA and
// OpenCL programs, as well as the CPU code, so it has some #ifdefs to
// work everywhere.  Some operations are defined as macros because
// this allows us to use them as constant expressions in things like
// array sizes and static initialisers.

// Some of the #ifdefs are because OpenCL uses type-generic functions
// for some operations (e.g. sqrt), while C and CUDA sensibly use
// distinct functions for different precisions (e.g. sqrtf() and
// sqrt()).  This is quite annoying.  Due to C's unfortunate casting
// rules, it is also really easy to accidentally implement
// floating-point functions in the wrong precision, so be careful.

// Double-precision definitions are only included if the preprocessor
// macro FUTHARK_F64_ENABLED is set.

SCALAR_FUN_ATTR int32_t futrts_to_bits32(float x);
SCALAR_FUN_ATTR float futrts_from_bits32(int32_t x);

SCALAR_FUN_ATTR uint8_t add8(uint8_t x, uint8_t y) {
  return x + y;
}

SCALAR_FUN_ATTR uint16_t add16(uint16_t x, uint16_t y) {
  return x + y;
}

SCALAR_FUN_ATTR uint32_t add32(uint32_t x, uint32_t y) {
  return x + y;
}

SCALAR_FUN_ATTR uint64_t add64(uint64_t x, uint64_t y) {
  return x + y;
}

SCALAR_FUN_ATTR uint8_t sub8(uint8_t x, uint8_t y) {
  return x - y;
}

SCALAR_FUN_ATTR uint16_t sub16(uint16_t x, uint16_t y) {
  return x - y;
}

SCALAR_FUN_ATTR uint32_t sub32(uint32_t x, uint32_t y) {
  return x - y;
}

SCALAR_FUN_ATTR uint64_t sub64(uint64_t x, uint64_t y) {
  return x - y;
}

SCALAR_FUN_ATTR uint8_t mul8(uint8_t x, uint8_t y) {
  return x * y;
}

SCALAR_FUN_ATTR uint16_t mul16(uint16_t x, uint16_t y) {
  return x * y;
}

SCALAR_FUN_ATTR uint32_t mul32(uint32_t x, uint32_t y) {
  return x * y;
}

SCALAR_FUN_ATTR uint64_t mul64(uint64_t x, uint64_t y) {
  return x * y;
}

#if ISPC

SCALAR_FUN_ATTR uint8_t udiv8(uint8_t x, uint8_t y) {
  // This strange pattern is used to prevent the ISPC compiler from
  // causing SIGFPEs and bogus results on divisions where inactive lanes
  // have 0-valued divisors. It ensures that any inactive lane instead
  // has a divisor of 1. https://github.com/ispc/ispc/issues/2292
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR uint16_t udiv16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR uint32_t udiv32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }


  return x / ys;
}

SCALAR_FUN_ATTR uint64_t udiv64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }


  return x / ys;
}

SCALAR_FUN_ATTR uint8_t udiv_up8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }


  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint16_t udiv_up16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint32_t udiv_up32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint64_t udiv_up64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint8_t umod8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR uint16_t umod16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }


  return x % ys;
}

SCALAR_FUN_ATTR uint32_t umod32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR uint64_t umod64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint8_t umod_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR uint16_t umod_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR uint32_t umod_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR uint64_t umod_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int8_t sdiv8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int8_t q = x / ys;
  int8_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int16_t sdiv16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int16_t q = x / ys;
  int16_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int32_t sdiv32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  int32_t q = x / ys;
  int32_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int64_t sdiv64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int64_t q = x / ys;
  int64_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

SCALAR_FUN_ATTR int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

SCALAR_FUN_ATTR int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

SCALAR_FUN_ATTR int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

SCALAR_FUN_ATTR int8_t smod8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int8_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int16_t smod16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int16_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int32_t smod32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int32_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int64_t smod64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  int64_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

SCALAR_FUN_ATTR int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

SCALAR_FUN_ATTR int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

SCALAR_FUN_ATTR int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

SCALAR_FUN_ATTR int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

SCALAR_FUN_ATTR int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

SCALAR_FUN_ATTR int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

SCALAR_FUN_ATTR int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

SCALAR_FUN_ATTR int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

SCALAR_FUN_ATTR int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

SCALAR_FUN_ATTR int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

SCALAR_FUN_ATTR int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

SCALAR_FUN_ATTR int8_t squot8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR int16_t squot16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR int32_t squot32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR int64_t squot64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

SCALAR_FUN_ATTR int8_t srem8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR int16_t srem16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR int32_t srem32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR int64_t srem64(int64_t x, int64_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x % ys;
}

SCALAR_FUN_ATTR int8_t squot_safe8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int16_t squot_safe16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int32_t squot_safe32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int64_t squot_safe64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int8_t srem_safe8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int16_t srem_safe16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int32_t srem_safe32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int64_t srem_safe64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return y == 0 ? 0 : x % ys;
}

#else

SCALAR_FUN_ATTR uint8_t udiv8(uint8_t x, uint8_t y) {
  return x / y;
}

SCALAR_FUN_ATTR uint16_t udiv16(uint16_t x, uint16_t y) {
  return x / y;
}

SCALAR_FUN_ATTR uint32_t udiv32(uint32_t x, uint32_t y) {
  return x / y;
}

SCALAR_FUN_ATTR uint64_t udiv64(uint64_t x, uint64_t y) {
  return x / y;
}

SCALAR_FUN_ATTR uint8_t udiv_up8(uint8_t x, uint8_t y) {
  return (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint16_t udiv_up16(uint16_t x, uint16_t y) {
  return (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint32_t udiv_up32(uint32_t x, uint32_t y) {
  return (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint64_t udiv_up64(uint64_t x, uint64_t y) {
  return (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint8_t umod8(uint8_t x, uint8_t y) {
  return x % y;
}

SCALAR_FUN_ATTR uint16_t umod16(uint16_t x, uint16_t y) {
  return x % y;
}

SCALAR_FUN_ATTR uint32_t umod32(uint32_t x, uint32_t y) {
  return x % y;
}

SCALAR_FUN_ATTR uint64_t umod64(uint64_t x, uint64_t y) {
  return x % y;
}

SCALAR_FUN_ATTR uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

SCALAR_FUN_ATTR uint8_t umod_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR uint16_t umod_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR uint32_t umod_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR uint64_t umod_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR int8_t sdiv8(int8_t x, int8_t y) {
  int8_t q = x / y;
  int8_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int16_t sdiv16(int16_t x, int16_t y) {
  int16_t q = x / y;
  int16_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int32_t sdiv32(int32_t x, int32_t y) {
  int32_t q = x / y;
  int32_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int64_t sdiv64(int64_t x, int64_t y) {
  int64_t q = x / y;
  int64_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

SCALAR_FUN_ATTR int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

SCALAR_FUN_ATTR int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

SCALAR_FUN_ATTR int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

SCALAR_FUN_ATTR int8_t smod8(int8_t x, int8_t y) {
  int8_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int16_t smod16(int16_t x, int16_t y) {
  int16_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int32_t smod32(int32_t x, int32_t y) {
  int32_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int64_t smod64(int64_t x, int64_t y) {
  int64_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

SCALAR_FUN_ATTR int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

SCALAR_FUN_ATTR int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

SCALAR_FUN_ATTR int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

SCALAR_FUN_ATTR int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

SCALAR_FUN_ATTR int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

SCALAR_FUN_ATTR int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

SCALAR_FUN_ATTR int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

SCALAR_FUN_ATTR int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

SCALAR_FUN_ATTR int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

SCALAR_FUN_ATTR int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

SCALAR_FUN_ATTR int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

SCALAR_FUN_ATTR int8_t squot8(int8_t x, int8_t y) {
  return x / y;
}

SCALAR_FUN_ATTR int16_t squot16(int16_t x, int16_t y) {
  return x / y;
}

SCALAR_FUN_ATTR int32_t squot32(int32_t x, int32_t y) {
  return x / y;
}

SCALAR_FUN_ATTR int64_t squot64(int64_t x, int64_t y) {
  return x / y;
}

SCALAR_FUN_ATTR int8_t srem8(int8_t x, int8_t y) {
  return x % y;
}

SCALAR_FUN_ATTR int16_t srem16(int16_t x, int16_t y) {
  return x % y;
}

SCALAR_FUN_ATTR int32_t srem32(int32_t x, int32_t y) {
  return x % y;
}

SCALAR_FUN_ATTR int64_t srem64(int64_t x, int64_t y) {
  return x % y;
}

SCALAR_FUN_ATTR int8_t squot_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR int16_t squot_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR int32_t squot_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR int64_t squot_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x / y;
}

SCALAR_FUN_ATTR int8_t srem_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR int16_t srem_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR int32_t srem_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x % y;
}

SCALAR_FUN_ATTR int64_t srem_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x % y;
}

#endif

SCALAR_FUN_ATTR int8_t smin8(int8_t x, int8_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR int16_t smin16(int16_t x, int16_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR int32_t smin32(int32_t x, int32_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR int64_t smin64(int64_t x, int64_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR uint8_t umin8(uint8_t x, uint8_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR uint16_t umin16(uint16_t x, uint16_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR uint32_t umin32(uint32_t x, uint32_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR uint64_t umin64(uint64_t x, uint64_t y) {
  return x < y ? x : y;
}

SCALAR_FUN_ATTR int8_t smax8(int8_t x, int8_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR int16_t smax16(int16_t x, int16_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR int32_t smax32(int32_t x, int32_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR int64_t smax64(int64_t x, int64_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint8_t umax8(uint8_t x, uint8_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint16_t umax16(uint16_t x, uint16_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint32_t umax32(uint32_t x, uint32_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint64_t umax64(uint64_t x, uint64_t y) {
  return x < y ? y : x;
}

SCALAR_FUN_ATTR uint8_t shl8(uint8_t x, uint8_t y) {
  return (uint8_t)(x << y);
}

SCALAR_FUN_ATTR uint16_t shl16(uint16_t x, uint16_t y) {
  return (uint16_t)(x << y);
}

SCALAR_FUN_ATTR uint32_t shl32(uint32_t x, uint32_t y) {
  return x << y;
}

SCALAR_FUN_ATTR uint64_t shl64(uint64_t x, uint64_t y) {
  return x << y;
}

SCALAR_FUN_ATTR uint8_t lshr8(uint8_t x, uint8_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR uint16_t lshr16(uint16_t x, uint16_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR uint32_t lshr32(uint32_t x, uint32_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR uint64_t lshr64(uint64_t x, uint64_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR int8_t ashr8(int8_t x, int8_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR int16_t ashr16(int16_t x, int16_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR int32_t ashr32(int32_t x, int32_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR int64_t ashr64(int64_t x, int64_t y) {
  return x >> y;
}

SCALAR_FUN_ATTR uint8_t and8(uint8_t x, uint8_t y) {
  return x & y;
}

SCALAR_FUN_ATTR uint16_t and16(uint16_t x, uint16_t y) {
  return x & y;
}

SCALAR_FUN_ATTR uint32_t and32(uint32_t x, uint32_t y) {
  return x & y;
}

SCALAR_FUN_ATTR uint64_t and64(uint64_t x, uint64_t y) {
  return x & y;
}

SCALAR_FUN_ATTR uint8_t or8(uint8_t x, uint8_t y) {
  return x | y;
}

SCALAR_FUN_ATTR uint16_t or16(uint16_t x, uint16_t y) {
  return x | y;
}

SCALAR_FUN_ATTR uint32_t or32(uint32_t x, uint32_t y) {
  return x | y;
}

SCALAR_FUN_ATTR uint64_t or64(uint64_t x, uint64_t y) {
  return x | y;
}

SCALAR_FUN_ATTR uint8_t xor8(uint8_t x, uint8_t y) {
  return x ^ y;
}

SCALAR_FUN_ATTR uint16_t xor16(uint16_t x, uint16_t y) {
  return x ^ y;
}

SCALAR_FUN_ATTR uint32_t xor32(uint32_t x, uint32_t y) {
  return x ^ y;
}

SCALAR_FUN_ATTR uint64_t xor64(uint64_t x, uint64_t y) {
  return x ^ y;
}

SCALAR_FUN_ATTR bool ult8(uint8_t x, uint8_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool ult16(uint16_t x, uint16_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool ult32(uint32_t x, uint32_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool ult64(uint64_t x, uint64_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool ule8(uint8_t x, uint8_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool ule16(uint16_t x, uint16_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool ule32(uint32_t x, uint32_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool ule64(uint64_t x, uint64_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool slt8(int8_t x, int8_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool slt16(int16_t x, int16_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool slt32(int32_t x, int32_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool slt64(int64_t x, int64_t y) {
  return x < y;
}

SCALAR_FUN_ATTR bool sle8(int8_t x, int8_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool sle16(int16_t x, int16_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool sle32(int32_t x, int32_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR bool sle64(int64_t x, int64_t y) {
  return x <= y;
}

SCALAR_FUN_ATTR uint8_t pow8(uint8_t x, uint8_t y) {
  uint8_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR uint16_t pow16(uint16_t x, uint16_t y) {
  uint16_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR uint32_t pow32(uint32_t x, uint32_t y) {
  uint32_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR uint64_t pow64(uint64_t x, uint64_t y) {
  uint64_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR bool itob_i8_bool(int8_t x) {
  return x != 0;
}

SCALAR_FUN_ATTR bool itob_i16_bool(int16_t x) {
  return x != 0;
}

SCALAR_FUN_ATTR bool itob_i32_bool(int32_t x) {
  return x != 0;
}

SCALAR_FUN_ATTR bool itob_i64_bool(int64_t x) {
  return x != 0;
}

SCALAR_FUN_ATTR int8_t btoi_bool_i8(bool x) {
  return x;
}

SCALAR_FUN_ATTR int16_t btoi_bool_i16(bool x) {
  return x;
}

SCALAR_FUN_ATTR int32_t btoi_bool_i32(bool x) {
  return x;
}

SCALAR_FUN_ATTR int64_t btoi_bool_i64(bool x) {
  return x;
}

#define sext_i8_i8(x) ((int8_t) (int8_t) (x))
#define sext_i8_i16(x) ((int16_t) (int8_t) (x))
#define sext_i8_i32(x) ((int32_t) (int8_t) (x))
#define sext_i8_i64(x) ((int64_t) (int8_t) (x))
#define sext_i16_i8(x) ((int8_t) (int16_t) (x))
#define sext_i16_i16(x) ((int16_t) (int16_t) (x))
#define sext_i16_i32(x) ((int32_t) (int16_t) (x))
#define sext_i16_i64(x) ((int64_t) (int16_t) (x))
#define sext_i32_i8(x) ((int8_t) (int32_t) (x))
#define sext_i32_i16(x) ((int16_t) (int32_t) (x))
#define sext_i32_i32(x) ((int32_t) (int32_t) (x))
#define sext_i32_i64(x) ((int64_t) (int32_t) (x))
#define sext_i64_i8(x) ((int8_t) (int64_t) (x))
#define sext_i64_i16(x) ((int16_t) (int64_t) (x))
#define sext_i64_i32(x) ((int32_t) (int64_t) (x))
#define sext_i64_i64(x) ((int64_t) (int64_t) (x))
#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))
#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))
#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))
#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))
#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))
#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))
#define zext_i16_i32(x) ((int32_t) (uint16_t) (x))
#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))
#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))
#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))
#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))
#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))
#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))
#define zext_i64_i16(x) ((int16_t) (uint64_t) (x))
#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))
#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))

SCALAR_FUN_ATTR int8_t abs8(int8_t x) {
  return (int8_t)abs(x);
}

SCALAR_FUN_ATTR int16_t abs16(int16_t x) {
  return (int16_t)abs(x);
}

SCALAR_FUN_ATTR int32_t abs32(int32_t x) {
  return abs(x);
}

SCALAR_FUN_ATTR int64_t abs64(int64_t x) {
#if defined(__OPENCL_VERSION__) || defined(ISPC)
  return abs(x);
#else
  return llabs(x);
#endif
}

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR int32_t futrts_popc8(int8_t x) {
  return popcount(x);
}

SCALAR_FUN_ATTR int32_t futrts_popc16(int16_t x) {
  return popcount(x);
}

SCALAR_FUN_ATTR int32_t futrts_popc32(int32_t x) {
  return popcount(x);
}

SCALAR_FUN_ATTR int32_t futrts_popc64(int64_t x) {
  return popcount(x);
}
#elif defined(__CUDA_ARCH__)

SCALAR_FUN_ATTR int32_t futrts_popc8(int8_t x) {
  return __popc(zext_i8_i32(x));
}

SCALAR_FUN_ATTR int32_t futrts_popc16(int16_t x) {
  return __popc(zext_i16_i32(x));
}

SCALAR_FUN_ATTR int32_t futrts_popc32(int32_t x) {
  return __popc(x);
}

SCALAR_FUN_ATTR int32_t futrts_popc64(int64_t x) {
  return __popcll(x);
}

#else // Not OpenCL or CUDA, but plain C.

SCALAR_FUN_ATTR int32_t futrts_popc8(uint8_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

SCALAR_FUN_ATTR int32_t futrts_popc16(uint16_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

SCALAR_FUN_ATTR int32_t futrts_popc32(uint32_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

SCALAR_FUN_ATTR int32_t futrts_popc64(uint64_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR uint8_t  futrts_umul_hi8 ( uint8_t a,  uint8_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint8_t  futrts_smul_hi8 ( int8_t a,  int8_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint16_t futrts_smul_hi16(int16_t a, int16_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return mul_hi(a, b); }
#elif defined(__CUDA_ARCH__)
SCALAR_FUN_ATTR  uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return __umulhi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return __umul64hi(a, b); }
SCALAR_FUN_ATTR  uint8_t futrts_smul_hi8 ( int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return __mulhi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return __mul64hi(a, b); }
#elif ISPC
SCALAR_FUN_ATTR uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) {
  uint64_t ah = a >> 32;
  uint64_t al = a & 0xffffffff;
  uint64_t bh = b >> 32;
  uint64_t bl = b & 0xffffffff;

  uint64_t p1 = al * bl;
  uint64_t p2 = al * bh;
  uint64_t p3 = ah * bl;
  uint64_t p4 = ah * bh;

  uint64_t p1h = p1 >> 32;
  uint64_t p2h = p2 >> 32;
  uint64_t p3h = p3 >> 32;
  uint64_t p2l = p2 & 0xffffffff;
  uint64_t p3l = p3 & 0xffffffff;

  uint64_t l = p1h + p2l + p3l;
  uint64_t m = (p2 >> 32) + (p3 >> 32);
  uint64_t h = (l >> 32) + m + p4;

  return h;
}
SCALAR_FUN_ATTR  int8_t futrts_smul_hi8 ( int8_t a,  int8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
SCALAR_FUN_ATTR int64_t futrts_smul_hi64(int64_t a, int64_t b) {
  uint64_t ah = a >> 32;
  uint64_t al = a & 0xffffffff;
  uint64_t bh = b >> 32;
  uint64_t bl = b & 0xffffffff;

  uint64_t p1 =  al * bl;
  int64_t  p2 = al * bh;
  int64_t  p3 = ah * bl;
  uint64_t p4 =  ah * bh;

  uint64_t p1h = p1 >> 32;
  uint64_t p2h = p2 >> 32;
  uint64_t p3h = p3 >> 32;
  uint64_t p2l = p2 & 0xffffffff;
  uint64_t p3l = p3 & 0xffffffff;

  uint64_t l = p1h + p2l + p3l;
  uint64_t m = (p2 >> 32) + (p3 >> 32);
  uint64_t h = (l >> 32) + m + p4;

  return h;
}

#else // Not OpenCL, ISPC, or CUDA, but plain C.
SCALAR_FUN_ATTR uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return ((__uint128_t)a) * ((__uint128_t)b) >> 64; }
SCALAR_FUN_ATTR int8_t futrts_smul_hi8(int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }
SCALAR_FUN_ATTR int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }
SCALAR_FUN_ATTR int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((int64_t)a) * ((int64_t)b) >> 32; }
SCALAR_FUN_ATTR int64_t futrts_smul_hi64(int64_t a, int64_t b) { return ((__int128_t)a) * ((__int128_t)b) >> 64; }
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR  uint8_t futrts_umad_hi8 ( uint8_t a,  uint8_t b,  uint8_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR  uint8_t futrts_smad_hi8( int8_t a,  int8_t b,   int8_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return mad_hi(a, b, c); }
#else // Not OpenCL

SCALAR_FUN_ATTR  uint8_t futrts_umad_hi8( uint8_t a,  uint8_t b,  uint8_t c) { return futrts_umul_hi8(a, b) + c; }
SCALAR_FUN_ATTR uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return futrts_umul_hi16(a, b) + c; }
SCALAR_FUN_ATTR uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return futrts_umul_hi32(a, b) + c; }
SCALAR_FUN_ATTR uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return futrts_umul_hi64(a, b) + c; }
SCALAR_FUN_ATTR  uint8_t futrts_smad_hi8 ( int8_t a,  int8_t b,  int8_t c) { return futrts_smul_hi8(a, b) + c; }
SCALAR_FUN_ATTR uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return futrts_smul_hi16(a, b) + c; }
SCALAR_FUN_ATTR uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return futrts_smul_hi32(a, b) + c; }
SCALAR_FUN_ATTR uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return futrts_smul_hi64(a, b) + c; }
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR int32_t futrts_clzz8(int8_t x) {
  return clz(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) {
  return clz(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) {
  return clz(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) {
  return clz(x);
}

#elif defined(__CUDA_ARCH__)

SCALAR_FUN_ATTR int32_t futrts_clzz8(int8_t x) {
  return __clz(zext_i8_i32(x)) - 24;
}

SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) {
  return __clz(zext_i16_i32(x)) - 16;
}

SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) {
  return __clz(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) {
  return __clzll(x);
}

#elif ISPC

SCALAR_FUN_ATTR int32_t futrts_clzz8(int8_t x) {
  return count_leading_zeros((int32_t)(uint8_t)x)-24;
}

SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) {
  return count_leading_zeros((int32_t)(uint16_t)x)-16;
}

SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) {
  return count_leading_zeros(x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) {
  return count_leading_zeros(x);
}

#else // Not OpenCL, ISPC or CUDA, but plain C.

SCALAR_FUN_ATTR int32_t futrts_clzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24;
}

SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16;
}

SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_clz((uint32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_clzll((uint64_t)x);
}
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  int i = 0;
  for (; i < 8 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  int i = 0;
  for (; i < 16 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  int i = 0;
  for (; i < 32 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  int i = 0;
  for (; i < 64 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

#elif defined(__CUDA_ARCH__)

SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  int y = __ffs(x);
  return y == 0 ? 8 : y - 1;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  int y = __ffs(x);
  return y == 0 ? 16 : y - 1;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  int y = __ffs(x);
  return y == 0 ? 32 : y - 1;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  int y = __ffsll(x);
  return y == 0 ? 64 : y - 1;
}

#elif ISPC

SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : count_trailing_zeros((int32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : count_trailing_zeros((int32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  return count_trailing_zeros(x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  return count_trailing_zeros(x);
}

#else // Not OpenCL or CUDA, but plain C.

SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_ctz((uint32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_ctz((uint32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_ctz((uint32_t)x);
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_ctzll((uint64_t)x);
}
#endif

SCALAR_FUN_ATTR float fdiv32(float x, float y) {
  return x / y;
}

SCALAR_FUN_ATTR float fadd32(float x, float y) {
  return x + y;
}

SCALAR_FUN_ATTR float fsub32(float x, float y) {
  return x - y;
}

SCALAR_FUN_ATTR float fmul32(float x, float y) {
  return x * y;
}

SCALAR_FUN_ATTR bool cmplt32(float x, float y) {
  return x < y;
}

SCALAR_FUN_ATTR bool cmple32(float x, float y) {
  return x <= y;
}

SCALAR_FUN_ATTR float sitofp_i8_f32(int8_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float sitofp_i16_f32(int16_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float sitofp_i32_f32(int32_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float sitofp_i64_f32(int64_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float uitofp_i8_f32(uint8_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float uitofp_i16_f32(uint16_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float uitofp_i32_f32(uint32_t x) {
  return (float) x;
}

SCALAR_FUN_ATTR float uitofp_i64_f32(uint64_t x) {
  return (float) x;
}

#ifdef __OPENCL_VERSION__
SCALAR_FUN_ATTR float fabs32(float x) {
  return fabs(x);
}

SCALAR_FUN_ATTR float fmax32(float x, float y) {
  return fmax(x, y);
}

SCALAR_FUN_ATTR float fmin32(float x, float y) {
  return fmin(x, y);
}

SCALAR_FUN_ATTR float fpow32(float x, float y) {
  return pow(x, y);
}

#elif ISPC

SCALAR_FUN_ATTR float fabs32(float x) {
  return abs(x);
}

SCALAR_FUN_ATTR float fmax32(float x, float y) {
  return isnan(x) ? y : isnan(y) ? x : max(x, y);
}

SCALAR_FUN_ATTR float fmin32(float x, float y) {
  return isnan(x) ? y : isnan(y) ? x : min(x, y);
}

SCALAR_FUN_ATTR float fpow32(float a, float b) {
  float ret;
  foreach_active (i) {
      uniform float r = __stdlib_powf(extract(a, i), extract(b, i));
      ret = insert(ret, i, r);
  }
  return ret;
}

#else // Not OpenCL, but CUDA or plain C.

SCALAR_FUN_ATTR float fabs32(float x) {
  return fabsf(x);
}

SCALAR_FUN_ATTR float fmax32(float x, float y) {
  return fmaxf(x, y);
}

SCALAR_FUN_ATTR float fmin32(float x, float y) {
  return fminf(x, y);
}

SCALAR_FUN_ATTR float fpow32(float x, float y) {
  return powf(x, y);
}
#endif

SCALAR_FUN_ATTR bool futrts_isnan32(float x) {
  return isnan(x);
}

#if ISPC

SCALAR_FUN_ATTR bool futrts_isinf32(float x) {
  return !isnan(x) && isnan(x - x);
}

SCALAR_FUN_ATTR bool futrts_isfinite32(float x) {
  return !isnan(x) && !futrts_isinf32(x);
}

#else

SCALAR_FUN_ATTR bool futrts_isinf32(float x) {
  return isinf(x);
}

#endif

SCALAR_FUN_ATTR int8_t fptosi_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

SCALAR_FUN_ATTR int16_t fptosi_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

SCALAR_FUN_ATTR int32_t fptosi_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

SCALAR_FUN_ATTR int64_t fptosi_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int64_t) x;
  };
}

SCALAR_FUN_ATTR uint8_t fptoui_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

SCALAR_FUN_ATTR uint16_t fptoui_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

SCALAR_FUN_ATTR uint32_t fptoui_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

SCALAR_FUN_ATTR uint64_t fptoui_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

SCALAR_FUN_ATTR bool ftob_f32_bool(float x) {
  return x != 0;
}

SCALAR_FUN_ATTR float btof_bool_f32(bool x) {
  return x ? 1 : 0;
}

#ifdef __OPENCL_VERSION__
SCALAR_FUN_ATTR float futrts_log32(float x) {
  return log(x);
}

SCALAR_FUN_ATTR float futrts_log2_32(float x) {
  return log2(x);
}

SCALAR_FUN_ATTR float futrts_log10_32(float x) {
  return log10(x);
}

SCALAR_FUN_ATTR float futrts_log1p_32(float x) {
  return log1p(x);
}

SCALAR_FUN_ATTR float futrts_sqrt32(float x) {
  return sqrt(x);
}

SCALAR_FUN_ATTR float futrts_cbrt32(float x) {
  return cbrt(x);
}

SCALAR_FUN_ATTR float futrts_exp32(float x) {
  return exp(x);
}

SCALAR_FUN_ATTR float futrts_cos32(float x) {
  return cos(x);
}

SCALAR_FUN_ATTR float futrts_sin32(float x) {
  return sin(x);
}

SCALAR_FUN_ATTR float futrts_tan32(float x) {
  return tan(x);
}

SCALAR_FUN_ATTR float futrts_acos32(float x) {
  return acos(x);
}

SCALAR_FUN_ATTR float futrts_asin32(float x) {
  return asin(x);
}

SCALAR_FUN_ATTR float futrts_atan32(float x) {
  return atan(x);
}

SCALAR_FUN_ATTR float futrts_cosh32(float x) {
  return cosh(x);
}

SCALAR_FUN_ATTR float futrts_sinh32(float x) {
  return sinh(x);
}

SCALAR_FUN_ATTR float futrts_tanh32(float x) {
  return tanh(x);
}

SCALAR_FUN_ATTR float futrts_acosh32(float x) {
  return acosh(x);
}

SCALAR_FUN_ATTR float futrts_asinh32(float x) {
  return asinh(x);
}

SCALAR_FUN_ATTR float futrts_atanh32(float x) {
  return atanh(x);
}

SCALAR_FUN_ATTR float futrts_atan2_32(float x, float y) {
  return atan2(x, y);
}

SCALAR_FUN_ATTR float futrts_hypot32(float x, float y) {
  return hypot(x, y);
}

SCALAR_FUN_ATTR float futrts_gamma32(float x) {
  return tgamma(x);
}

SCALAR_FUN_ATTR float futrts_lgamma32(float x) {
  return lgamma(x);
}

SCALAR_FUN_ATTR float futrts_erf32(float x) {
  return erf(x);
}

SCALAR_FUN_ATTR float futrts_erfc32(float x) {
  return erfc(x);
}

SCALAR_FUN_ATTR float fmod32(float x, float y) {
  return fmod(x, y);
}

SCALAR_FUN_ATTR float futrts_round32(float x) {
  return rint(x);
}

SCALAR_FUN_ATTR float futrts_floor32(float x) {
  return floor(x);
}

SCALAR_FUN_ATTR float futrts_ceil32(float x) {
  return ceil(x);
}

SCALAR_FUN_ATTR float futrts_nextafter32(float x, float y) {
  return nextafter(x, y);
}

SCALAR_FUN_ATTR float futrts_lerp32(float v0, float v1, float t) {
  return mix(v0, v1, t);
}

SCALAR_FUN_ATTR float futrts_ldexp32(float x, int32_t y) {
  return ldexp(x, y);
}

SCALAR_FUN_ATTR float futrts_copysign32(float x, float y) {
  return copysign(x, y);
}

SCALAR_FUN_ATTR float futrts_mad32(float a, float b, float c) {
  return mad(a, b, c);
}

SCALAR_FUN_ATTR float futrts_fma32(float a, float b, float c) {
  return fma(a, b, c);
}

#elif ISPC

SCALAR_FUN_ATTR float futrts_log32(float x) {
  return futrts_isfinite32(x) || (futrts_isinf32(x) && x < 0)? log(x) : x;
}

SCALAR_FUN_ATTR float futrts_log2_32(float x) {
  return futrts_log32(x) / log(2.0f);
}

SCALAR_FUN_ATTR float futrts_log10_32(float x) {
  return futrts_log32(x) / log(10.0f);
}

SCALAR_FUN_ATTR float futrts_log1p_32(float x) {
  if(x == -1.0f || (futrts_isinf32(x) && x > 0.0f)) return x / 0.0f;
  float y = 1.0f + x;
  float z = y - 1.0f;
  return log(y) - (z-x)/y;
}

SCALAR_FUN_ATTR float futrts_sqrt32(float x) {
  return sqrt(x);
}

extern "C" unmasked uniform float cbrtf(uniform float);
SCALAR_FUN_ATTR float futrts_cbrt32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = cbrtf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR float futrts_exp32(float x) {
  return exp(x);
}

SCALAR_FUN_ATTR float futrts_cos32(float x) {
  return cos(x);
}

SCALAR_FUN_ATTR float futrts_sin32(float x) {
  return sin(x);
}

SCALAR_FUN_ATTR float futrts_tan32(float x) {
  return tan(x);
}

SCALAR_FUN_ATTR float futrts_acos32(float x) {
  return acos(x);
}

SCALAR_FUN_ATTR float futrts_asin32(float x) {
  return asin(x);
}

SCALAR_FUN_ATTR float futrts_atan32(float x) {
  return atan(x);
}

SCALAR_FUN_ATTR float futrts_cosh32(float x) {
  return (exp(x)+exp(-x)) / 2.0f;
}

SCALAR_FUN_ATTR float futrts_sinh32(float x) {
  return (exp(x)-exp(-x)) / 2.0f;
}

SCALAR_FUN_ATTR float futrts_tanh32(float x) {
  return futrts_sinh32(x)/futrts_cosh32(x);
}

SCALAR_FUN_ATTR float futrts_acosh32(float x) {
  float f = x+sqrt(x*x-1);
  if(futrts_isfinite32(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR float futrts_asinh32(float x) {
  float f = x+sqrt(x*x+1);
  if(futrts_isfinite32(f)) return log(f);
  return f;

}

SCALAR_FUN_ATTR float futrts_atanh32(float x) {
  float f = (1+x)/(1-x);
  if(futrts_isfinite32(f)) return log(f)/2.0f;
  return f;

}

SCALAR_FUN_ATTR float futrts_atan2_32(float x, float y) {
  return (x == 0.0f && y == 0.0f) ? 0.0f : atan2(x, y);
}

SCALAR_FUN_ATTR float futrts_hypot32(float x, float y) {
  if (futrts_isfinite32(x) && futrts_isfinite32(y)) {
    x = abs(x);
    y = abs(y);
    float a;
    float b;
    if (x >= y){
        a = x;
        b = y;
    } else {
        a = y;
        b = x;
    }
    if(b == 0){
      return a;
    }

    int e;
    float an;
    float bn;
    an = frexp (a, &e);
    bn = ldexp (b, - e);
    float cn;
    cn = sqrt (an * an + bn * bn);
    return ldexp (cn, e);
  } else {
    if (futrts_isinf32(x) || futrts_isinf32(y)) return INFINITY;
    else return x + y;
  }

}

extern "C" unmasked uniform float tgammaf(uniform float x);
SCALAR_FUN_ATTR float futrts_gamma32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = tgammaf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float lgammaf(uniform float x);
SCALAR_FUN_ATTR float futrts_lgamma32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = lgammaf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float erff(uniform float x);
SCALAR_FUN_ATTR float futrts_erf32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = erff(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float erfcf(uniform float x);
SCALAR_FUN_ATTR float futrts_erfc32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = erfcf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR float fmod32(float x, float y) {
  return x - y * trunc(x/y);
}

SCALAR_FUN_ATTR float futrts_round32(float x) {
  return round(x);
}

SCALAR_FUN_ATTR float futrts_floor32(float x) {
  return floor(x);
}

SCALAR_FUN_ATTR float futrts_ceil32(float x) {
  return ceil(x);
}

extern "C" unmasked uniform float nextafterf(uniform float x, uniform float y);
SCALAR_FUN_ATTR float futrts_nextafter32(float x, float y) {
  float res;
  foreach_active (i) {
    uniform float r = nextafterf(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR float futrts_ldexp32(float x, int32_t y) {
  return x * pow((double)2.0, (double)y);
}

SCALAR_FUN_ATTR float futrts_copysign32(float x, float y) {
  int32_t xb = futrts_to_bits32(x);
  int32_t yb = futrts_to_bits32(y);
  return futrts_from_bits32((xb & ~(1<<31)) | (yb & (1<<31)));
}

SCALAR_FUN_ATTR float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

SCALAR_FUN_ATTR float futrts_fma32(float a, float b, float c) {
  return a * b + c;
}

#else // Not OpenCL or ISPC, but CUDA or plain C.

SCALAR_FUN_ATTR float futrts_log32(float x) {
  return logf(x);
}

SCALAR_FUN_ATTR float futrts_log2_32(float x) {
  return log2f(x);
}

SCALAR_FUN_ATTR float futrts_log10_32(float x) {
  return log10f(x);
}

SCALAR_FUN_ATTR float futrts_log1p_32(float x) {
  return log1pf(x);
}

SCALAR_FUN_ATTR float futrts_sqrt32(float x) {
  return sqrtf(x);
}

SCALAR_FUN_ATTR float futrts_cbrt32(float x) {
  return cbrtf(x);
}

SCALAR_FUN_ATTR float futrts_exp32(float x) {
  return expf(x);
}

SCALAR_FUN_ATTR float futrts_cos32(float x) {
  return cosf(x);
}

SCALAR_FUN_ATTR float futrts_sin32(float x) {
  return sinf(x);
}

SCALAR_FUN_ATTR float futrts_tan32(float x) {
  return tanf(x);
}

SCALAR_FUN_ATTR float futrts_acos32(float x) {
  return acosf(x);
}

SCALAR_FUN_ATTR float futrts_asin32(float x) {
  return asinf(x);
}

SCALAR_FUN_ATTR float futrts_atan32(float x) {
  return atanf(x);
}

SCALAR_FUN_ATTR float futrts_cosh32(float x) {
  return coshf(x);
}

SCALAR_FUN_ATTR float futrts_sinh32(float x) {
  return sinhf(x);
}

SCALAR_FUN_ATTR float futrts_tanh32(float x) {
  return tanhf(x);
}

SCALAR_FUN_ATTR float futrts_acosh32(float x) {
  return acoshf(x);
}

SCALAR_FUN_ATTR float futrts_asinh32(float x) {
  return asinhf(x);
}

SCALAR_FUN_ATTR float futrts_atanh32(float x) {
  return atanhf(x);
}

SCALAR_FUN_ATTR float futrts_atan2_32(float x, float y) {
  return atan2f(x, y);
}

SCALAR_FUN_ATTR float futrts_hypot32(float x, float y) {
  return hypotf(x, y);
}

SCALAR_FUN_ATTR float futrts_gamma32(float x) {
  return tgammaf(x);
}

SCALAR_FUN_ATTR float futrts_lgamma32(float x) {
  return lgammaf(x);
}

SCALAR_FUN_ATTR float futrts_erf32(float x) {
  return erff(x);
}

SCALAR_FUN_ATTR float futrts_erfc32(float x) {
  return erfcf(x);
}

SCALAR_FUN_ATTR float fmod32(float x, float y) {
  return fmodf(x, y);
}

SCALAR_FUN_ATTR float futrts_round32(float x) {
  return rintf(x);
}

SCALAR_FUN_ATTR float futrts_floor32(float x) {
  return floorf(x);
}

SCALAR_FUN_ATTR float futrts_ceil32(float x) {
  return ceilf(x);
}

SCALAR_FUN_ATTR float futrts_nextafter32(float x, float y) {
  return nextafterf(x, y);
}

SCALAR_FUN_ATTR float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR float futrts_ldexp32(float x, int32_t y) {
  return ldexpf(x, y);
}

SCALAR_FUN_ATTR float futrts_copysign32(float x, float y) {
  return copysignf(x, y);
}

SCALAR_FUN_ATTR float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

SCALAR_FUN_ATTR float futrts_fma32(float a, float b, float c) {
  return fmaf(a, b, c);
}
#endif

#if ISPC
SCALAR_FUN_ATTR int32_t futrts_to_bits32(float x) {
  return intbits(x);
}

SCALAR_FUN_ATTR float futrts_from_bits32(int32_t x) {
  return floatbits(x);
}
#else
SCALAR_FUN_ATTR int32_t futrts_to_bits32(float x) {
  union {
    float f;
    int32_t t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR float futrts_from_bits32(int32_t x) {
  union {
    int32_t f;
    float t;
  } p;

  p.f = x;
  return p.t;
}
#endif

SCALAR_FUN_ATTR float fsignum32(float x) {
  return futrts_isnan32(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0);
}

#ifdef FUTHARK_F64_ENABLED

SCALAR_FUN_ATTR double futrts_from_bits64(int64_t x);
SCALAR_FUN_ATTR int64_t futrts_to_bits64(double x);

#if ISPC
SCALAR_FUN_ATTR bool futrts_isinf64(float x) {
  return !isnan(x) && isnan(x - x);
}

SCALAR_FUN_ATTR bool futrts_isfinite64(float x) {
  return !isnan(x) && !futrts_isinf64(x);
}

SCALAR_FUN_ATTR double fdiv64(double x, double y) {
  return x / y;
}

SCALAR_FUN_ATTR double fadd64(double x, double y) {
  return x + y;
}

SCALAR_FUN_ATTR double fsub64(double x, double y) {
  return x - y;
}

SCALAR_FUN_ATTR double fmul64(double x, double y) {
  return x * y;
}

SCALAR_FUN_ATTR bool cmplt64(double x, double y) {
  return x < y;
}

SCALAR_FUN_ATTR bool cmple64(double x, double y) {
  return x <= y;
}

SCALAR_FUN_ATTR double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double fabs64(double x) {
  return abs(x);
}

SCALAR_FUN_ATTR double fmax64(double x, double y) {
  return isnan(x) ? y : isnan(y) ? x : max(x, y);
}

SCALAR_FUN_ATTR double fmin64(double x, double y) {
  return isnan(x) ? y : isnan(y) ? x : min(x, y);
}

SCALAR_FUN_ATTR double fpow64(double a, double b) {
  float ret;
  foreach_active (i) {
      uniform float r = __stdlib_powf(extract(a, i), extract(b, i));
      ret = insert(ret, i, r);
  }
  return ret;
}

SCALAR_FUN_ATTR double futrts_log64(double x) {
  return futrts_isfinite64(x) || (futrts_isinf64(x) && x < 0)? log(x) : x;
}

SCALAR_FUN_ATTR double futrts_log2_64(double x) {
  return futrts_log64(x)/log(2.0d);
}

SCALAR_FUN_ATTR double futrts_log10_64(double x) {
  return futrts_log64(x)/log(10.0d);
}

SCALAR_FUN_ATTR double futrts_log1p_64(double x) {
  if(x == -1.0d || (futrts_isinf64(x) && x > 0.0d)) return x / 0.0d;
  double y = 1.0d + x;
  double z = y - 1.0d;
  return log(y) - (z-x)/y;
}

SCALAR_FUN_ATTR double futrts_sqrt64(double x) {
  return sqrt(x);
}

extern "C" unmasked uniform double cbrt(uniform double);
SCALAR_FUN_ATTR double futrts_cbrt64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = cbrtf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_exp64(double x) {
  return exp(x);
}

SCALAR_FUN_ATTR double futrts_cos64(double x) {
  return cos(x);
}

SCALAR_FUN_ATTR double futrts_sin64(double x) {
  return sin(x);
}

SCALAR_FUN_ATTR double futrts_tan64(double x) {
  return tan(x);
}

SCALAR_FUN_ATTR double futrts_acos64(double x) {
  return acos(x);
}

SCALAR_FUN_ATTR double futrts_asin64(double x) {
  return asin(x);
}

SCALAR_FUN_ATTR double futrts_atan64(double x) {
  return atan(x);
}

SCALAR_FUN_ATTR double futrts_cosh64(double x) {
  return (exp(x)+exp(-x)) / 2.0d;
}

SCALAR_FUN_ATTR double futrts_sinh64(double x) {
  return (exp(x)-exp(-x)) / 2.0d;
}

SCALAR_FUN_ATTR double futrts_tanh64(double x) {
  return futrts_sinh64(x)/futrts_cosh64(x);
}

SCALAR_FUN_ATTR double futrts_acosh64(double x) {
  double f = x+sqrt(x*x-1.0d);
  if(futrts_isfinite64(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR double futrts_asinh64(double x) {
  double f = x+sqrt(x*x+1.0d);
  if(futrts_isfinite64(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR double futrts_atanh64(double x) {
  double f = (1.0d+x)/(1.0d-x);
  if(futrts_isfinite64(f)) return log(f)/2.0d;
  return f;

}

SCALAR_FUN_ATTR double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

extern "C" unmasked uniform double hypot(uniform double x, uniform double y);
SCALAR_FUN_ATTR double futrts_hypot64(double x, double y) {
  double res;
  foreach_active (i) {
    uniform double r = hypot(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double tgamma(uniform double x);
SCALAR_FUN_ATTR double futrts_gamma64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = tgamma(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double lgamma(uniform double x);
SCALAR_FUN_ATTR double futrts_lgamma64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = lgamma(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double erf(uniform double x);
SCALAR_FUN_ATTR double futrts_erf64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = erf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double erfc(uniform double x);
SCALAR_FUN_ATTR double futrts_erfc64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = erfc(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_fma64(double a, double b, double c) {
  return a * b + c;
}

SCALAR_FUN_ATTR double futrts_round64(double x) {
  return round(x);
}

SCALAR_FUN_ATTR double futrts_ceil64(double x) {
  return ceil(x);
}

extern "C" unmasked uniform double nextafter(uniform float x, uniform double y);
SCALAR_FUN_ATTR float futrts_nextafter64(double x, double y) {
  double res;
  foreach_active (i) {
    uniform double r = nextafter(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_floor64(double x) {
  return floor(x);
}

SCALAR_FUN_ATTR bool futrts_isnan64(double x) {
  return isnan(x);
}

SCALAR_FUN_ATTR int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

SCALAR_FUN_ATTR int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

SCALAR_FUN_ATTR int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

SCALAR_FUN_ATTR int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

SCALAR_FUN_ATTR uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

SCALAR_FUN_ATTR uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

SCALAR_FUN_ATTR uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

SCALAR_FUN_ATTR uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

SCALAR_FUN_ATTR bool ftob_f64_bool(double x) {
  return x != 0.0;
}

SCALAR_FUN_ATTR double btof_bool_f64(bool x) {
  return x ? 1.0 : 0.0;
}

SCALAR_FUN_ATTR int64_t futrts_to_bits64(double x) {
  int64_t res;
  foreach_active (i) {
    uniform double tmp = extract(x, i);
    uniform int64_t r = *((uniform int64_t* uniform)&tmp);
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_from_bits64(int64_t x) {
  double res;
  foreach_active (i) {
    uniform int64_t tmp = extract(x, i);
    uniform double r = *((uniform double* uniform)&tmp);
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double fmod64(double x, double y) {
  return x - y * trunc(x/y);
}

SCALAR_FUN_ATTR double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0 ? 1.0d : 0.0d) - (x < 0 ? 1.0d : 0.0d);
}

SCALAR_FUN_ATTR double futrts_lerp64(double v0, double v1, double t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR double futrts_ldexp64(double x, int32_t y) {
  return x * pow((double)2.0, (double)y);
}

SCALAR_FUN_ATTR double futrts_copysign64(double x, double y) {
  int64_t xb = futrts_to_bits64(x);
  int64_t yb = futrts_to_bits64(y);
  return futrts_from_bits64((xb & ~(((int64_t)1)<<63)) | (yb & (((int64_t)1)<<63)));
}

SCALAR_FUN_ATTR double futrts_mad64(double a, double b, double c) {
  return a * b + c;
}

SCALAR_FUN_ATTR float fpconv_f32_f32(float x) {
  return (float) x;
}

SCALAR_FUN_ATTR double fpconv_f32_f64(float x) {
  return (double) x;
}

SCALAR_FUN_ATTR float fpconv_f64_f32(double x) {
  return (float) x;
}

SCALAR_FUN_ATTR double fpconv_f64_f64(double x) {
  return (double) x;
}

#else

SCALAR_FUN_ATTR double fdiv64(double x, double y) {
  return x / y;
}

SCALAR_FUN_ATTR double fadd64(double x, double y) {
  return x + y;
}

SCALAR_FUN_ATTR double fsub64(double x, double y) {
  return x - y;
}

SCALAR_FUN_ATTR double fmul64(double x, double y) {
  return x * y;
}

SCALAR_FUN_ATTR bool cmplt64(double x, double y) {
  return x < y;
}

SCALAR_FUN_ATTR bool cmple64(double x, double y) {
  return x <= y;
}

SCALAR_FUN_ATTR double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

SCALAR_FUN_ATTR double fabs64(double x) {
  return fabs(x);
}

SCALAR_FUN_ATTR double fmax64(double x, double y) {
  return fmax(x, y);
}

SCALAR_FUN_ATTR double fmin64(double x, double y) {
  return fmin(x, y);
}

SCALAR_FUN_ATTR double fpow64(double x, double y) {
  return pow(x, y);
}

SCALAR_FUN_ATTR double futrts_log64(double x) {
  return log(x);
}

SCALAR_FUN_ATTR double futrts_log2_64(double x) {
  return log2(x);
}

SCALAR_FUN_ATTR double futrts_log10_64(double x) {
  return log10(x);
}

SCALAR_FUN_ATTR double futrts_log1p_64(double x) {
  return log1p(x);
}

SCALAR_FUN_ATTR double futrts_sqrt64(double x) {
  return sqrt(x);
}

SCALAR_FUN_ATTR double futrts_cbrt64(double x) {
  return cbrt(x);
}

SCALAR_FUN_ATTR double futrts_exp64(double x) {
  return exp(x);
}

SCALAR_FUN_ATTR double futrts_cos64(double x) {
  return cos(x);
}

SCALAR_FUN_ATTR double futrts_sin64(double x) {
  return sin(x);
}

SCALAR_FUN_ATTR double futrts_tan64(double x) {
  return tan(x);
}

SCALAR_FUN_ATTR double futrts_acos64(double x) {
  return acos(x);
}

SCALAR_FUN_ATTR double futrts_asin64(double x) {
  return asin(x);
}

SCALAR_FUN_ATTR double futrts_atan64(double x) {
  return atan(x);
}

SCALAR_FUN_ATTR double futrts_cosh64(double x) {
  return cosh(x);
}

SCALAR_FUN_ATTR double futrts_sinh64(double x) {
  return sinh(x);
}

SCALAR_FUN_ATTR double futrts_tanh64(double x) {
  return tanh(x);
}

SCALAR_FUN_ATTR double futrts_acosh64(double x) {
  return acosh(x);
}

SCALAR_FUN_ATTR double futrts_asinh64(double x) {
  return asinh(x);
}

SCALAR_FUN_ATTR double futrts_atanh64(double x) {
  return atanh(x);
}

SCALAR_FUN_ATTR double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

SCALAR_FUN_ATTR double futrts_hypot64(double x, double y) {
  return hypot(x, y);
}

SCALAR_FUN_ATTR double futrts_gamma64(double x) {
  return tgamma(x);
}

SCALAR_FUN_ATTR double futrts_lgamma64(double x) {
  return lgamma(x);
}

SCALAR_FUN_ATTR double futrts_erf64(double x) {
  return erf(x);
}

SCALAR_FUN_ATTR double futrts_erfc64(double x) {
  return erfc(x);
}

SCALAR_FUN_ATTR double futrts_fma64(double a, double b, double c) {
  return fma(a, b, c);
}

SCALAR_FUN_ATTR double futrts_round64(double x) {
  return rint(x);
}

SCALAR_FUN_ATTR double futrts_ceil64(double x) {
  return ceil(x);
}

SCALAR_FUN_ATTR float futrts_nextafter64(float x, float y) {
  return nextafter(x, y);
}

SCALAR_FUN_ATTR double futrts_floor64(double x) {
  return floor(x);
}

SCALAR_FUN_ATTR bool futrts_isnan64(double x) {
  return isnan(x);
}

SCALAR_FUN_ATTR bool futrts_isinf64(double x) {
  return isinf(x);
}

SCALAR_FUN_ATTR int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

SCALAR_FUN_ATTR int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

SCALAR_FUN_ATTR int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

SCALAR_FUN_ATTR int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

SCALAR_FUN_ATTR uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

SCALAR_FUN_ATTR uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

SCALAR_FUN_ATTR uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

SCALAR_FUN_ATTR uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

SCALAR_FUN_ATTR bool ftob_f64_bool(double x) {
  return x != 0;
}

SCALAR_FUN_ATTR double btof_bool_f64(bool x) {
  return x ? 1 : 0;
}

SCALAR_FUN_ATTR int64_t futrts_to_bits64(double x) {
  union {
    double f;
    int64_t t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR double futrts_from_bits64(int64_t x) {
  union {
    int64_t f;
    double t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR double fmod64(double x, double y) {
  return fmod(x, y);
}

SCALAR_FUN_ATTR double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);
}

SCALAR_FUN_ATTR double futrts_lerp64(double v0, double v1, double t) {
#ifdef __OPENCL_VERSION__
  return mix(v0, v1, t);
#else
  return v0 + (v1 - v0) * t;
#endif
}

SCALAR_FUN_ATTR double futrts_ldexp64(double x, int32_t y) {
  return ldexp(x, y);
}

SCALAR_FUN_ATTR float futrts_copysign64(double x, double y) {
  return copysign(x, y);
}

SCALAR_FUN_ATTR double futrts_mad64(double a, double b, double c) {
#ifdef __OPENCL_VERSION__
  return mad(a, b, c);
#else
  return a * b + c;
#endif
}

SCALAR_FUN_ATTR float fpconv_f32_f32(float x) {
  return (float) x;
}

SCALAR_FUN_ATTR double fpconv_f32_f64(float x) {
  return (double) x;
}

SCALAR_FUN_ATTR float fpconv_f64_f32(double x) {
  return (float) x;
}

SCALAR_FUN_ATTR double fpconv_f64_f64(double x) {
  return (double) x;
}

#endif

#endif

// End of scalar.h.
// Start of scalar_f16.h.

// Half-precision is emulated if needed (e.g. in straight C) with the
// native type used if possible.  The emulation works by typedef'ing
// 'float' to 'f16', and then implementing all operations on single
// precision.  To cut down on duplication, we use the same code for
// those Futhark functions that require just operators or casts.  The
// in-memory representation for arrays will still be 16 bits even
// under emulation, so the compiler will have to be careful when
// generating reads or writes.

#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600) && !(defined(ISPC))
#define EMULATE_F16
#endif

#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#endif

#ifdef EMULATE_F16

// Note that the half-precision storage format is still 16 bits - the
// compiler will have to be real careful!
typedef float f16;

#elif ISPC
typedef float16 f16;

#else

#ifdef __CUDA_ARCH__
#include <cuda_fp16.h>
#endif

typedef half f16;

#endif

// Some of these functions convert to single precision because half
// precision versions are not available.

SCALAR_FUN_ATTR f16 fadd16(f16 x, f16 y) {
  return x + y;
}

SCALAR_FUN_ATTR f16 fsub16(f16 x, f16 y) {
  return x - y;
}

SCALAR_FUN_ATTR f16 fmul16(f16 x, f16 y) {
  return x * y;
}

SCALAR_FUN_ATTR bool cmplt16(f16 x, f16 y) {
  return x < y;
}

SCALAR_FUN_ATTR bool cmple16(f16 x, f16 y) {
  return x <= y;
}

SCALAR_FUN_ATTR f16 sitofp_i8_f16(int8_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 sitofp_i16_f16(int16_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 sitofp_i32_f16(int32_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 sitofp_i64_f16(int64_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 uitofp_i8_f16(uint8_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 uitofp_i16_f16(uint16_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 uitofp_i32_f16(uint32_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR f16 uitofp_i64_f16(uint64_t x) {
  return (f16) x;
}

SCALAR_FUN_ATTR int8_t fptosi_f16_i8(f16 x) {
  return (int8_t) (float) x;
}

SCALAR_FUN_ATTR int16_t fptosi_f16_i16(f16 x) {
  return (int16_t) x;
}

SCALAR_FUN_ATTR int32_t fptosi_f16_i32(f16 x) {
  return (int32_t) x;
}

SCALAR_FUN_ATTR int64_t fptosi_f16_i64(f16 x) {
  return (int64_t) x;
}

SCALAR_FUN_ATTR uint8_t fptoui_f16_i8(f16 x) {
  return (uint8_t) (float) x;
}

SCALAR_FUN_ATTR uint16_t fptoui_f16_i16(f16 x) {
  return (uint16_t) x;
}

SCALAR_FUN_ATTR uint32_t fptoui_f16_i32(f16 x) {
  return (uint32_t) x;
}

SCALAR_FUN_ATTR uint64_t fptoui_f16_i64(f16 x) {
  return (uint64_t) x;
}

SCALAR_FUN_ATTR bool ftob_f16_bool(f16 x) {
  return x != (f16)0;
}

SCALAR_FUN_ATTR f16 btof_bool_f16(bool x) {
  return x ? 1 : 0;
}

#ifndef EMULATE_F16
SCALAR_FUN_ATTR bool futrts_isnan16(f16 x) {
  return isnan((float)x);
}

#ifdef __OPENCL_VERSION__

SCALAR_FUN_ATTR f16 fabs16(f16 x) {
  return fabs(x);
}

SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) {
  return fmax(x, y);
}

SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) {
  return fmin(x, y);
}

SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}

#elif ISPC
SCALAR_FUN_ATTR f16 fabs16(f16 x) {
  return abs(x);
}

SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) {
  return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : max(x, y);
}

SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) {
  return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : min(x, y);
}

SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}

#else // Assuming CUDA.

SCALAR_FUN_ATTR f16 fabs16(f16 x) {
  return fabsf(x);
}

SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) {
  return fmaxf(x, y);
}

SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) {
  return fminf(x, y);
}

SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) {
  return powf(x, y);
}
#endif

#if ISPC
SCALAR_FUN_ATTR bool futrts_isinf16(float x) {
  return !futrts_isnan16(x) && futrts_isnan16(x - x);
}
SCALAR_FUN_ATTR bool futrts_isfinite16(float x) {
  return !futrts_isnan16(x) && !futrts_isinf16(x);
}

#else

SCALAR_FUN_ATTR bool futrts_isinf16(f16 x) {
  return isinf((float)x);
}
#endif

#ifdef __OPENCL_VERSION__
SCALAR_FUN_ATTR f16 futrts_log16(f16 x) {
  return log(x);
}

SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) {
  return log2(x);
}

SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) {
  return log10(x);
}

SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) {
  return log1p(x);
}

SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) {
  return sqrt(x);
}

SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) {
  return cbrt(x);
}

SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) {
  return exp(x);
}

SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) {
  return cos(x);
}

SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) {
  return sin(x);
}

SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) {
  return tan(x);
}

SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) {
  return acos(x);
}

SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) {
  return asin(x);
}

SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) {
  return atan(x);
}

SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) {
  return cosh(x);
}

SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) {
  return sinh(x);
}

SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) {
  return tanh(x);
}

SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) {
  return acosh(x);
}

SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) {
  return asinh(x);
}

SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) {
  return atanh(x);
}

SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2(x, y);
}

SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) {
  return hypot(x, y);
}

SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) {
  return tgamma(x);
}

SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) {
  return lgamma(x);
}

SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) {
  return erf(x);
}

SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) {
  return erfc(x);
}

SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) {
  return fmod(x, y);
}

SCALAR_FUN_ATTR f16 futrts_round16(f16 x) {
  return rint(x);
}

SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) {
  return floor(x);
}

SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) {
  return ceil(x);
}

SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) {
  return nextafter(x, y);
}

SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return mix(v0, v1, t);
}

SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) {
  return ldexp(x, y);
}

SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) {
  return copysign(x, y);
}

SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return mad(a, b, c);
}

SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fma(a, b, c);
}
#elif ISPC

SCALAR_FUN_ATTR f16 futrts_log16(f16 x) {
  return futrts_isfinite16(x) || (futrts_isinf16(x) && x < 0) ? log(x) : x;
}

SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) {
  return futrts_log16(x) / log(2.0f16);
}

SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) {
  return futrts_log16(x) / log(10.0f16);
}

SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) {
  if(x == -1.0f16 || (futrts_isinf16(x) && x > 0.0f16)) return x / 0.0f16;
  f16 y = 1.0f16 + x;
  f16 z = y - 1.0f16;
  return log(y) - (z-x)/y;
}

SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) {
  return (float16)sqrt((float)x);
}

SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) {
  return exp(x);
}

SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) {
  return (float16)cos((float)x);
}

SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) {
  return (float16)sin((float)x);
}

SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) {
  return (float16)tan((float)x);
}

SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) {
  return (float16)acos((float)x);
}

SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) {
  return (float16)asin((float)x);
}

SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) {
  return (float16)atan((float)x);
}

SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) {
  return (exp(x)+exp(-x)) / 2.0f16;
}

SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) {
  return (exp(x)-exp(-x)) / 2.0f16;
}

SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) {
  return futrts_sinh16(x)/futrts_cosh16(x);
}

SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) {
  float16 f = x+(float16)sqrt((float)(x*x-1));
  if(futrts_isfinite16(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) {
  float16 f = x+(float16)sqrt((float)(x*x+1));
  if(futrts_isfinite16(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) {
  float16 f = (1+x)/(1-x);
  if(futrts_isfinite16(f)) return log(f)/2.0f16;
  return f;
}

SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) {
  return (float16)atan2((float)x, (float)y);
}

SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) {
  return (float16)futrts_hypot32((float)x, (float)y);
}

extern "C" unmasked uniform float tgammaf(uniform float x);
SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) {
  f16 res;
  foreach_active (i) {
    uniform f16 r = (f16)tgammaf(extract((float)x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float lgammaf(uniform float x);
SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) {
  f16 res;
  foreach_active (i) {
    uniform f16 r = (f16)lgammaf(extract((float)x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) {
  f16 res = (f16)futrts_cbrt32((float)x);
  return res;
}

SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) {
  f16 res = (f16)futrts_erf32((float)x);
  return res;
}

SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) {
  f16 res = (f16)futrts_erfc32((float)x);
  return res;
}

SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) {
  return x - y * (float16)trunc((float) (x/y));
}

SCALAR_FUN_ATTR f16 futrts_round16(f16 x) {
  return (float16)round((float)x);
}

SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) {
  return (float16)floor((float)x);
}

SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) {
  return (float16)ceil((float)x);
}

SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) {
  return (float16)futrts_nextafter32((float)x, (float) y);
}

SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) {
  return futrts_ldexp32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) {
  return futrts_copysign32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

#else // Assume CUDA.

SCALAR_FUN_ATTR f16 futrts_log16(f16 x) {
  return hlog(x);
}

SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) {
  return hlog2(x);
}

SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) {
  return hlog10(x);
}

SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) {
  return (f16)log1pf((float)x);
}

SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) {
  return hsqrt(x);
}

SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) {
  return cbrtf(x);
}

SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) {
  return hexp(x);
}

SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) {
  return hcos(x);
}

SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) {
  return hsin(x);
}

SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) {
  return tanf(x);
}

SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) {
  return acosf(x);
}

SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) {
  return asinf(x);
}

SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) {
  return atanf(x);
}

SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) {
  return coshf(x);
}

SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) {
  return sinhf(x);
}

SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) {
  return tanhf(x);
}

SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) {
  return acoshf(x);
}

SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) {
  return asinhf(x);
}

SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) {
  return atanhf(x);
}

SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2f(x, y);
}

SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) {
  return hypotf(x, y);
}

SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) {
  return tgammaf(x);
}

SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) {
  return lgammaf(x);
}

SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) {
  return erff(x);
}

SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) {
  return erfcf(x);
}

SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) {
  return fmodf(x, y);
}

SCALAR_FUN_ATTR f16 futrts_round16(f16 x) {
  return rintf(x);
}

SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) {
  return hfloor(x);
}

SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) {
  return hceil(x);
}

SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) {
  return __ushort_as_half(halfbitsnextafter(__half_as_ushort(x), __half_as_ushort(y)));
}

SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) {
  return futrts_ldexp32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) {
  return futrts_copysign32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fmaf(a, b, c);
}

#endif

// The CUDA __half type cannot be put in unions for some reason, so we
// use bespoke conversion functions instead.
#ifdef __CUDA_ARCH__
SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  return __half_as_ushort(x);
}
SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  return __ushort_as_half(x);
}
#elif ISPC

SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  varying int16_t y = *((varying int16_t * uniform)&x);
  return y;
}

SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  varying f16 y = *((varying f16 * uniform)&x);
  return y;
}
#else
SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  union {
    f16 f;
    int16_t t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  union {
    int16_t f;
    f16 t;
  } p;

  p.f = x;
  return p.t;
}
#endif

#else // No native f16 - emulate.

SCALAR_FUN_ATTR f16 fabs16(f16 x) {
  return fabs32(x);
}

SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) {
  return fmax32(x, y);
}

SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) {
  return fmin32(x, y);
}

SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) {
  return fpow32(x, y);
}

SCALAR_FUN_ATTR bool futrts_isnan16(f16 x) {
  return futrts_isnan32(x);
}

SCALAR_FUN_ATTR bool futrts_isinf16(f16 x) {
  return futrts_isinf32(x);
}

SCALAR_FUN_ATTR f16 futrts_log16(f16 x) {
  return futrts_log32(x);
}

SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) {
  return futrts_log2_32(x);
}

SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) {
  return futrts_log10_32(x);
}

SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) {
  return futrts_log1p_32(x);
}

SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) {
  return futrts_sqrt32(x);
}

SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) {
  return futrts_cbrt32(x);
}

SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) {
  return futrts_exp32(x);
}

SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) {
  return futrts_cos32(x);
}

SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) {
  return futrts_sin32(x);
}

SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) {
  return futrts_tan32(x);
}

SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) {
  return futrts_acos32(x);
}

SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) {
  return futrts_asin32(x);
}

SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) {
  return futrts_atan32(x);
}

SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) {
  return futrts_cosh32(x);
}

SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) {
  return futrts_sinh32(x);
}

SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) {
  return futrts_tanh32(x);
}

SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) {
  return futrts_acosh32(x);
}

SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) {
  return futrts_asinh32(x);
}

SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) {
  return futrts_atanh32(x);
}

SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) {
  return futrts_atan2_32(x, y);
}

SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) {
  return futrts_hypot32(x, y);
}

SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) {
  return futrts_gamma32(x);
}

SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) {
  return futrts_lgamma32(x);
}

SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) {
  return futrts_erf32(x);
}

SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) {
  return futrts_erfc32(x);
}

SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) {
  return fmod32(x, y);
}

SCALAR_FUN_ATTR f16 futrts_round16(f16 x) {
  return futrts_round32(x);
}

SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) {
  return futrts_floor32(x);
}

SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) {
  return futrts_ceil32(x);
}

SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) {
  return halfbits2float(halfbitsnextafter(float2halfbits(x), float2halfbits(y)));
}

SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return futrts_lerp32(v0, v1, t);
}

SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) {
  return futrts_ldexp32(x, y);
}

SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) {
  return futrts_copysign32((float)x, y);
}

SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return futrts_mad32(a, b, c);
}

SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return futrts_fma32(a, b, c);
}

// Even when we are using an OpenCL that does not support cl_khr_fp16,
// it must still support vload_half for actually creating a
// half-precision number, which can then be efficiently converted to a
// float.  Similarly for vstore_half.
#ifdef __OPENCL_VERSION__

SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  int16_t y;
  // Violating strict aliasing here.
  vstore_half((float)x, 0, (half*)&y);
  return y;
}

SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  return (f16)vload_half(0, (half*)&x);
}

#else

SCALAR_FUN_ATTR int16_t futrts_to_bits16(f16 x) {
  return (int16_t)float2halfbits(x);
}

SCALAR_FUN_ATTR f16 futrts_from_bits16(int16_t x) {
  return halfbits2float((uint16_t)x);
}

SCALAR_FUN_ATTR f16 fsignum16(f16 x) {
  return futrts_isnan16(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0);
}

#endif

#endif

SCALAR_FUN_ATTR float fpconv_f16_f16(f16 x) {
  return x;
}

SCALAR_FUN_ATTR float fpconv_f16_f32(f16 x) {
  return x;
}

SCALAR_FUN_ATTR f16 fpconv_f32_f16(float x) {
  return (f16) x;
}

#ifdef FUTHARK_F64_ENABLED

SCALAR_FUN_ATTR double fpconv_f16_f64(f16 x) {
  return (double) x;
}

#if ISPC
SCALAR_FUN_ATTR f16 fpconv_f64_f16(double x) {
  return (f16) ((float)x);
}
#else
SCALAR_FUN_ATTR f16 fpconv_f64_f16(double x) {
  return (f16) x;
}
#endif
#endif


// End of scalar_f16.h.

// Start of context_prototypes.h
//
// Prototypes for the functions in context.h, or that will be called
// from those functions, that need to be available very early.

struct futhark_context_config;
struct futhark_context;

static void set_error(struct futhark_context* ctx, char *error);

// These are called in context/config new/free functions and contain
// shared setup.  They are generated by the compiler itself.
static int init_constants(struct futhark_context*);
static int free_constants(struct futhark_context*);
static void setup_program(struct futhark_context* ctx);
static void teardown_program(struct futhark_context *ctx);

// Allocate host memory.  Must be freed with host_free().
static void host_alloc(struct futhark_context* ctx, size_t size, const char* tag, size_t* size_out, void** mem_out);
// Allocate memory allocated with host_alloc().
static void host_free(struct futhark_context* ctx, size_t size, const char* tag, void* mem);

// Log that a copy has occurred.
static void log_copy(struct futhark_context* ctx,
                     const char *kind, int r,
                     int64_t dst_offset, int64_t dst_strides[r],
                     int64_t src_offset, int64_t src_strides[r],
                     int64_t shape[r]);

static void log_transpose(struct futhark_context* ctx,
                          int64_t k, int64_t m, int64_t n);

static bool lmad_map_tr(int64_t *num_arrays_out, int64_t *n_out, int64_t *m_out,
                        int r,
                        const int64_t dst_strides[r],
                        const int64_t src_strides[r],
                        const int64_t shape[r]);

static bool lmad_contiguous(int r, int64_t strides[r], int64_t shape[r]);

static bool lmad_memcpyable(int r,
                            int64_t dst_strides[r], int64_t src_strides[r], int64_t shape[r]);

static void add_event(struct futhark_context* ctx,
                      const char* name,
                      char* description,
                      void* data,
                      event_report_fn f);

// Functions that must be defined by the backend.
static void backend_context_config_setup(struct futhark_context_config* cfg);
static void backend_context_config_teardown(struct futhark_context_config* cfg);
static int backend_context_setup(struct futhark_context *ctx);
static void backend_context_teardown(struct futhark_context *ctx);

// End of of context_prototypes.h

struct memblock {
    int *references;
    unsigned char *mem;
    int64_t size;
    const char *desc;
};
struct constants {
    int dummy;
};
struct tuning_params {
    int dummy;
};
static const int num_tuning_params = 0;
static const char *tuning_param_names[] = {NULL};
static const char *tuning_param_vars[] = {NULL};
static const char *tuning_param_classes[] = {NULL};
static int64_t tuning_param_defaults[] = {0};
// Start of backends/c.h

struct futhark_context_config {
  int in_use;
  int debugging;
  int profiling;
  int logging;
  char *cache_fname;
  int num_tuning_params;
  int64_t *tuning_params;
  const char** tuning_param_names;
  const char** tuning_param_vars;
  const char** tuning_param_classes;
};

static void backend_context_config_setup(struct futhark_context_config* cfg) {
  (void)cfg;
}

static void backend_context_config_teardown(struct futhark_context_config* cfg) {
  (void)cfg;
}

int futhark_context_config_set_tuning_param(struct futhark_context_config* cfg, const char *param_name, size_t param_value) {
  (void)cfg; (void)param_name; (void)param_value;
  return 1;
}

struct futhark_context {
  struct futhark_context_config* cfg;
  int detail_memory;
  int debugging;
  int profiling;
  int profiling_paused;
  int logging;
  lock_t lock;
  char *error;
  lock_t error_lock;
  FILE *log;
  struct constants *constants;
  struct free_list free_list;
  struct event_list event_list;
  int64_t peak_mem_usage_default;
  int64_t cur_mem_usage_default;
  struct program* program;
  bool program_initialised;
};

int backend_context_setup(struct futhark_context* ctx) {
  (void)ctx;
  return 0;
}

void backend_context_teardown(struct futhark_context* ctx) {
  (void)ctx;
}

int futhark_context_sync(struct futhark_context* ctx) {
  (void)ctx;
  return 0;
}

// End of backends/c.h

struct program {
    int dummy;
};
static void setup_program(struct futhark_context *ctx)
{
    (void) ctx;
    
    int error = 0;
    
    (void) error;
    ctx->program = malloc(sizeof(struct program));
}
static void teardown_program(struct futhark_context *ctx)
{
    (void) ctx;
    
    int error = 0;
    
    (void) error;
    free(ctx->program);
}
static void set_tuning_params(struct futhark_context *ctx)
{
    (void) ctx;
}
int memblock_unref(struct futhark_context *ctx, struct memblock *block, const char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(ctx->log, "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n", desc, block->desc, "default space", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_default -= block->size;
            host_free(ctx, (size_t) block->size, desc, (void *) block->mem);
            free(block->references);
            if (ctx->detail_memory)
                fprintf(ctx->log, "%lld bytes freed (now allocated: %lld bytes)\n", (long long) block->size, (long long) ctx->cur_mem_usage_default);
        }
        block->references = NULL;
    }
    return 0;
}
int memblock_alloc(struct futhark_context *ctx, struct memblock *block, int64_t size, const char *desc)
{
    if (size < 0)
        futhark_panic(1, "Negative allocation of %lld bytes attempted for %s in %s.\n", (long long) size, desc, "default space", ctx->cur_mem_usage_default);
    
    int ret = memblock_unref(ctx, block, desc);
    
    if (ret != FUTHARK_SUCCESS)
        return ret;
    if (ctx->detail_memory)
        fprintf(ctx->log, "Allocating %lld bytes for %s in %s (currently allocated: %lld bytes).\n", (long long) size, desc, "default space", (long long) ctx->cur_mem_usage_default);
    host_alloc(ctx, (size_t) size, desc, (size_t *) &size, (void *) &block->mem);
    if (ctx->error == NULL) {
        block->references = (int *) malloc(sizeof(int));
        *block->references = 1;
        block->size = size;
        block->desc = desc;
        
        long long new_usage = ctx->cur_mem_usage_default + size;
        
        if (ctx->detail_memory)
            fprintf(ctx->log, "Received block of %lld bytes; now allocated: %lld bytes", (long long) block->size, new_usage);
        ctx->cur_mem_usage_default = new_usage;
        if (new_usage > ctx->peak_mem_usage_default) {
            ctx->peak_mem_usage_default = new_usage;
            if (ctx->detail_memory)
                fprintf(ctx->log, " (new peak).\n");
        } else if (ctx->detail_memory)
            fprintf(ctx->log, ".\n");
        return FUTHARK_SUCCESS;
    } else {
        // We are naively assuming that any memory allocation error is due to OOM.
        lock_lock(&ctx->error_lock);
        
        char *old_error = ctx->error;
        
        ctx->error = msgprintf("Failed to allocate memory in %s.\nAttempted allocation: %12lld bytes\nCurrently allocated:  %12lld bytes\n%s", "default space", (long long) size, (long long) ctx->cur_mem_usage_default, old_error);
        free(old_error);
        lock_unlock(&ctx->error_lock);
        return FUTHARK_OUT_OF_MEMORY;
    }
}
int memblock_set(struct futhark_context *ctx, struct memblock *lhs, struct memblock *rhs, const char *lhs_desc)
{
    int ret = memblock_unref(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
char *futhark_context_report(struct futhark_context *ctx)
{
    if (futhark_context_sync(ctx) != 0)
        return NULL;
    
    struct str_builder builder;
    
    str_builder_init(&builder);
    str_builder_char(&builder, '{');
    str_builder_str(&builder, "\"memory\":{");
    str_builder(&builder, "\"default space\": %lld", (long long) ctx->peak_mem_usage_default);
    str_builder_str(&builder, "},\"events\":[");
    if (report_events_in_list(&ctx->event_list, &builder) != 0) {
        free(builder.str);
        return NULL;
    } else {
        str_builder_str(&builder, "]}");
        return builder.str;
    }
}
int futhark_context_clear_caches(struct futhark_context *ctx)
{
    lock_lock(&ctx->lock);
    ctx->peak_mem_usage_default = 0;
    lock_unlock(&ctx->lock);
    return ctx->error != NULL;
}

// Start of context.h

// Internal functions.

static void set_error(struct futhark_context* ctx, char *error) {
  lock_lock(&ctx->error_lock);
  if (ctx->error == NULL) {
    ctx->error = error;
  } else {
    free(error);
  }
  lock_unlock(&ctx->error_lock);
}

// XXX: should be static, but used in ispc_util.h
void lexical_realloc_error(struct futhark_context* ctx, size_t new_size) {
  set_error(ctx,
            msgprintf("Failed to allocate memory.\nAttempted allocation: %12lld bytes\n",
                      (long long) new_size));
}

static int lexical_realloc(struct futhark_context *ctx,
                           unsigned char **ptr,
                           int64_t *old_size,
                           int64_t new_size) {
  unsigned char *new = realloc(*ptr, (size_t)new_size);
  if (new == NULL) {
    lexical_realloc_error(ctx, new_size);
    return FUTHARK_OUT_OF_MEMORY;
  } else {
    *ptr = new;
    *old_size = new_size;
    return FUTHARK_SUCCESS;
  }
}

static void free_all_in_free_list(struct futhark_context* ctx) {
  fl_mem mem;
  free_list_pack(&ctx->free_list);
  while (free_list_first(&ctx->free_list, (fl_mem*)&mem) == 0) {
    free((void*)mem);
  }
}

static int is_small_alloc(size_t size) {
  return size < 1024*1024;
}

static void host_alloc(struct futhark_context* ctx,
                       size_t size, const char* tag, size_t* size_out, void** mem_out) {
  if (is_small_alloc(size) || free_list_find(&ctx->free_list, size, tag, size_out, (fl_mem*)mem_out) != 0) {
    *size_out = size;
    *mem_out = malloc(size);
  }
}

static void host_free(struct futhark_context* ctx,
                      size_t size, const char* tag, void* mem) {
  // Small allocations are handled by malloc()s own free list.  The
  // threshold here is kind of arbitrary, but seems to work OK.
  // Larger allocations are mmap()ed/munmapped() every time, which is
  // very slow, and Futhark programs tend to use a few very large
  // allocations.
  if (is_small_alloc(size)) {
    free(mem);
  } else {
    free_list_insert(&ctx->free_list, size, (fl_mem)mem, tag);
  }
}

static void add_event(struct futhark_context* ctx,
                      const char* name,
                      char* description,
                      void* data,
                      event_report_fn f) {
  if (ctx->logging) {
    fprintf(ctx->log, "Event: %s\n%s\n", name, description);
  }
  add_event_to_list(&ctx->event_list, name, description, data, f);
}

char *futhark_context_get_error(struct futhark_context *ctx) {
  char *error = ctx->error;
  ctx->error = NULL;
  return error;
}

void futhark_context_config_set_debugging(struct futhark_context_config *cfg, int flag) {
    cfg->profiling = cfg->logging = cfg->debugging = flag;
}

void futhark_context_config_set_profiling(struct futhark_context_config *cfg, int flag) {
    cfg->profiling = flag;
}

void futhark_context_config_set_logging(struct futhark_context_config *cfg, int flag) {
    cfg->logging = flag;
}

void futhark_context_config_set_cache_file(struct futhark_context_config *cfg, const char *f) {
  cfg->cache_fname = strdup(f);
}

int futhark_get_tuning_param_count(void) {
  return num_tuning_params;
}

const char *futhark_get_tuning_param_name(int i) {
  return tuning_param_names[i];
}

const char *futhark_get_tuning_param_class(int i) {
    return tuning_param_classes[i];
}

void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f){
  ctx->log = f;
}

void futhark_context_pause_profiling(struct futhark_context *ctx) {
  ctx->profiling_paused = 1;
}

void futhark_context_unpause_profiling(struct futhark_context *ctx) {
  ctx->profiling_paused = 0;
}

struct futhark_context_config* futhark_context_config_new(void) {
  struct futhark_context_config* cfg = malloc(sizeof(struct futhark_context_config));
  if (cfg == NULL) {
    return NULL;
  }
  cfg->in_use = 0;
  cfg->debugging = 0;
  cfg->profiling = 0;
  cfg->logging = 0;
  cfg->cache_fname = NULL;
  cfg->num_tuning_params = num_tuning_params;
  cfg->tuning_params = malloc(cfg->num_tuning_params * sizeof(int64_t));
  memcpy(cfg->tuning_params, tuning_param_defaults,
         cfg->num_tuning_params * sizeof(int64_t));
  cfg->tuning_param_names = tuning_param_names;
  cfg->tuning_param_vars = tuning_param_vars;
  cfg->tuning_param_classes = tuning_param_classes;
  backend_context_config_setup(cfg);
  return cfg;
}

void futhark_context_config_free(struct futhark_context_config* cfg) {
  assert(!cfg->in_use);
  backend_context_config_teardown(cfg);
  free(cfg->cache_fname);
  free(cfg->tuning_params);
  free(cfg);
}

struct futhark_context* futhark_context_new(struct futhark_context_config* cfg) {
  struct futhark_context* ctx = malloc(sizeof(struct futhark_context));
  if (ctx == NULL) {
    return NULL;
  }
  assert(!cfg->in_use);
  ctx->cfg = cfg;
  ctx->cfg->in_use = 1;
  ctx->program_initialised = false;
  create_lock(&ctx->error_lock);
  create_lock(&ctx->lock);
  free_list_init(&ctx->free_list);
  event_list_init(&ctx->event_list);
  ctx->peak_mem_usage_default = 0;
  ctx->cur_mem_usage_default = 0;
  ctx->constants = malloc(sizeof(struct constants));
  ctx->debugging = cfg->debugging;
  ctx->logging = cfg->logging;
  ctx->detail_memory = cfg->logging;
  ctx->profiling = cfg->profiling;
  ctx->profiling_paused = 0;
  ctx->error = NULL;
  ctx->log = stderr;
  set_tuning_params(ctx);
  if (backend_context_setup(ctx) == 0) {
    setup_program(ctx);
    init_constants(ctx);
    ctx->program_initialised = true;
    (void)futhark_context_clear_caches(ctx);
    (void)futhark_context_sync(ctx);
  }
  return ctx;
}

void futhark_context_free(struct futhark_context* ctx) {
  if (ctx->program_initialised) {
    free_constants(ctx);
    teardown_program(ctx);
  }
  backend_context_teardown(ctx);
  free_all_in_free_list(ctx);
  free_list_destroy(&ctx->free_list);
  event_list_free(&ctx->event_list);
  free(ctx->constants);
  free(ctx->error);
  free_lock(&ctx->lock);
  free_lock(&ctx->error_lock);
  ctx->cfg->in_use = 0;
  free(ctx);
}

// End of context.h

// Start of copy.h

// Cache-oblivious map-transpose function.
#define GEN_MAP_TRANSPOSE(NAME, ELEM_TYPE)                              \
  static void map_transpose_##NAME                                      \
  (ELEM_TYPE* dst, ELEM_TYPE* src,                                      \
   int64_t k, int64_t m, int64_t n,                                     \
   int64_t cb, int64_t ce, int64_t rb, int64_t re)                      \
  {                                                                     \
  int32_t r = re - rb;                                                  \
  int32_t c = ce - cb;                                                  \
  if (k == 1) {                                                         \
    if (r <= 64 && c <= 64) {                                           \
      for (int64_t j = 0; j < c; j++) {                                 \
        for (int64_t i = 0; i < r; i++) {                               \
          dst[(j + cb) * n + (i + rb)] = src[(i + rb) * m + (j + cb)];  \
        }                                                               \
      }                                                                 \
    } else if (c <= r) {                                                \
      map_transpose_##NAME(dst, src, k, m, n, cb, ce, rb, rb + r/2);    \
      map_transpose_##NAME(dst, src, k, m, n, cb, ce, rb + r/2, re);    \
    } else {                                                            \
      map_transpose_##NAME(dst, src, k, m, n, cb, cb + c/2, rb, re);    \
      map_transpose_##NAME(dst, src, k, m, n, cb + c/2, ce, rb, re);    \
    }                                                                   \
  } else {                                                              \
  for (int64_t i = 0; i < k; i++) {                                     \
    map_transpose_##NAME(dst + i * m * n, src + i * m * n, 1, m, n, cb, ce, rb, re); \
  }\
} \
}

// Straightforward LMAD copy function.
#define GEN_LMAD_COPY_ELEMENTS(NAME, ELEM_TYPE)                         \
  static void lmad_copy_elements_##NAME(int r,                          \
                                        ELEM_TYPE* dst, int64_t dst_strides[r], \
                                        ELEM_TYPE *src, int64_t src_strides[r], \
                                        int64_t shape[r]) {             \
    if (r == 1) {                                                       \
      for (int i = 0; i < shape[0]; i++) {                              \
        dst[i*dst_strides[0]] = src[i*src_strides[0]];                  \
      }                                                                 \
    } else if (r > 1) {                                                 \
      for (int i = 0; i < shape[0]; i++) {                              \
        lmad_copy_elements_##NAME(r-1,                                  \
                                  dst+i*dst_strides[0], dst_strides+1,  \
                                  src+i*src_strides[0], src_strides+1,  \
                                  shape+1);                             \
      }                                                                 \
    }                                                                   \
  }                                                                     \

// Check whether this LMAD can be seen as a transposed 2D array.  This
// is done by checking every possible splitting point.
static bool lmad_is_tr(int64_t *n_out, int64_t *m_out,
                       int r,
                       const int64_t strides[r],
                       const int64_t shape[r]) {
  for (int i = 1; i < r; i++) {
    int n = 1, m = 1;
    bool ok = true;
    int64_t expected = 1;
    // Check strides before 'i'.
    for (int j = i-1; j >= 0; j--) {
      ok = ok && strides[j] == expected;
      expected *= shape[j];
      n *= shape[j];
    }
    // Check strides after 'i'.
    for (int j = r-1; j >= i; j--) {
      ok = ok && strides[j] == expected;
      expected *= shape[j];
      m *= shape[j];
    }
    if (ok) {
      *n_out = n;
      *m_out = m;
      return true;
    }
  }
  return false;
}

// This function determines whether the a 'dst' LMAD is row-major and
// 'src' LMAD is column-major.  Both LMADs are for arrays of the same
// shape.  Both LMADs are allowed to have additional dimensions "on
// top".  Essentially, this function determines whether a copy from
// 'src' to 'dst' is a "map(transpose)" that we know how to implement
// efficiently.  The LMADs can have arbitrary rank, and the main
// challenge here is checking whether the src LMAD actually
// corresponds to a 2D column-major layout by morally collapsing
// dimensions.  There is a lot of looping here, but the actual trip
// count is going to be very low in practice.
//
// Returns true if this is indeed a map(transpose), and writes the
// number of arrays, and moral array size to appropriate output
// parameters.
static bool lmad_map_tr(int64_t *num_arrays_out, int64_t *n_out, int64_t *m_out,
                        int r,
                        const int64_t dst_strides[r],
                        const int64_t src_strides[r],
                        const int64_t shape[r]) {
  int64_t rowmajor_strides[r];
  rowmajor_strides[r-1] = 1;

  for (int i = r-2; i >= 0; i--) {
    rowmajor_strides[i] = rowmajor_strides[i+1] * shape[i+1];
  }

  // map_r will be the number of mapped dimensions on top.
  int map_r = 0;
  int64_t num_arrays = 1;
  for (int i = 0; i < r; i++) {
    if (dst_strides[i] != rowmajor_strides[i] ||
        src_strides[i] != rowmajor_strides[i]) {
      break;
    } else {
      num_arrays *= shape[i];
      map_r++;
    }
  }

  *num_arrays_out = num_arrays;

  if (r==map_r) {
    return false;
  }

  if (memcmp(&rowmajor_strides[map_r],
             &dst_strides[map_r],
             sizeof(int64_t)*(r-map_r)) == 0) {
    return lmad_is_tr(n_out, m_out, r-map_r, src_strides+map_r, shape+map_r);
  } else if (memcmp(&rowmajor_strides[map_r],
                    &src_strides[map_r],
                    sizeof(int64_t)*(r-map_r)) == 0) {
    return lmad_is_tr(m_out, n_out, r-map_r, dst_strides+map_r, shape+map_r);
  }
  return false;
}

// Check if the strides correspond to row-major strides of *any*
// permutation of the shape.  This is done by recursive search with
// backtracking.  This is worst-case exponential, but hopefully the
// arrays we encounter do not have that many dimensions.
static bool lmad_contiguous_search(int checked, int64_t expected,
                                   int r,
                                   int64_t strides[r], int64_t shape[r], bool used[r]) {
  for (int i = 0; i < r; i++) {
    for (int j = 0; j < r; j++) {
      if (!used[j] && strides[j] == expected && strides[j] >= 0) {
        used[j] = true;
        if (checked+1 == r ||
            lmad_contiguous_search(checked+1, expected * shape[j], r, strides, shape, used)) {
          return true;
        }
        used[j] = false;
      }
    }
  }
  return false;
}

// Does this LMAD correspond to an array with positive strides and no
// holes?
static bool lmad_contiguous(int r, int64_t strides[r], int64_t shape[r]) {
  bool used[r];
  for (int i = 0; i < r; i++) {
    used[i] = false;
  }
  return lmad_contiguous_search(0, 1, r, strides, shape, used);
}

// Does this copy correspond to something that could be done with a
// memcpy()-like operation?  I.e. do the LMADs actually represent the
// same in-memory layout and are they contiguous?
static bool lmad_memcpyable(int r,
                            int64_t dst_strides[r], int64_t src_strides[r], int64_t shape[r]) {
  if (!lmad_contiguous(r, dst_strides, shape)) {
    return false;
  }
  for (int i = 0; i < r; i++) {
    if (dst_strides[i] != src_strides[i] && shape[i] != 1) {
      return false;
    }
  }
  return true;
}


static void log_copy(struct futhark_context* ctx,
                     const char *kind, int r,
                     int64_t dst_offset, int64_t dst_strides[r],
                     int64_t src_offset, int64_t src_strides[r],
                     int64_t shape[r]) {
  if (ctx->logging) {
    fprintf(ctx->log, "\n# Copy %s\n", kind);
    fprintf(ctx->log, "Shape: ");
    for (int i = 0; i < r; i++) { fprintf(ctx->log, "[%ld]", (long int)shape[i]); }
    fprintf(ctx->log, "\n");
    fprintf(ctx->log, "Dst offset: %ld\n", (long int)dst_offset);
    fprintf(ctx->log, "Dst strides:");
    for (int i = 0; i < r; i++) { fprintf(ctx->log, " %ld", (long int)dst_strides[i]); }
    fprintf(ctx->log, "\n");
    fprintf(ctx->log, "Src offset: %ld\n", (long int)src_offset);
    fprintf(ctx->log, "Src strides:");
    for (int i = 0; i < r; i++) { fprintf(ctx->log, " %ld", (long int)src_strides[i]); }
    fprintf(ctx->log, "\n");
  }
}

static void log_transpose(struct futhark_context* ctx,
                          int64_t k, int64_t n, int64_t m) {
  if (ctx->logging) {
    fprintf(ctx->log, "## Transpose\n");
    fprintf(ctx->log, "Arrays     : %ld\n", (long int)k);
    fprintf(ctx->log, "X elements : %ld\n", (long int)m);
    fprintf(ctx->log, "Y elements : %ld\n", (long int)n);
    fprintf(ctx->log, "\n");
  }
}

#define GEN_LMAD_COPY(NAME, ELEM_TYPE)                                  \
  static void lmad_copy_##NAME                                          \
  (struct futhark_context *ctx, int r,                                  \
   ELEM_TYPE* dst, int64_t dst_offset, int64_t dst_strides[r],          \
   ELEM_TYPE *src, int64_t src_offset, int64_t src_strides[r],          \
   int64_t shape[r]) {                                                  \
    log_copy(ctx, "CPU to CPU", r, dst_offset, dst_strides,             \
             src_offset, src_strides, shape);                           \
    int64_t size = 1;                                                   \
    for (int i = 0; i < r; i++) { size *= shape[i]; }                   \
    if (size == 0) { return; }                                          \
    int64_t k, n, m;                                                    \
    if (lmad_map_tr(&k, &n, &m,                                         \
                    r, dst_strides, src_strides, shape)) {              \
      log_transpose(ctx, k, n, m);                                      \
      map_transpose_##NAME                                              \
        (dst+dst_offset, src+src_offset, k, n, m, 0, n, 0, m);          \
    } else if (lmad_memcpyable(r, dst_strides, src_strides, shape)) {   \
      if (ctx->logging) {fprintf(ctx->log, "## Flat copy\n\n");}          \
      memcpy(dst+dst_offset, src+src_offset, size*sizeof(*dst));        \
    } else {                                                            \
      if (ctx->logging) {fprintf(ctx->log, "## General copy\n\n");}       \
      lmad_copy_elements_##NAME                                         \
        (r,                                                             \
         dst+dst_offset, dst_strides,                                   \
         src+src_offset, src_strides, shape);                           \
    }                                                                   \
  }

GEN_MAP_TRANSPOSE(1b, uint8_t)
GEN_MAP_TRANSPOSE(2b, uint16_t)
GEN_MAP_TRANSPOSE(4b, uint32_t)
GEN_MAP_TRANSPOSE(8b, uint64_t)

GEN_LMAD_COPY_ELEMENTS(1b, uint8_t)
GEN_LMAD_COPY_ELEMENTS(2b, uint16_t)
GEN_LMAD_COPY_ELEMENTS(4b, uint32_t)
GEN_LMAD_COPY_ELEMENTS(8b, uint64_t)

GEN_LMAD_COPY(1b, uint8_t)
GEN_LMAD_COPY(2b, uint16_t)
GEN_LMAD_COPY(4b, uint32_t)
GEN_LMAD_COPY(8b, uint64_t)

// End of copy.h

#define FUTHARK_FUN_ATTR static

FUTHARK_FUN_ATTR int futrts_entry_Inner_Radix_Hash_Join(struct futhark_context *ctx, struct memblock *mem_out_p_133978, struct memblock *mem_out_p_133979, struct memblock *mem_out_p_133980, int64_t *out_prim_out_133981, struct memblock pR_mem_133466, struct memblock pS_mem_133467, struct memblock bounds_mem_133468, struct memblock depths_mem_133469, struct memblock first_info_idx_mem_133470, struct memblock last_info_idx_mem_133471, int64_t nR_117695, int64_t b_117696, int64_t nS_117697, int64_t dz2081U_117698, int64_t dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699, int32_t radix_sizze_117700, int32_t maxDepth_117705);
FUTHARK_FUN_ATTR int futrts_entry_argmin_double(struct futhark_context *ctx, int64_t *out_prim_out_134018, struct memblock ks_mem_133466, int64_t n_61823);
FUTHARK_FUN_ATTR int futrts_entry_argmin_float(struct futhark_context *ctx, int64_t *out_prim_out_134019, struct memblock ks_mem_133466, int64_t n_61646);
FUTHARK_FUN_ATTR int futrts_entry_argmin_int(struct futhark_context *ctx, int64_t *out_prim_out_134020, struct memblock ks_mem_133466, int64_t n_61295);
FUTHARK_FUN_ATTR int futrts_entry_argmin_long(struct futhark_context *ctx, int64_t *out_prim_out_134021, struct memblock ks_mem_133466, int64_t n_61469);
FUTHARK_FUN_ATTR int futrts_entry_argmin_short(struct futhark_context *ctx, int64_t *out_prim_out_134022, struct memblock ks_mem_133466, int64_t n_61121);
FUTHARK_FUN_ATTR int futrts_entry_calc_partitions_from_partitioned_set(struct futhark_context *ctx, struct memblock *mem_out_p_134023, struct memblock *mem_out_p_134024, int64_t *out_prim_out_134025, int32_t *out_prim_out_134026, struct memblock pXs_mem_133466, int64_t n_114179, int64_t b_114180, int32_t radix_sizze_114181, int64_t offset_114183, int64_t sizze_thresh_114184, int32_t max_depth_114185);
FUTHARK_FUN_ATTR int futrts_entry_create_hash_table_from_partitioned_set(struct futhark_context *ctx, struct memblock *mem_out_p_134034, struct memblock *mem_out_p_134035, int64_t *out_prim_out_134036, struct memblock pXs_mem_133466, struct memblock bounds_mem_133467, struct memblock depths_mem_133468, int64_t n_114971, int64_t b_114972, int64_t dz2080U_114973, int64_t dz2081U_114974, int32_t radix_sizze_114975, int32_t maxDepth_114979, int64_t scatter_psizze_114980);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_GFTR(struct futhark_context *ctx, struct memblock *mem_out_p_134042, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_65436, int64_t dz2083U_65437, int64_t incr_65438, int64_t psizze_65439, int64_t pL_bytes_65441);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_double(struct futhark_context *ctx, struct memblock *mem_out_p_134043, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_64972, int64_t dz2083U_64973, int64_t incr_64974, int64_t psizze_64975);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_double_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134044, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_66944, int64_t n_66945, int64_t incr_66946, int64_t psizze_66947);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_float(struct futhark_context *ctx, struct memblock *mem_out_p_134045, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_64692, int64_t dz2083U_64693, int64_t incr_64694, int64_t psizze_64695);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_float_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134046, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_66643, int64_t n_66644, int64_t incr_66645, int64_t psizze_66646);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_int(struct futhark_context *ctx, struct memblock *mem_out_p_134047, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_64132, int64_t dz2083U_64133, int64_t incr_64134, int64_t psizze_64135);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_int_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134048, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_66041, int64_t n_66042, int64_t incr_66043, int64_t psizze_66044);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_long(struct futhark_context *ctx, struct memblock *mem_out_p_134049, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_64412, int64_t dz2083U_64413, int64_t incr_64414, int64_t psizze_64415);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_long_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134050, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_66342, int64_t n_66343, int64_t incr_66344, int64_t psizze_66345);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_short(struct futhark_context *ctx, struct memblock *mem_out_p_134051, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_63852, int64_t dz2083U_63853, int64_t incr_63854, int64_t psizze_63855);
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_short_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134052, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_65740, int64_t n_65741, int64_t incr_65742, int64_t psizze_65743);
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_double(struct futhark_context *ctx, struct memblock *mem_out_p_134053, struct memblock *mem_out_p_134054, struct memblock *mem_out_p_134055, int64_t *out_prim_out_134056, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_109429, int64_t nS_109430, int64_t offset_R_109433, int64_t offset_S_109434, int64_t partitionSizze_109435, int64_t scatter_psizze_109436);
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_float(struct futhark_context *ctx, struct memblock *mem_out_p_134065, struct memblock *mem_out_p_134066, struct memblock *mem_out_p_134067, int64_t *out_prim_out_134068, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_107305, int64_t nS_107306, int64_t offset_R_107309, int64_t offset_S_107310, int64_t partitionSizze_107311, int64_t scatter_psizze_107312);
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_int(struct futhark_context *ctx, struct memblock *mem_out_p_134077, struct memblock *mem_out_p_134078, struct memblock *mem_out_p_134079, int64_t *out_prim_out_134080, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_103069, int64_t nS_103070, int64_t offset_R_103073, int64_t offset_S_103074, int64_t partitionSizze_103075, int64_t scatter_psizze_103076);
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_long(struct futhark_context *ctx, struct memblock *mem_out_p_134089, struct memblock *mem_out_p_134090, struct memblock *mem_out_p_134091, int64_t *out_prim_out_134092, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_105181, int64_t nS_105182, int64_t offset_R_105185, int64_t offset_S_105186, int64_t partitionSizze_105187, int64_t scatter_psizze_105188);
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_short(struct futhark_context *ctx, struct memblock *mem_out_p_134101, struct memblock *mem_out_p_134102, struct memblock *mem_out_p_134103, int64_t *out_prim_out_134104, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_100945, int64_t nS_100946, int64_t offset_R_100949, int64_t offset_S_100950, int64_t partitionSizze_100951, int64_t scatter_psizze_100952);
FUTHARK_FUN_ATTR int futrts_entry_max_idx(struct futhark_context *ctx, int64_t *out_prim_out_134113, struct memblock eta_p_mem_133466, int64_t nz2080U_61900);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_double(struct futhark_context *ctx, struct memblock *mem_out_p_134114, struct memblock *mem_out_p_134115, struct memblock xs_mem_133466, int64_t n_98615, int64_t incr_98616);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_float(struct futhark_context *ctx, struct memblock *mem_out_p_134126, struct memblock *mem_out_p_134127, struct memblock xs_mem_133466, int64_t n_96470, int64_t incr_96471);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_int(struct futhark_context *ctx, struct memblock *mem_out_p_134138, struct memblock *mem_out_p_134139, struct memblock xs_mem_133466, int64_t n_92184, int64_t incr_92185);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_long(struct futhark_context *ctx, struct memblock *mem_out_p_134150, struct memblock *mem_out_p_134151, struct memblock xs_mem_133466, int64_t n_94325, int64_t incr_94326);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_short(struct futhark_context *ctx, struct memblock *mem_out_p_134162, struct memblock *mem_out_p_134163, struct memblock xs_mem_133466, int64_t n_90039, int64_t incr_90040);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_double(struct futhark_context *ctx, struct memblock *mem_out_p_134174, struct memblock *mem_out_p_134175, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_83511, int64_t b_83512);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_float(struct futhark_context *ctx, struct memblock *mem_out_p_134186, struct memblock *mem_out_p_134187, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_81146, int64_t b_81147);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_int(struct futhark_context *ctx, struct memblock *mem_out_p_134198, struct memblock *mem_out_p_134199, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_76426, int64_t b_76427);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_long(struct futhark_context *ctx, struct memblock *mem_out_p_134210, struct memblock *mem_out_p_134211, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_78781, int64_t b_78782);
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_short(struct futhark_context *ctx, struct memblock *mem_out_p_134222, struct memblock *mem_out_p_134223, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_74061, int64_t b_74062);
FUTHARK_FUN_ATTR int futrts_entry_min_idx(struct futhark_context *ctx, int64_t *out_prim_out_134234, struct memblock eta_p_mem_133466, int64_t nz2080U_61860);
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_double(struct futhark_context *ctx, struct memblock *mem_out_p_134235, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_63570, int64_t incr_63571, int64_t block_sizze_63572);
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_float(struct futhark_context *ctx, struct memblock *mem_out_p_134236, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_63236, int64_t incr_63237, int64_t block_sizze_63238);
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_int(struct futhark_context *ctx, struct memblock *mem_out_p_134237, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_62568, int64_t incr_62569, int64_t block_sizze_62570);
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_long(struct futhark_context *ctx, struct memblock *mem_out_p_134238, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_62902, int64_t incr_62903, int64_t block_sizze_62904);
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_short(struct futhark_context *ctx, struct memblock *mem_out_p_134239, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_62234, int64_t incr_62235, int64_t block_sizze_62236);
FUTHARK_FUN_ATTR int futrts_entry_partition_and_deepen_GFTR(struct futhark_context *ctx, struct memblock *mem_out_p_134240, struct memblock *mem_out_p_134241, struct memblock xs_mem_133466, struct memblock pL_mem_133467, int64_t n_111999, int64_t b_112000, int64_t pL_b_112001, int16_t block_sizze_112002, int64_t gather_psizze_112003, int32_t radix_sizze_112004, int64_t sizze_thresh_112007, int32_t max_depth_112008);
FUTHARK_FUN_ATTR int futrts_entry_partition_and_deepen_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134253, struct memblock *mem_out_p_134254, struct memblock xs_mem_133466, int64_t n_113366, int64_t b_113367, int16_t block_sizze_113368, int64_t gather_psizze_113369, int32_t radix_sizze_113370, int64_t offset_113372, int64_t sizze_thresh_113373, int32_t max_depth_113374);
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_double(struct futhark_context *ctx, struct memblock *mem_out_p_134265, struct memblock *mem_out_p_134266, struct memblock xs_mem_133466, int64_t n_87893, int64_t incr_87894, int16_t block_sizze_87895);
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_float(struct futhark_context *ctx, struct memblock *mem_out_p_134270, struct memblock *mem_out_p_134271, struct memblock xs_mem_133466, int64_t n_87004, int64_t incr_87005, int16_t block_sizze_87006);
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_int(struct futhark_context *ctx, struct memblock *mem_out_p_134275, struct memblock *mem_out_p_134276, struct memblock xs_mem_133466, int64_t n_85247, int64_t incr_85248, int16_t block_sizze_85249);
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_long(struct futhark_context *ctx, struct memblock *mem_out_p_134280, struct memblock *mem_out_p_134281, struct memblock xs_mem_133466, int64_t n_86115, int64_t incr_86116, int16_t block_sizze_86117);
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_short(struct futhark_context *ctx, struct memblock *mem_out_p_134285, struct memblock *mem_out_p_134286, struct memblock xs_mem_133466, int64_t n_84379, int64_t incr_84380, int16_t block_sizze_84381);
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_double(struct futhark_context *ctx, struct memblock *mem_out_p_134290, struct memblock *mem_out_p_134291, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_71590, int64_t b_71591, int16_t block_sizze_71592);
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_float(struct futhark_context *ctx, struct memblock *mem_out_p_134296, struct memblock *mem_out_p_134297, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_70640, int64_t b_70641, int16_t block_sizze_70642);
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_int(struct futhark_context *ctx, struct memblock *mem_out_p_134302, struct memblock *mem_out_p_134303, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_68806, int64_t b_68807, int16_t block_sizze_68808);
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_long(struct futhark_context *ctx, struct memblock *mem_out_p_134308, struct memblock *mem_out_p_134309, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_69694, int64_t b_69695, int16_t block_sizze_69696);
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_short(struct futhark_context *ctx, struct memblock *mem_out_p_134314, struct memblock *mem_out_p_134315, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_67912, int64_t b_67913, int16_t block_sizze_67914);
FUTHARK_FUN_ATTR int futrts_getPartitionBounds_12125(struct futhark_context *ctx, struct memblock *mem_out_p_134320, struct memblock *mem_out_p_134321, int64_t *out_prim_out_134322, int64_t *out_prim_out_134323, int32_t *out_prim_out_134324, struct memblock pXs_mem_133466, int64_t n_111148, int64_t b_111149, int32_t curDepth_111150, int32_t i_111152, int32_t j_111153);
FUTHARK_FUN_ATTR int futrts_get_bit_1844(struct futhark_context *ctx, int32_t *out_prim_out_134330, int32_t bit_67290, int16_t x_67291);
FUTHARK_FUN_ATTR int futrts_get_bit_2253(struct futhark_context *ctx, int32_t *out_prim_out_134331, int32_t bit_69072, int64_t x_69073);
FUTHARK_FUN_ATTR int futrts_greatest_divisor_leq_than_5357(struct futhark_context *ctx, int64_t *out_prim_out_134332, int64_t upper_bound_71619, int64_t n_71620);
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11643(struct futhark_context *ctx, struct memblock *mem_out_p_134333, struct memblock nameless_mem_133466, int64_t n_83536, int64_t incr_83537);
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11664(struct futhark_context *ctx, struct memblock *mem_out_p_134334, struct memblock nameless_mem_133466, int64_t n_84404, int64_t incr_84405);
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11686(struct futhark_context *ctx, struct memblock *mem_out_p_134335, struct memblock nameless_mem_133466, int64_t n_85272, int64_t incr_85273);
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11708(struct futhark_context *ctx, struct memblock *mem_out_p_134336, struct memblock nameless_mem_133466, int64_t n_86140, int64_t incr_86141);
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11729(struct futhark_context *ctx, struct memblock *mem_out_p_134337, struct memblock nameless_mem_133466, int64_t n_87029, int64_t incr_87030);
FUTHARK_FUN_ATTR int futrts_lifted_normalizze_10748(struct futhark_context *ctx, int64_t *out_prim_out_134338, int64_t *out_prim_out_134339, int64_t *out_prim_out_134340, int64_t *out_prim_out_134341, int64_t *out_prim_out_134342, int64_t slo_71849, int64_t shi_71850, int64_t tlo_71851, int64_t thi_71852, int64_t count_71853);
FUTHARK_FUN_ATTR int futrts_partitioned_scatter_12235(struct futhark_context *ctx, struct memblock *mem_out_p_134343, struct memblock dest_mem_133466, struct memblock is_mem_133467, struct memblock vs_mem_133468, int64_t nd_114497, int64_t n_114498, int64_t psizze_114499);
FUTHARK_FUN_ATTR int futrts_set_bit_2464(struct futhark_context *ctx, int8_t *out_prim_out_134345, int32_t bit_66984, int8_t x_66985, int32_t b_66986);

static int init_constants(struct futhark_context *ctx)
{
    (void) ctx;
    
    int err = 0;
    
    
  cleanup:
    return err;
}
static int free_constants(struct futhark_context *ctx)
{
    (void) ctx;
    return 0;
}
struct futhark_u8_2d {
    struct memblock mem;
    int64_t shape[2];
};
struct futhark_u8_2d *futhark_new_u8_2d(struct futhark_context *ctx, const uint8_t *data, int64_t dim0, int64_t dim1)
{
    int err = 0;
    struct futhark_u8_2d *bad = NULL;
    struct futhark_u8_2d *arr = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * dim1 * 1, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    if ((size_t) (dim0 * dim1) * 1 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) (dim0 * dim1) * 1);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_u8_2d *futhark_new_raw_u8_2d(struct futhark_context *ctx, unsigned char *data, int64_t dim0, int64_t dim1)
{
    int err = 0;
    struct futhark_u8_2d *bad = NULL;
    struct futhark_u8_2d *arr = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr, uint8_t *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) (arr->shape[0] * arr->shape[1]) * 1 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) (arr->shape[0] * arr->shape[1]) * 1);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_u8_2d(struct futhark_context *ctx, uint8_t *out, struct futhark_u8_2d *arr, int64_t i0, int64_t i1)
{
    int err = 0;
    
    if ((i0 >= 0 && i0 < arr->shape[0]) && (i1 >= 0 && i1 < arr->shape[1])) {
        lock_lock(&ctx->lock);
        if (1 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 1 * (i0 * arr->shape[1] + i1 * 1), 1);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_u8_2d(struct futhark_context *ctx, struct futhark_u8_2d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_i16_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_i16_1d *futhark_new_i16_1d(struct futhark_context *ctx, const int16_t *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i16_1d *bad = NULL;
    struct futhark_i16_1d *arr = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 2, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 2 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) dim0 * 2);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_i16_1d *futhark_new_raw_i16_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i16_1d *bad = NULL;
    struct futhark_i16_1d *arr = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_i16_1d(struct futhark_context *ctx, struct futhark_i16_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_i16_1d(struct futhark_context *ctx, struct futhark_i16_1d *arr, int16_t *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 2 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 2);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_i16_1d(struct futhark_context *ctx, int16_t *out, struct futhark_i16_1d *arr, int64_t i0)
{
    int err = 0;
    
    if (i0 >= 0 && i0 < arr->shape[0]) {
        lock_lock(&ctx->lock);
        if (2 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 2 * (i0 * 1), 2);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_i16_1d(struct futhark_context *ctx, struct futhark_i16_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_i16_1d(struct futhark_context *ctx, struct futhark_i16_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_i32_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_i32_1d *futhark_new_i32_1d(struct futhark_context *ctx, const int32_t *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i32_1d *bad = NULL;
    struct futhark_i32_1d *arr = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 4, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 4 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) dim0 * 4);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_i32_1d *futhark_new_raw_i32_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i32_1d *bad = NULL;
    struct futhark_i32_1d *arr = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr, int32_t *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 4 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 4);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_i32_1d(struct futhark_context *ctx, int32_t *out, struct futhark_i32_1d *arr, int64_t i0)
{
    int err = 0;
    
    if (i0 >= 0 && i0 < arr->shape[0]) {
        lock_lock(&ctx->lock);
        if (4 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 4 * (i0 * 1), 4);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_i32_1d(struct futhark_context *ctx, struct futhark_i32_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_i64_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_i64_1d *futhark_new_i64_1d(struct futhark_context *ctx, const int64_t *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i64_1d *bad = NULL;
    struct futhark_i64_1d *arr = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 8, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 8 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) dim0 * 8);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_i64_1d *futhark_new_raw_i64_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0)
{
    int err = 0;
    struct futhark_i64_1d *bad = NULL;
    struct futhark_i64_1d *arr = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr, int64_t *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 8 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 8);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_i64_1d(struct futhark_context *ctx, int64_t *out, struct futhark_i64_1d *arr, int64_t i0)
{
    int err = 0;
    
    if (i0 >= 0 && i0 < arr->shape[0]) {
        lock_lock(&ctx->lock);
        if (8 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 8 * (i0 * 1), 8);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_f32_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const float *data, int64_t dim0)
{
    int err = 0;
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 4, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 4 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) dim0 * 4);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0)
{
    int err = 0;
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr, float *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 4 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 4);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_f32_1d(struct futhark_context *ctx, float *out, struct futhark_f32_1d *arr, int64_t i0)
{
    int err = 0;
    
    if (i0 >= 0 && i0 < arr->shape[0]) {
        lock_lock(&ctx->lock);
        if (4 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 4 * (i0 * 1), 4);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_f64_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_f64_1d *futhark_new_f64_1d(struct futhark_context *ctx, const double *data, int64_t dim0)
{
    int err = 0;
    struct futhark_f64_1d *bad = NULL;
    struct futhark_f64_1d *arr = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 8, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 8 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) dim0 * 8);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_f64_1d *futhark_new_raw_f64_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0)
{
    int err = 0;
    struct futhark_f64_1d *bad = NULL;
    struct futhark_f64_1d *arr = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr, double *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 8 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 8);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_f64_1d(struct futhark_context *ctx, double *out, struct futhark_f64_1d *arr, int64_t i0)
{
    int err = 0;
    
    if (i0 >= 0 && i0 < arr->shape[0]) {
        lock_lock(&ctx->lock);
        if (8 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 8 * (i0 * 1), 8);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_opaque_sortStruct_short {
    struct futhark_i16_1d *v0;
    struct futhark_u8_2d *v1;
};
int futhark_project_opaque_sortStruct_short_k(struct futhark_context *ctx, struct futhark_i16_1d **out, const struct futhark_opaque_sortStruct_short *obj)
{
    (void) ctx;
    
    struct futhark_i16_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i16_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i16_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortStruct_short_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_short *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v1, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortStruct_short(struct futhark_context *ctx, struct futhark_opaque_sortStruct_short **out, const struct futhark_i16_1d *f_k, const struct futhark_u8_2d *f_pL)
{
    struct futhark_opaque_sortStruct_short *v = malloc(sizeof(struct futhark_opaque_sortStruct_short));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i16_1d));
        *v->v0 = *f_k;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_u8_2d));
        *v->v1 = *f_pL;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortStruct_short(struct futhark_context *ctx, struct futhark_opaque_sortStruct_short *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i16_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortStruct_short(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_short *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i16_1d(ctx, obj->v0)[0] * sizeof(int16_t);
    int64_t size_1 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i16", 4);
        out += 4;
        memcpy(out, futhark_shape_i16_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i16_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i16_1d(ctx, obj->v0)[0] * sizeof(int16_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v1), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v1, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_sortStruct_short *futhark_restore_opaque_sortStruct_short(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortStruct_short *obj = malloc(sizeof(struct futhark_opaque_sortStruct_short));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i16", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int16_t);
    
    int64_t shape_1[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * shape_1[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_i16_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_u8_2d(ctx, data_1, shape_1[0], shape_1[1]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i16_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_sortStruct_int {
    struct futhark_i32_1d *v0;
    struct futhark_u8_2d *v1;
};
int futhark_project_opaque_sortStruct_int_k(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_sortStruct_int *obj)
{
    (void) ctx;
    
    struct futhark_i32_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i32_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i32_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortStruct_int_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_int *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v1, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortStruct_int(struct futhark_context *ctx, struct futhark_opaque_sortStruct_int **out, const struct futhark_i32_1d *f_k, const struct futhark_u8_2d *f_pL)
{
    struct futhark_opaque_sortStruct_int *v = malloc(sizeof(struct futhark_opaque_sortStruct_int));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i32_1d));
        *v->v0 = *f_k;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_u8_2d));
        *v->v1 = *f_pL;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortStruct_int(struct futhark_context *ctx, struct futhark_opaque_sortStruct_int *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortStruct_int(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_int *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i32_1d(ctx, obj->v0)[0] * sizeof(int32_t);
    int64_t size_1 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, futhark_shape_i32_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i32_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i32_1d(ctx, obj->v0)[0] * sizeof(int32_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v1), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v1, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_sortStruct_int *futhark_restore_opaque_sortStruct_int(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortStruct_int *obj = malloc(sizeof(struct futhark_opaque_sortStruct_int));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int32_t);
    
    int64_t shape_1[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * shape_1[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_i32_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_u8_2d(ctx, data_1, shape_1[0], shape_1[1]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_sortStruct_long {
    struct futhark_i64_1d *v0;
    struct futhark_u8_2d *v1;
};
int futhark_project_opaque_sortStruct_long_k(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortStruct_long *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortStruct_long_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_long *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v1, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortStruct_long(struct futhark_context *ctx, struct futhark_opaque_sortStruct_long **out, const struct futhark_i64_1d *f_k, const struct futhark_u8_2d *f_pL)
{
    struct futhark_opaque_sortStruct_long *v = malloc(sizeof(struct futhark_opaque_sortStruct_long));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_k;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_u8_2d));
        *v->v1 = *f_pL;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortStruct_long(struct futhark_context *ctx, struct futhark_opaque_sortStruct_long *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortStruct_long(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_long *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v1), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v1, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_sortStruct_long *futhark_restore_opaque_sortStruct_long(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortStruct_long *obj = malloc(sizeof(struct futhark_opaque_sortStruct_long));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * shape_1[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_u8_2d(ctx, data_1, shape_1[0], shape_1[1]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_sortStruct_float {
    struct futhark_f32_1d *v0;
    struct futhark_u8_2d *v1;
};
int futhark_project_opaque_sortStruct_float_k(struct futhark_context *ctx, struct futhark_f32_1d **out, const struct futhark_opaque_sortStruct_float *obj)
{
    (void) ctx;
    
    struct futhark_f32_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_f32_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_f32_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortStruct_float_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_float *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v1, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortStruct_float(struct futhark_context *ctx, struct futhark_opaque_sortStruct_float **out, const struct futhark_f32_1d *f_k, const struct futhark_u8_2d *f_pL)
{
    struct futhark_opaque_sortStruct_float *v = malloc(sizeof(struct futhark_opaque_sortStruct_float));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_f32_1d));
        *v->v0 = *f_k;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_u8_2d));
        *v->v1 = *f_pL;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortStruct_float(struct futhark_context *ctx, struct futhark_opaque_sortStruct_float *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_f32_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortStruct_float(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_float *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_f32_1d(ctx, obj->v0)[0] * sizeof(float);
    int64_t size_1 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, futhark_shape_f32_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_f32_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_f32_1d(ctx, obj->v0)[0] * sizeof(float);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v1), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v1, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_sortStruct_float *futhark_restore_opaque_sortStruct_float(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortStruct_float *obj = malloc(sizeof(struct futhark_opaque_sortStruct_float));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(float);
    
    int64_t shape_1[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * shape_1[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_f32_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_u8_2d(ctx, data_1, shape_1[0], shape_1[1]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_f32_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_sortStruct_double {
    struct futhark_f64_1d *v0;
    struct futhark_u8_2d *v1;
};
int futhark_project_opaque_sortStruct_double_k(struct futhark_context *ctx, struct futhark_f64_1d **out, const struct futhark_opaque_sortStruct_double *obj)
{
    (void) ctx;
    
    struct futhark_f64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_f64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_f64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortStruct_double_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_sortStruct_double *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v1, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortStruct_double(struct futhark_context *ctx, struct futhark_opaque_sortStruct_double **out, const struct futhark_f64_1d *f_k, const struct futhark_u8_2d *f_pL)
{
    struct futhark_opaque_sortStruct_double *v = malloc(sizeof(struct futhark_opaque_sortStruct_double));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_f64_1d));
        *v->v0 = *f_k;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_u8_2d));
        *v->v1 = *f_pL;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortStruct_double(struct futhark_context *ctx, struct futhark_opaque_sortStruct_double *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_f64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortStruct_double(struct futhark_context *ctx, const struct futhark_opaque_sortStruct_double *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_f64_1d(ctx, obj->v0)[0] * sizeof(double);
    int64_t size_1 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " f64", 4);
        out += 4;
        memcpy(out, futhark_shape_f64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_f64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_f64_1d(ctx, obj->v0)[0] * sizeof(double);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v1), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v1, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_sortStruct_double *futhark_restore_opaque_sortStruct_double(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortStruct_double *obj = malloc(sizeof(struct futhark_opaque_sortStruct_double));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " f64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(double);
    
    int64_t shape_1[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * shape_1[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_f64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_u8_2d(ctx, data_1, shape_1[0], shape_1[1]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_f64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_sortInfo_short {
    struct futhark_i64_1d *v0;
    struct futhark_i16_1d *v1;
};
int futhark_project_opaque_sortInfo_short_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_short *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortInfo_short_xs(struct futhark_context *ctx, struct futhark_i16_1d **out, const struct futhark_opaque_sortInfo_short *obj)
{
    (void) ctx;
    
    struct futhark_i16_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i16_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i16_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortInfo_short(struct futhark_context *ctx, struct futhark_opaque_sortInfo_short **out, const struct futhark_i64_1d *f_is, const struct futhark_i16_1d *f_xs)
{
    struct futhark_opaque_sortInfo_short *v = malloc(sizeof(struct futhark_opaque_sortInfo_short));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_is;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i16_1d));
        *v->v1 = *f_xs;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortInfo_short(struct futhark_context *ctx, struct futhark_opaque_sortInfo_short *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i16_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortInfo_short(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_short *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i16_1d(ctx, obj->v1)[0] * sizeof(int16_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i16", 4);
        out += 4;
        memcpy(out, futhark_shape_i16_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i16_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i16_1d(ctx, obj->v1)[0] * sizeof(int16_t);
    }
    return ret;
}
struct futhark_opaque_sortInfo_short *futhark_restore_opaque_sortInfo_short(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortInfo_short *obj = malloc(sizeof(struct futhark_opaque_sortInfo_short));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i16", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int16_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i16_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i16_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_sortInfo_int {
    struct futhark_i64_1d *v0;
    struct futhark_i32_1d *v1;
};
int futhark_project_opaque_sortInfo_int_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_int *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortInfo_int_xs(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_sortInfo_int *obj)
{
    (void) ctx;
    
    struct futhark_i32_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i32_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i32_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortInfo_int(struct futhark_context *ctx, struct futhark_opaque_sortInfo_int **out, const struct futhark_i64_1d *f_is, const struct futhark_i32_1d *f_xs)
{
    struct futhark_opaque_sortInfo_int *v = malloc(sizeof(struct futhark_opaque_sortInfo_int));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_is;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i32_1d));
        *v->v1 = *f_xs;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortInfo_int(struct futhark_context *ctx, struct futhark_opaque_sortInfo_int *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortInfo_int(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_int *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i32_1d(ctx, obj->v1)[0] * sizeof(int32_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, futhark_shape_i32_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i32_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i32_1d(ctx, obj->v1)[0] * sizeof(int32_t);
    }
    return ret;
}
struct futhark_opaque_sortInfo_int *futhark_restore_opaque_sortInfo_int(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortInfo_int *obj = malloc(sizeof(struct futhark_opaque_sortInfo_int));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int32_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i32_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_sortInfo_long {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
};
int futhark_project_opaque_sortInfo_long_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_long *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortInfo_long_xs(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_long *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortInfo_long(struct futhark_context *ctx, struct futhark_opaque_sortInfo_long **out, const struct futhark_i64_1d *f_is, const struct futhark_i64_1d *f_xs)
{
    struct futhark_opaque_sortInfo_long *v = malloc(sizeof(struct futhark_opaque_sortInfo_long));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_is;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_xs;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortInfo_long(struct futhark_context *ctx, struct futhark_opaque_sortInfo_long *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortInfo_long(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_long *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    }
    return ret;
}
struct futhark_opaque_sortInfo_long *futhark_restore_opaque_sortInfo_long(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortInfo_long *obj = malloc(sizeof(struct futhark_opaque_sortInfo_long));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_sortInfo_float {
    struct futhark_i64_1d *v0;
    struct futhark_f32_1d *v1;
};
int futhark_project_opaque_sortInfo_float_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_float *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortInfo_float_xs(struct futhark_context *ctx, struct futhark_f32_1d **out, const struct futhark_opaque_sortInfo_float *obj)
{
    (void) ctx;
    
    struct futhark_f32_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_f32_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_f32_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortInfo_float(struct futhark_context *ctx, struct futhark_opaque_sortInfo_float **out, const struct futhark_i64_1d *f_is, const struct futhark_f32_1d *f_xs)
{
    struct futhark_opaque_sortInfo_float *v = malloc(sizeof(struct futhark_opaque_sortInfo_float));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_is;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_f32_1d));
        *v->v1 = *f_xs;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortInfo_float(struct futhark_context *ctx, struct futhark_opaque_sortInfo_float *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_f32_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortInfo_float(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_float *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_f32_1d(ctx, obj->v1)[0] * sizeof(float);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, futhark_shape_f32_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_f32_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_f32_1d(ctx, obj->v1)[0] * sizeof(float);
    }
    return ret;
}
struct futhark_opaque_sortInfo_float *futhark_restore_opaque_sortInfo_float(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortInfo_float *obj = malloc(sizeof(struct futhark_opaque_sortInfo_float));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(float);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_f32_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_f32_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_sortInfo_double {
    struct futhark_i64_1d *v0;
    struct futhark_f64_1d *v1;
};
int futhark_project_opaque_sortInfo_double_is(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_sortInfo_double *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_sortInfo_double_xs(struct futhark_context *ctx, struct futhark_f64_1d **out, const struct futhark_opaque_sortInfo_double *obj)
{
    (void) ctx;
    
    struct futhark_f64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_f64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_f64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_sortInfo_double(struct futhark_context *ctx, struct futhark_opaque_sortInfo_double **out, const struct futhark_i64_1d *f_is, const struct futhark_f64_1d *f_xs)
{
    struct futhark_opaque_sortInfo_double *v = malloc(sizeof(struct futhark_opaque_sortInfo_double));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_is;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_f64_1d));
        *v->v1 = *f_xs;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_sortInfo_double(struct futhark_context *ctx, struct futhark_opaque_sortInfo_double *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_f64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_sortInfo_double(struct futhark_context *ctx, const struct futhark_opaque_sortInfo_double *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_f64_1d(ctx, obj->v1)[0] * sizeof(double);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " f64", 4);
        out += 4;
        memcpy(out, futhark_shape_f64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_f64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_f64_1d(ctx, obj->v1)[0] * sizeof(double);
    }
    return ret;
}
struct futhark_opaque_sortInfo_double *futhark_restore_opaque_sortInfo_double(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_sortInfo_double *obj = malloc(sizeof(struct futhark_opaque_sortInfo_double));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " f64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(double);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_f64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_f64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_joinPairs_short {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
    struct futhark_i16_1d *v2;
};
int futhark_project_opaque_joinPairs_short_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_short *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_short_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_short *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_short_vs(struct futhark_context *ctx, struct futhark_i16_1d **out, const struct futhark_opaque_joinPairs_short *obj)
{
    (void) ctx;
    
    struct futhark_i16_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i16_1d));
    memcpy(v, obj->v2, sizeof(struct futhark_i16_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_joinPairs_short(struct futhark_context *ctx, struct futhark_opaque_joinPairs_short **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_i16_1d *f_vs)
{
    struct futhark_opaque_joinPairs_short *v = malloc(sizeof(struct futhark_opaque_joinPairs_short));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_ix;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_iy;
        (void) (*v->v1->mem.references)++;
    }
    {
        v->v2 = malloc(sizeof(struct futhark_i16_1d));
        *v->v2 = *f_vs;
        (void) (*v->v2->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_joinPairs_short(struct futhark_context *ctx, struct futhark_opaque_joinPairs_short *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    if (obj->v2 != NULL && (tmp = futhark_free_i16_1d(ctx, obj->v2)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_joinPairs_short(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_short *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    int64_t size_2 = 7 + 1 * sizeof(int64_t) + futhark_shape_i16_1d(ctx, obj->v2)[0] * sizeof(int16_t);
    
    *n = size_0 + size_1 + size_2;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i16", 4);
        out += 4;
        memcpy(out, futhark_shape_i16_1d(ctx, obj->v2), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i16_1d(ctx, obj->v2, (void *) out);
        out += futhark_shape_i16_1d(ctx, obj->v2)[0] * sizeof(int16_t);
    }
    return ret;
}
struct futhark_opaque_joinPairs_short *futhark_restore_opaque_joinPairs_short(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_joinPairs_short *obj = malloc(sizeof(struct futhark_opaque_joinPairs_short));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    
    int64_t shape_2[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i16", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_2, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    obj->v2 = NULL;
    src += shape_2[0] * sizeof(int16_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
        obj->v2 = futhark_new_i16_1d(ctx, data_2, shape_2[0]);
        if (obj->v2 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        if (obj->v2 != NULL && (tmp = futhark_free_i16_1d(ctx, obj->v2)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_joinPairs_int {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
    struct futhark_i32_1d *v2;
};
int futhark_project_opaque_joinPairs_int_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_int *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_int_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_int *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_int_vs(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_joinPairs_int *obj)
{
    (void) ctx;
    
    struct futhark_i32_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i32_1d));
    memcpy(v, obj->v2, sizeof(struct futhark_i32_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_joinPairs_int(struct futhark_context *ctx, struct futhark_opaque_joinPairs_int **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_i32_1d *f_vs)
{
    struct futhark_opaque_joinPairs_int *v = malloc(sizeof(struct futhark_opaque_joinPairs_int));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_ix;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_iy;
        (void) (*v->v1->mem.references)++;
    }
    {
        v->v2 = malloc(sizeof(struct futhark_i32_1d));
        *v->v2 = *f_vs;
        (void) (*v->v2->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_joinPairs_int(struct futhark_context *ctx, struct futhark_opaque_joinPairs_int *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    if (obj->v2 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v2)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_joinPairs_int(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_int *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    int64_t size_2 = 7 + 1 * sizeof(int64_t) + futhark_shape_i32_1d(ctx, obj->v2)[0] * sizeof(int32_t);
    
    *n = size_0 + size_1 + size_2;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, futhark_shape_i32_1d(ctx, obj->v2), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i32_1d(ctx, obj->v2, (void *) out);
        out += futhark_shape_i32_1d(ctx, obj->v2)[0] * sizeof(int32_t);
    }
    return ret;
}
struct futhark_opaque_joinPairs_int *futhark_restore_opaque_joinPairs_int(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_joinPairs_int *obj = malloc(sizeof(struct futhark_opaque_joinPairs_int));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    
    int64_t shape_2[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_2, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    obj->v2 = NULL;
    src += shape_2[0] * sizeof(int32_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
        obj->v2 = futhark_new_i32_1d(ctx, data_2, shape_2[0]);
        if (obj->v2 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        if (obj->v2 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v2)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_joinPairs_long {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
    struct futhark_i64_1d *v2;
};
int futhark_project_opaque_joinPairs_long_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_long *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_long_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_long *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_long_vs(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_long *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v2, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_joinPairs_long(struct futhark_context *ctx, struct futhark_opaque_joinPairs_long **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_i64_1d *f_vs)
{
    struct futhark_opaque_joinPairs_long *v = malloc(sizeof(struct futhark_opaque_joinPairs_long));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_ix;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_iy;
        (void) (*v->v1->mem.references)++;
    }
    {
        v->v2 = malloc(sizeof(struct futhark_i64_1d));
        *v->v2 = *f_vs;
        (void) (*v->v2->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_joinPairs_long(struct futhark_context *ctx, struct futhark_opaque_joinPairs_long *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    if (obj->v2 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v2)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_joinPairs_long(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_long *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    int64_t size_2 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v2)[0] * sizeof(int64_t);
    
    *n = size_0 + size_1 + size_2;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v2), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v2, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v2)[0] * sizeof(int64_t);
    }
    return ret;
}
struct futhark_opaque_joinPairs_long *futhark_restore_opaque_joinPairs_long(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_joinPairs_long *obj = malloc(sizeof(struct futhark_opaque_joinPairs_long));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    
    int64_t shape_2[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_2, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    obj->v2 = NULL;
    src += shape_2[0] * sizeof(int64_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
        obj->v2 = futhark_new_i64_1d(ctx, data_2, shape_2[0]);
        if (obj->v2 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        if (obj->v2 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v2)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_joinPairs_float {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
    struct futhark_f32_1d *v2;
};
int futhark_project_opaque_joinPairs_float_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_float *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_float_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_float *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_float_vs(struct futhark_context *ctx, struct futhark_f32_1d **out, const struct futhark_opaque_joinPairs_float *obj)
{
    (void) ctx;
    
    struct futhark_f32_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_f32_1d));
    memcpy(v, obj->v2, sizeof(struct futhark_f32_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_joinPairs_float(struct futhark_context *ctx, struct futhark_opaque_joinPairs_float **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_f32_1d *f_vs)
{
    struct futhark_opaque_joinPairs_float *v = malloc(sizeof(struct futhark_opaque_joinPairs_float));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_ix;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_iy;
        (void) (*v->v1->mem.references)++;
    }
    {
        v->v2 = malloc(sizeof(struct futhark_f32_1d));
        *v->v2 = *f_vs;
        (void) (*v->v2->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_joinPairs_float(struct futhark_context *ctx, struct futhark_opaque_joinPairs_float *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    if (obj->v2 != NULL && (tmp = futhark_free_f32_1d(ctx, obj->v2)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_joinPairs_float(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_float *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    int64_t size_2 = 7 + 1 * sizeof(int64_t) + futhark_shape_f32_1d(ctx, obj->v2)[0] * sizeof(float);
    
    *n = size_0 + size_1 + size_2;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, futhark_shape_f32_1d(ctx, obj->v2), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_f32_1d(ctx, obj->v2, (void *) out);
        out += futhark_shape_f32_1d(ctx, obj->v2)[0] * sizeof(float);
    }
    return ret;
}
struct futhark_opaque_joinPairs_float *futhark_restore_opaque_joinPairs_float(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_joinPairs_float *obj = malloc(sizeof(struct futhark_opaque_joinPairs_float));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    
    int64_t shape_2[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_2, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    obj->v2 = NULL;
    src += shape_2[0] * sizeof(float);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
        obj->v2 = futhark_new_f32_1d(ctx, data_2, shape_2[0]);
        if (obj->v2 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        if (obj->v2 != NULL && (tmp = futhark_free_f32_1d(ctx, obj->v2)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_joinPairs_double {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
    struct futhark_f64_1d *v2;
};
int futhark_project_opaque_joinPairs_double_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_double *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_double_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_double *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_double_vs(struct futhark_context *ctx, struct futhark_f64_1d **out, const struct futhark_opaque_joinPairs_double *obj)
{
    (void) ctx;
    
    struct futhark_f64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_f64_1d));
    memcpy(v, obj->v2, sizeof(struct futhark_f64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_joinPairs_double(struct futhark_context *ctx, struct futhark_opaque_joinPairs_double **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_f64_1d *f_vs)
{
    struct futhark_opaque_joinPairs_double *v = malloc(sizeof(struct futhark_opaque_joinPairs_double));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_ix;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_iy;
        (void) (*v->v1->mem.references)++;
    }
    {
        v->v2 = malloc(sizeof(struct futhark_f64_1d));
        *v->v2 = *f_vs;
        (void) (*v->v2->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_joinPairs_double(struct futhark_context *ctx, struct futhark_opaque_joinPairs_double *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    if (obj->v2 != NULL && (tmp = futhark_free_f64_1d(ctx, obj->v2)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_joinPairs_double(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_double *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    int64_t size_2 = 7 + 1 * sizeof(int64_t) + futhark_shape_f64_1d(ctx, obj->v2)[0] * sizeof(double);
    
    *n = size_0 + size_1 + size_2;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " f64", 4);
        out += 4;
        memcpy(out, futhark_shape_f64_1d(ctx, obj->v2), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_f64_1d(ctx, obj->v2, (void *) out);
        out += futhark_shape_f64_1d(ctx, obj->v2)[0] * sizeof(double);
    }
    return ret;
}
struct futhark_opaque_joinPairs_double *futhark_restore_opaque_joinPairs_double(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_joinPairs_double *obj = malloc(sizeof(struct futhark_opaque_joinPairs_double));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    
    int64_t shape_2[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " f64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_2, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    obj->v2 = NULL;
    src += shape_2[0] * sizeof(double);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
        obj->v2 = futhark_new_f64_1d(ctx, data_2, shape_2[0]);
        if (obj->v2 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        if (obj->v2 != NULL && (tmp = futhark_free_f64_1d(ctx, obj->v2)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_partitionedSet_GFTR {
    struct futhark_u8_2d *v0;
    struct futhark_u8_2d *v1;
};
int futhark_project_opaque_partitionedSet_GFTR_ks(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFTR *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v0, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionedSet_GFTR_pL(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFTR *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v1, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_partitionedSet_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR **out, const struct futhark_u8_2d *f_ks, const struct futhark_u8_2d *f_pL)
{
    struct futhark_opaque_partitionedSet_GFTR *v = malloc(sizeof(struct futhark_opaque_partitionedSet_GFTR));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_u8_2d));
        *v->v0 = *f_ks;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_u8_2d));
        *v->v1 = *f_pL;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_partitionedSet_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_partitionedSet_GFTR(struct futhark_context *ctx, const struct futhark_opaque_partitionedSet_GFTR *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v0)[0] * futhark_shape_u8_2d(ctx, obj->v0)[1] * sizeof(int8_t);
    int64_t size_1 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v0), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v0, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v0)[0] * futhark_shape_u8_2d(ctx, obj->v0)[1] * sizeof(int8_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v1), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v1, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_partitionedSet_GFTR *futhark_restore_opaque_partitionedSet_GFTR(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_partitionedSet_GFTR *obj = malloc(sizeof(struct futhark_opaque_partitionedSet_GFTR));
    int64_t shape_0[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * shape_0[1] * sizeof(int8_t);
    
    int64_t shape_1[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * shape_1[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_u8_2d(ctx, data_0, shape_0[0], shape_0[1]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_u8_2d(ctx, data_1, shape_1[0], shape_1[1]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_partitionedSet_GFUR {
    struct futhark_i64_1d *v0;
    struct futhark_u8_2d *v1;
};
int futhark_project_opaque_partitionedSet_GFUR_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_partitionedSet_GFUR *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionedSet_GFUR_ks(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_partitionedSet_GFUR *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v1, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_partitionedSet_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR **out, const struct futhark_i64_1d *f_idx, const struct futhark_u8_2d *f_ks)
{
    struct futhark_opaque_partitionedSet_GFUR *v = malloc(sizeof(struct futhark_opaque_partitionedSet_GFUR));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_idx;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_u8_2d));
        *v->v1 = *f_ks;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_partitionedSet_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_partitionedSet_GFUR(struct futhark_context *ctx, const struct futhark_opaque_partitionedSet_GFUR *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v1), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v1, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v1)[0] * futhark_shape_u8_2d(ctx, obj->v1)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_partitionedSet_GFUR *futhark_restore_opaque_partitionedSet_GFUR(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_partitionedSet_GFUR *obj = malloc(sizeof(struct futhark_opaque_partitionedSet_GFUR));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * shape_1[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_u8_2d(ctx, data_1, shape_1[0], shape_1[1]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_partitionInfo {
    struct futhark_i64_1d *v0;
    struct futhark_i32_1d *v1;
    int32_t v2;
};
int futhark_project_opaque_partitionInfo_bounds(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionInfo_depths(struct futhark_context *ctx, struct futhark_i32_1d **out, const struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    struct futhark_i32_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i32_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i32_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_partitionInfo_maxDepth(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    int32_t v;
    
    v = obj->v2;
    *out = v;
    return 0;
}
int futhark_new_opaque_partitionInfo(struct futhark_context *ctx, struct futhark_opaque_partitionInfo **out, const struct futhark_i64_1d *f_bounds, const struct futhark_i32_1d *f_depths, const int32_t f_maxDepth)
{
    struct futhark_opaque_partitionInfo *v = malloc(sizeof(struct futhark_opaque_partitionInfo));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_bounds;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i32_1d));
        *v->v1 = *f_depths;
        (void) (*v->v1->mem.references)++;
    }
    v->v2 = f_maxDepth;
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_partitionInfo(struct futhark_context *ctx, struct futhark_opaque_partitionInfo *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_partitionInfo(struct futhark_context *ctx, const struct futhark_opaque_partitionInfo *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i32_1d(ctx, obj->v1)[0] * sizeof(int32_t);
    int64_t size_2 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int32_t);
    
    *n = size_0 + size_1 + size_2;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, futhark_shape_i32_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i32_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i32_1d(ctx, obj->v1)[0] * sizeof(int32_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, &obj->v2, sizeof(obj->v2));
        out += sizeof(obj->v2);
    }
    return ret;
}
struct futhark_opaque_partitionInfo *futhark_restore_opaque_partitionInfo(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_partitionInfo *obj = malloc(sizeof(struct futhark_opaque_partitionInfo));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int32_t);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    src += sizeof(obj->v2);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i32_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
        memcpy(&obj->v2, data_2, sizeof(obj->v2));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i32_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_radix_hashTable {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
};
int futhark_project_opaque_radix_hashTable_first_info_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_radix_hashTable *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_radix_hashTable_last_info_idx(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_radix_hashTable *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_radix_hashTable(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable **out, const struct futhark_i64_1d *f_first_info_idx, const struct futhark_i64_1d *f_last_info_idx)
{
    struct futhark_opaque_radix_hashTable *v = malloc(sizeof(struct futhark_opaque_radix_hashTable));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_first_info_idx;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_last_info_idx;
        (void) (*v->v1->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_radix_hashTable(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_radix_hashTable(struct futhark_context *ctx, const struct futhark_opaque_radix_hashTable *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    }
    return ret;
}
struct futhark_opaque_radix_hashTable *futhark_restore_opaque_radix_hashTable(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_radix_hashTable *obj = malloc(sizeof(struct futhark_opaque_radix_hashTable));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_joinPairs_bsq {
    struct futhark_i64_1d *v0;
    struct futhark_i64_1d *v1;
    struct futhark_u8_2d *v2;
};
int futhark_project_opaque_joinPairs_bsq_ix(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_bsq *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v0, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_bsq_iy(struct futhark_context *ctx, struct futhark_i64_1d **out, const struct futhark_opaque_joinPairs_bsq *obj)
{
    (void) ctx;
    
    struct futhark_i64_1d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_i64_1d));
    memcpy(v, obj->v1, sizeof(struct futhark_i64_1d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_joinPairs_bsq_vs(struct futhark_context *ctx, struct futhark_u8_2d **out, const struct futhark_opaque_joinPairs_bsq *obj)
{
    (void) ctx;
    
    struct futhark_u8_2d *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_u8_2d));
    memcpy(v, obj->v2, sizeof(struct futhark_u8_2d));
    (void) (*v->mem.references)++;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_new_opaque_joinPairs_bsq(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq **out, const struct futhark_i64_1d *f_ix, const struct futhark_i64_1d *f_iy, const struct futhark_u8_2d *f_vs)
{
    struct futhark_opaque_joinPairs_bsq *v = malloc(sizeof(struct futhark_opaque_joinPairs_bsq));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = malloc(sizeof(struct futhark_i64_1d));
        *v->v0 = *f_ix;
        (void) (*v->v0->mem.references)++;
    }
    {
        v->v1 = malloc(sizeof(struct futhark_i64_1d));
        *v->v1 = *f_iy;
        (void) (*v->v1->mem.references)++;
    }
    {
        v->v2 = malloc(sizeof(struct futhark_u8_2d));
        *v->v2 = *f_vs;
        (void) (*v->v2->mem.references)++;
    }
    lock_unlock(&ctx->lock);
    *out = v;
    return FUTHARK_SUCCESS;
}
int futhark_free_opaque_joinPairs_bsq(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
        ret = tmp;
    if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
        ret = tmp;
    if (obj->v2 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v2)) != 0)
        ret = tmp;
    free(obj);
    return ret;
}
int futhark_store_opaque_joinPairs_bsq(struct futhark_context *ctx, const struct futhark_opaque_joinPairs_bsq *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
    int64_t size_1 = 7 + 1 * sizeof(int64_t) + futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
    int64_t size_2 = 7 + 2 * sizeof(int64_t) + futhark_shape_u8_2d(ctx, obj->v2)[0] * futhark_shape_u8_2d(ctx, obj->v2)[1] * sizeof(int8_t);
    
    *n = size_0 + size_1 + size_2;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v0), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v0, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v0)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 1;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, futhark_shape_i64_1d(ctx, obj->v1), 1 * sizeof(int64_t));
        out += 1 * sizeof(int64_t);
        ret |= futhark_values_i64_1d(ctx, obj->v1, (void *) out);
        out += futhark_shape_i64_1d(ctx, obj->v1)[0] * sizeof(int64_t);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 2;
        memcpy(out, "  u8", 4);
        out += 4;
        memcpy(out, futhark_shape_u8_2d(ctx, obj->v2), 2 * sizeof(int64_t));
        out += 2 * sizeof(int64_t);
        ret |= futhark_values_u8_2d(ctx, obj->v2, (void *) out);
        out += futhark_shape_u8_2d(ctx, obj->v2)[0] * futhark_shape_u8_2d(ctx, obj->v2)[1] * sizeof(int8_t);
    }
    return ret;
}
struct futhark_opaque_joinPairs_bsq *futhark_restore_opaque_joinPairs_bsq(struct futhark_context *ctx, const void *p)
{
    (void) ctx;
    
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_joinPairs_bsq *obj = malloc(sizeof(struct futhark_opaque_joinPairs_bsq));
    int64_t shape_0[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_0, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    obj->v0 = NULL;
    src += shape_0[0] * sizeof(int64_t);
    
    int64_t shape_1[1] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 1;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_1, src, 1 * sizeof(int64_t));
        src += 1 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    obj->v1 = NULL;
    src += shape_1[0] * sizeof(int64_t);
    
    int64_t shape_2[2] = {0};
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 2;
    err |= memcmp(src, "  u8", 4) != 0;
    src += 4;
    if (err == 0) {
        memcpy(shape_2, src, 2 * sizeof(int64_t));
        src += 2 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    obj->v2 = NULL;
    src += shape_2[0] * shape_2[1] * sizeof(int8_t);
    if (err == 0) {
        obj->v0 = futhark_new_i64_1d(ctx, data_0, shape_0[0]);
        if (obj->v0 == NULL)
            err = 1;
        obj->v1 = futhark_new_i64_1d(ctx, data_1, shape_1[0]);
        if (obj->v1 == NULL)
            err = 1;
        obj->v2 = futhark_new_u8_2d(ctx, data_2, shape_2[0], shape_2[1]);
        if (obj->v2 == NULL)
            err = 1;
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        if (obj->v0 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v0)) != 0)
            ret = tmp;
        if (obj->v1 != NULL && (tmp = futhark_free_i64_1d(ctx, obj->v1)) != 0)
            ret = tmp;
        if (obj->v2 != NULL && (tmp = futhark_free_u8_2d(ctx, obj->v2)) != 0)
            ret = tmp;
        free(obj);
        obj = NULL;
    }
    return obj;
}

FUTHARK_FUN_ATTR int futrts_entry_Inner_Radix_Hash_Join(struct futhark_context *ctx, struct memblock *mem_out_p_133978, struct memblock *mem_out_p_133979, struct memblock *mem_out_p_133980, int64_t *out_prim_out_133981, struct memblock pR_mem_133466, struct memblock pS_mem_133467, struct memblock bounds_mem_133468, struct memblock depths_mem_133469, struct memblock first_info_idx_mem_133470, struct memblock last_info_idx_mem_133471, int64_t nR_117695, int64_t b_117696, int64_t nS_117697, int64_t dz2081U_117698, int64_t dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699, int32_t radix_sizze_117700, int32_t maxDepth_117705)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133473_cached_sizze_133982 = 0;
    unsigned char *mem_133473 = NULL;
    int64_t mem_133481_cached_sizze_133983 = 0;
    unsigned char *mem_133481 = NULL;
    int64_t mem_133483_cached_sizze_133984 = 0;
    unsigned char *mem_133483 = NULL;
    int64_t mem_133485_cached_sizze_133985 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_133986 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133489_cached_sizze_133987 = 0;
    unsigned char *mem_133489 = NULL;
    int64_t mem_133491_cached_sizze_133988 = 0;
    unsigned char *mem_133491 = NULL;
    int64_t mem_133510_cached_sizze_133989 = 0;
    unsigned char *mem_133510 = NULL;
    int64_t mem_133520_cached_sizze_133990 = 0;
    unsigned char *mem_133520 = NULL;
    int64_t mem_133521_cached_sizze_133991 = 0;
    unsigned char *mem_133521 = NULL;
    int64_t mem_133534_cached_sizze_133992 = 0;
    unsigned char *mem_133534 = NULL;
    int64_t mem_133535_cached_sizze_133993 = 0;
    unsigned char *mem_133535 = NULL;
    int64_t mem_133548_cached_sizze_133994 = 0;
    unsigned char *mem_133548 = NULL;
    int64_t mem_133549_cached_sizze_133995 = 0;
    unsigned char *mem_133549 = NULL;
    int64_t mem_133562_cached_sizze_133996 = 0;
    unsigned char *mem_133562 = NULL;
    int64_t mem_133563_cached_sizze_133997 = 0;
    unsigned char *mem_133563 = NULL;
    int64_t mem_133567_cached_sizze_133998 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133568_cached_sizze_133999 = 0;
    unsigned char *mem_133568 = NULL;
    int64_t mem_133581_cached_sizze_134000 = 0;
    unsigned char *mem_133581 = NULL;
    int64_t mem_133582_cached_sizze_134001 = 0;
    unsigned char *mem_133582 = NULL;
    int64_t mem_133583_cached_sizze_134002 = 0;
    unsigned char *mem_133583 = NULL;
    int64_t mem_133584_cached_sizze_134003 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133597_cached_sizze_134004 = 0;
    unsigned char *mem_133597 = NULL;
    int64_t mem_133598_cached_sizze_134005 = 0;
    unsigned char *mem_133598 = NULL;
    int64_t mem_133599_cached_sizze_134006 = 0;
    unsigned char *mem_133599 = NULL;
    int64_t mem_133600_cached_sizze_134007 = 0;
    unsigned char *mem_133600 = NULL;
    int64_t mem_133616_cached_sizze_134008 = 0;
    unsigned char *mem_133616 = NULL;
    int64_t mem_133617_cached_sizze_134009 = 0;
    unsigned char *mem_133617 = NULL;
    int64_t mem_133630_cached_sizze_134010 = 0;
    unsigned char *mem_133630 = NULL;
    int64_t mem_133631_cached_sizze_134011 = 0;
    unsigned char *mem_133631 = NULL;
    int64_t mem_133644_cached_sizze_134012 = 0;
    unsigned char *mem_133644 = NULL;
    int64_t mem_133645_cached_sizze_134013 = 0;
    unsigned char *mem_133645 = NULL;
    int64_t mem_133665_cached_sizze_134014 = 0;
    unsigned char *mem_133665 = NULL;
    int64_t mem_133675_cached_sizze_134015 = 0;
    unsigned char *mem_133675 = NULL;
    int64_t mem_133677_cached_sizze_134016 = 0;
    unsigned char *mem_133677 = NULL;
    int64_t mem_133697_cached_sizze_134017 = 0;
    unsigned char *mem_133697 = NULL;
    struct memblock mem_133717;
    
    mem_133717.references = NULL;
    
    struct memblock mem_133715;
    
    mem_133715.references = NULL;
    
    struct memblock mem_133673;
    
    mem_133673.references = NULL;
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t prim_out_133880;
    int64_t i32_res_121834 = sext_i32_i64(radix_sizze_117700);
    bool nonnegative_121835 = sle64((int64_t) 0, i32_res_121834);
    bool nonzzero_cert_121836;
    
    if (!nonnegative_121835) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  ftHashJoin.fut:7:47-307:53\n   #1  ftRelational.fut:302:1-309:54\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t arg_121837 = shl64((int64_t) 1, i32_res_121834);
    bool assert_cond_121838 = arg_121837 == dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699;
    bool assert_c_121839;
    
    if (!assert_cond_121838) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: entry point arguments have invalid sizes.", "-> #0  ftRelational.fut:307:4-309:18\n   #1  ftRelational.fut:302:1-309:54\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133472 = (int64_t) 8 * b_117696;
    
    if (mem_133473_cached_sizze_133982 < bytes_133472) {
        err = lexical_realloc(ctx, &mem_133473, &mem_133473_cached_sizze_133982, bytes_133472);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < b_117696; i_133300++) {
        int64_t zm_lhs_126557 = sub64(b_117696, i_133300);
        int64_t lifted_lambda_res_126558 = sub64(zm_lhs_126557, (int64_t) 1);
        
        ((int64_t *) mem_133473)[i_133300] = lifted_lambda_res_126558;
    }
    
    int32_t getRadix_arg1_126559 = sub32(radix_sizze_117700, 1);
    int32_t i64_res_126560 = sext_i64_i32(b_117696);
    int32_t zm_lhs_126561 = mul32(8, i64_res_126560);
    int32_t min_arg1_126562 = sub32(zm_lhs_126561, 1);
    int32_t min_res_126563 = smin32(getRadix_arg1_126559, min_arg1_126562);
    int32_t i32_arg0_126567 = sub32(i64_res_126560, 1);
    int64_t i32_res_126568 = sext_i32_i64(i32_arg0_126567);
    int32_t zm_rhs_126570 = sdiv32(min_res_126563, 8);
    int32_t zm_lhs_126571 = sub32(i64_res_126560, zm_rhs_126570);
    int32_t i32_arg0_126572 = sub32(zm_lhs_126571, 1);
    int64_t i32_res_126573 = sext_i32_i64(i32_arg0_126572);
    int64_t min_arg1_126575 = sub64(bytes_133472, (int64_t) 1);
    int64_t min_res_126576 = smin64(i32_res_126573, min_arg1_126575);
    int32_t lastBit_126578 = smod32(min_res_126563, 8);
    int32_t zm_lhs_126581 = sub32(8, lastBit_126578);
    int32_t i32_arg0_126582 = sub32(zm_lhs_126581, 1);
    int8_t unsign_arg0_126583 = zext_i32_i8(i32_arg0_126582);
    int8_t unsign_arg0_126584 = lshr8((int8_t) -1, unsign_arg0_126583);
    bool x_126593 = sle64((int64_t) 0, i32_res_126568);
    bool y_126594 = slt64(i32_res_126568, b_117696);
    bool bounds_check_126595 = x_126593 && y_126594;
    bool index_certs_126596;
    
    if (!bounds_check_126595) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_126568, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:31:48-64\n   #1  ftRelational.fut:302:1-309:54\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool x_126604 = sle64((int64_t) 0, min_res_126576);
    bool y_126605 = slt64(min_res_126576, b_117696);
    bool bounds_check_126606 = x_126604 && y_126605;
    bool index_certs_126607;
    
    if (!bounds_check_126606) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_126576, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftRelational.fut:302:1-309:54\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zeze_rhs_122251 = sub64(dz2081U_117698, (int64_t) 1);
    int64_t bytes_133480 = (int64_t) 8 * nR_117695;
    
    if (mem_133481_cached_sizze_133983 < bytes_133480) {
        err = lexical_realloc(ctx, &mem_133481, &mem_133481_cached_sizze_133983, bytes_133480);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133483_cached_sizze_133984 < bytes_133480) {
        err = lexical_realloc(ctx, &mem_133483, &mem_133483_cached_sizze_133984, bytes_133480);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133485_cached_sizze_133985 < bytes_133480) {
        err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_133985, bytes_133480);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133487_cached_sizze_133986 < bytes_133480) {
        err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_133986, bytes_133480);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133489_cached_sizze_133987 < bytes_133480) {
        err = lexical_realloc(ctx, &mem_133489, &mem_133489_cached_sizze_133987, bytes_133480);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133491_cached_sizze_133988 < bytes_133480) {
        err = lexical_realloc(ctx, &mem_133491, &mem_133491_cached_sizze_133988, bytes_133480);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133510_cached_sizze_133989 < b_117696) {
        err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_133989, b_117696);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t discard_133400;
    int64_t discard_133401;
    int64_t defunc_res_133287;
    int64_t scanacc_133384;
    int64_t scanacc_133385;
    int64_t redout_133388;
    
    scanacc_133384 = (int64_t) 0;
    scanacc_133385 = (int64_t) 0;
    redout_133388 = (int64_t) 0;
    for (int64_t i_133393 = 0; i_133393 < nR_117695; i_133393++) {
        for (int64_t i_133304 = 0; i_133304 < b_117696; i_133304++) {
            int8_t eta_p_128220 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133304];
            bool cond_128221 = sle64(i_133304, i32_res_126568);
            bool cond_t_res_128222 = sle64(min_res_126576, i_133304);
            bool x_128223 = cond_128221 && cond_t_res_128222;
            int8_t lifted_lambda_res_128224;
            
            if (x_128223) {
                lifted_lambda_res_128224 = eta_p_128220;
            } else {
                lifted_lambda_res_128224 = (int8_t) 0;
            }
            ((int8_t *) mem_133510)[i_133304] = lifted_lambda_res_128224;
        }
        
        int8_t za_lhs_128225 = ((int8_t *) mem_133510)[i32_res_126568];
        int8_t mod1_x_128226 = (int8_t) -1 & za_lhs_128225;
        
        ((int8_t *) mem_133510)[i32_res_126568] = mod1_x_128226;
        
        int8_t za_lhs_128228 = ((int8_t *) mem_133510)[min_res_126576];
        int8_t tmp_128229 = unsign_arg0_126584 & za_lhs_128228;
        
        ((int8_t *) mem_133510)[min_res_126576] = tmp_128229;
        
        int64_t defunc_res_133276;
        int64_t redout_133306 = (int64_t) 0;
        
        for (int64_t i_133307 = 0; i_133307 < b_117696; i_133307++) {
            int8_t eta_p_129478 = ((int8_t *) mem_133510)[i_133307];
            int64_t eta_p_129479 = ((int64_t *) mem_133473)[i_133307];
            int64_t u8_res_129480 = zext_i8_i64(eta_p_129478);
            int64_t zlzl_rhs_129481 = mul64((int64_t) 8, eta_p_129479);
            int64_t zt_rhs_129482 = shl64((int64_t) 1, zlzl_rhs_129481);
            int64_t lifted_lambda_res_129483 = mul64(u8_res_129480, zt_rhs_129482);
            int64_t zp_res_128242 = add64(lifted_lambda_res_129483, redout_133306);
            int64_t redout_tmp_133892 = zp_res_128242;
            
            redout_133306 = redout_tmp_133892;
        }
        defunc_res_133276 = redout_133306;
        
        bool x_128243 = sle64((int64_t) 0, defunc_res_133276);
        bool y_128244 = slt64(defunc_res_133276, dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699);
        bool bounds_check_128245 = x_128243 && y_128244;
        bool index_certs_128246;
        
        if (!bounds_check_128245) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_res_133276, "] out of bounds for array of shape [", (long long) dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699, "].", "-> #0  ftHashJoin.fut:344:13-35\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t spi_128247 = ((int64_t *) first_info_idx_mem_133470.mem)[defunc_res_133276];
        bool cond_128248 = slt64(spi_128247, (int64_t) 0);
        int64_t rv_partitionMatchBounds_res_128249;
        int64_t rv_partitionMatchBounds_res_128250;
        
        if (cond_128248) {
            rv_partitionMatchBounds_res_128249 = (int64_t) -1;
            rv_partitionMatchBounds_res_128250 = (int64_t) -1;
        } else {
            bool x_128251 = sle64((int64_t) 0, spi_128247);
            bool y_128252 = slt64(spi_128247, dz2081U_117698);
            bool bounds_check_128253 = x_128251 && y_128252;
            bool index_certs_128254;
            
            if (!bounds_check_128253) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) spi_128247, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:347:8-21\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int32_t zeze_lhs_128255 = ((int32_t *) depths_mem_133469.mem)[spi_128247];
            bool cond_128256 = zeze_lhs_128255 == 1;
            bool x_133779 = !cond_128256;
            int64_t end_spi_128259;
            
            if (x_133779) {
                int64_t x_133781 = ((int64_t *) last_info_idx_mem_133471.mem)[defunc_res_133276];
                
                end_spi_128259 = x_133781;
            } else {
                end_spi_128259 = (int64_t) 0;
            }
            
            int64_t zs_lhs_128260 = sub64(end_spi_128259, spi_128247);
            int64_t max_arg1_128261 = sdiv64(zs_lhs_128260, (int64_t) 2);
            int64_t max_res_128262 = smax64((int64_t) 1, max_arg1_128261);
            bool loop_cond_128263 = slt64((int64_t) 0, max_res_128262);
            int64_t rv_partitionMatchBounds_res_f_res_128257;
            int64_t rv_partitionMatchBounds_res_f_res_128258;
            
            if (cond_128256) {
                rv_partitionMatchBounds_res_f_res_128257 = spi_128247;
                rv_partitionMatchBounds_res_f_res_128258 = spi_128247;
            } else {
                bool loop_not_taken_128264 = !loop_cond_128263;
                bool protect_assert_disj_128265 = bounds_check_128253 || loop_not_taken_128264;
                bool index_certs_128266;
                
                if (!protect_assert_disj_128265) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) spi_128247, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:356:24-37\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t cur_S_128267;
                
                if (loop_cond_128263) {
                    int64_t x_132909 = ((int64_t *) bounds_mem_133468.mem)[spi_128247];
                    
                    cur_S_128267 = x_132909;
                } else {
                    cur_S_128267 = (int64_t) 0;
                }
                
                bool x_128269 = sle64((int64_t) 0, cur_S_128267);
                bool y_128270 = slt64(cur_S_128267, nS_117697);
                bool bounds_check_128271 = x_128269 && y_128270;
                bool protect_assert_disj_128272 = loop_not_taken_128264 || bounds_check_128271;
                bool index_certs_128273;
                
                if (!protect_assert_disj_128272) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) cur_S_128267, "] out of bounds for array of shape [", (long long) nS_117697, "].", "-> #0  ftHashJoin.fut:356:21-38\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool protect_assert_disj_128286 = bounds_check_126595 || loop_not_taken_128264;
                bool index_certs_128287;
                
                if (!protect_assert_disj_128286) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_126568, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:31:48-64\n   #1  ftRelational.fut:302:1-309:54\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t map2_arg2_128277 = add64((int64_t) 1, i32_res_126568);
                int64_t tmp_128317 = sub64(spi_128247, (int64_t) 1);
                bool x_128318 = sle64((int64_t) 0, tmp_128317);
                bool y_128319 = slt64(tmp_128317, dz2081U_117698);
                bool bounds_check_128320 = x_128318 && y_128319;
                int64_t lmad_ext_133518 = b_117696 * cur_S_128267;
                
                if (mem_133520_cached_sizze_133990 < b_117696) {
                    err = lexical_realloc(ctx, &mem_133520, &mem_133520_cached_sizze_133990, b_117696);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
                if (mem_133521_cached_sizze_133991 < b_117696) {
                    err = lexical_realloc(ctx, &mem_133521, &mem_133521_cached_sizze_133991, b_117696);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
                
                bool rv_partitionMatchBounds_res_f_res_f_res_128288;
                int64_t rv_partitionMatchBounds_res_f_res_f_res_128289;
                int64_t rv_partitionMatchBounds_res_f_res_f_res_128290;
                bool loop_while_128291;
                int64_t heshi_128292;
                int64_t step_128293;
                
                loop_while_128291 = loop_cond_128263;
                heshi_128292 = spi_128247;
                step_128293 = max_res_128262;
                while (loop_while_128291) {
                    bool x_128294 = sle64((int64_t) 0, heshi_128292);
                    bool y_128295 = slt64(heshi_128292, dz2081U_117698);
                    bool bounds_check_128296 = x_128294 && y_128295;
                    bool index_certs_128297;
                    
                    if (!bounds_check_128296) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) heshi_128292, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:353:25-40\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t cur_depth_128298 = ((int32_t *) depths_mem_133469.mem)[heshi_128292];
                    bool cond_128299 = heshi_128292 == spi_128247;
                    bool protect_assert_disj_133774 = cond_128299 || bounds_check_128320;
                    bool index_certs_128321;
                    
                    if (!protect_assert_disj_133774) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128317, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:357:55-70\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t zm_lhs_128340 = mul32(radix_sizze_117700, cur_depth_128298);
                    int32_t byteSeq_eq_arg1_128341 = sub32(zm_lhs_128340, 1);
                    int32_t zm_rhs_128383 = sdiv32(byteSeq_eq_arg1_128341, 8);
                    int32_t zm_lhs_128384 = sub32(i64_res_126560, zm_rhs_128383);
                    int32_t i32_arg0_128385 = sub32(zm_lhs_128384, 1);
                    int64_t i32_res_128386 = sext_i32_i64(i32_arg0_128385);
                    bool zzero_lte_i_128393 = sle64((int64_t) 0, i32_res_128386);
                    int64_t j_m_i_128387 = sub64(map2_arg2_128277, i32_res_128386);
                    int64_t m_128389 = sub64(j_m_i_128387, (int64_t) 1);
                    int64_t i_p_m_t_s_128390 = add64(i32_res_128386, m_128389);
                    bool i_p_m_t_s_leq_w_128392 = slt64(i_p_m_t_s_128390, b_117696);
                    bool y_128395 = i_p_m_t_s_leq_w_128392 && zzero_lte_i_128393;
                    bool zzero_leq_i_p_m_t_s_128391 = sle64((int64_t) 0, i_p_m_t_s_128390);
                    bool y_128396 = zzero_leq_i_p_m_t_s_128391 && y_128395;
                    bool i_lte_j_128394 = sle64(i32_res_128386, map2_arg2_128277);
                    bool forwards_ok_128397 = i_lte_j_128394 && y_128396;
                    bool empty_slice_128388 = j_m_i_128387 == (int64_t) 0;
                    bool ok_or_empty_128398 = empty_slice_128388 || forwards_ok_128397;
                    bool index_certs_128399;
                    
                    if (!ok_or_empty_128398) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_128386, ":", (long long) map2_arg2_128277, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:48:38-49\n   #1  ftHashJoin.fut:134:3-40\n   #2  ftHashJoin.fut:361:14-52\n   #3  ftHashJoin.fut:426:3-432:70\n   #4  /prelude/functional.fut:9:44-45\n   #5  ftRelational.fut:306:4-309:35\n   #6  ftRelational.fut:302:1-309:54\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t min_res_128342 = smin32(min_arg1_126562, byteSeq_eq_arg1_128341);
                    int32_t zm_rhs_128343 = sdiv32(min_res_128342, 8);
                    int32_t zm_lhs_128344 = sub32(i64_res_126560, zm_rhs_128343);
                    int32_t i32_arg0_128345 = sub32(zm_lhs_128344, 1);
                    int64_t i32_res_128346 = sext_i32_i64(i32_arg0_128345);
                    int64_t min_res_128347 = smin64(min_arg1_126575, i32_res_128346);
                    bool y_128364 = slt64(min_res_128347, b_117696);
                    bool x_128363 = sle64((int64_t) 0, min_res_128347);
                    bool bounds_check_128365 = x_128363 && y_128364;
                    bool index_certs_128366;
                    
                    if (!bounds_check_128365) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_128347, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftRelational.fut:302:1-309:54\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t prev_depth_128300;
                    
                    if (cond_128299) {
                        prev_depth_128300 = cur_depth_128298;
                    } else {
                        int64_t tmp_128301 = sub64(heshi_128292, (int64_t) 1);
                        bool x_128302 = sle64((int64_t) 0, tmp_128301);
                        bool y_128303 = slt64(tmp_128301, dz2081U_117698);
                        bool bounds_check_128304 = x_128302 && y_128303;
                        bool index_certs_128305;
                        
                        if (!bounds_check_128304) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128301, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:354:60-77\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t prev_depth_f_res_128306 = ((int32_t *) depths_mem_133469.mem)[tmp_128301];
                        
                        prev_depth_128300 = prev_depth_f_res_128306;
                    }
                    
                    bool cond_128307 = heshi_128292 == end_spi_128259;
                    int32_t next_depth_128308;
                    
                    if (cond_128307) {
                        next_depth_128308 = cur_depth_128298;
                    } else {
                        int64_t tmp_128309 = add64((int64_t) 1, heshi_128292);
                        bool x_128310 = sle64((int64_t) 0, tmp_128309);
                        bool y_128311 = slt64(tmp_128309, dz2081U_117698);
                        bool bounds_check_128312 = x_128310 && y_128311;
                        bool index_certs_128313;
                        
                        if (!bounds_check_128312) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128309, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:355:64-81\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t next_depth_f_res_128314 = ((int32_t *) depths_mem_133469.mem)[tmp_128309];
                        
                        next_depth_128308 = next_depth_f_res_128314;
                    }
                    
                    bool x_133771 = !cond_128299;
                    int64_t tmp_128322;
                    
                    if (x_133771) {
                        int64_t x_133775 = ((int64_t *) bounds_mem_133468.mem)[tmp_128317];
                        
                        tmp_128322 = x_133775;
                    } else {
                        tmp_128322 = (int64_t) 0;
                    }
                    
                    int64_t lmad_ext_133517 = b_117696 * tmp_128322;
                    int64_t ext_133519;
                    
                    if (cond_128299) {
                        ext_133519 = lmad_ext_133518;
                    } else {
                        ext_133519 = lmad_ext_133517;
                    }
                    if (!cond_128299) {
                        bool x_128323 = sle64((int64_t) 0, tmp_128322);
                        bool y_128324 = slt64(tmp_128322, nS_117697);
                        bool bounds_check_128325 = x_128323 && y_128324;
                        bool index_certs_128326;
                        
                        if (!bounds_check_128325) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128322, "] out of bounds for array of shape [", (long long) nS_117697, "].", "-> #0  ftHashJoin.fut:357:52-71\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                    }
                    for (int64_t i_133312 = 0; i_133312 < b_117696; i_133312++) {
                        int8_t eta_p_129493 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133312];
                        int8_t eta_p_129494 = ((int8_t *) pS_mem_133467.mem)[cur_S_128267 * b_117696 + i_133312];
                        bool cond_129496 = sle64(i_133312, i32_res_126568);
                        bool cond_t_res_129497 = sle64(min_res_128347, i_133312);
                        bool x_129498 = cond_129496 && cond_t_res_129497;
                        int8_t lifted_lambda_res_129499;
                        
                        if (x_129498) {
                            lifted_lambda_res_129499 = eta_p_129493;
                        } else {
                            lifted_lambda_res_129499 = (int8_t) 0;
                        }
                        
                        int8_t lifted_lambda_res_129504;
                        
                        if (x_129498) {
                            lifted_lambda_res_129504 = eta_p_129494;
                        } else {
                            lifted_lambda_res_129504 = (int8_t) 0;
                        }
                        ((int8_t *) mem_133520)[i_133312] = lifted_lambda_res_129504;
                        ((int8_t *) mem_133521)[i_133312] = lifted_lambda_res_129499;
                    }
                    
                    int8_t za_lhs_128377 = ((int8_t *) mem_133520)[i32_res_126568];
                    int8_t mod1_x_128378 = (int8_t) -1 & za_lhs_128377;
                    
                    ((int8_t *) mem_133520)[i32_res_126568] = mod1_x_128378;
                    
                    int8_t za_lhs_128380 = ((int8_t *) mem_133520)[min_res_128347];
                    int32_t lastBit_128348 = smod32(min_res_128342, 8);
                    int32_t zm_lhs_128349 = sub32(8, lastBit_128348);
                    int32_t i32_arg0_128350 = sub32(zm_lhs_128349, 1);
                    int8_t unsign_arg0_128351 = zext_i32_i8(i32_arg0_128350);
                    int8_t unsign_arg0_128352 = lshr8((int8_t) -1, unsign_arg0_128351);
                    int8_t tmp_128381 = unsign_arg0_128352 & za_lhs_128380;
                    
                    ((int8_t *) mem_133520)[min_res_128347] = tmp_128381;
                    
                    int8_t za_lhs_128360 = ((int8_t *) mem_133521)[i32_res_126568];
                    int8_t mod1_x_128361 = (int8_t) -1 & za_lhs_128360;
                    
                    ((int8_t *) mem_133521)[i32_res_126568] = mod1_x_128361;
                    
                    int8_t za_lhs_128367 = ((int8_t *) mem_133521)[min_res_128347];
                    int8_t tmp_128368 = unsign_arg0_128352 & za_lhs_128367;
                    
                    ((int8_t *) mem_133521)[min_res_128347] = tmp_128368;
                    
                    bool defunc_0_reduce_res_133160;
                    bool redout_133315 = 1;
                    
                    for (int64_t i_133316 = 0; i_133316 < j_m_i_128387; i_133316++) {
                        int64_t slice_133457 = i32_res_128386 + i_133316;
                        int8_t eta_p_129487 = ((int8_t *) mem_133521)[slice_133457];
                        int8_t eta_p_129488 = ((int8_t *) mem_133520)[slice_133457];
                        bool defunc_0_f_res_129489 = eta_p_129487 == eta_p_129488;
                        bool x_128410 = defunc_0_f_res_129489 && redout_133315;
                        bool redout_tmp_133898 = x_128410;
                        
                        redout_133315 = redout_tmp_133898;
                    }
                    defunc_0_reduce_res_133160 = redout_133315;
                    
                    bool cond_128411;
                    
                    if (defunc_0_reduce_res_133160) {
                        int32_t zm_lhs_132915 = mul32(radix_sizze_117700, prev_depth_128300);
                        int32_t byteSeq_neq_arg1_132916 = sub32(zm_lhs_132915, 1);
                        int32_t zm_rhs_132917 = sdiv32(byteSeq_neq_arg1_132916, 8);
                        int32_t zm_lhs_132918 = sub32(i64_res_126560, zm_rhs_132917);
                        int32_t i32_arg0_132919 = sub32(zm_lhs_132918, 1);
                        int64_t i32_res_132920 = sext_i32_i64(i32_arg0_132919);
                        int64_t j_m_i_132921 = sub64(map2_arg2_128277, i32_res_132920);
                        bool cond_t_res_132922;
                        
                        if (cond_128299) {
                            cond_t_res_132922 = 1;
                        } else {
                            int32_t min_res_132923 = smin32(min_arg1_126562, byteSeq_neq_arg1_132916);
                            int32_t zm_rhs_132924 = sdiv32(min_res_132923, 8);
                            int32_t zm_lhs_132925 = sub32(i64_res_126560, zm_rhs_132924);
                            int32_t i32_arg0_132926 = sub32(zm_lhs_132925, 1);
                            int64_t i32_res_132927 = sext_i32_i64(i32_arg0_132926);
                            int64_t min_res_132928 = smin64(min_arg1_126575, i32_res_132927);
                            bool x_132953 = sle64((int64_t) 0, min_res_132928);
                            bool y_132954 = slt64(min_res_132928, b_117696);
                            bool bounds_check_132955 = x_132953 && y_132954;
                            bool index_certs_132956;
                            
                            if (!bounds_check_132955) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_132928, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftRelational.fut:302:1-309:54\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            bool empty_slice_132966 = j_m_i_132921 == (int64_t) 0;
                            int64_t m_132967 = sub64(j_m_i_132921, (int64_t) 1);
                            int64_t i_p_m_t_s_132968 = add64(i32_res_132920, m_132967);
                            bool zzero_leq_i_p_m_t_s_132969 = sle64((int64_t) 0, i_p_m_t_s_132968);
                            bool i_p_m_t_s_leq_w_132970 = slt64(i_p_m_t_s_132968, b_117696);
                            bool zzero_lte_i_132971 = sle64((int64_t) 0, i32_res_132920);
                            bool i_lte_j_132972 = sle64(i32_res_132920, map2_arg2_128277);
                            bool y_132973 = i_p_m_t_s_leq_w_132970 && zzero_lte_i_132971;
                            bool y_132974 = zzero_leq_i_p_m_t_s_132969 && y_132973;
                            bool forwards_ok_132975 = i_lte_j_132972 && y_132974;
                            bool ok_or_empty_132976 = empty_slice_132966 || forwards_ok_132975;
                            bool index_certs_132977;
                            
                            if (!ok_or_empty_132976) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_132920, ":", (long long) map2_arg2_128277, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:56:38-49\n   #1  ftHashJoin.fut:138:3-41\n   #2  ftHashJoin.fut:363:30-71\n   #3  ftHashJoin.fut:426:3-432:70\n   #4  /prelude/functional.fut:9:44-45\n   #5  ftRelational.fut:306:4-309:35\n   #6  ftRelational.fut:302:1-309:54\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t lastBit_132929 = smod32(min_res_132923, 8);
                            int32_t zm_lhs_132930 = sub32(8, lastBit_132929);
                            int32_t i32_arg0_132931 = sub32(zm_lhs_132930, 1);
                            int8_t unsign_arg0_132932 = zext_i32_i8(i32_arg0_132931);
                            int8_t unsign_arg0_132933 = lshr8((int8_t) -1, unsign_arg0_132932);
                            
                            if (mem_133534_cached_sizze_133992 < b_117696) {
                                err = lexical_realloc(ctx, &mem_133534, &mem_133534_cached_sizze_133992, b_117696);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            if (mem_133535_cached_sizze_133993 < b_117696) {
                                err = lexical_realloc(ctx, &mem_133535, &mem_133535_cached_sizze_133993, b_117696);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            for (int64_t i_133321 = 0; i_133321 < b_117696; i_133321++) {
                                int8_t eta_p_132937 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133321];
                                int8_t eta_p_132938 = ((int8_t *) pS_mem_133467.mem)[ext_133519 + i_133321];
                                bool cond_132939 = sle64(i_133321, i32_res_126568);
                                bool cond_t_res_132940 = sle64(min_res_132928, i_133321);
                                bool x_132941 = cond_132939 && cond_t_res_132940;
                                int8_t lifted_lambda_res_132942;
                                
                                if (x_132941) {
                                    lifted_lambda_res_132942 = eta_p_132937;
                                } else {
                                    lifted_lambda_res_132942 = (int8_t) 0;
                                }
                                
                                int8_t lifted_lambda_res_132946;
                                
                                if (x_132941) {
                                    lifted_lambda_res_132946 = eta_p_132938;
                                } else {
                                    lifted_lambda_res_132946 = (int8_t) 0;
                                }
                                ((int8_t *) mem_133534)[i_133321] = lifted_lambda_res_132946;
                                ((int8_t *) mem_133535)[i_133321] = lifted_lambda_res_132942;
                            }
                            
                            int8_t za_lhs_132950 = ((int8_t *) mem_133535)[i32_res_126568];
                            int8_t mod1_x_132951 = (int8_t) -1 & za_lhs_132950;
                            
                            ((int8_t *) mem_133535)[i32_res_126568] = mod1_x_132951;
                            
                            int8_t za_lhs_132957 = ((int8_t *) mem_133535)[min_res_132928];
                            int8_t tmp_132958 = unsign_arg0_132933 & za_lhs_132957;
                            
                            ((int8_t *) mem_133535)[min_res_132928] = tmp_132958;
                            
                            int8_t za_lhs_132960 = ((int8_t *) mem_133534)[i32_res_126568];
                            int8_t mod1_x_132961 = (int8_t) -1 & za_lhs_132960;
                            
                            ((int8_t *) mem_133534)[i32_res_126568] = mod1_x_132961;
                            
                            int8_t za_lhs_132963 = ((int8_t *) mem_133534)[min_res_132928];
                            int8_t tmp_132964 = unsign_arg0_132933 & za_lhs_132963;
                            
                            ((int8_t *) mem_133534)[min_res_132928] = tmp_132964;
                            
                            bool defunc_0_reduce_res_132980;
                            bool redout_133324 = 0;
                            
                            for (int64_t i_133325 = 0; i_133325 < j_m_i_132921; i_133325++) {
                                int64_t slice_133453 = i32_res_132920 + i_133325;
                                int8_t eta_p_132981 = ((int8_t *) mem_133535)[slice_133453];
                                int8_t eta_p_132982 = ((int8_t *) mem_133534)[slice_133453];
                                bool defunc_0_f_res_132983 = eta_p_132981 == eta_p_132982;
                                bool defunc_0_f_res_132984 = !defunc_0_f_res_132983;
                                bool defunc_0_op_res_132987 = defunc_0_f_res_132984 || redout_133324;
                                bool redout_tmp_133901 = defunc_0_op_res_132987;
                                
                                redout_133324 = redout_tmp_133901;
                            }
                            defunc_0_reduce_res_132980 = redout_133324;
                            cond_t_res_132922 = defunc_0_reduce_res_132980;
                        }
                        cond_128411 = cond_t_res_132922;
                    } else {
                        cond_128411 = 0;
                    }
                    
                    int64_t loopres_128486;
                    int64_t loopres_128487;
                    
                    if (cond_128411) {
                        loopres_128486 = heshi_128292;
                        loopres_128487 = (int64_t) 0;
                    } else {
                        bool defunc_0_reduce_res_133157;
                        bool redout_133326 = 1;
                        
                        for (int64_t i_133327 = 0; i_133327 < j_m_i_128387; i_133327++) {
                            int64_t slice_133451 = i32_res_128386 + i_133327;
                            int8_t eta_p_129518 = ((int8_t *) mem_133521)[slice_133451];
                            int8_t eta_p_129519 = ((int8_t *) mem_133520)[slice_133451];
                            bool defunc_0_f_res_129520 = eta_p_129518 == eta_p_129519;
                            bool x_128496 = defunc_0_f_res_129520 && redout_133326;
                            bool redout_tmp_133902 = x_128496;
                            
                            redout_133326 = redout_tmp_133902;
                        }
                        defunc_0_reduce_res_133157 = redout_133326;
                        
                        bool loop_cond_t_res_128502 = slt32(0, cur_depth_128298);
                        int64_t loopres_f_res_128497;
                        int64_t loopres_f_res_128498;
                        
                        if (defunc_0_reduce_res_133157) {
                            int64_t tmp_132989 = sub64(heshi_128292, step_128293);
                            int64_t max_arg1_132990 = sdiv64(step_128293, (int64_t) 2);
                            int64_t max_res_132991 = smax64((int64_t) 1, max_arg1_132990);
                            
                            loopres_f_res_128497 = tmp_132989;
                            loopres_f_res_128498 = max_res_132991;
                        } else {
                            if (mem_133548_cached_sizze_133994 < b_117696) {
                                err = lexical_realloc(ctx, &mem_133548, &mem_133548_cached_sizze_133994, b_117696);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            if (mem_133549_cached_sizze_133995 < b_117696) {
                                err = lexical_realloc(ctx, &mem_133549, &mem_133549_cached_sizze_133995, b_117696);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            if (mem_133562_cached_sizze_133996 < b_117696) {
                                err = lexical_realloc(ctx, &mem_133562, &mem_133562_cached_sizze_133996, b_117696);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            if (mem_133563_cached_sizze_133997 < b_117696) {
                                err = lexical_realloc(ctx, &mem_133563, &mem_133563_cached_sizze_133997, b_117696);
                                if (err != FUTHARK_SUCCESS)
                                    goto cleanup;
                            }
                            
                            bool radix_lt_res_128503;
                            int32_t radix_lt_res_128504;
                            bool radix_lt_res_128505;
                            bool loop_while_128506;
                            int32_t p_128507;
                            bool p_128508;
                            
                            loop_while_128506 = loop_cond_t_res_128502;
                            p_128507 = 0;
                            p_128508 = 0;
                            while (loop_while_128506) {
                                int32_t zt_rhs_128509 = add32(1, p_128507);
                                int32_t zm_lhs_128510 = mul32(radix_sizze_117700, zt_rhs_128509);
                                int32_t byteSeq_lt_arg1_128511 = sub32(zm_lhs_128510, 1);
                                int32_t byteSeq_lt_arg0_128512 = mul32(radix_sizze_117700, p_128507);
                                int32_t min_res_128513 = smin32(min_arg1_126562, byteSeq_lt_arg1_128511);
                                int32_t zm_rhs_128514 = sdiv32(byteSeq_lt_arg0_128512, 8);
                                int32_t zm_lhs_128515 = sub32(i64_res_126560, zm_rhs_128514);
                                int32_t i32_arg0_128516 = sub32(zm_lhs_128515, 1);
                                int64_t i32_res_128517 = sext_i32_i64(i32_arg0_128516);
                                int32_t zm_rhs_128518 = sdiv32(min_res_128513, 8);
                                int32_t zm_lhs_128519 = sub32(i64_res_126560, zm_rhs_128518);
                                int32_t i32_arg0_128520 = sub32(zm_lhs_128519, 1);
                                int64_t i32_res_128521 = sext_i32_i64(i32_arg0_128520);
                                int64_t min_res_128522 = smin64(min_arg1_126575, i32_res_128521);
                                bool x_128538 = sle64((int64_t) 0, i32_res_128517);
                                bool y_128539 = slt64(i32_res_128517, b_117696);
                                bool bounds_check_128540 = x_128538 && y_128539;
                                bool index_certs_128541;
                                
                                if (!bounds_check_128540) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_128517, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:31:48-64\n   #1  ftHashJoin.fut:79:12-27\n   #2  ftRelational.fut:302:1-309:54\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_128545 = sle64((int64_t) 0, min_res_128522);
                                bool y_128546 = slt64(min_res_128522, b_117696);
                                bool bounds_check_128547 = x_128545 && y_128546;
                                bool index_certs_128548;
                                
                                if (!bounds_check_128547) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_128522, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftHashJoin.fut:79:12-27\n   #2  ftRelational.fut:302:1-309:54\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int32_t firstBit_128523 = smod32(byteSeq_lt_arg0_128512, 8);
                                int32_t lastBit_128524 = smod32(min_res_128513, 8);
                                int8_t unsign_arg0_128525 = zext_i32_i8(firstBit_128523);
                                int8_t first_bitMask_128526 = shl8((int8_t) -1, unsign_arg0_128525);
                                int32_t zm_lhs_128527 = sub32(8, lastBit_128524);
                                int32_t i32_arg0_128528 = sub32(zm_lhs_128527, 1);
                                int8_t unsign_arg0_128529 = zext_i32_i8(i32_arg0_128528);
                                int8_t unsign_arg0_128530 = lshr8((int8_t) -1, unsign_arg0_128529);
                                
                                for (int64_t i_133332 = 0; i_133332 < b_117696; i_133332++) {
                                    int8_t eta_p_129949 = ((int8_t *) pS_mem_133467.mem)[cur_S_128267 * b_117696 + i_133332];
                                    int8_t eta_p_129950 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133332];
                                    bool cond_129956 = sle64(i_133332, i32_res_128517);
                                    bool cond_t_res_129957 = sle64(min_res_128522, i_133332);
                                    bool x_129958 = cond_129956 && cond_t_res_129957;
                                    int8_t lifted_lambda_res_129959;
                                    
                                    if (x_129958) {
                                        lifted_lambda_res_129959 = eta_p_129950;
                                    } else {
                                        lifted_lambda_res_129959 = (int8_t) 0;
                                    }
                                    
                                    int8_t lifted_lambda_res_129964;
                                    
                                    if (x_129958) {
                                        lifted_lambda_res_129964 = eta_p_129949;
                                    } else {
                                        lifted_lambda_res_129964 = (int8_t) 0;
                                    }
                                    ((int8_t *) mem_133548)[i_133332] = lifted_lambda_res_129964;
                                    ((int8_t *) mem_133549)[i_133332] = lifted_lambda_res_129959;
                                }
                                lmad_copy_1b(ctx, 1, (uint8_t *) mem_133562, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133549, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_117696});
                                lmad_copy_1b(ctx, 1, (uint8_t *) mem_133563, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133548, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_117696});
                                
                                int8_t za_lhs_128542 = ((int8_t *) mem_133562)[i32_res_128517];
                                int8_t mod1_x_128543 = first_bitMask_128526 & za_lhs_128542;
                                
                                ((int8_t *) mem_133562)[i32_res_128517] = mod1_x_128543;
                                
                                int8_t za_lhs_128549 = ((int8_t *) mem_133562)[min_res_128522];
                                int8_t tmp_128550 = unsign_arg0_128530 & za_lhs_128549;
                                
                                ((int8_t *) mem_133562)[min_res_128522] = tmp_128550;
                                
                                int8_t za_lhs_128559 = ((int8_t *) mem_133563)[i32_res_128517];
                                int8_t mod1_x_128560 = first_bitMask_128526 & za_lhs_128559;
                                
                                ((int8_t *) mem_133563)[i32_res_128517] = mod1_x_128560;
                                
                                int8_t za_lhs_128562 = ((int8_t *) mem_133563)[min_res_128522];
                                int8_t tmp_128563 = unsign_arg0_128530 & za_lhs_128562;
                                
                                ((int8_t *) mem_133563)[min_res_128522] = tmp_128563;
                                
                                int32_t zm_rhs_128565 = sdiv32(byteSeq_lt_arg1_128511, 8);
                                int32_t zm_lhs_128566 = sub32(i64_res_126560, zm_rhs_128565);
                                int32_t i32_arg0_128567 = sub32(zm_lhs_128566, 1);
                                int64_t i32_res_128568 = sext_i32_i64(i32_arg0_128567);
                                bool loop_cond_t_res_128569 = slt64(i32_res_128568, i32_res_128517);
                                bool byteSeq_lt_res_128570;
                                int64_t byteSeq_lt_res_128571;
                                bool byteSeq_lt_res_128572;
                                bool loop_while_128573;
                                int64_t p_128574;
                                bool p_128575;
                                
                                loop_while_128573 = loop_cond_t_res_128569;
                                p_128574 = i32_res_128568;
                                p_128575 = 0;
                                while (loop_while_128573) {
                                    bool x_128576 = sle64((int64_t) 0, p_128574);
                                    bool y_128577 = slt64(p_128574, b_117696);
                                    bool bounds_check_128578 = x_128576 && y_128577;
                                    bool index_certs_128579;
                                    
                                    if (!bounds_check_128578) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_128574, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:86:17-27\n   #1  ftRelational.fut:302:1-309:54\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int8_t zl_lhs_128580 = ((int8_t *) mem_133562)[p_128574];
                                    int8_t zl_rhs_128581 = ((int8_t *) mem_133563)[p_128574];
                                    bool dlt_128582 = ult8(zl_lhs_128580, zl_rhs_128581);
                                    bool dgt_128583 = ult8(zl_rhs_128581, zl_lhs_128580);
                                    bool tmp_128584 = dlt_128582 || dgt_128583;
                                    bool cond_128585 = !tmp_128584;
                                    int64_t tmp_128586;
                                    
                                    if (cond_128585) {
                                        int64_t tmp_t_res_132992 = add64((int64_t) 1, p_128574);
                                        
                                        tmp_128586 = tmp_t_res_132992;
                                    } else {
                                        tmp_128586 = i32_res_128517;
                                    }
                                    
                                    bool cond_128588 = !dlt_128582;
                                    bool loop_cond_t_res_128589 = slt64(tmp_128586, i32_res_128517);
                                    bool x_128590 = cond_128588 && loop_cond_t_res_128589;
                                    bool loop_while_tmp_133908 = x_128590;
                                    int64_t p_tmp_133909 = tmp_128586;
                                    bool p_tmp_133910 = dlt_128582;
                                    
                                    loop_while_128573 = loop_while_tmp_133908;
                                    p_128574 = p_tmp_133909;
                                    p_128575 = p_tmp_133910;
                                }
                                byteSeq_lt_res_128570 = loop_while_128573;
                                byteSeq_lt_res_128571 = p_128574;
                                byteSeq_lt_res_128572 = p_128575;
                                
                                int8_t za_lhs_128598 = ((int8_t *) mem_133549)[i32_res_128517];
                                int8_t mod1_x_128599 = first_bitMask_128526 & za_lhs_128598;
                                
                                ((int8_t *) mem_133549)[i32_res_128517] = mod1_x_128599;
                                
                                int8_t za_lhs_128601 = ((int8_t *) mem_133549)[min_res_128522];
                                int8_t tmp_128602 = unsign_arg0_128530 & za_lhs_128601;
                                
                                ((int8_t *) mem_133549)[min_res_128522] = tmp_128602;
                                
                                int8_t za_lhs_128611 = ((int8_t *) mem_133548)[i32_res_128517];
                                int8_t mod1_x_128612 = first_bitMask_128526 & za_lhs_128611;
                                
                                ((int8_t *) mem_133548)[i32_res_128517] = mod1_x_128612;
                                
                                int8_t za_lhs_128614 = ((int8_t *) mem_133548)[min_res_128522];
                                int8_t tmp_128615 = unsign_arg0_128530 & za_lhs_128614;
                                
                                ((int8_t *) mem_133548)[min_res_128522] = tmp_128615;
                                
                                bool byteSeq_gt_res_128617;
                                int64_t byteSeq_gt_res_128618;
                                bool byteSeq_gt_res_128619;
                                bool loop_while_128620;
                                int64_t p_128621;
                                bool p_128622;
                                
                                loop_while_128620 = loop_cond_t_res_128569;
                                p_128621 = i32_res_128568;
                                p_128622 = 0;
                                while (loop_while_128620) {
                                    bool x_128623 = sle64((int64_t) 0, p_128621);
                                    bool y_128624 = slt64(p_128621, b_117696);
                                    bool bounds_check_128625 = x_128623 && y_128624;
                                    bool index_certs_128626;
                                    
                                    if (!bounds_check_128625) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_128621, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:123:17-27\n   #1  ftRelational.fut:302:1-309:54\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int8_t zl_lhs_128627 = ((int8_t *) mem_133549)[p_128621];
                                    int8_t zl_rhs_128628 = ((int8_t *) mem_133548)[p_128621];
                                    bool dlt_128629 = ult8(zl_lhs_128627, zl_rhs_128628);
                                    bool dgt_128630 = ult8(zl_rhs_128628, zl_lhs_128627);
                                    bool tmp_128631 = dlt_128629 || dgt_128630;
                                    bool cond_128632 = !tmp_128631;
                                    int64_t tmp_128633;
                                    
                                    if (cond_128632) {
                                        int64_t tmp_t_res_132993 = add64((int64_t) 1, p_128621);
                                        
                                        tmp_128633 = tmp_t_res_132993;
                                    } else {
                                        tmp_128633 = i32_res_128517;
                                    }
                                    
                                    bool cond_128635 = !dgt_128630;
                                    bool loop_cond_t_res_128636 = slt64(tmp_128633, i32_res_128517);
                                    bool x_128637 = cond_128635 && loop_cond_t_res_128636;
                                    bool loop_while_tmp_133911 = x_128637;
                                    int64_t p_tmp_133912 = tmp_128633;
                                    bool p_tmp_133913 = dgt_128630;
                                    
                                    loop_while_128620 = loop_while_tmp_133911;
                                    p_128621 = p_tmp_133912;
                                    p_128622 = p_tmp_133913;
                                }
                                byteSeq_gt_res_128617 = loop_while_128620;
                                byteSeq_gt_res_128618 = p_128621;
                                byteSeq_gt_res_128619 = p_128622;
                                
                                bool tmp_128638 = byteSeq_lt_res_128572 || byteSeq_gt_res_128619;
                                bool cond_128639 = !tmp_128638;
                                int32_t tmp_128640;
                                
                                if (cond_128639) {
                                    tmp_128640 = zt_rhs_128509;
                                } else {
                                    tmp_128640 = cur_depth_128298;
                                }
                                
                                bool cond_128641 = !byteSeq_lt_res_128572;
                                bool loop_cond_t_res_128642 = slt32(tmp_128640, cur_depth_128298);
                                bool x_128643 = cond_128641 && loop_cond_t_res_128642;
                                bool loop_while_tmp_133903 = x_128643;
                                int32_t p_tmp_133904 = tmp_128640;
                                bool p_tmp_133905 = byteSeq_lt_res_128572;
                                
                                loop_while_128506 = loop_while_tmp_133903;
                                p_128507 = p_tmp_133904;
                                p_128508 = p_tmp_133905;
                            }
                            radix_lt_res_128503 = loop_while_128506;
                            radix_lt_res_128504 = p_128507;
                            radix_lt_res_128505 = p_128508;
                            
                            int64_t loopres_f_res_f_res_128644;
                            int64_t loopres_f_res_f_res_128645;
                            
                            if (radix_lt_res_128505) {
                                bool loop_cond_t_res_133005 = slt32(0, prev_depth_128300);
                                bool cond_133004;
                                
                                if (cond_128299) {
                                    cond_133004 = 1;
                                } else {
                                    if (mem_133583_cached_sizze_134002 < b_117696) {
                                        err = lexical_realloc(ctx, &mem_133583, &mem_133583_cached_sizze_134002, b_117696);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    if (mem_133584_cached_sizze_134003 < b_117696) {
                                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134003, b_117696);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    if (mem_133597_cached_sizze_134004 < b_117696) {
                                        err = lexical_realloc(ctx, &mem_133597, &mem_133597_cached_sizze_134004, b_117696);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    if (mem_133598_cached_sizze_134005 < b_117696) {
                                        err = lexical_realloc(ctx, &mem_133598, &mem_133598_cached_sizze_134005, b_117696);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    
                                    bool radix_gt_res_133006;
                                    int32_t radix_gt_res_133007;
                                    bool radix_gt_res_133008;
                                    bool loop_while_133009;
                                    int32_t p_133010;
                                    bool p_133011;
                                    
                                    loop_while_133009 = loop_cond_t_res_133005;
                                    p_133010 = 0;
                                    p_133011 = 0;
                                    while (loop_while_133009) {
                                        int32_t zt_rhs_133012 = add32(1, p_133010);
                                        int32_t zm_lhs_133013 = mul32(radix_sizze_117700, zt_rhs_133012);
                                        int32_t byteSeq_lt_arg1_133014 = sub32(zm_lhs_133013, 1);
                                        int32_t byteSeq_lt_arg0_133015 = mul32(radix_sizze_117700, p_133010);
                                        int32_t min_res_133016 = smin32(min_arg1_126562, byteSeq_lt_arg1_133014);
                                        int32_t zm_rhs_133017 = sdiv32(byteSeq_lt_arg0_133015, 8);
                                        int32_t zm_lhs_133018 = sub32(i64_res_126560, zm_rhs_133017);
                                        int32_t i32_arg0_133019 = sub32(zm_lhs_133018, 1);
                                        int64_t i32_res_133020 = sext_i32_i64(i32_arg0_133019);
                                        int32_t zm_rhs_133021 = sdiv32(min_res_133016, 8);
                                        int32_t zm_lhs_133022 = sub32(i64_res_126560, zm_rhs_133021);
                                        int32_t i32_arg0_133023 = sub32(zm_lhs_133022, 1);
                                        int64_t i32_res_133024 = sext_i32_i64(i32_arg0_133023);
                                        int64_t min_res_133025 = smin64(min_arg1_126575, i32_res_133024);
                                        bool x_133061 = sle64((int64_t) 0, i32_res_133020);
                                        bool y_133062 = slt64(i32_res_133020, b_117696);
                                        bool bounds_check_133063 = x_133061 && y_133062;
                                        bool index_certs_133064;
                                        
                                        if (!bounds_check_133063) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_133020, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:31:48-64\n   #1  ftHashJoin.fut:79:12-27\n   #2  ftRelational.fut:302:1-309:54\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_133068 = sle64((int64_t) 0, min_res_133025);
                                        bool y_133069 = slt64(min_res_133025, b_117696);
                                        bool bounds_check_133070 = x_133068 && y_133069;
                                        bool index_certs_133071;
                                        
                                        if (!bounds_check_133070) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_133025, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftHashJoin.fut:79:12-27\n   #2  ftRelational.fut:302:1-309:54\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int32_t firstBit_133026 = smod32(byteSeq_lt_arg0_133015, 8);
                                        int32_t lastBit_133027 = smod32(min_res_133016, 8);
                                        int8_t unsign_arg0_133028 = zext_i32_i8(firstBit_133026);
                                        int8_t first_bitMask_133029 = shl8((int8_t) -1, unsign_arg0_133028);
                                        int32_t zm_lhs_133030 = sub32(8, lastBit_133027);
                                        int32_t i32_arg0_133031 = sub32(zm_lhs_133030, 1);
                                        int8_t unsign_arg0_133032 = zext_i32_i8(i32_arg0_133031);
                                        int8_t unsign_arg0_133033 = lshr8((int8_t) -1, unsign_arg0_133032);
                                        
                                        for (int64_t i_133339 = 0; i_133339 < b_117696; i_133339++) {
                                            int8_t eta_p_133039 = ((int8_t *) pS_mem_133467.mem)[ext_133519 + i_133339];
                                            int8_t eta_p_133040 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133339];
                                            bool cond_133041 = sle64(i_133339, i32_res_133020);
                                            bool cond_t_res_133042 = sle64(min_res_133025, i_133339);
                                            bool x_133043 = cond_133041 && cond_t_res_133042;
                                            int8_t lifted_lambda_res_133044;
                                            
                                            if (x_133043) {
                                                lifted_lambda_res_133044 = eta_p_133040;
                                            } else {
                                                lifted_lambda_res_133044 = (int8_t) 0;
                                            }
                                            
                                            int8_t lifted_lambda_res_133048;
                                            
                                            if (x_133043) {
                                                lifted_lambda_res_133048 = eta_p_133039;
                                            } else {
                                                lifted_lambda_res_133048 = (int8_t) 0;
                                            }
                                            ((int8_t *) mem_133583)[i_133339] = lifted_lambda_res_133048;
                                            ((int8_t *) mem_133584)[i_133339] = lifted_lambda_res_133044;
                                        }
                                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133597, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133584, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_117696});
                                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133598, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133583, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_117696});
                                        
                                        int8_t za_lhs_133065 = ((int8_t *) mem_133597)[i32_res_133020];
                                        int8_t mod1_x_133066 = first_bitMask_133029 & za_lhs_133065;
                                        
                                        ((int8_t *) mem_133597)[i32_res_133020] = mod1_x_133066;
                                        
                                        int8_t za_lhs_133072 = ((int8_t *) mem_133597)[min_res_133025];
                                        int8_t tmp_133073 = unsign_arg0_133033 & za_lhs_133072;
                                        
                                        ((int8_t *) mem_133597)[min_res_133025] = tmp_133073;
                                        
                                        int8_t za_lhs_133075 = ((int8_t *) mem_133598)[i32_res_133020];
                                        int8_t mod1_x_133076 = first_bitMask_133029 & za_lhs_133075;
                                        
                                        ((int8_t *) mem_133598)[i32_res_133020] = mod1_x_133076;
                                        
                                        int8_t za_lhs_133078 = ((int8_t *) mem_133598)[min_res_133025];
                                        int8_t tmp_133079 = unsign_arg0_133033 & za_lhs_133078;
                                        
                                        ((int8_t *) mem_133598)[min_res_133025] = tmp_133079;
                                        
                                        int32_t zm_rhs_133081 = sdiv32(byteSeq_lt_arg1_133014, 8);
                                        int32_t zm_lhs_133082 = sub32(i64_res_126560, zm_rhs_133081);
                                        int32_t i32_arg0_133083 = sub32(zm_lhs_133082, 1);
                                        int64_t i32_res_133084 = sext_i32_i64(i32_arg0_133083);
                                        bool loop_cond_t_res_133085 = slt64(i32_res_133084, i32_res_133020);
                                        bool byteSeq_lt_res_133086;
                                        int64_t byteSeq_lt_res_133087;
                                        bool byteSeq_lt_res_133088;
                                        bool loop_while_133089;
                                        int64_t p_133090;
                                        bool p_133091;
                                        
                                        loop_while_133089 = loop_cond_t_res_133085;
                                        p_133090 = i32_res_133084;
                                        p_133091 = 0;
                                        while (loop_while_133089) {
                                            bool x_133092 = sle64((int64_t) 0, p_133090);
                                            bool y_133093 = slt64(p_133090, b_117696);
                                            bool bounds_check_133094 = x_133092 && y_133093;
                                            bool index_certs_133095;
                                            
                                            if (!bounds_check_133094) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_133090, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:86:17-27\n   #1  ftRelational.fut:302:1-309:54\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int8_t zl_lhs_133096 = ((int8_t *) mem_133597)[p_133090];
                                            int8_t zl_rhs_133097 = ((int8_t *) mem_133598)[p_133090];
                                            bool dlt_133098 = ult8(zl_lhs_133096, zl_rhs_133097);
                                            bool dgt_133099 = ult8(zl_rhs_133097, zl_lhs_133096);
                                            bool tmp_133100 = dlt_133098 || dgt_133099;
                                            bool cond_133101 = !tmp_133100;
                                            int64_t tmp_133102;
                                            
                                            if (cond_133101) {
                                                int64_t tmp_t_res_133103 = add64((int64_t) 1, p_133090);
                                                
                                                tmp_133102 = tmp_t_res_133103;
                                            } else {
                                                tmp_133102 = i32_res_133020;
                                            }
                                            
                                            bool cond_133104 = !dlt_133098;
                                            bool loop_cond_t_res_133105 = slt64(tmp_133102, i32_res_133020);
                                            bool x_133106 = cond_133104 && loop_cond_t_res_133105;
                                            bool loop_while_tmp_133919 = x_133106;
                                            int64_t p_tmp_133920 = tmp_133102;
                                            bool p_tmp_133921 = dlt_133098;
                                            
                                            loop_while_133089 = loop_while_tmp_133919;
                                            p_133090 = p_tmp_133920;
                                            p_133091 = p_tmp_133921;
                                        }
                                        byteSeq_lt_res_133086 = loop_while_133089;
                                        byteSeq_lt_res_133087 = p_133090;
                                        byteSeq_lt_res_133088 = p_133091;
                                        
                                        int8_t za_lhs_133107 = ((int8_t *) mem_133584)[i32_res_133020];
                                        int8_t mod1_x_133108 = first_bitMask_133029 & za_lhs_133107;
                                        
                                        ((int8_t *) mem_133584)[i32_res_133020] = mod1_x_133108;
                                        
                                        int8_t za_lhs_133110 = ((int8_t *) mem_133584)[min_res_133025];
                                        int8_t tmp_133111 = unsign_arg0_133033 & za_lhs_133110;
                                        
                                        ((int8_t *) mem_133584)[min_res_133025] = tmp_133111;
                                        
                                        int8_t za_lhs_133113 = ((int8_t *) mem_133583)[i32_res_133020];
                                        int8_t mod1_x_133114 = first_bitMask_133029 & za_lhs_133113;
                                        
                                        ((int8_t *) mem_133583)[i32_res_133020] = mod1_x_133114;
                                        
                                        int8_t za_lhs_133116 = ((int8_t *) mem_133583)[min_res_133025];
                                        int8_t tmp_133117 = unsign_arg0_133033 & za_lhs_133116;
                                        
                                        ((int8_t *) mem_133583)[min_res_133025] = tmp_133117;
                                        
                                        bool byteSeq_gt_res_133119;
                                        int64_t byteSeq_gt_res_133120;
                                        bool byteSeq_gt_res_133121;
                                        bool loop_while_133122;
                                        int64_t p_133123;
                                        bool p_133124;
                                        
                                        loop_while_133122 = loop_cond_t_res_133085;
                                        p_133123 = i32_res_133084;
                                        p_133124 = 0;
                                        while (loop_while_133122) {
                                            bool x_133125 = sle64((int64_t) 0, p_133123);
                                            bool y_133126 = slt64(p_133123, b_117696);
                                            bool bounds_check_133127 = x_133125 && y_133126;
                                            bool index_certs_133128;
                                            
                                            if (!bounds_check_133127) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_133123, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:123:17-27\n   #1  ftRelational.fut:302:1-309:54\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int8_t zl_lhs_133129 = ((int8_t *) mem_133584)[p_133123];
                                            int8_t zl_rhs_133130 = ((int8_t *) mem_133583)[p_133123];
                                            bool dlt_133131 = ult8(zl_lhs_133129, zl_rhs_133130);
                                            bool dgt_133132 = ult8(zl_rhs_133130, zl_lhs_133129);
                                            bool tmp_133133 = dlt_133131 || dgt_133132;
                                            bool cond_133134 = !tmp_133133;
                                            int64_t tmp_133135;
                                            
                                            if (cond_133134) {
                                                int64_t tmp_t_res_133136 = add64((int64_t) 1, p_133123);
                                                
                                                tmp_133135 = tmp_t_res_133136;
                                            } else {
                                                tmp_133135 = i32_res_133020;
                                            }
                                            
                                            bool cond_133137 = !dgt_133132;
                                            bool loop_cond_t_res_133138 = slt64(tmp_133135, i32_res_133020);
                                            bool x_133139 = cond_133137 && loop_cond_t_res_133138;
                                            bool loop_while_tmp_133922 = x_133139;
                                            int64_t p_tmp_133923 = tmp_133135;
                                            bool p_tmp_133924 = dgt_133132;
                                            
                                            loop_while_133122 = loop_while_tmp_133922;
                                            p_133123 = p_tmp_133923;
                                            p_133124 = p_tmp_133924;
                                        }
                                        byteSeq_gt_res_133119 = loop_while_133122;
                                        byteSeq_gt_res_133120 = p_133123;
                                        byteSeq_gt_res_133121 = p_133124;
                                        
                                        bool tmp_133140 = byteSeq_lt_res_133088 || byteSeq_gt_res_133121;
                                        bool cond_133141 = !tmp_133140;
                                        int32_t tmp_133142;
                                        
                                        if (cond_133141) {
                                            tmp_133142 = zt_rhs_133012;
                                        } else {
                                            tmp_133142 = prev_depth_128300;
                                        }
                                        
                                        bool cond_133143 = !byteSeq_gt_res_133121;
                                        bool loop_cond_t_res_133144 = slt32(tmp_133142, prev_depth_128300);
                                        bool x_133145 = cond_133143 && loop_cond_t_res_133144;
                                        bool loop_while_tmp_133914 = x_133145;
                                        int32_t p_tmp_133915 = tmp_133142;
                                        bool p_tmp_133916 = byteSeq_gt_res_133121;
                                        
                                        loop_while_133009 = loop_while_tmp_133914;
                                        p_133010 = p_tmp_133915;
                                        p_133011 = p_tmp_133916;
                                    }
                                    radix_gt_res_133006 = loop_while_133009;
                                    radix_gt_res_133007 = p_133010;
                                    radix_gt_res_133008 = p_133011;
                                    cond_133004 = radix_gt_res_133008;
                                }
                                
                                int64_t loopres_f_res_f_res_t_res_133146;
                                int64_t loopres_f_res_f_res_t_res_133147;
                                
                                if (cond_133004) {
                                    loopres_f_res_f_res_t_res_133146 = (int64_t) -1;
                                    loopres_f_res_f_res_t_res_133147 = (int64_t) 0;
                                } else {
                                    int64_t tmp_133148 = sub64(heshi_128292, step_128293);
                                    int64_t max_arg1_133149 = sdiv64(step_128293, (int64_t) 2);
                                    int64_t max_res_133150 = smax64((int64_t) 1, max_arg1_133149);
                                    
                                    loopres_f_res_f_res_t_res_133146 = tmp_133148;
                                    loopres_f_res_f_res_t_res_133147 = max_res_133150;
                                }
                                loopres_f_res_f_res_128644 = loopres_f_res_f_res_t_res_133146;
                                loopres_f_res_f_res_128645 = loopres_f_res_f_res_t_res_133147;
                            } else {
                                int64_t tmp_128329 = add64((int64_t) 1, spi_128247);
                                bool x_128330 = sle64((int64_t) 0, tmp_128329);
                                bool y_128331 = slt64(tmp_128329, dz2081U_117698);
                                bool bounds_check_128332 = x_128330 && y_128331;
                                bool protect_assert_disj_133764 = cond_128307 || bounds_check_128332;
                                bool protect_assert_disj_133795 = cond_128307 || protect_assert_disj_133764;
                                bool index_certs_128333;
                                
                                if (!protect_assert_disj_133795) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128329, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:358:59-74\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool loop_cond_t_res_128795 = slt32(0, next_depth_128308);
                                bool x_133792 = !cond_128307;
                                bool protect_cond_conj_133796 = x_133792 && x_133792;
                                int64_t tmp_128334;
                                
                                if (protect_cond_conj_133796) {
                                    int64_t x_133765 = ((int64_t *) bounds_mem_133468.mem)[tmp_128329];
                                    
                                    tmp_128334 = x_133765;
                                } else {
                                    tmp_128334 = (int64_t) 0;
                                }
                                
                                int64_t lmad_ext_133564 = b_117696 * tmp_128334;
                                int64_t ext_133566;
                                
                                if (cond_128307) {
                                    ext_133566 = lmad_ext_133518;
                                } else {
                                    ext_133566 = lmad_ext_133564;
                                }
                                
                                bool cond_128794;
                                
                                if (cond_128307) {
                                    cond_128794 = 1;
                                } else {
                                    if (!cond_128307) {
                                        bool x_128335 = sle64((int64_t) 0, tmp_128334);
                                        bool y_128336 = slt64(tmp_128334, nS_117697);
                                        bool bounds_check_128337 = x_128335 && y_128336;
                                        bool index_certs_128338;
                                        
                                        if (!bounds_check_128337) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128334, "] out of bounds for array of shape [", (long long) nS_117697, "].", "-> #0  ftHashJoin.fut:358:56-75\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                    }
                                    if (mem_133567_cached_sizze_133998 < b_117696) {
                                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_133998, b_117696);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    if (mem_133568_cached_sizze_133999 < b_117696) {
                                        err = lexical_realloc(ctx, &mem_133568, &mem_133568_cached_sizze_133999, b_117696);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    if (mem_133581_cached_sizze_134000 < b_117696) {
                                        err = lexical_realloc(ctx, &mem_133581, &mem_133581_cached_sizze_134000, b_117696);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    if (mem_133582_cached_sizze_134001 < b_117696) {
                                        err = lexical_realloc(ctx, &mem_133582, &mem_133582_cached_sizze_134001, b_117696);
                                        if (err != FUTHARK_SUCCESS)
                                            goto cleanup;
                                    }
                                    
                                    bool radix_lt_res_128796;
                                    int32_t radix_lt_res_128797;
                                    bool radix_lt_res_128798;
                                    bool loop_while_128799;
                                    int32_t p_128800;
                                    bool p_128801;
                                    
                                    loop_while_128799 = loop_cond_t_res_128795;
                                    p_128800 = 0;
                                    p_128801 = 0;
                                    while (loop_while_128799) {
                                        int32_t zt_rhs_128802 = add32(1, p_128800);
                                        int32_t zm_lhs_128803 = mul32(radix_sizze_117700, zt_rhs_128802);
                                        int32_t byteSeq_lt_arg1_128804 = sub32(zm_lhs_128803, 1);
                                        int32_t byteSeq_lt_arg0_128805 = mul32(radix_sizze_117700, p_128800);
                                        int32_t min_res_128806 = smin32(min_arg1_126562, byteSeq_lt_arg1_128804);
                                        int32_t zm_rhs_128807 = sdiv32(byteSeq_lt_arg0_128805, 8);
                                        int32_t zm_lhs_128808 = sub32(i64_res_126560, zm_rhs_128807);
                                        int32_t i32_arg0_128809 = sub32(zm_lhs_128808, 1);
                                        int64_t i32_res_128810 = sext_i32_i64(i32_arg0_128809);
                                        int32_t zm_rhs_128811 = sdiv32(min_res_128806, 8);
                                        int32_t zm_lhs_128812 = sub32(i64_res_126560, zm_rhs_128811);
                                        int32_t i32_arg0_128813 = sub32(zm_lhs_128812, 1);
                                        int64_t i32_res_128814 = sext_i32_i64(i32_arg0_128813);
                                        int64_t min_res_128815 = smin64(min_arg1_126575, i32_res_128814);
                                        bool x_128831 = sle64((int64_t) 0, i32_res_128810);
                                        bool y_128832 = slt64(i32_res_128810, b_117696);
                                        bool bounds_check_128833 = x_128831 && y_128832;
                                        bool index_certs_128834;
                                        
                                        if (!bounds_check_128833) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_128810, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:31:48-64\n   #1  ftHashJoin.fut:79:12-27\n   #2  ftRelational.fut:302:1-309:54\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128838 = sle64((int64_t) 0, min_res_128815);
                                        bool y_128839 = slt64(min_res_128815, b_117696);
                                        bool bounds_check_128840 = x_128838 && y_128839;
                                        bool index_certs_128841;
                                        
                                        if (!bounds_check_128840) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_128815, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftHashJoin.fut:79:12-27\n   #2  ftRelational.fut:302:1-309:54\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int32_t firstBit_128816 = smod32(byteSeq_lt_arg0_128805, 8);
                                        int32_t lastBit_128817 = smod32(min_res_128806, 8);
                                        int8_t unsign_arg0_128818 = zext_i32_i8(firstBit_128816);
                                        int8_t first_bitMask_128819 = shl8((int8_t) -1, unsign_arg0_128818);
                                        int32_t zm_lhs_128820 = sub32(8, lastBit_128817);
                                        int32_t i32_arg0_128821 = sub32(zm_lhs_128820, 1);
                                        int8_t unsign_arg0_128822 = zext_i32_i8(i32_arg0_128821);
                                        int8_t unsign_arg0_128823 = lshr8((int8_t) -1, unsign_arg0_128822);
                                        
                                        for (int64_t i_133346 = 0; i_133346 < b_117696; i_133346++) {
                                            int8_t eta_p_129847 = ((int8_t *) pS_mem_133467.mem)[ext_133566 + i_133346];
                                            int8_t eta_p_129848 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133346];
                                            bool cond_129854 = sle64(i_133346, i32_res_128810);
                                            bool cond_t_res_129855 = sle64(min_res_128815, i_133346);
                                            bool x_129856 = cond_129854 && cond_t_res_129855;
                                            int8_t lifted_lambda_res_129857;
                                            
                                            if (x_129856) {
                                                lifted_lambda_res_129857 = eta_p_129848;
                                            } else {
                                                lifted_lambda_res_129857 = (int8_t) 0;
                                            }
                                            
                                            int8_t lifted_lambda_res_129862;
                                            
                                            if (x_129856) {
                                                lifted_lambda_res_129862 = eta_p_129847;
                                            } else {
                                                lifted_lambda_res_129862 = (int8_t) 0;
                                            }
                                            ((int8_t *) mem_133567)[i_133346] = lifted_lambda_res_129862;
                                            ((int8_t *) mem_133568)[i_133346] = lifted_lambda_res_129857;
                                        }
                                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133581, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133568, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_117696});
                                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133582, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133567, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_117696});
                                        
                                        int8_t za_lhs_128835 = ((int8_t *) mem_133581)[i32_res_128810];
                                        int8_t mod1_x_128836 = first_bitMask_128819 & za_lhs_128835;
                                        
                                        ((int8_t *) mem_133581)[i32_res_128810] = mod1_x_128836;
                                        
                                        int8_t za_lhs_128842 = ((int8_t *) mem_133581)[min_res_128815];
                                        int8_t tmp_128843 = unsign_arg0_128823 & za_lhs_128842;
                                        
                                        ((int8_t *) mem_133581)[min_res_128815] = tmp_128843;
                                        
                                        int8_t za_lhs_128852 = ((int8_t *) mem_133582)[i32_res_128810];
                                        int8_t mod1_x_128853 = first_bitMask_128819 & za_lhs_128852;
                                        
                                        ((int8_t *) mem_133582)[i32_res_128810] = mod1_x_128853;
                                        
                                        int8_t za_lhs_128855 = ((int8_t *) mem_133582)[min_res_128815];
                                        int8_t tmp_128856 = unsign_arg0_128823 & za_lhs_128855;
                                        
                                        ((int8_t *) mem_133582)[min_res_128815] = tmp_128856;
                                        
                                        int32_t zm_rhs_128858 = sdiv32(byteSeq_lt_arg1_128804, 8);
                                        int32_t zm_lhs_128859 = sub32(i64_res_126560, zm_rhs_128858);
                                        int32_t i32_arg0_128860 = sub32(zm_lhs_128859, 1);
                                        int64_t i32_res_128861 = sext_i32_i64(i32_arg0_128860);
                                        bool loop_cond_t_res_128862 = slt64(i32_res_128861, i32_res_128810);
                                        bool byteSeq_lt_res_128863;
                                        int64_t byteSeq_lt_res_128864;
                                        bool byteSeq_lt_res_128865;
                                        bool loop_while_128866;
                                        int64_t p_128867;
                                        bool p_128868;
                                        
                                        loop_while_128866 = loop_cond_t_res_128862;
                                        p_128867 = i32_res_128861;
                                        p_128868 = 0;
                                        while (loop_while_128866) {
                                            bool x_128869 = sle64((int64_t) 0, p_128867);
                                            bool y_128870 = slt64(p_128867, b_117696);
                                            bool bounds_check_128871 = x_128869 && y_128870;
                                            bool index_certs_128872;
                                            
                                            if (!bounds_check_128871) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_128867, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:86:17-27\n   #1  ftRelational.fut:302:1-309:54\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int8_t zl_lhs_128873 = ((int8_t *) mem_133581)[p_128867];
                                            int8_t zl_rhs_128874 = ((int8_t *) mem_133582)[p_128867];
                                            bool dlt_128875 = ult8(zl_lhs_128873, zl_rhs_128874);
                                            bool dgt_128876 = ult8(zl_rhs_128874, zl_lhs_128873);
                                            bool tmp_128877 = dlt_128875 || dgt_128876;
                                            bool cond_128878 = !tmp_128877;
                                            int64_t tmp_128879;
                                            
                                            if (cond_128878) {
                                                int64_t tmp_t_res_133151 = add64((int64_t) 1, p_128867);
                                                
                                                tmp_128879 = tmp_t_res_133151;
                                            } else {
                                                tmp_128879 = i32_res_128810;
                                            }
                                            
                                            bool cond_128881 = !dlt_128875;
                                            bool loop_cond_t_res_128882 = slt64(tmp_128879, i32_res_128810);
                                            bool x_128883 = cond_128881 && loop_cond_t_res_128882;
                                            bool loop_while_tmp_133930 = x_128883;
                                            int64_t p_tmp_133931 = tmp_128879;
                                            bool p_tmp_133932 = dlt_128875;
                                            
                                            loop_while_128866 = loop_while_tmp_133930;
                                            p_128867 = p_tmp_133931;
                                            p_128868 = p_tmp_133932;
                                        }
                                        byteSeq_lt_res_128863 = loop_while_128866;
                                        byteSeq_lt_res_128864 = p_128867;
                                        byteSeq_lt_res_128865 = p_128868;
                                        
                                        int8_t za_lhs_128891 = ((int8_t *) mem_133568)[i32_res_128810];
                                        int8_t mod1_x_128892 = first_bitMask_128819 & za_lhs_128891;
                                        
                                        ((int8_t *) mem_133568)[i32_res_128810] = mod1_x_128892;
                                        
                                        int8_t za_lhs_128894 = ((int8_t *) mem_133568)[min_res_128815];
                                        int8_t tmp_128895 = unsign_arg0_128823 & za_lhs_128894;
                                        
                                        ((int8_t *) mem_133568)[min_res_128815] = tmp_128895;
                                        
                                        int8_t za_lhs_128904 = ((int8_t *) mem_133567)[i32_res_128810];
                                        int8_t mod1_x_128905 = first_bitMask_128819 & za_lhs_128904;
                                        
                                        ((int8_t *) mem_133567)[i32_res_128810] = mod1_x_128905;
                                        
                                        int8_t za_lhs_128907 = ((int8_t *) mem_133567)[min_res_128815];
                                        int8_t tmp_128908 = unsign_arg0_128823 & za_lhs_128907;
                                        
                                        ((int8_t *) mem_133567)[min_res_128815] = tmp_128908;
                                        
                                        bool byteSeq_gt_res_128910;
                                        int64_t byteSeq_gt_res_128911;
                                        bool byteSeq_gt_res_128912;
                                        bool loop_while_128913;
                                        int64_t p_128914;
                                        bool p_128915;
                                        
                                        loop_while_128913 = loop_cond_t_res_128862;
                                        p_128914 = i32_res_128861;
                                        p_128915 = 0;
                                        while (loop_while_128913) {
                                            bool x_128916 = sle64((int64_t) 0, p_128914);
                                            bool y_128917 = slt64(p_128914, b_117696);
                                            bool bounds_check_128918 = x_128916 && y_128917;
                                            bool index_certs_128919;
                                            
                                            if (!bounds_check_128918) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_128914, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:123:17-27\n   #1  ftRelational.fut:302:1-309:54\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int8_t zl_lhs_128920 = ((int8_t *) mem_133568)[p_128914];
                                            int8_t zl_rhs_128921 = ((int8_t *) mem_133567)[p_128914];
                                            bool dlt_128922 = ult8(zl_lhs_128920, zl_rhs_128921);
                                            bool dgt_128923 = ult8(zl_rhs_128921, zl_lhs_128920);
                                            bool tmp_128924 = dlt_128922 || dgt_128923;
                                            bool cond_128925 = !tmp_128924;
                                            int64_t tmp_128926;
                                            
                                            if (cond_128925) {
                                                int64_t tmp_t_res_133152 = add64((int64_t) 1, p_128914);
                                                
                                                tmp_128926 = tmp_t_res_133152;
                                            } else {
                                                tmp_128926 = i32_res_128810;
                                            }
                                            
                                            bool cond_128928 = !dgt_128923;
                                            bool loop_cond_t_res_128929 = slt64(tmp_128926, i32_res_128810);
                                            bool x_128930 = cond_128928 && loop_cond_t_res_128929;
                                            bool loop_while_tmp_133933 = x_128930;
                                            int64_t p_tmp_133934 = tmp_128926;
                                            bool p_tmp_133935 = dgt_128923;
                                            
                                            loop_while_128913 = loop_while_tmp_133933;
                                            p_128914 = p_tmp_133934;
                                            p_128915 = p_tmp_133935;
                                        }
                                        byteSeq_gt_res_128910 = loop_while_128913;
                                        byteSeq_gt_res_128911 = p_128914;
                                        byteSeq_gt_res_128912 = p_128915;
                                        
                                        bool tmp_128931 = byteSeq_lt_res_128865 || byteSeq_gt_res_128912;
                                        bool cond_128932 = !tmp_128931;
                                        int32_t tmp_128933;
                                        
                                        if (cond_128932) {
                                            tmp_128933 = zt_rhs_128802;
                                        } else {
                                            tmp_128933 = next_depth_128308;
                                        }
                                        
                                        bool cond_128934 = !byteSeq_lt_res_128865;
                                        bool loop_cond_t_res_128935 = slt32(tmp_128933, next_depth_128308);
                                        bool x_128936 = cond_128934 && loop_cond_t_res_128935;
                                        bool loop_while_tmp_133925 = x_128936;
                                        int32_t p_tmp_133926 = tmp_128933;
                                        bool p_tmp_133927 = byteSeq_lt_res_128865;
                                        
                                        loop_while_128799 = loop_while_tmp_133925;
                                        p_128800 = p_tmp_133926;
                                        p_128801 = p_tmp_133927;
                                    }
                                    radix_lt_res_128796 = loop_while_128799;
                                    radix_lt_res_128797 = p_128800;
                                    radix_lt_res_128798 = p_128801;
                                    cond_128794 = radix_lt_res_128798;
                                }
                                
                                int64_t loopres_f_res_f_res_f_res_128937;
                                int64_t loopres_f_res_f_res_f_res_128938;
                                
                                if (cond_128794) {
                                    loopres_f_res_f_res_f_res_128937 = (int64_t) -1;
                                    loopres_f_res_f_res_f_res_128938 = (int64_t) 0;
                                } else {
                                    int64_t tmp_128939 = add64(heshi_128292, step_128293);
                                    int64_t max_arg1_128940 = sdiv64(step_128293, (int64_t) 2);
                                    int64_t max_res_128941 = smax64((int64_t) 1, max_arg1_128940);
                                    
                                    loopres_f_res_f_res_f_res_128937 = tmp_128939;
                                    loopres_f_res_f_res_f_res_128938 = max_res_128941;
                                }
                                loopres_f_res_f_res_128644 = loopres_f_res_f_res_f_res_128937;
                                loopres_f_res_f_res_128645 = loopres_f_res_f_res_f_res_128938;
                            }
                            loopres_f_res_128497 = loopres_f_res_f_res_128644;
                            loopres_f_res_128498 = loopres_f_res_f_res_128645;
                        }
                        loopres_128486 = loopres_f_res_128497;
                        loopres_128487 = loopres_f_res_128498;
                    }
                    
                    bool loop_cond_128942 = slt64((int64_t) 0, loopres_128487);
                    bool loop_while_tmp_133893 = loop_cond_128942;
                    int64_t heshi_tmp_133894 = loopres_128486;
                    int64_t step_tmp_133895 = loopres_128487;
                    
                    loop_while_128291 = loop_while_tmp_133893;
                    heshi_128292 = heshi_tmp_133894;
                    step_128293 = step_tmp_133895;
                }
                rv_partitionMatchBounds_res_f_res_f_res_128288 = loop_while_128291;
                rv_partitionMatchBounds_res_f_res_f_res_128289 = heshi_128292;
                rv_partitionMatchBounds_res_f_res_f_res_128290 = step_128293;
                
                int64_t zs_lhs_128943 = sub64(end_spi_128259, rv_partitionMatchBounds_res_f_res_f_res_128289);
                int64_t max_arg1_128944 = sdiv64(zs_lhs_128943, (int64_t) 2);
                int64_t max_res_128945 = smax64((int64_t) 1, max_arg1_128944);
                bool cond_128946 = slt64(rv_partitionMatchBounds_res_f_res_f_res_128289, (int64_t) 0);
                bool loop_cond_128948 = slt64((int64_t) 0, max_res_128945);
                int64_t rv_partitionMatchBounds_res_f_res_f_res_128947;
                
                if (cond_128946) {
                    rv_partitionMatchBounds_res_f_res_f_res_128947 = (int64_t) -1;
                } else {
                    bool loop_not_taken_128949 = !loop_cond_128948;
                    bool protect_assert_disj_128950 = bounds_check_128253 || loop_not_taken_128949;
                    bool index_certs_128951;
                    
                    if (!protect_assert_disj_128950) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) spi_128247, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:381:24-37\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t cur_S_128952;
                    
                    if (loop_cond_128948) {
                        int64_t x_133161 = ((int64_t *) bounds_mem_133468.mem)[spi_128247];
                        
                        cur_S_128952 = x_133161;
                    } else {
                        cur_S_128952 = (int64_t) 0;
                    }
                    
                    bool x_128954 = sle64((int64_t) 0, cur_S_128952);
                    bool y_128955 = slt64(cur_S_128952, nS_117697);
                    bool bounds_check_128956 = x_128954 && y_128955;
                    bool protect_assert_disj_128957 = loop_not_taken_128949 || bounds_check_128956;
                    bool index_certs_128958;
                    
                    if (!protect_assert_disj_128957) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) cur_S_128952, "] out of bounds for array of shape [", (long long) nS_117697, "].", "-> #0  ftHashJoin.fut:381:21-38\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool protect_assert_disj_128959 = bounds_check_126595 || loop_not_taken_128949;
                    bool index_certs_128960;
                    
                    if (!protect_assert_disj_128959) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_126568, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:31:48-64\n   #1  ftRelational.fut:302:1-309:54\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    if (mem_133599_cached_sizze_134006 < b_117696) {
                        err = lexical_realloc(ctx, &mem_133599, &mem_133599_cached_sizze_134006, b_117696);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133600_cached_sizze_134007 < b_117696) {
                        err = lexical_realloc(ctx, &mem_133600, &mem_133600_cached_sizze_134007, b_117696);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    
                    bool rv_partitionMatchBounds_res_f_res_f_res_f_res_128961;
                    int64_t rv_partitionMatchBounds_res_f_res_f_res_f_res_128962;
                    int64_t rv_partitionMatchBounds_res_f_res_f_res_f_res_128963;
                    bool loop_while_128964;
                    int64_t heshi_128965;
                    int64_t step_128966;
                    
                    loop_while_128964 = loop_cond_128948;
                    heshi_128965 = end_spi_128259;
                    step_128966 = max_res_128945;
                    while (loop_while_128964) {
                        bool x_128967 = sle64((int64_t) 0, heshi_128965);
                        bool y_128968 = slt64(heshi_128965, dz2081U_117698);
                        bool bounds_check_128969 = x_128967 && y_128968;
                        bool index_certs_128970;
                        
                        if (!bounds_check_128969) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) heshi_128965, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:379:25-40\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t cur_depth_128971 = ((int32_t *) depths_mem_133469.mem)[heshi_128965];
                        int32_t zm_lhs_128993 = mul32(radix_sizze_117700, cur_depth_128971);
                        int32_t byteSeq_eq_arg1_128994 = sub32(zm_lhs_128993, 1);
                        int32_t zm_rhs_129036 = sdiv32(byteSeq_eq_arg1_128994, 8);
                        int32_t zm_lhs_129037 = sub32(i64_res_126560, zm_rhs_129036);
                        int32_t i32_arg0_129038 = sub32(zm_lhs_129037, 1);
                        int64_t i32_res_129039 = sext_i32_i64(i32_arg0_129038);
                        bool zzero_lte_i_129046 = sle64((int64_t) 0, i32_res_129039);
                        int64_t j_m_i_129040 = sub64(map2_arg2_128277, i32_res_129039);
                        int64_t m_129042 = sub64(j_m_i_129040, (int64_t) 1);
                        int64_t i_p_m_t_s_129043 = add64(i32_res_129039, m_129042);
                        bool i_p_m_t_s_leq_w_129045 = slt64(i_p_m_t_s_129043, b_117696);
                        bool y_129048 = i_p_m_t_s_leq_w_129045 && zzero_lte_i_129046;
                        bool zzero_leq_i_p_m_t_s_129044 = sle64((int64_t) 0, i_p_m_t_s_129043);
                        bool y_129049 = zzero_leq_i_p_m_t_s_129044 && y_129048;
                        bool i_lte_j_129047 = sle64(i32_res_129039, map2_arg2_128277);
                        bool forwards_ok_129050 = i_lte_j_129047 && y_129049;
                        bool empty_slice_129041 = j_m_i_129040 == (int64_t) 0;
                        bool ok_or_empty_129051 = empty_slice_129041 || forwards_ok_129050;
                        bool index_certs_129052;
                        
                        if (!ok_or_empty_129051) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_129039, ":", (long long) map2_arg2_128277, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:48:38-49\n   #1  ftHashJoin.fut:134:3-40\n   #2  ftHashJoin.fut:385:14-52\n   #3  ftHashJoin.fut:426:3-432:70\n   #4  /prelude/functional.fut:9:44-45\n   #5  ftRelational.fut:306:4-309:35\n   #6  ftRelational.fut:302:1-309:54\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t min_res_128995 = smin32(min_arg1_126562, byteSeq_eq_arg1_128994);
                        int32_t zm_rhs_128996 = sdiv32(min_res_128995, 8);
                        int32_t zm_lhs_128997 = sub32(i64_res_126560, zm_rhs_128996);
                        int32_t i32_arg0_128998 = sub32(zm_lhs_128997, 1);
                        int64_t i32_res_128999 = sext_i32_i64(i32_arg0_128998);
                        int64_t min_res_129000 = smin64(min_arg1_126575, i32_res_128999);
                        bool y_129017 = slt64(min_res_129000, b_117696);
                        bool x_129016 = sle64((int64_t) 0, min_res_129000);
                        bool bounds_check_129018 = x_129016 && y_129017;
                        bool index_certs_129019;
                        
                        if (!bounds_check_129018) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_129000, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftRelational.fut:302:1-309:54\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_128972 = heshi_128965 == end_spi_128259;
                        int32_t next_depth_128973;
                        
                        if (cond_128972) {
                            next_depth_128973 = cur_depth_128971;
                        } else {
                            int64_t tmp_128974 = add64((int64_t) 1, heshi_128965);
                            bool x_128975 = sle64((int64_t) 0, tmp_128974);
                            bool y_128976 = slt64(tmp_128974, dz2081U_117698);
                            bool bounds_check_128977 = x_128975 && y_128976;
                            bool index_certs_128978;
                            
                            if (!bounds_check_128977) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128974, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:380:64-81\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t next_depth_f_res_128979 = ((int32_t *) depths_mem_133469.mem)[tmp_128974];
                            
                            next_depth_128973 = next_depth_f_res_128979;
                        }
                        for (int64_t i_133353 = 0; i_133353 < b_117696; i_133353++) {
                            int8_t eta_p_130848 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133353];
                            int8_t eta_p_130849 = ((int8_t *) pS_mem_133467.mem)[cur_S_128952 * b_117696 + i_133353];
                            bool cond_130851 = sle64(i_133353, i32_res_126568);
                            bool cond_t_res_130852 = sle64(min_res_129000, i_133353);
                            bool x_130853 = cond_130851 && cond_t_res_130852;
                            int8_t lifted_lambda_res_130854;
                            
                            if (x_130853) {
                                lifted_lambda_res_130854 = eta_p_130848;
                            } else {
                                lifted_lambda_res_130854 = (int8_t) 0;
                            }
                            
                            int8_t lifted_lambda_res_130859;
                            
                            if (x_130853) {
                                lifted_lambda_res_130859 = eta_p_130849;
                            } else {
                                lifted_lambda_res_130859 = (int8_t) 0;
                            }
                            ((int8_t *) mem_133599)[i_133353] = lifted_lambda_res_130859;
                            ((int8_t *) mem_133600)[i_133353] = lifted_lambda_res_130854;
                        }
                        
                        int8_t za_lhs_129030 = ((int8_t *) mem_133599)[i32_res_126568];
                        int8_t mod1_x_129031 = (int8_t) -1 & za_lhs_129030;
                        
                        ((int8_t *) mem_133599)[i32_res_126568] = mod1_x_129031;
                        
                        int8_t za_lhs_129033 = ((int8_t *) mem_133599)[min_res_129000];
                        int32_t lastBit_129001 = smod32(min_res_128995, 8);
                        int32_t zm_lhs_129002 = sub32(8, lastBit_129001);
                        int32_t i32_arg0_129003 = sub32(zm_lhs_129002, 1);
                        int8_t unsign_arg0_129004 = zext_i32_i8(i32_arg0_129003);
                        int8_t unsign_arg0_129005 = lshr8((int8_t) -1, unsign_arg0_129004);
                        int8_t tmp_129034 = unsign_arg0_129005 & za_lhs_129033;
                        
                        ((int8_t *) mem_133599)[min_res_129000] = tmp_129034;
                        
                        int8_t za_lhs_129013 = ((int8_t *) mem_133600)[i32_res_126568];
                        int8_t mod1_x_129014 = (int8_t) -1 & za_lhs_129013;
                        
                        ((int8_t *) mem_133600)[i32_res_126568] = mod1_x_129014;
                        
                        int8_t za_lhs_129020 = ((int8_t *) mem_133600)[min_res_129000];
                        int8_t tmp_129021 = unsign_arg0_129005 & za_lhs_129020;
                        
                        ((int8_t *) mem_133600)[min_res_129000] = tmp_129021;
                        
                        bool defunc_0_reduce_res_133268;
                        bool redout_133356 = 1;
                        
                        for (int64_t i_133357 = 0; i_133357 < j_m_i_129040; i_133357++) {
                            int64_t slice_133441 = i32_res_129039 + i_133357;
                            int8_t eta_p_130842 = ((int8_t *) mem_133600)[slice_133441];
                            int8_t eta_p_130843 = ((int8_t *) mem_133599)[slice_133441];
                            bool defunc_0_f_res_130844 = eta_p_130842 == eta_p_130843;
                            bool x_129063 = defunc_0_f_res_130844 && redout_133356;
                            bool redout_tmp_133941 = x_129063;
                            
                            redout_133356 = redout_tmp_133941;
                        }
                        defunc_0_reduce_res_133268 = redout_133356;
                        
                        bool cond_129064;
                        
                        if (defunc_0_reduce_res_133268) {
                            int64_t tmp_133176 = add64((int64_t) 1, spi_128247);
                            bool x_133177 = sle64((int64_t) 0, tmp_133176);
                            bool y_133178 = slt64(tmp_133176, dz2081U_117698);
                            bool bounds_check_133179 = x_133177 && y_133178;
                            bool protect_assert_disj_133748 = cond_128972 || bounds_check_133179;
                            bool protect_assert_disj_133790 = cond_128972 || protect_assert_disj_133748;
                            bool index_certs_133180;
                            
                            if (!protect_assert_disj_133790) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_133176, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:382:59-74\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t zm_lhs_133167 = mul32(radix_sizze_117700, next_depth_128973);
                            int32_t byteSeq_neq_arg1_133168 = sub32(zm_lhs_133167, 1);
                            int32_t zm_rhs_133169 = sdiv32(byteSeq_neq_arg1_133168, 8);
                            int32_t zm_lhs_133170 = sub32(i64_res_126560, zm_rhs_133169);
                            int32_t i32_arg0_133171 = sub32(zm_lhs_133170, 1);
                            int64_t i32_res_133172 = sext_i32_i64(i32_arg0_133171);
                            int64_t j_m_i_133173 = sub64(map2_arg2_128277, i32_res_133172);
                            bool x_133787 = !cond_128972;
                            bool protect_cond_conj_133791 = x_133787 && x_133787;
                            int64_t tmp_133181;
                            
                            if (protect_cond_conj_133791) {
                                int64_t x_133749 = ((int64_t *) bounds_mem_133468.mem)[tmp_133176];
                                
                                tmp_133181 = x_133749;
                            } else {
                                tmp_133181 = (int64_t) 0;
                            }
                            
                            int64_t lmad_ext_133613 = b_117696 * tmp_133181;
                            int64_t lmad_ext_133614 = b_117696 * cur_S_128952;
                            int64_t ext_133615;
                            
                            if (cond_128972) {
                                ext_133615 = lmad_ext_133614;
                            } else {
                                ext_133615 = lmad_ext_133613;
                            }
                            
                            bool cond_t_res_133174;
                            
                            if (cond_128972) {
                                cond_t_res_133174 = 1;
                            } else {
                                int32_t min_res_133187 = smin32(min_arg1_126562, byteSeq_neq_arg1_133168);
                                int32_t zm_rhs_133188 = sdiv32(min_res_133187, 8);
                                int32_t zm_lhs_133189 = sub32(i64_res_126560, zm_rhs_133188);
                                int32_t i32_arg0_133190 = sub32(zm_lhs_133189, 1);
                                int64_t i32_res_133191 = sext_i32_i64(i32_arg0_133190);
                                int64_t min_res_133192 = smin64(min_arg1_126575, i32_res_133191);
                                bool x_133217 = sle64((int64_t) 0, min_res_133192);
                                bool y_133218 = slt64(min_res_133192, b_117696);
                                bool bounds_check_133219 = x_133217 && y_133218;
                                bool index_certs_133220;
                                
                                if (!bounds_check_133219) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_133192, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftRelational.fut:302:1-309:54\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool empty_slice_133230 = j_m_i_133173 == (int64_t) 0;
                                int64_t m_133231 = sub64(j_m_i_133173, (int64_t) 1);
                                int64_t i_p_m_t_s_133232 = add64(i32_res_133172, m_133231);
                                bool zzero_leq_i_p_m_t_s_133233 = sle64((int64_t) 0, i_p_m_t_s_133232);
                                bool i_p_m_t_s_leq_w_133234 = slt64(i_p_m_t_s_133232, b_117696);
                                bool zzero_lte_i_133235 = sle64((int64_t) 0, i32_res_133172);
                                bool i_lte_j_133236 = sle64(i32_res_133172, map2_arg2_128277);
                                bool y_133237 = i_p_m_t_s_leq_w_133234 && zzero_lte_i_133235;
                                bool y_133238 = zzero_leq_i_p_m_t_s_133233 && y_133237;
                                bool forwards_ok_133239 = i_lte_j_133236 && y_133238;
                                bool ok_or_empty_133240 = empty_slice_133230 || forwards_ok_133239;
                                bool index_certs_133241;
                                
                                if (!ok_or_empty_133240) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_133172, ":", (long long) map2_arg2_128277, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:56:38-49\n   #1  ftHashJoin.fut:138:3-41\n   #2  ftHashJoin.fut:387:34-75\n   #3  ftHashJoin.fut:426:3-432:70\n   #4  /prelude/functional.fut:9:44-45\n   #5  ftRelational.fut:306:4-309:35\n   #6  ftRelational.fut:302:1-309:54\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                if (!cond_128972) {
                                    bool x_133182 = sle64((int64_t) 0, tmp_133181);
                                    bool y_133183 = slt64(tmp_133181, nS_117697);
                                    bool bounds_check_133184 = x_133182 && y_133183;
                                    bool index_certs_133185;
                                    
                                    if (!bounds_check_133184) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_133181, "] out of bounds for array of shape [", (long long) nS_117697, "].", "-> #0  ftHashJoin.fut:382:56-75\n   #1  ftHashJoin.fut:426:3-432:70\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                }
                                
                                int32_t lastBit_133193 = smod32(min_res_133187, 8);
                                int32_t zm_lhs_133194 = sub32(8, lastBit_133193);
                                int32_t i32_arg0_133195 = sub32(zm_lhs_133194, 1);
                                int8_t unsign_arg0_133196 = zext_i32_i8(i32_arg0_133195);
                                int8_t unsign_arg0_133197 = lshr8((int8_t) -1, unsign_arg0_133196);
                                
                                if (mem_133616_cached_sizze_134008 < b_117696) {
                                    err = lexical_realloc(ctx, &mem_133616, &mem_133616_cached_sizze_134008, b_117696);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                if (mem_133617_cached_sizze_134009 < b_117696) {
                                    err = lexical_realloc(ctx, &mem_133617, &mem_133617_cached_sizze_134009, b_117696);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                for (int64_t i_133362 = 0; i_133362 < b_117696; i_133362++) {
                                    int8_t eta_p_133201 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133362];
                                    int8_t eta_p_133202 = ((int8_t *) pS_mem_133467.mem)[ext_133615 + i_133362];
                                    bool cond_133203 = sle64(i_133362, i32_res_126568);
                                    bool cond_t_res_133204 = sle64(min_res_133192, i_133362);
                                    bool x_133205 = cond_133203 && cond_t_res_133204;
                                    int8_t lifted_lambda_res_133206;
                                    
                                    if (x_133205) {
                                        lifted_lambda_res_133206 = eta_p_133201;
                                    } else {
                                        lifted_lambda_res_133206 = (int8_t) 0;
                                    }
                                    
                                    int8_t lifted_lambda_res_133210;
                                    
                                    if (x_133205) {
                                        lifted_lambda_res_133210 = eta_p_133202;
                                    } else {
                                        lifted_lambda_res_133210 = (int8_t) 0;
                                    }
                                    ((int8_t *) mem_133616)[i_133362] = lifted_lambda_res_133210;
                                    ((int8_t *) mem_133617)[i_133362] = lifted_lambda_res_133206;
                                }
                                
                                int8_t za_lhs_133214 = ((int8_t *) mem_133617)[i32_res_126568];
                                int8_t mod1_x_133215 = (int8_t) -1 & za_lhs_133214;
                                
                                ((int8_t *) mem_133617)[i32_res_126568] = mod1_x_133215;
                                
                                int8_t za_lhs_133221 = ((int8_t *) mem_133617)[min_res_133192];
                                int8_t tmp_133222 = unsign_arg0_133197 & za_lhs_133221;
                                
                                ((int8_t *) mem_133617)[min_res_133192] = tmp_133222;
                                
                                int8_t za_lhs_133224 = ((int8_t *) mem_133616)[i32_res_126568];
                                int8_t mod1_x_133225 = (int8_t) -1 & za_lhs_133224;
                                
                                ((int8_t *) mem_133616)[i32_res_126568] = mod1_x_133225;
                                
                                int8_t za_lhs_133227 = ((int8_t *) mem_133616)[min_res_133192];
                                int8_t tmp_133228 = unsign_arg0_133197 & za_lhs_133227;
                                
                                ((int8_t *) mem_133616)[min_res_133192] = tmp_133228;
                                
                                bool defunc_0_reduce_res_133244;
                                bool redout_133365 = 0;
                                
                                for (int64_t i_133366 = 0; i_133366 < j_m_i_133173; i_133366++) {
                                    int64_t slice_133437 = i32_res_133172 + i_133366;
                                    int8_t eta_p_133245 = ((int8_t *) mem_133617)[slice_133437];
                                    int8_t eta_p_133246 = ((int8_t *) mem_133616)[slice_133437];
                                    bool defunc_0_f_res_133247 = eta_p_133245 == eta_p_133246;
                                    bool defunc_0_f_res_133248 = !defunc_0_f_res_133247;
                                    bool defunc_0_op_res_133251 = defunc_0_f_res_133248 || redout_133365;
                                    bool redout_tmp_133944 = defunc_0_op_res_133251;
                                    
                                    redout_133365 = redout_tmp_133944;
                                }
                                defunc_0_reduce_res_133244 = redout_133365;
                                cond_t_res_133174 = defunc_0_reduce_res_133244;
                            }
                            cond_129064 = cond_t_res_133174;
                        } else {
                            cond_129064 = 0;
                        }
                        
                        int64_t loopres_129139;
                        int64_t loopres_129140;
                        
                        if (cond_129064) {
                            loopres_129139 = heshi_128965;
                            loopres_129140 = (int64_t) 0;
                        } else {
                            bool defunc_0_reduce_res_133265;
                            bool redout_133367 = 1;
                            
                            for (int64_t i_133368 = 0; i_133368 < j_m_i_129040; i_133368++) {
                                int64_t slice_133435 = i32_res_129039 + i_133368;
                                int8_t eta_p_131016 = ((int8_t *) mem_133600)[slice_133435];
                                int8_t eta_p_131017 = ((int8_t *) mem_133599)[slice_133435];
                                bool defunc_0_f_res_131018 = eta_p_131016 == eta_p_131017;
                                bool x_129149 = defunc_0_f_res_131018 && redout_133367;
                                bool redout_tmp_133945 = x_129149;
                                
                                redout_133367 = redout_tmp_133945;
                            }
                            defunc_0_reduce_res_133265 = redout_133367;
                            
                            bool loop_cond_t_res_129155 = slt32(0, cur_depth_128971);
                            int64_t loopres_f_res_129150;
                            int64_t loopres_f_res_129151;
                            
                            if (defunc_0_reduce_res_133265) {
                                int64_t tmp_133253 = add64(heshi_128965, step_128966);
                                int64_t max_arg1_133254 = sdiv64(step_128966, (int64_t) 2);
                                int64_t max_res_133255 = smax64((int64_t) 1, max_arg1_133254);
                                
                                loopres_f_res_129150 = tmp_133253;
                                loopres_f_res_129151 = max_res_133255;
                            } else {
                                if (mem_133630_cached_sizze_134010 < b_117696) {
                                    err = lexical_realloc(ctx, &mem_133630, &mem_133630_cached_sizze_134010, b_117696);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                if (mem_133631_cached_sizze_134011 < b_117696) {
                                    err = lexical_realloc(ctx, &mem_133631, &mem_133631_cached_sizze_134011, b_117696);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                if (mem_133644_cached_sizze_134012 < b_117696) {
                                    err = lexical_realloc(ctx, &mem_133644, &mem_133644_cached_sizze_134012, b_117696);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                if (mem_133645_cached_sizze_134013 < b_117696) {
                                    err = lexical_realloc(ctx, &mem_133645, &mem_133645_cached_sizze_134013, b_117696);
                                    if (err != FUTHARK_SUCCESS)
                                        goto cleanup;
                                }
                                
                                bool radix_lt_res_129156;
                                int32_t radix_lt_res_129157;
                                bool radix_lt_res_129158;
                                bool loop_while_129159;
                                int32_t p_129160;
                                bool p_129161;
                                
                                loop_while_129159 = loop_cond_t_res_129155;
                                p_129160 = 0;
                                p_129161 = 0;
                                while (loop_while_129159) {
                                    int32_t zt_rhs_129162 = add32(1, p_129160);
                                    int32_t zm_lhs_129163 = mul32(radix_sizze_117700, zt_rhs_129162);
                                    int32_t byteSeq_lt_arg1_129164 = sub32(zm_lhs_129163, 1);
                                    int32_t byteSeq_lt_arg0_129165 = mul32(radix_sizze_117700, p_129160);
                                    int32_t min_res_129166 = smin32(min_arg1_126562, byteSeq_lt_arg1_129164);
                                    int32_t zm_rhs_129167 = sdiv32(byteSeq_lt_arg0_129165, 8);
                                    int32_t zm_lhs_129168 = sub32(i64_res_126560, zm_rhs_129167);
                                    int32_t i32_arg0_129169 = sub32(zm_lhs_129168, 1);
                                    int64_t i32_res_129170 = sext_i32_i64(i32_arg0_129169);
                                    int32_t zm_rhs_129171 = sdiv32(min_res_129166, 8);
                                    int32_t zm_lhs_129172 = sub32(i64_res_126560, zm_rhs_129171);
                                    int32_t i32_arg0_129173 = sub32(zm_lhs_129172, 1);
                                    int64_t i32_res_129174 = sext_i32_i64(i32_arg0_129173);
                                    int64_t min_res_129175 = smin64(min_arg1_126575, i32_res_129174);
                                    bool x_129191 = sle64((int64_t) 0, i32_res_129170);
                                    bool y_129192 = slt64(i32_res_129170, b_117696);
                                    bool bounds_check_129193 = x_129191 && y_129192;
                                    bool index_certs_129194;
                                    
                                    if (!bounds_check_129193) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_129170, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:31:48-64\n   #1  ftHashJoin.fut:79:12-27\n   #2  ftRelational.fut:302:1-309:54\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_129198 = sle64((int64_t) 0, min_res_129175);
                                    bool y_129199 = slt64(min_res_129175, b_117696);
                                    bool bounds_check_129200 = x_129198 && y_129199;
                                    bool index_certs_129201;
                                    
                                    if (!bounds_check_129200) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_129175, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftHashJoin.fut:79:12-27\n   #2  ftRelational.fut:302:1-309:54\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int32_t firstBit_129176 = smod32(byteSeq_lt_arg0_129165, 8);
                                    int32_t lastBit_129177 = smod32(min_res_129166, 8);
                                    int8_t unsign_arg0_129178 = zext_i32_i8(firstBit_129176);
                                    int8_t first_bitMask_129179 = shl8((int8_t) -1, unsign_arg0_129178);
                                    int32_t zm_lhs_129180 = sub32(8, lastBit_129177);
                                    int32_t i32_arg0_129181 = sub32(zm_lhs_129180, 1);
                                    int8_t unsign_arg0_129182 = zext_i32_i8(i32_arg0_129181);
                                    int8_t unsign_arg0_129183 = lshr8((int8_t) -1, unsign_arg0_129182);
                                    
                                    for (int64_t i_133373 = 0; i_133373 < b_117696; i_133373++) {
                                        int8_t eta_p_131064 = ((int8_t *) pS_mem_133467.mem)[cur_S_128952 * b_117696 + i_133373];
                                        int8_t eta_p_131065 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133373];
                                        bool cond_131071 = sle64(i_133373, i32_res_129170);
                                        bool cond_t_res_131072 = sle64(min_res_129175, i_133373);
                                        bool x_131073 = cond_131071 && cond_t_res_131072;
                                        int8_t lifted_lambda_res_131074;
                                        
                                        if (x_131073) {
                                            lifted_lambda_res_131074 = eta_p_131065;
                                        } else {
                                            lifted_lambda_res_131074 = (int8_t) 0;
                                        }
                                        
                                        int8_t lifted_lambda_res_131079;
                                        
                                        if (x_131073) {
                                            lifted_lambda_res_131079 = eta_p_131064;
                                        } else {
                                            lifted_lambda_res_131079 = (int8_t) 0;
                                        }
                                        ((int8_t *) mem_133630)[i_133373] = lifted_lambda_res_131079;
                                        ((int8_t *) mem_133631)[i_133373] = lifted_lambda_res_131074;
                                    }
                                    lmad_copy_1b(ctx, 1, (uint8_t *) mem_133644, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133631, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_117696});
                                    lmad_copy_1b(ctx, 1, (uint8_t *) mem_133645, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133630, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_117696});
                                    
                                    int8_t za_lhs_129195 = ((int8_t *) mem_133644)[i32_res_129170];
                                    int8_t mod1_x_129196 = first_bitMask_129179 & za_lhs_129195;
                                    
                                    ((int8_t *) mem_133644)[i32_res_129170] = mod1_x_129196;
                                    
                                    int8_t za_lhs_129202 = ((int8_t *) mem_133644)[min_res_129175];
                                    int8_t tmp_129203 = unsign_arg0_129183 & za_lhs_129202;
                                    
                                    ((int8_t *) mem_133644)[min_res_129175] = tmp_129203;
                                    
                                    int8_t za_lhs_129212 = ((int8_t *) mem_133645)[i32_res_129170];
                                    int8_t mod1_x_129213 = first_bitMask_129179 & za_lhs_129212;
                                    
                                    ((int8_t *) mem_133645)[i32_res_129170] = mod1_x_129213;
                                    
                                    int8_t za_lhs_129215 = ((int8_t *) mem_133645)[min_res_129175];
                                    int8_t tmp_129216 = unsign_arg0_129183 & za_lhs_129215;
                                    
                                    ((int8_t *) mem_133645)[min_res_129175] = tmp_129216;
                                    
                                    int32_t zm_rhs_129218 = sdiv32(byteSeq_lt_arg1_129164, 8);
                                    int32_t zm_lhs_129219 = sub32(i64_res_126560, zm_rhs_129218);
                                    int32_t i32_arg0_129220 = sub32(zm_lhs_129219, 1);
                                    int64_t i32_res_129221 = sext_i32_i64(i32_arg0_129220);
                                    bool loop_cond_t_res_129222 = slt64(i32_res_129221, i32_res_129170);
                                    bool byteSeq_lt_res_129223;
                                    int64_t byteSeq_lt_res_129224;
                                    bool byteSeq_lt_res_129225;
                                    bool loop_while_129226;
                                    int64_t p_129227;
                                    bool p_129228;
                                    
                                    loop_while_129226 = loop_cond_t_res_129222;
                                    p_129227 = i32_res_129221;
                                    p_129228 = 0;
                                    while (loop_while_129226) {
                                        bool x_129229 = sle64((int64_t) 0, p_129227);
                                        bool y_129230 = slt64(p_129227, b_117696);
                                        bool bounds_check_129231 = x_129229 && y_129230;
                                        bool index_certs_129232;
                                        
                                        if (!bounds_check_129231) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_129227, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:86:17-27\n   #1  ftRelational.fut:302:1-309:54\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int8_t zl_lhs_129233 = ((int8_t *) mem_133644)[p_129227];
                                        int8_t zl_rhs_129234 = ((int8_t *) mem_133645)[p_129227];
                                        bool dlt_129235 = ult8(zl_lhs_129233, zl_rhs_129234);
                                        bool dgt_129236 = ult8(zl_rhs_129234, zl_lhs_129233);
                                        bool tmp_129237 = dlt_129235 || dgt_129236;
                                        bool cond_129238 = !tmp_129237;
                                        int64_t tmp_129239;
                                        
                                        if (cond_129238) {
                                            int64_t tmp_t_res_133256 = add64((int64_t) 1, p_129227);
                                            
                                            tmp_129239 = tmp_t_res_133256;
                                        } else {
                                            tmp_129239 = i32_res_129170;
                                        }
                                        
                                        bool cond_129241 = !dlt_129235;
                                        bool loop_cond_t_res_129242 = slt64(tmp_129239, i32_res_129170);
                                        bool x_129243 = cond_129241 && loop_cond_t_res_129242;
                                        bool loop_while_tmp_133951 = x_129243;
                                        int64_t p_tmp_133952 = tmp_129239;
                                        bool p_tmp_133953 = dlt_129235;
                                        
                                        loop_while_129226 = loop_while_tmp_133951;
                                        p_129227 = p_tmp_133952;
                                        p_129228 = p_tmp_133953;
                                    }
                                    byteSeq_lt_res_129223 = loop_while_129226;
                                    byteSeq_lt_res_129224 = p_129227;
                                    byteSeq_lt_res_129225 = p_129228;
                                    
                                    int8_t za_lhs_129251 = ((int8_t *) mem_133631)[i32_res_129170];
                                    int8_t mod1_x_129252 = first_bitMask_129179 & za_lhs_129251;
                                    
                                    ((int8_t *) mem_133631)[i32_res_129170] = mod1_x_129252;
                                    
                                    int8_t za_lhs_129254 = ((int8_t *) mem_133631)[min_res_129175];
                                    int8_t tmp_129255 = unsign_arg0_129183 & za_lhs_129254;
                                    
                                    ((int8_t *) mem_133631)[min_res_129175] = tmp_129255;
                                    
                                    int8_t za_lhs_129264 = ((int8_t *) mem_133630)[i32_res_129170];
                                    int8_t mod1_x_129265 = first_bitMask_129179 & za_lhs_129264;
                                    
                                    ((int8_t *) mem_133630)[i32_res_129170] = mod1_x_129265;
                                    
                                    int8_t za_lhs_129267 = ((int8_t *) mem_133630)[min_res_129175];
                                    int8_t tmp_129268 = unsign_arg0_129183 & za_lhs_129267;
                                    
                                    ((int8_t *) mem_133630)[min_res_129175] = tmp_129268;
                                    
                                    bool byteSeq_gt_res_129270;
                                    int64_t byteSeq_gt_res_129271;
                                    bool byteSeq_gt_res_129272;
                                    bool loop_while_129273;
                                    int64_t p_129274;
                                    bool p_129275;
                                    
                                    loop_while_129273 = loop_cond_t_res_129222;
                                    p_129274 = i32_res_129221;
                                    p_129275 = 0;
                                    while (loop_while_129273) {
                                        bool x_129276 = sle64((int64_t) 0, p_129274);
                                        bool y_129277 = slt64(p_129274, b_117696);
                                        bool bounds_check_129278 = x_129276 && y_129277;
                                        bool index_certs_129279;
                                        
                                        if (!bounds_check_129278) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) p_129274, "] out of bounds for array of shape [", (long long) b_117696, "].", "-> #0  ftHashJoin.fut:123:17-27\n   #1  ftRelational.fut:302:1-309:54\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int8_t zl_lhs_129280 = ((int8_t *) mem_133631)[p_129274];
                                        int8_t zl_rhs_129281 = ((int8_t *) mem_133630)[p_129274];
                                        bool dlt_129282 = ult8(zl_lhs_129280, zl_rhs_129281);
                                        bool dgt_129283 = ult8(zl_rhs_129281, zl_lhs_129280);
                                        bool tmp_129284 = dlt_129282 || dgt_129283;
                                        bool cond_129285 = !tmp_129284;
                                        int64_t tmp_129286;
                                        
                                        if (cond_129285) {
                                            int64_t tmp_t_res_133257 = add64((int64_t) 1, p_129274);
                                            
                                            tmp_129286 = tmp_t_res_133257;
                                        } else {
                                            tmp_129286 = i32_res_129170;
                                        }
                                        
                                        bool cond_129288 = !dgt_129283;
                                        bool loop_cond_t_res_129289 = slt64(tmp_129286, i32_res_129170);
                                        bool x_129290 = cond_129288 && loop_cond_t_res_129289;
                                        bool loop_while_tmp_133954 = x_129290;
                                        int64_t p_tmp_133955 = tmp_129286;
                                        bool p_tmp_133956 = dgt_129283;
                                        
                                        loop_while_129273 = loop_while_tmp_133954;
                                        p_129274 = p_tmp_133955;
                                        p_129275 = p_tmp_133956;
                                    }
                                    byteSeq_gt_res_129270 = loop_while_129273;
                                    byteSeq_gt_res_129271 = p_129274;
                                    byteSeq_gt_res_129272 = p_129275;
                                    
                                    bool tmp_129291 = byteSeq_lt_res_129225 || byteSeq_gt_res_129272;
                                    bool cond_129292 = !tmp_129291;
                                    int32_t tmp_129293;
                                    
                                    if (cond_129292) {
                                        tmp_129293 = zt_rhs_129162;
                                    } else {
                                        tmp_129293 = cur_depth_128971;
                                    }
                                    
                                    bool cond_129294 = !byteSeq_lt_res_129225;
                                    bool loop_cond_t_res_129295 = slt32(tmp_129293, cur_depth_128971);
                                    bool x_129296 = cond_129294 && loop_cond_t_res_129295;
                                    bool loop_while_tmp_133946 = x_129296;
                                    int32_t p_tmp_133947 = tmp_129293;
                                    bool p_tmp_133948 = byteSeq_lt_res_129225;
                                    
                                    loop_while_129159 = loop_while_tmp_133946;
                                    p_129160 = p_tmp_133947;
                                    p_129161 = p_tmp_133948;
                                }
                                radix_lt_res_129156 = loop_while_129159;
                                radix_lt_res_129157 = p_129160;
                                radix_lt_res_129158 = p_129161;
                                
                                int64_t loopres_f_res_f_res_129297;
                                int64_t loopres_f_res_f_res_129298;
                                
                                if (radix_lt_res_129158) {
                                    int64_t tmp_133262 = sub64(heshi_128965, step_128966);
                                    int64_t max_arg1_133263 = sdiv64(step_128966, (int64_t) 2);
                                    int64_t max_res_133264 = smax64((int64_t) 1, max_arg1_133263);
                                    
                                    loopres_f_res_f_res_129297 = tmp_133262;
                                    loopres_f_res_f_res_129298 = max_res_133264;
                                } else {
                                    int64_t tmp_129302 = add64(heshi_128965, step_128966);
                                    int64_t max_arg1_129303 = sdiv64(step_128966, (int64_t) 2);
                                    int64_t max_res_129304 = smax64((int64_t) 1, max_arg1_129303);
                                    
                                    loopres_f_res_f_res_129297 = tmp_129302;
                                    loopres_f_res_f_res_129298 = max_res_129304;
                                }
                                loopres_f_res_129150 = loopres_f_res_f_res_129297;
                                loopres_f_res_129151 = loopres_f_res_f_res_129298;
                            }
                            loopres_129139 = loopres_f_res_129150;
                            loopres_129140 = loopres_f_res_129151;
                        }
                        
                        bool loop_cond_129305 = slt64((int64_t) 0, loopres_129140);
                        bool loop_while_tmp_133936 = loop_cond_129305;
                        int64_t heshi_tmp_133937 = loopres_129139;
                        int64_t step_tmp_133938 = loopres_129140;
                        
                        loop_while_128964 = loop_while_tmp_133936;
                        heshi_128965 = heshi_tmp_133937;
                        step_128966 = step_tmp_133938;
                    }
                    rv_partitionMatchBounds_res_f_res_f_res_f_res_128961 = loop_while_128964;
                    rv_partitionMatchBounds_res_f_res_f_res_f_res_128962 = heshi_128965;
                    rv_partitionMatchBounds_res_f_res_f_res_f_res_128963 = step_128966;
                    rv_partitionMatchBounds_res_f_res_f_res_128947 = rv_partitionMatchBounds_res_f_res_f_res_f_res_128962;
                }
                rv_partitionMatchBounds_res_f_res_128257 = rv_partitionMatchBounds_res_f_res_f_res_128289;
                rv_partitionMatchBounds_res_f_res_128258 = rv_partitionMatchBounds_res_f_res_f_res_128947;
            }
            rv_partitionMatchBounds_res_128249 = rv_partitionMatchBounds_res_f_res_128257;
            rv_partitionMatchBounds_res_128250 = rv_partitionMatchBounds_res_f_res_128258;
        }
        
        bool cond_129308 = slt64(rv_partitionMatchBounds_res_128249, (int64_t) 0);
        bool x_129310 = sle64((int64_t) 0, rv_partitionMatchBounds_res_128249);
        bool y_129311 = slt64(rv_partitionMatchBounds_res_128249, dz2081U_117698);
        bool bounds_check_129312 = x_129310 && y_129311;
        bool protect_assert_disj_129313 = cond_129308 || bounds_check_129312;
        bool index_certs_129314;
        
        if (!protect_assert_disj_129313) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) rv_partitionMatchBounds_res_128249, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:437:23-36\n   #1  /prelude/soacs.fut:67:23-24\n   #2  /prelude/soacs.fut:67:27-37\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool cond_129317 = rv_partitionMatchBounds_res_128250 == zeze_rhs_122251;
        int64_t tmp_129319 = add64((int64_t) 1, rv_partitionMatchBounds_res_128250);
        bool x_129320 = sle64((int64_t) 0, tmp_129319);
        bool y_129321 = slt64(tmp_129319, dz2081U_117698);
        bool bounds_check_129322 = x_129320 && y_129321;
        bool protect_assert_disj_129323 = cond_129317 || bounds_check_129322;
        bool protect_assert_disj_129324 = cond_129308 || protect_assert_disj_129323;
        bool index_certs_129325;
        
        if (!protect_assert_disj_129324) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_129319, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:438:50-65\n   #1  /prelude/soacs.fut:67:23-24\n   #2  /prelude/soacs.fut:67:27-37\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool x_129309 = !cond_129308;
        int64_t inf_s_idx_129315;
        
        if (x_129309) {
            int64_t x_133269 = ((int64_t *) bounds_mem_133468.mem)[rv_partitionMatchBounds_res_128249];
            
            inf_s_idx_129315 = x_133269;
        } else {
            inf_s_idx_129315 = (int64_t) 0;
        }
        
        bool x_129318 = !cond_129317;
        bool protect_cond_conj_129326 = x_129309 && x_129318;
        int64_t sup_s_idx_f_res_129327;
        
        if (protect_cond_conj_129326) {
            int64_t x_133270 = ((int64_t *) bounds_mem_133468.mem)[tmp_129319];
            
            sup_s_idx_f_res_129327 = x_133270;
        } else {
            sup_s_idx_f_res_129327 = (int64_t) 0;
        }
        
        int64_t sup_s_idx_129329;
        
        if (cond_129317) {
            sup_s_idx_129329 = nS_117697;
        } else {
            sup_s_idx_129329 = sup_s_idx_f_res_129327;
        }
        
        int64_t j_m_i_129330 = sub64(sup_s_idx_129329, inf_s_idx_129315);
        int64_t lifted_lambda_res_129331;
        
        if (cond_129308) {
            lifted_lambda_res_129331 = (int64_t) 0;
        } else {
            bool empty_slice_129337 = j_m_i_129330 == (int64_t) 0;
            int64_t m_129338 = sub64(j_m_i_129330, (int64_t) 1);
            int64_t i_p_m_t_s_129339 = add64(inf_s_idx_129315, m_129338);
            bool zzero_leq_i_p_m_t_s_129340 = sle64((int64_t) 0, i_p_m_t_s_129339);
            bool i_p_m_t_s_leq_w_129341 = slt64(i_p_m_t_s_129339, nS_117697);
            bool zzero_lte_i_129342 = sle64((int64_t) 0, inf_s_idx_129315);
            bool i_lte_j_129343 = sle64(inf_s_idx_129315, sup_s_idx_129329);
            bool y_129344 = i_p_m_t_s_leq_w_129341 && zzero_lte_i_129342;
            bool y_129345 = zzero_leq_i_p_m_t_s_129340 && y_129344;
            bool forwards_ok_129346 = i_lte_j_129343 && y_129345;
            bool ok_or_empty_129347 = empty_slice_129337 || forwards_ok_129346;
            bool index_certs_129348;
            
            if (!ok_or_empty_129347) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) inf_s_idx_129315, ":", (long long) sup_s_idx_129329, "] out of bounds for array of shape [", (long long) nS_117697, "].", "-> #0  ftHashJoin.fut:439:19-42\n   #1  /prelude/soacs.fut:67:23-24\n   #2  /prelude/soacs.fut:67:27-37\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_cond_129349 = slt64((int64_t) 0, j_m_i_129330);
            bool rv_findPairCount_res_129350;
            int64_t rv_findPairCount_res_129351;
            int64_t rv_findPairCount_res_129352;
            bool loop_while_129353;
            int64_t count_129354;
            int64_t j_129355;
            
            loop_while_129353 = loop_cond_129349;
            count_129354 = (int64_t) 0;
            j_129355 = (int64_t) 0;
            while (loop_while_129353) {
                bool x_129356 = sle64((int64_t) 0, j_129355);
                bool y_129357 = slt64(j_129355, j_m_i_129330);
                bool bounds_check_129358 = x_129356 && y_129357;
                bool index_certs_129359;
                
                if (!bounds_check_129358) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_129355, "] out of bounds for array of shape [", (long long) j_m_i_129330, "].", "-> #0  ftHashJoin.fut:404:35-40\n   #1  ftHashJoin.fut:440:10-35\n   #2  /prelude/soacs.fut:67:23-24\n   #3  /prelude/soacs.fut:67:27-37\n   #4  ftRelational.fut:306:4-309:35\n   #5  ftRelational.fut:302:1-309:54\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t slice_129360 = inf_s_idx_129315 + j_129355;
                bool defunc_0_reduce_res_133273;
                bool redout_133376 = 1;
                
                for (int64_t i_133377 = 0; i_133377 < b_117696; i_133377++) {
                    int8_t eta_p_132371 = ((int8_t *) pR_mem_133466.mem)[i_133393 * b_117696 + i_133377];
                    int8_t eta_p_132372 = ((int8_t *) pS_mem_133467.mem)[slice_129360 * b_117696 + i_133377];
                    bool defunc_0_f_res_132373 = eta_p_132371 == eta_p_132372;
                    bool x_129370 = defunc_0_f_res_132373 && redout_133376;
                    bool redout_tmp_133960 = x_129370;
                    
                    redout_133376 = redout_tmp_133960;
                }
                defunc_0_reduce_res_133273 = redout_133376;
                
                int64_t loopres_129371;
                int64_t loopres_129372;
                
                if (defunc_0_reduce_res_133273) {
                    int64_t tmp_133271 = add64((int64_t) 1, count_129354);
                    int64_t tmp_133272 = add64((int64_t) 1, j_129355);
                    
                    loopres_129371 = tmp_133271;
                    loopres_129372 = tmp_133272;
                } else {
                    int64_t tmp_129375 = add64((int64_t) 1, j_129355);
                    
                    loopres_129371 = count_129354;
                    loopres_129372 = tmp_129375;
                }
                
                bool loop_cond_129376 = slt64(loopres_129372, j_m_i_129330);
                bool loop_while_tmp_133957 = loop_cond_129376;
                int64_t count_tmp_133958 = loopres_129371;
                int64_t j_tmp_133959 = loopres_129372;
                
                loop_while_129353 = loop_while_tmp_133957;
                count_129354 = count_tmp_133958;
                j_129355 = j_tmp_133959;
            }
            rv_findPairCount_res_129350 = loop_while_129353;
            rv_findPairCount_res_129351 = count_129354;
            rv_findPairCount_res_129352 = j_129355;
            lifted_lambda_res_129331 = rv_findPairCount_res_129351;
        }
        
        bool lifted_lambda_res_129378 = slt64((int64_t) 1, lifted_lambda_res_129331);
        int64_t defunc_0_f_res_129379 = btoi_bool_i64(lifted_lambda_res_129378);
        int64_t defunc_0_op_res_122354 = add64(defunc_0_f_res_129379, scanacc_133384);
        int64_t defunc_0_op_res_122329 = add64(lifted_lambda_res_129331, scanacc_133385);
        int64_t zp_res_126550 = add64(lifted_lambda_res_129331, redout_133388);
        
        ((int64_t *) mem_133481)[i_133393] = defunc_0_op_res_122354;
        ((int64_t *) mem_133483)[i_133393] = defunc_0_op_res_122329;
        ((int64_t *) mem_133485)[i_133393] = defunc_0_f_res_129379;
        ((int64_t *) mem_133487)[i_133393] = lifted_lambda_res_129331;
        ((int64_t *) mem_133489)[i_133393] = rv_partitionMatchBounds_res_128249;
        ((int64_t *) mem_133491)[i_133393] = rv_partitionMatchBounds_res_128250;
        
        int64_t scanacc_tmp_133882 = defunc_0_op_res_122354;
        int64_t scanacc_tmp_133883 = defunc_0_op_res_122329;
        int64_t redout_tmp_133886 = zp_res_126550;
        
        scanacc_133384 = scanacc_tmp_133882;
        scanacc_133385 = scanacc_tmp_133883;
        redout_133388 = redout_tmp_133886;
    }
    discard_133400 = scanacc_133384;
    discard_133401 = scanacc_133385;
    defunc_res_133287 = redout_133388;
    
    bool cond_122355 = nR_117695 == (int64_t) 0;
    bool x_122356 = !cond_122355;
    int64_t tmp_122357 = sub64(nR_117695, (int64_t) 1);
    bool x_122358 = sle64((int64_t) 0, tmp_122357);
    bool y_122359 = slt64(tmp_122357, nR_117695);
    bool bounds_check_122360 = x_122358 && y_122359;
    bool protect_assert_disj_122361 = cond_122355 || bounds_check_122360;
    bool index_certs_122362;
    
    if (!protect_assert_disj_122361) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_122357, "] out of bounds for array of shape [", (long long) nR_117695, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:306:4-309:35\n   #3  ftRelational.fut:302:1-309:54\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t m_f_res_122363;
    
    if (x_122356) {
        int64_t x_133277 = ((int64_t *) mem_133481)[tmp_122357];
        
        m_f_res_122363 = x_133277;
    } else {
        m_f_res_122363 = (int64_t) 0;
    }
    
    int64_t m_122365;
    
    if (cond_122355) {
        m_122365 = (int64_t) 0;
    } else {
        m_122365 = m_f_res_122363;
    }
    
    int64_t bytes_133672 = (int64_t) 8 * defunc_res_133287;
    int64_t m_122375 = sub64(m_122365, (int64_t) 1);
    bool i_p_m_t_s_leq_w_122377 = slt64(m_122375, nR_117695);
    bool zzero_leq_i_p_m_t_s_122376 = sle64((int64_t) 0, m_122375);
    bool y_122379 = zzero_leq_i_p_m_t_s_122376 && i_p_m_t_s_leq_w_122377;
    bool i_lte_j_122378 = sle64((int64_t) 0, m_122365);
    bool forwards_ok_122380 = i_lte_j_122378 && y_122379;
    bool eq_x_zz_122372 = (int64_t) 0 == m_f_res_122363;
    bool p_and_eq_x_y_122373 = x_122356 && eq_x_zz_122372;
    bool empty_slice_122374 = cond_122355 || p_and_eq_x_y_122373;
    bool ok_or_empty_122381 = empty_slice_122374 || forwards_ok_122380;
    bool index_certs_122382;
    
    if (!ok_or_empty_122381) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_122365, "] out of bounds for array of shape [", (long long) nR_117695, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:306:4-309:35\n   #3  ftRelational.fut:302:1-309:54\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133674 = (int64_t) 8 * m_122365;
    int64_t bytes_133714 = b_117696 * defunc_res_133287;
    
    if (mem_133665_cached_sizze_134014 < bytes_133480) {
        err = lexical_realloc(ctx, &mem_133665, &mem_133665_cached_sizze_134014, bytes_133480);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133404 = 0; i_133404 < nR_117695; i_133404++) {
        int64_t eta_p_127956 = ((int64_t *) mem_133487)[i_133404];
        int64_t zv_lhs_127958 = add64((int64_t) -1, i_133404);
        int64_t tmp_127959 = smod64(zv_lhs_127958, nR_117695);
        int64_t lifted_lambda_res_127960 = ((int64_t *) mem_133483)[tmp_127959];
        bool cond_127962 = i_133404 == (int64_t) 0;
        int64_t lifted_lambda_res_127963;
        
        if (cond_127962) {
            lifted_lambda_res_127963 = (int64_t) 0;
        } else {
            lifted_lambda_res_127963 = lifted_lambda_res_127960;
        }
        
        bool cond_127965 = slt64((int64_t) 0, eta_p_127956);
        int64_t lifted_lambda_res_127966;
        
        if (cond_127965) {
            lifted_lambda_res_127966 = lifted_lambda_res_127963;
        } else {
            lifted_lambda_res_127966 = (int64_t) -1;
        }
        ((int64_t *) mem_133665)[i_133404] = lifted_lambda_res_127966;
    }
    if (memblock_alloc(ctx, &mem_133673, bytes_133672, "mem_133673")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133962 = 0; nest_i_133962 < defunc_res_133287; nest_i_133962++) {
        ((int64_t *) mem_133673.mem)[nest_i_133962] = (int64_t) 0;
    }
    if (mem_133675_cached_sizze_134015 < bytes_133674) {
        err = lexical_realloc(ctx, &mem_133675, &mem_133675_cached_sizze_134015, bytes_133674);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133675, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_122365});
    if (mem_133677_cached_sizze_134016 < bytes_133674) {
        err = lexical_realloc(ctx, &mem_133677, &mem_133677_cached_sizze_134016, bytes_133674);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133677, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133665, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_122365});
    for (int64_t write_iter_133406 = 0; write_iter_133406 < nR_117695; write_iter_133406++) {
        int64_t write_iv_133410 = ((int64_t *) mem_133665)[write_iter_133406];
        int64_t write_iv_133412 = ((int64_t *) mem_133485)[write_iter_133406];
        int64_t write_iv_133413 = ((int64_t *) mem_133481)[write_iter_133406];
        int64_t write_iv_133415 = ((int64_t *) mem_133487)[write_iter_133406];
        bool cond_129393 = write_iv_133412 == (int64_t) 1;
        int64_t lifted_lambda_res_129394;
        
        if (cond_129393) {
            int64_t lifted_lambda_res_t_res_133278 = sub64(write_iv_133413, (int64_t) 1);
            
            lifted_lambda_res_129394 = lifted_lambda_res_t_res_133278;
        } else {
            lifted_lambda_res_129394 = (int64_t) -1;
        }
        if (sle64((int64_t) 0, write_iv_133410) && slt64(write_iv_133410, defunc_res_133287)) {
            ((int64_t *) mem_133673.mem)[write_iv_133410] = write_iter_133406;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_129394) && slt64(lifted_lambda_res_129394, m_122365)) {
            ((int64_t *) mem_133677)[lifted_lambda_res_129394] = write_iv_133410;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_129394) && slt64(lifted_lambda_res_129394, m_122365)) {
            ((int64_t *) mem_133675)[lifted_lambda_res_129394] = write_iv_133415;
        }
    }
    if (mem_133697_cached_sizze_134017 < bytes_133672) {
        err = lexical_realloc(ctx, &mem_133697, &mem_133697_cached_sizze_134017, bytes_133672);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t nest_i_133966 = 0; nest_i_133966 < defunc_res_133287; nest_i_133966++) {
        ((int64_t *) mem_133697)[nest_i_133966] = (int64_t) 1;
    }
    for (int64_t i_122399 = 0; i_122399 < m_122365; i_122399++) {
        int64_t loopres_122402 = ((int64_t *) mem_133677)[i_122399];
        int64_t loopres_122403 = ((int64_t *) mem_133675)[i_122399];
        bool x_122404 = sle64((int64_t) 0, loopres_122402);
        bool y_122405 = slt64(loopres_122402, defunc_res_133287);
        bool bounds_check_122406 = x_122404 && y_122405;
        bool index_certs_122407;
        
        if (!bounds_check_122406) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_122402, "] out of bounds for array of shape [", (long long) defunc_res_133287, "].", "-> #0  ftHashJoin.fut:458:37-47\n   #1  ftRelational.fut:306:4-309:35\n   #2  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool bounds_invalid_upwards_122409 = slt64(loopres_122403, (int64_t) 1);
        bool valid_122410 = !bounds_invalid_upwards_122409;
        bool range_valid_c_122411;
        
        if (!valid_122410) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 1, "...", (long long) loopres_122403, " is invalid.", "-> #0  ftHashJoin.fut:459:18-24\n   #1  ftRelational.fut:306:4-309:35\n   #2  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t tmp_122414 = add64(loopres_122402, loopres_122403);
        bool empty_slice_122415 = loopres_122403 == (int64_t) 0;
        int64_t m_122416 = sub64(loopres_122403, (int64_t) 1);
        int64_t i_p_m_t_s_122417 = add64(loopres_122402, m_122416);
        bool zzero_leq_i_p_m_t_s_122418 = sle64((int64_t) 0, i_p_m_t_s_122417);
        bool i_p_m_t_s_leq_w_122419 = slt64(i_p_m_t_s_122417, defunc_res_133287);
        bool i_lte_j_122420 = sle64(loopres_122402, tmp_122414);
        bool y_122421 = x_122404 && i_p_m_t_s_leq_w_122419;
        bool y_122422 = zzero_leq_i_p_m_t_s_122418 && y_122421;
        bool forwards_ok_122423 = i_lte_j_122420 && y_122422;
        bool ok_or_empty_122424 = empty_slice_122415 || forwards_ok_122423;
        bool index_certs_122425;
        
        if (!ok_or_empty_122424) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_122402, ":", (long long) tmp_122414, "] out of bounds for array of shape [", (long long) defunc_res_133287, "].", "-> #0  ftHashJoin.fut:460:10-43\n   #1  ftRelational.fut:306:4-309:35\n   #2  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t loopres_122408 = ((int64_t *) mem_133673.mem)[loopres_122402];
        
        for (int64_t i_133969 = 0; i_133969 < loopres_122403; i_133969++) {
            int64_t x_133970 = (int64_t) 1 + i_133969 * (int64_t) 1;
            
            ((int64_t *) mem_133697)[loopres_122402 + i_133969] = x_133970;
        }
        for (int64_t nest_i_133971 = 0; nest_i_133971 < loopres_122403; nest_i_133971++) {
            ((int64_t *) mem_133673.mem)[loopres_122402 + nest_i_133971] = loopres_122408;
        }
    }
    if (memblock_alloc(ctx, &mem_133715, bytes_133714, "mem_133715")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133717, bytes_133672, "mem_133717")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133425 = 0; i_133425 < defunc_res_133287; i_133425++) {
        int64_t eta_p_129399 = ((int64_t *) mem_133673.mem)[i_133425];
        bool x_129401 = sle64((int64_t) 0, eta_p_129399);
        bool y_129402 = slt64(eta_p_129399, nR_117695);
        bool bounds_check_129403 = x_129401 && y_129402;
        bool index_certs_129404;
        
        if (!bounds_check_129403) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_129399, "] out of bounds for array of shape [", (long long) nR_117695, "].", "-> #0  ftHashJoin.fut:463:16-22\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:306:4-309:35\n   #3  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t lifted_lambda_res_129406 = ((int64_t *) mem_133489)[eta_p_129399];
        int64_t lifted_lambda_res_129407 = ((int64_t *) mem_133491)[eta_p_129399];
        bool x_129408 = sle64((int64_t) 0, lifted_lambda_res_129406);
        bool y_129409 = slt64(lifted_lambda_res_129406, dz2081U_117698);
        bool bounds_check_129410 = x_129408 && y_129409;
        bool index_certs_129411;
        
        if (!bounds_check_129410) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lifted_lambda_res_129406, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:465:23-36\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:306:4-309:35\n   #3  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t inf_s_idx_129412 = ((int64_t *) bounds_mem_133468.mem)[lifted_lambda_res_129406];
        bool cond_129413 = lifted_lambda_res_129407 == zeze_rhs_122251;
        bool x_129414 = !cond_129413;
        int64_t tmp_129415 = add64((int64_t) 1, lifted_lambda_res_129407);
        bool x_129416 = sle64((int64_t) 0, tmp_129415);
        bool y_129417 = slt64(tmp_129415, dz2081U_117698);
        bool bounds_check_129418 = x_129416 && y_129417;
        bool protect_assert_disj_129419 = cond_129413 || bounds_check_129418;
        bool index_certs_129420;
        
        if (!protect_assert_disj_129419) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_129415, "] out of bounds for array of shape [", (long long) dz2081U_117698, "].", "-> #0  ftHashJoin.fut:466:50-65\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:306:4-309:35\n   #3  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t sup_s_idx_f_res_129421;
        
        if (x_129414) {
            int64_t x_133279 = ((int64_t *) bounds_mem_133468.mem)[tmp_129415];
            
            sup_s_idx_f_res_129421 = x_133279;
        } else {
            sup_s_idx_f_res_129421 = (int64_t) 0;
        }
        
        int64_t sup_s_idx_129423;
        
        if (cond_129413) {
            sup_s_idx_129423 = nS_117697;
        } else {
            sup_s_idx_129423 = sup_s_idx_f_res_129421;
        }
        
        int64_t j_m_i_129424 = sub64(sup_s_idx_129423, inf_s_idx_129412);
        bool empty_slice_129425 = j_m_i_129424 == (int64_t) 0;
        int64_t m_129426 = sub64(j_m_i_129424, (int64_t) 1);
        int64_t i_p_m_t_s_129427 = add64(inf_s_idx_129412, m_129426);
        bool zzero_leq_i_p_m_t_s_129428 = sle64((int64_t) 0, i_p_m_t_s_129427);
        bool i_p_m_t_s_leq_w_129429 = slt64(i_p_m_t_s_129427, nS_117697);
        bool zzero_lte_i_129430 = sle64((int64_t) 0, inf_s_idx_129412);
        bool i_lte_j_129431 = sle64(inf_s_idx_129412, sup_s_idx_129423);
        bool y_129432 = i_p_m_t_s_leq_w_129429 && zzero_lte_i_129430;
        bool y_129433 = zzero_leq_i_p_m_t_s_129428 && y_129432;
        bool forwards_ok_129434 = i_lte_j_129431 && y_129433;
        bool ok_or_empty_129435 = empty_slice_129425 || forwards_ok_129434;
        bool index_certs_129436;
        
        if (!ok_or_empty_129435) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) inf_s_idx_129412, ":", (long long) sup_s_idx_129423, "] out of bounds for array of shape [", (long long) nS_117697, "].", "-> #0  ftHashJoin.fut:467:19-42\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:306:4-309:35\n   #3  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool index_certs_129475;
        
        if (!bounds_check_129403) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_129399, "] out of bounds for array of shape [", (long long) nR_117695, "].", "-> #0  ftHashJoin.fut:472:39-45\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:472:22-46\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t eta_p_129398 = ((int64_t *) mem_133697)[i_133425];
        bool cond_129437 = slt64((int64_t) 0, eta_p_129398);
        bool loop_cond_t_res_129438 = slt64((int64_t) 0, j_m_i_129424);
        bool x_129439 = cond_129437 && loop_cond_t_res_129438;
        bool find_kth_match_res_129440;
        int64_t find_kth_match_res_129441;
        int64_t find_kth_match_res_129442;
        bool loop_while_129443;
        int64_t count_129444;
        int64_t j_129445;
        
        loop_while_129443 = x_129439;
        count_129444 = (int64_t) 0;
        j_129445 = (int64_t) 0;
        while (loop_while_129443) {
            bool x_129446 = sle64((int64_t) 0, j_129445);
            bool y_129447 = slt64(j_129445, j_m_i_129424);
            bool bounds_check_129448 = x_129446 && y_129447;
            bool index_certs_129449;
            
            if (!bounds_check_129448) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_129445, "] out of bounds for array of shape [", (long long) j_m_i_129424, "].", "-> #0  ftHashJoin.fut:416:33-38\n   #1  ftHashJoin.fut:468:11-36\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftRelational.fut:306:4-309:35\n   #4  ftRelational.fut:302:1-309:54\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t slice_129450 = inf_s_idx_129412 + j_129445;
            bool defunc_0_reduce_res_133282;
            bool redout_133419 = 1;
            
            for (int64_t i_133420 = 0; i_133420 < b_117696; i_133420++) {
                int8_t eta_p_132894 = ((int8_t *) pR_mem_133466.mem)[eta_p_129399 * b_117696 + i_133420];
                int8_t eta_p_132895 = ((int8_t *) pS_mem_133467.mem)[slice_129450 * b_117696 + i_133420];
                bool defunc_0_f_res_132896 = eta_p_132894 == eta_p_132895;
                bool x_129460 = defunc_0_f_res_132896 && redout_133419;
                bool redout_tmp_133977 = x_129460;
                
                redout_133419 = redout_tmp_133977;
            }
            defunc_0_reduce_res_133282 = redout_133419;
            
            int64_t loopres_129461;
            int64_t loopres_129462;
            
            if (defunc_0_reduce_res_133282) {
                int64_t tmp_133280 = add64((int64_t) 1, count_129444);
                int64_t tmp_133281 = add64((int64_t) 1, j_129445);
                
                loopres_129461 = tmp_133280;
                loopres_129462 = tmp_133281;
            } else {
                int64_t tmp_129465 = add64((int64_t) 1, j_129445);
                
                loopres_129461 = count_129444;
                loopres_129462 = tmp_129465;
            }
            
            bool cond_129466 = slt64(loopres_129461, eta_p_129398);
            bool loop_cond_t_res_129467 = slt64(loopres_129462, j_m_i_129424);
            bool x_129468 = cond_129466 && loop_cond_t_res_129467;
            bool loop_while_tmp_133974 = x_129468;
            int64_t count_tmp_133975 = loopres_129461;
            int64_t j_tmp_133976 = loopres_129462;
            
            loop_while_129443 = loop_while_tmp_133974;
            count_129444 = count_tmp_133975;
            j_129445 = j_tmp_133976;
        }
        find_kth_match_res_129440 = loop_while_129443;
        find_kth_match_res_129441 = count_129444;
        find_kth_match_res_129442 = j_129445;
        
        int64_t find_kth_match_res_129469 = sub64(find_kth_match_res_129442, (int64_t) 1);
        int64_t lifted_lambda_res_129470 = add64(inf_s_idx_129412, find_kth_match_res_129469);
        
        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133715.mem, i_133425 * b_117696, (int64_t []) {(int64_t) 1}, (uint8_t *) pR_mem_133466.mem, eta_p_129399 * b_117696, (int64_t []) {(int64_t) 1}, (int64_t []) {b_117696});
        ((int64_t *) mem_133717.mem)[i_133425] = lifted_lambda_res_129470;
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133673, "mem_133673") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133717, "mem_133717") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133879, &mem_133715, "mem_133715") != 0)
        return 1;
    prim_out_133880 = defunc_res_133287;
    if (memblock_set(ctx, &*mem_out_p_133978, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_133979, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_133980, &mem_out_133879, "mem_out_133879") != 0)
        return 1;
    *out_prim_out_133981 = prim_out_133880;
    
  cleanup:
    {
        free(mem_133473);
        free(mem_133481);
        free(mem_133483);
        free(mem_133485);
        free(mem_133487);
        free(mem_133489);
        free(mem_133491);
        free(mem_133510);
        free(mem_133520);
        free(mem_133521);
        free(mem_133534);
        free(mem_133535);
        free(mem_133548);
        free(mem_133549);
        free(mem_133562);
        free(mem_133563);
        free(mem_133567);
        free(mem_133568);
        free(mem_133581);
        free(mem_133582);
        free(mem_133583);
        free(mem_133584);
        free(mem_133597);
        free(mem_133598);
        free(mem_133599);
        free(mem_133600);
        free(mem_133616);
        free(mem_133617);
        free(mem_133630);
        free(mem_133631);
        free(mem_133644);
        free(mem_133645);
        free(mem_133665);
        free(mem_133675);
        free(mem_133677);
        free(mem_133697);
        if (memblock_unref(ctx, &mem_133717, "mem_133717") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133715, "mem_133715") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133673, "mem_133673") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133879, "mem_out_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_argmin_double(struct futhark_context *ctx, int64_t *out_prim_out_134018, struct memblock ks_mem_133466, int64_t n_61823)
{
    (void) ctx;
    
    int err = 0;
    int64_t prim_out_133877;
    int64_t defunc_0_reduce_comm_res_127931;
    double defunc_0_reduce_comm_res_127932;
    int64_t redout_133298;
    double redout_133299;
    
    redout_133298 = n_61823;
    redout_133299 = INFINITY;
    for (int64_t i_133300 = 0; i_133300 < n_61823; i_133300++) {
        double x_118776 = ((double *) ks_mem_133466.mem)[i_133300];
        bool defunc_0_lt_res_118781 = redout_133299 < x_118776;
        bool defunc_0_eq_res_118783 = redout_133299 == x_118776;
        bool cond_f_res_t_res_118784 = slt64(redout_133298, i_133300);
        bool x_118785 = defunc_0_eq_res_118783 && cond_f_res_t_res_118784;
        bool x_126068 = !defunc_0_lt_res_118781;
        bool y_126069 = x_118785 && x_126068;
        bool cond_118782 = defunc_0_lt_res_118781 || y_126069;
        int64_t defunc_0_op_res_118786;
        
        if (cond_118782) {
            defunc_0_op_res_118786 = redout_133298;
        } else {
            defunc_0_op_res_118786 = i_133300;
        }
        
        double defunc_0_op_res_118787;
        
        if (cond_118782) {
            defunc_0_op_res_118787 = redout_133299;
        } else {
            defunc_0_op_res_118787 = x_118776;
        }
        
        int64_t redout_tmp_133878 = defunc_0_op_res_118786;
        double redout_tmp_133879 = defunc_0_op_res_118787;
        
        redout_133298 = redout_tmp_133878;
        redout_133299 = redout_tmp_133879;
    }
    defunc_0_reduce_comm_res_127931 = redout_133298;
    defunc_0_reduce_comm_res_127932 = redout_133299;
    prim_out_133877 = defunc_0_reduce_comm_res_127931;
    *out_prim_out_134018 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_argmin_float(struct futhark_context *ctx, int64_t *out_prim_out_134019, struct memblock ks_mem_133466, int64_t n_61646)
{
    (void) ctx;
    
    int err = 0;
    int64_t prim_out_133877;
    int64_t defunc_0_reduce_comm_res_127931;
    float defunc_0_reduce_comm_res_127932;
    int64_t redout_133298;
    float redout_133299;
    
    redout_133298 = n_61646;
    redout_133299 = INFINITY;
    for (int64_t i_133300 = 0; i_133300 < n_61646; i_133300++) {
        float x_118776 = ((float *) ks_mem_133466.mem)[i_133300];
        bool defunc_0_lt_res_118781 = redout_133299 < x_118776;
        bool defunc_0_eq_res_118783 = redout_133299 == x_118776;
        bool cond_f_res_t_res_118784 = slt64(redout_133298, i_133300);
        bool x_118785 = defunc_0_eq_res_118783 && cond_f_res_t_res_118784;
        bool x_126068 = !defunc_0_lt_res_118781;
        bool y_126069 = x_118785 && x_126068;
        bool cond_118782 = defunc_0_lt_res_118781 || y_126069;
        int64_t defunc_0_op_res_118786;
        
        if (cond_118782) {
            defunc_0_op_res_118786 = redout_133298;
        } else {
            defunc_0_op_res_118786 = i_133300;
        }
        
        float defunc_0_op_res_118787;
        
        if (cond_118782) {
            defunc_0_op_res_118787 = redout_133299;
        } else {
            defunc_0_op_res_118787 = x_118776;
        }
        
        int64_t redout_tmp_133878 = defunc_0_op_res_118786;
        float redout_tmp_133879 = defunc_0_op_res_118787;
        
        redout_133298 = redout_tmp_133878;
        redout_133299 = redout_tmp_133879;
    }
    defunc_0_reduce_comm_res_127931 = redout_133298;
    defunc_0_reduce_comm_res_127932 = redout_133299;
    prim_out_133877 = defunc_0_reduce_comm_res_127931;
    *out_prim_out_134019 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_argmin_int(struct futhark_context *ctx, int64_t *out_prim_out_134020, struct memblock ks_mem_133466, int64_t n_61295)
{
    (void) ctx;
    
    int err = 0;
    int64_t prim_out_133877;
    int64_t defunc_0_reduce_comm_res_127931;
    int32_t defunc_0_reduce_comm_res_127932;
    int64_t redout_133298;
    int32_t redout_133299;
    
    redout_133298 = n_61295;
    redout_133299 = 2147483647;
    for (int64_t i_133300 = 0; i_133300 < n_61295; i_133300++) {
        int32_t x_118776 = ((int32_t *) ks_mem_133466.mem)[i_133300];
        bool defunc_0_lt_res_118781 = slt32(redout_133299, x_118776);
        bool defunc_0_eq_res_118783 = redout_133299 == x_118776;
        bool cond_f_res_t_res_118784 = slt64(redout_133298, i_133300);
        bool x_118785 = defunc_0_eq_res_118783 && cond_f_res_t_res_118784;
        bool x_126068 = !defunc_0_lt_res_118781;
        bool y_126069 = x_118785 && x_126068;
        bool cond_118782 = defunc_0_lt_res_118781 || y_126069;
        int64_t defunc_0_op_res_118786;
        
        if (cond_118782) {
            defunc_0_op_res_118786 = redout_133298;
        } else {
            defunc_0_op_res_118786 = i_133300;
        }
        
        int32_t defunc_0_op_res_118787;
        
        if (cond_118782) {
            defunc_0_op_res_118787 = redout_133299;
        } else {
            defunc_0_op_res_118787 = x_118776;
        }
        
        int64_t redout_tmp_133878 = defunc_0_op_res_118786;
        int32_t redout_tmp_133879 = defunc_0_op_res_118787;
        
        redout_133298 = redout_tmp_133878;
        redout_133299 = redout_tmp_133879;
    }
    defunc_0_reduce_comm_res_127931 = redout_133298;
    defunc_0_reduce_comm_res_127932 = redout_133299;
    prim_out_133877 = defunc_0_reduce_comm_res_127931;
    *out_prim_out_134020 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_argmin_long(struct futhark_context *ctx, int64_t *out_prim_out_134021, struct memblock ks_mem_133466, int64_t n_61469)
{
    (void) ctx;
    
    int err = 0;
    int64_t prim_out_133877;
    int64_t defunc_0_reduce_comm_res_127931;
    int64_t defunc_0_reduce_comm_res_127932;
    int64_t redout_133298;
    int64_t redout_133299;
    
    redout_133298 = n_61469;
    redout_133299 = (int64_t) 9223372036854775807;
    for (int64_t i_133300 = 0; i_133300 < n_61469; i_133300++) {
        int64_t x_118776 = ((int64_t *) ks_mem_133466.mem)[i_133300];
        bool defunc_0_lt_res_118781 = slt64(redout_133299, x_118776);
        bool defunc_0_eq_res_118783 = redout_133299 == x_118776;
        bool cond_f_res_t_res_118784 = slt64(redout_133298, i_133300);
        bool x_118785 = defunc_0_eq_res_118783 && cond_f_res_t_res_118784;
        bool x_126068 = !defunc_0_lt_res_118781;
        bool y_126069 = x_118785 && x_126068;
        bool cond_118782 = defunc_0_lt_res_118781 || y_126069;
        int64_t defunc_0_op_res_118786;
        
        if (cond_118782) {
            defunc_0_op_res_118786 = redout_133298;
        } else {
            defunc_0_op_res_118786 = i_133300;
        }
        
        int64_t defunc_0_op_res_118787;
        
        if (cond_118782) {
            defunc_0_op_res_118787 = redout_133299;
        } else {
            defunc_0_op_res_118787 = x_118776;
        }
        
        int64_t redout_tmp_133878 = defunc_0_op_res_118786;
        int64_t redout_tmp_133879 = defunc_0_op_res_118787;
        
        redout_133298 = redout_tmp_133878;
        redout_133299 = redout_tmp_133879;
    }
    defunc_0_reduce_comm_res_127931 = redout_133298;
    defunc_0_reduce_comm_res_127932 = redout_133299;
    prim_out_133877 = defunc_0_reduce_comm_res_127931;
    *out_prim_out_134021 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_argmin_short(struct futhark_context *ctx, int64_t *out_prim_out_134022, struct memblock ks_mem_133466, int64_t n_61121)
{
    (void) ctx;
    
    int err = 0;
    int64_t prim_out_133877;
    int64_t defunc_0_reduce_comm_res_127931;
    int16_t defunc_0_reduce_comm_res_127932;
    int64_t redout_133298;
    int16_t redout_133299;
    
    redout_133298 = n_61121;
    redout_133299 = (int16_t) 32767;
    for (int64_t i_133300 = 0; i_133300 < n_61121; i_133300++) {
        int16_t x_118776 = ((int16_t *) ks_mem_133466.mem)[i_133300];
        bool defunc_0_lt_res_118781 = slt16(redout_133299, x_118776);
        bool defunc_0_eq_res_118783 = redout_133299 == x_118776;
        bool cond_f_res_t_res_118784 = slt64(redout_133298, i_133300);
        bool x_118785 = defunc_0_eq_res_118783 && cond_f_res_t_res_118784;
        bool x_126068 = !defunc_0_lt_res_118781;
        bool y_126069 = x_118785 && x_126068;
        bool cond_118782 = defunc_0_lt_res_118781 || y_126069;
        int64_t defunc_0_op_res_118786;
        
        if (cond_118782) {
            defunc_0_op_res_118786 = redout_133298;
        } else {
            defunc_0_op_res_118786 = i_133300;
        }
        
        int16_t defunc_0_op_res_118787;
        
        if (cond_118782) {
            defunc_0_op_res_118787 = redout_133299;
        } else {
            defunc_0_op_res_118787 = x_118776;
        }
        
        int64_t redout_tmp_133878 = defunc_0_op_res_118786;
        int16_t redout_tmp_133879 = defunc_0_op_res_118787;
        
        redout_133298 = redout_tmp_133878;
        redout_133299 = redout_tmp_133879;
    }
    defunc_0_reduce_comm_res_127931 = redout_133298;
    defunc_0_reduce_comm_res_127932 = redout_133299;
    prim_out_133877 = defunc_0_reduce_comm_res_127931;
    *out_prim_out_134022 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_calc_partitions_from_partitioned_set(struct futhark_context *ctx, struct memblock *mem_out_p_134023, struct memblock *mem_out_p_134024, int64_t *out_prim_out_134025, int32_t *out_prim_out_134026, struct memblock pXs_mem_133466, int64_t n_114179, int64_t b_114180, int32_t radix_sizze_114181, int64_t offset_114183, int64_t sizze_thresh_114184, int32_t max_depth_114185)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133476_cached_sizze_134027 = 0;
    unsigned char *mem_133476 = NULL;
    int64_t mem_133478_cached_sizze_134028 = 0;
    unsigned char *mem_133478 = NULL;
    int64_t mem_133480_cached_sizze_134029 = 0;
    unsigned char *mem_133480 = NULL;
    int64_t mem_133482_cached_sizze_134030 = 0;
    unsigned char *mem_133482 = NULL;
    int64_t mem_133508_cached_sizze_134031 = 0;
    unsigned char *mem_133508 = NULL;
    int64_t mem_133510_cached_sizze_134032 = 0;
    unsigned char *mem_133510 = NULL;
    int64_t mem_133512_cached_sizze_134033 = 0;
    unsigned char *mem_133512 = NULL;
    struct memblock mem_133567;
    
    mem_133567.references = NULL;
    
    struct memblock mem_param_tmp_133882;
    
    mem_param_tmp_133882.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133900;
    
    mem_param_tmp_133900.references = NULL;
    
    struct memblock mem_param_tmp_133899;
    
    mem_param_tmp_133899.references = NULL;
    
    struct memblock mem_133553;
    
    mem_133553.references = NULL;
    
    struct memblock mem_133551;
    
    mem_133551.references = NULL;
    
    struct memblock ext_mem_133540;
    
    ext_mem_133540.references = NULL;
    
    struct memblock ext_mem_133541;
    
    ext_mem_133541.references = NULL;
    
    struct memblock mem_133538;
    
    mem_133538.references = NULL;
    
    struct memblock mem_param_133536;
    
    mem_param_133536.references = NULL;
    
    struct memblock mem_param_133533;
    
    mem_param_133533.references = NULL;
    
    struct memblock ext_mem_133558;
    
    ext_mem_133558.references = NULL;
    
    struct memblock ext_mem_133559;
    
    ext_mem_133559.references = NULL;
    
    struct memblock mem_param_133474;
    
    mem_param_133474.references = NULL;
    
    struct memblock mem_param_133471;
    
    mem_param_133471.references = NULL;
    
    struct memblock ext_mem_133564;
    
    ext_mem_133564.references = NULL;
    
    struct memblock ext_mem_133565;
    
    ext_mem_133565.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock ext_mem_133468;
    
    ext_mem_133468.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t prim_out_133879;
    int32_t prim_out_133880;
    int32_t getPartitionBounds_arg3_119311 = sub32(radix_sizze_114181, 1);
    int64_t calc_partitions_from_partitioned_set_res_119312;
    int64_t calc_partitions_from_partitioned_set_res_119313;
    int32_t calc_partitions_from_partitioned_set_res_119316;
    
    if (futrts_getPartitionBounds_12125(ctx, &ext_mem_133468, &ext_mem_133467, &calc_partitions_from_partitioned_set_res_119312, &calc_partitions_from_partitioned_set_res_119313, &calc_partitions_from_partitioned_set_res_119316, pXs_mem_133466, n_114179, b_114180, 1, 0, getPartitionBounds_arg3_119311) != 0) {
        err = 1;
        goto cleanup;
    }
    
    bool cond_119317 = slt32(calc_partitions_from_partitioned_set_res_119316, max_depth_114185);
    int64_t calc_partitions_from_partitioned_set_res_119318;
    int64_t calc_partitions_from_partitioned_set_res_119319;
    bool calc_partitions_from_partitioned_set_res_119320;
    int32_t calc_partitions_from_partitioned_set_res_119323;
    int64_t loop_dz2088U_119324;
    int64_t loop_dz2089U_119325;
    bool loop_while_119326;
    int32_t p_119329;
    
    if (memblock_set(ctx, &mem_param_133471, &ext_mem_133468, "ext_mem_133468") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133474, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    loop_dz2088U_119324 = calc_partitions_from_partitioned_set_res_119312;
    loop_dz2089U_119325 = calc_partitions_from_partitioned_set_res_119313;
    loop_while_119326 = cond_119317;
    p_119329 = calc_partitions_from_partitioned_set_res_119316;
    while (loop_while_119326) {
        int64_t zl_rhs_119332 = sub64(loop_dz2088U_119324, (int64_t) 1);
        int64_t bytes_133475 = (int64_t) 8 * loop_dz2088U_119324;
        
        if (mem_133476_cached_sizze_134027 < bytes_133475) {
            err = lexical_realloc(ctx, &mem_133476, &mem_133476_cached_sizze_134027, bytes_133475);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133478_cached_sizze_134028 < bytes_133475) {
            err = lexical_realloc(ctx, &mem_133478, &mem_133478_cached_sizze_134028, bytes_133475);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133480_cached_sizze_134029 < bytes_133475) {
            err = lexical_realloc(ctx, &mem_133480, &mem_133480_cached_sizze_134029, bytes_133475);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133482_cached_sizze_134030 < bytes_133475) {
            err = lexical_realloc(ctx, &mem_133482, &mem_133482_cached_sizze_134030, bytes_133475);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        
        int64_t discard_133312;
        int64_t scanacc_133302 = (int64_t) 0;
        
        for (int64_t i_133307 = 0; i_133307 < loop_dz2088U_119324; i_133307++) {
            int64_t tmp_127955 = ((int64_t *) mem_param_133471.mem)[i_133307];
            bool cond_127956 = slt64(i_133307, zl_rhs_119332);
            int64_t tmp_127957;
            
            if (cond_127956) {
                int64_t tmp_127995 = add64((int64_t) 1, i_133307);
                bool x_127996 = sle64((int64_t) 0, tmp_127995);
                bool y_127997 = slt64(tmp_127995, loop_dz2088U_119324);
                bool bounds_check_127998 = x_127996 && y_127997;
                bool index_certs_127999;
                
                if (!bounds_check_127998) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127995, "] out of bounds for array of shape [", (long long) loop_dz2088U_119324, "].", "-> #0  ftRelational.fut:244:55-62\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:232:1-269:32\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t tmp_t_res_128000 = ((int64_t *) mem_param_133471.mem)[tmp_127995];
                
                tmp_127957 = tmp_t_res_128000;
            } else {
                tmp_127957 = n_114179;
            }
            
            int64_t zg_lhs_127966 = sub64(tmp_127957, tmp_127955);
            bool lifted_lambda_res_127967 = slt64(sizze_thresh_114184, zg_lhs_127966);
            int64_t defunc_0_f_res_127968 = btoi_bool_i64(lifted_lambda_res_127967);
            int64_t defunc_0_op_res_119364 = add64(defunc_0_f_res_127968, scanacc_133302);
            
            ((int64_t *) mem_133476)[i_133307] = defunc_0_op_res_119364;
            ((int64_t *) mem_133478)[i_133307] = defunc_0_f_res_127968;
            ((int64_t *) mem_133480)[i_133307] = tmp_127955;
            ((int64_t *) mem_133482)[i_133307] = tmp_127957;
            
            int64_t scanacc_tmp_133889 = defunc_0_op_res_119364;
            
            scanacc_133302 = scanacc_tmp_133889;
        }
        discard_133312 = scanacc_133302;
        
        bool cond_119365 = loop_dz2088U_119324 == (int64_t) 0;
        bool x_119366 = !cond_119365;
        bool x_119368 = sle64((int64_t) 0, zl_rhs_119332);
        bool y_119369 = slt64(zl_rhs_119332, loop_dz2088U_119324);
        bool bounds_check_119370 = x_119368 && y_119369;
        bool protect_assert_disj_119371 = cond_119365 || bounds_check_119370;
        bool index_certs_119372;
        
        if (!protect_assert_disj_119371) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zl_rhs_119332, "] out of bounds for array of shape [", (long long) loop_dz2088U_119324, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:232:1-269:32\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t m_f_res_119373;
        
        if (x_119366) {
            int64_t x_128001 = ((int64_t *) mem_133476)[zl_rhs_119332];
            
            m_f_res_119373 = x_128001;
        } else {
            m_f_res_119373 = (int64_t) 0;
        }
        
        int64_t m_119375;
        
        if (cond_119365) {
            m_119375 = (int64_t) 0;
        } else {
            m_119375 = m_f_res_119373;
        }
        
        int64_t m_119385 = sub64(m_119375, (int64_t) 1);
        bool i_p_m_t_s_leq_w_119387 = slt64(m_119385, loop_dz2088U_119324);
        bool zzero_leq_i_p_m_t_s_119386 = sle64((int64_t) 0, m_119385);
        bool y_119389 = zzero_leq_i_p_m_t_s_119386 && i_p_m_t_s_leq_w_119387;
        bool i_lte_j_119388 = sle64((int64_t) 0, m_119375);
        bool forwards_ok_119390 = i_lte_j_119388 && y_119389;
        bool eq_x_zz_119382 = (int64_t) 0 == m_f_res_119373;
        bool p_and_eq_x_y_119383 = x_119366 && eq_x_zz_119382;
        bool empty_slice_119384 = cond_119365 || p_and_eq_x_y_119383;
        bool ok_or_empty_119391 = empty_slice_119384 || forwards_ok_119390;
        bool index_certs_119392;
        
        if (!ok_or_empty_119391) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_119375, "] out of bounds for array of shape [", (long long) loop_dz2088U_119324, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:232:1-269:32\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t bytes_133507 = (int64_t) 8 * m_119375;
        
        if (mem_133508_cached_sizze_134031 < bytes_133507) {
            err = lexical_realloc(ctx, &mem_133508, &mem_133508_cached_sizze_134031, bytes_133507);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133894 = 0; i_133894 < m_119375; i_133894++) {
            int64_t x_133895 = (int64_t) 0 + i_133894 * (int64_t) 1;
            
            ((int64_t *) mem_133508)[i_133894] = x_133895;
        }
        if (mem_133510_cached_sizze_134032 < bytes_133507) {
            err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134032, bytes_133507);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133482, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_119375});
        if (mem_133512_cached_sizze_134033 < bytes_133507) {
            err = lexical_realloc(ctx, &mem_133512, &mem_133512_cached_sizze_134033, bytes_133507);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133512, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133480, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_119375});
        for (int64_t write_iter_133313 = 0; write_iter_133313 < loop_dz2088U_119324; write_iter_133313++) {
            int64_t write_iv_133317 = ((int64_t *) mem_133478)[write_iter_133313];
            int64_t write_iv_133318 = ((int64_t *) mem_133476)[write_iter_133313];
            int64_t write_iv_133319 = ((int64_t *) mem_133480)[write_iter_133313];
            int64_t write_iv_133320 = ((int64_t *) mem_133482)[write_iter_133313];
            bool cond_127937 = write_iv_133317 == (int64_t) 1;
            int64_t lifted_lambda_res_127938;
            
            if (cond_127937) {
                int64_t lifted_lambda_res_t_res_128002 = sub64(write_iv_133318, (int64_t) 1);
                
                lifted_lambda_res_127938 = lifted_lambda_res_t_res_128002;
            } else {
                lifted_lambda_res_127938 = (int64_t) -1;
            }
            if (sle64((int64_t) 0, lifted_lambda_res_127938) && slt64(lifted_lambda_res_127938, m_119375)) {
                ((int64_t *) mem_133512)[lifted_lambda_res_127938] = write_iv_133319;
            }
            if (sle64((int64_t) 0, lifted_lambda_res_127938) && slt64(lifted_lambda_res_127938, m_119375)) {
                ((int64_t *) mem_133510)[lifted_lambda_res_127938] = write_iv_133320;
            }
            if (sle64((int64_t) 0, lifted_lambda_res_127938) && slt64(lifted_lambda_res_127938, m_119375)) {
                ((int64_t *) mem_133508)[lifted_lambda_res_127938] = write_iter_133313;
            }
        }
        
        int32_t new_i_119406 = mul32(radix_sizze_114181, p_119329);
        int32_t zt_rhs_119407 = add32(1, p_119329);
        int32_t zm_lhs_119408 = mul32(radix_sizze_114181, zt_rhs_119407);
        int32_t new_j_119409 = sub32(zm_lhs_119408, 1);
        int64_t loopres_119410;
        int64_t loopres_119411;
        int32_t loopres_119414;
        int64_t loopres_119415;
        int64_t loopres_119416;
        int64_t loop_dz2084Uz2089U_119418;
        int64_t loop_dz2085Uz2080U_119419;
        int32_t q_119422;
        int64_t ad_119423;
        int64_t ox_119424;
        
        if (memblock_set(ctx, &mem_param_133533, &mem_param_133471, "mem_param_133471") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133536, &mem_param_133474, "mem_param_133474") != 0)
            return 1;
        loop_dz2084Uz2089U_119418 = loop_dz2088U_119324;
        loop_dz2085Uz2080U_119419 = loop_dz2089U_119325;
        q_119422 = p_119329;
        ad_119423 = (int64_t) 0;
        ox_119424 = (int64_t) 0;
        for (int64_t i_119417 = 0; i_119417 < m_119375; i_119417++) {
            int64_t bounds_119425 = ((int64_t *) mem_133512)[i_119417];
            int64_t bounds_119426 = ((int64_t *) mem_133510)[i_119417];
            int64_t bounds_119427 = ((int64_t *) mem_133508)[i_119417];
            int64_t dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_119428 = sub64(bounds_119426, bounds_119425);
            bool empty_slice_119429 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_119428 == (int64_t) 0;
            int64_t m_119430 = sub64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_119428, (int64_t) 1);
            int64_t i_p_m_t_s_119431 = add64(bounds_119425, m_119430);
            bool zzero_leq_i_p_m_t_s_119432 = sle64((int64_t) 0, i_p_m_t_s_119431);
            bool i_p_m_t_s_leq_w_119433 = slt64(i_p_m_t_s_119431, n_114179);
            bool zzero_lte_i_119434 = sle64((int64_t) 0, bounds_119425);
            bool i_lte_j_119435 = sle64(bounds_119425, bounds_119426);
            bool y_119436 = i_p_m_t_s_leq_w_119433 && zzero_lte_i_119434;
            bool y_119437 = zzero_leq_i_p_m_t_s_119432 && y_119436;
            bool forwards_ok_119438 = i_lte_j_119435 && y_119437;
            bool ok_or_empty_119439 = empty_slice_119429 || forwards_ok_119438;
            bool index_certs_119440;
            
            if (!ok_or_empty_119439) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) bounds_119425, ":", (long long) bounds_119426, "] out of bounds for array of shape [", (long long) n_114179, "].", "-> #0  ftRelational.fut:250:21-43\n   #1  ftRelational.fut:232:1-269:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133537 = b_114180 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_119428;
            
            if (memblock_alloc(ctx, &mem_133538, bytes_133537, "mem_133538")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133538.mem, (int64_t) 0, (int64_t []) {b_114180, (int64_t) 1}, (uint8_t *) pXs_mem_133466.mem, b_114180 * bounds_119425, (int64_t []) {b_114180, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_119428, b_114180});
            
            int64_t loopres_119444;
            int64_t loopres_119445;
            int32_t loopres_119448;
            
            if (futrts_getPartitionBounds_12125(ctx, &ext_mem_133541, &ext_mem_133540, &loopres_119444, &loopres_119445, &loopres_119448, mem_133538, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_119428, b_114180, zt_rhs_119407, new_i_119406, new_j_119409) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref(ctx, &mem_133538, "mem_133538") != 0)
                return 1;
            
            int64_t zm_lhs_119449 = add64(ox_119424, bounds_119427);
            int64_t stitch_119450 = sub64(zm_lhs_119449, ad_119423);
            bool empty_slice_119451 = stitch_119450 == (int64_t) 0;
            int64_t m_119452 = sub64(stitch_119450, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_119453 = sle64((int64_t) 0, m_119452);
            bool i_p_m_t_s_leq_w_119454 = slt64(m_119452, loop_dz2084Uz2089U_119418);
            bool i_lte_j_119455 = sle64((int64_t) 0, stitch_119450);
            bool y_119456 = zzero_leq_i_p_m_t_s_119453 && i_p_m_t_s_leq_w_119454;
            bool forwards_ok_119457 = i_lte_j_119455 && y_119456;
            bool ok_or_empty_119458 = empty_slice_119451 || forwards_ok_119457;
            bool index_certs_119459;
            
            if (!ok_or_empty_119458) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) stitch_119450, "] out of bounds for array of shape [", (long long) loop_dz2084Uz2089U_119418, "].", "-> #0  ftRelational.fut:258:18-36\n   #1  ftRelational.fut:232:1-269:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t conc_tmp_119464 = loopres_119444 + stitch_119450;
            int64_t zpzp_rhs_119465 = add64((int64_t) 1, stitch_119450);
            int64_t j_m_i_119466 = sub64(loop_dz2084Uz2089U_119418, zpzp_rhs_119465);
            bool empty_slice_119467 = j_m_i_119466 == (int64_t) 0;
            int64_t m_119468 = sub64(j_m_i_119466, (int64_t) 1);
            int64_t i_p_m_t_s_119469 = add64(zpzp_rhs_119465, m_119468);
            bool zzero_leq_i_p_m_t_s_119470 = sle64((int64_t) 0, i_p_m_t_s_119469);
            bool i_p_m_t_s_leq_w_119471 = slt64(i_p_m_t_s_119469, loop_dz2084Uz2089U_119418);
            bool zzero_lte_i_119472 = sle64((int64_t) 0, zpzp_rhs_119465);
            bool i_lte_j_119473 = sle64(zpzp_rhs_119465, loop_dz2084Uz2089U_119418);
            bool y_119474 = i_p_m_t_s_leq_w_119471 && zzero_lte_i_119472;
            bool y_119475 = zzero_leq_i_p_m_t_s_119470 && y_119474;
            bool forwards_ok_119476 = i_lte_j_119473 && y_119475;
            bool ok_or_empty_119477 = empty_slice_119467 || forwards_ok_119476;
            bool index_certs_119478;
            
            if (!ok_or_empty_119477) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zpzp_rhs_119465, ":", (long long) loop_dz2084Uz2089U_119418, "] out of bounds for array of shape [", (long long) loop_dz2084Uz2089U_119418, "].", "-> #0  ftRelational.fut:258:90-126\n   #1  ftRelational.fut:232:1-269:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t conc_tmp_119480 = conc_tmp_119464 + j_m_i_119466;
            int64_t bytes_133550 = (int64_t) 8 * conc_tmp_119480;
            bool i_p_m_t_s_leq_w_119482 = slt64(m_119452, loop_dz2085Uz2080U_119419);
            bool y_119483 = zzero_leq_i_p_m_t_s_119453 && i_p_m_t_s_leq_w_119482;
            bool ok_or_empty_119484 = empty_slice_119451 || y_119483;
            bool index_certs_119485;
            
            if (!ok_or_empty_119484) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) stitch_119450, "] out of bounds for array of shape [", (long long) loop_dz2085Uz2080U_119419, "].", "-> #0  ftRelational.fut:259:18-36\n   #1  ftRelational.fut:232:1-269:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t conc_tmp_119487 = loopres_119445 + stitch_119450;
            int64_t j_m_i_119488 = sub64(loop_dz2085Uz2080U_119419, zpzp_rhs_119465);
            bool empty_slice_119489 = j_m_i_119488 == (int64_t) 0;
            int64_t m_119490 = sub64(j_m_i_119488, (int64_t) 1);
            int64_t i_p_m_t_s_119491 = add64(zpzp_rhs_119465, m_119490);
            bool zzero_leq_i_p_m_t_s_119492 = sle64((int64_t) 0, i_p_m_t_s_119491);
            bool i_p_m_t_s_leq_w_119493 = slt64(i_p_m_t_s_119491, loop_dz2085Uz2080U_119419);
            bool i_lte_j_119494 = sle64(zpzp_rhs_119465, loop_dz2085Uz2080U_119419);
            bool y_119495 = zzero_lte_i_119472 && i_p_m_t_s_leq_w_119493;
            bool y_119496 = zzero_leq_i_p_m_t_s_119492 && y_119495;
            bool forwards_ok_119497 = i_lte_j_119494 && y_119496;
            bool ok_or_empty_119498 = empty_slice_119489 || forwards_ok_119497;
            bool index_certs_119499;
            
            if (!ok_or_empty_119498) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zpzp_rhs_119465, ":", (long long) loop_dz2085Uz2080U_119419, "] out of bounds for array of shape [", (long long) loop_dz2085Uz2080U_119419, "].", "-> #0  ftRelational.fut:259:62-98\n   #1  ftRelational.fut:232:1-269:32\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t conc_tmp_119501 = conc_tmp_119487 + j_m_i_119488;
            int64_t bytes_133552 = (int64_t) 4 * conc_tmp_119501;
            
            if (memblock_alloc(ctx, &mem_133551, bytes_133550, "mem_133551")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t i_133327 = 0; i_133327 < loopres_119444; i_133327++) {
                int64_t eta_p_119462 = ((int64_t *) ext_mem_133541.mem)[i_133327];
                int64_t lifted_lambda_res_119463 = add64(bounds_119425, eta_p_119462);
                
                ((int64_t *) mem_133551.mem)[stitch_119450 + i_133327] = lifted_lambda_res_119463;
            }
            if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
                return 1;
            
            int64_t tmp_offs_133909 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133551.mem, tmp_offs_133909, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133533.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {stitch_119450});
            tmp_offs_133909 += stitch_119450;
            if (!(tmp_offs_133909 == stitch_119450)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133551.mem, tmp_offs_133909, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133551.mem, stitch_119450, (int64_t []) {(int64_t) 1}, (int64_t []) {loopres_119444});
            }
            tmp_offs_133909 += loopres_119444;
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133551.mem, tmp_offs_133909, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133533.mem, (int64_t) 0 + (int64_t) 1 * zpzp_rhs_119465, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_119466});
            tmp_offs_133909 += j_m_i_119466;
            if (memblock_alloc(ctx, &mem_133553, bytes_133552, "mem_133553")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t tmp_offs_133910 = (int64_t) 0;
            
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133553.mem, tmp_offs_133910, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_param_133536.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {stitch_119450});
            tmp_offs_133910 += stitch_119450;
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133553.mem, tmp_offs_133910, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133540.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loopres_119445});
            tmp_offs_133910 += loopres_119445;
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133553.mem, tmp_offs_133910, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_param_133536.mem, (int64_t) 0 + (int64_t) 1 * zpzp_rhs_119465, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_119488});
            tmp_offs_133910 += j_m_i_119488;
            if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
                return 1;
            
            int64_t tmp_119503 = add64((int64_t) 1, ad_119423);
            int64_t tmp_119504 = add64(ox_119424, loopres_119444);
            
            if (memblock_set(ctx, &mem_param_tmp_133899, &mem_133551, "mem_133551") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133900, &mem_133553, "mem_133553") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2089U_tmp_133901 = conc_tmp_119480;
            int64_t loop_dz2085Uz2080U_tmp_133902 = conc_tmp_119501;
            int32_t q_tmp_133905 = zt_rhs_119407;
            int64_t ad_tmp_133906 = tmp_119503;
            int64_t ox_tmp_133907 = tmp_119504;
            
            if (memblock_set(ctx, &mem_param_133533, &mem_param_tmp_133899, "mem_param_tmp_133899") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133536, &mem_param_tmp_133900, "mem_param_tmp_133900") != 0)
                return 1;
            loop_dz2084Uz2089U_119418 = loop_dz2084Uz2089U_tmp_133901;
            loop_dz2085Uz2080U_119419 = loop_dz2085Uz2080U_tmp_133902;
            q_119422 = q_tmp_133905;
            ad_119423 = ad_tmp_133906;
            ox_119424 = ox_tmp_133907;
        }
        if (memblock_set(ctx, &ext_mem_133559, &mem_param_133533, "mem_param_133533") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133558, &mem_param_133536, "mem_param_133536") != 0)
            return 1;
        loopres_119410 = loop_dz2084Uz2089U_119418;
        loopres_119411 = loop_dz2085Uz2080U_119419;
        loopres_119414 = q_119422;
        loopres_119415 = ad_119423;
        loopres_119416 = ox_119424;
        
        bool tmp_119505 = slt64((int64_t) 0, m_119375);
        bool cond_119506 = slt32(loopres_119414, max_depth_114185);
        bool x_119507 = tmp_119505 && cond_119506;
        
        if (memblock_set(ctx, &mem_param_tmp_133881, &ext_mem_133559, "ext_mem_133559") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133882, &ext_mem_133558, "ext_mem_133558") != 0)
            return 1;
        
        int64_t loop_dz2088U_tmp_133883 = loopres_119410;
        int64_t loop_dz2089U_tmp_133884 = loopres_119411;
        bool loop_while_tmp_133885 = x_119507;
        int32_t p_tmp_133888 = loopres_119414;
        
        if (memblock_set(ctx, &mem_param_133471, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133474, &mem_param_tmp_133882, "mem_param_tmp_133882") != 0)
            return 1;
        loop_dz2088U_119324 = loop_dz2088U_tmp_133883;
        loop_dz2089U_119325 = loop_dz2089U_tmp_133884;
        loop_while_119326 = loop_while_tmp_133885;
        p_119329 = p_tmp_133888;
    }
    if (memblock_set(ctx, &ext_mem_133565, &mem_param_133471, "mem_param_133471") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133564, &mem_param_133474, "mem_param_133474") != 0)
        return 1;
    calc_partitions_from_partitioned_set_res_119318 = loop_dz2088U_119324;
    calc_partitions_from_partitioned_set_res_119319 = loop_dz2089U_119325;
    calc_partitions_from_partitioned_set_res_119320 = loop_while_119326;
    calc_partitions_from_partitioned_set_res_119323 = p_119329;
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
        return 1;
    
    int64_t bytes_133566 = (int64_t) 8 * calc_partitions_from_partitioned_set_res_119318;
    bool dim_match_119511 = calc_partitions_from_partitioned_set_res_119318 == calc_partitions_from_partitioned_set_res_119319;
    bool empty_or_match_cert_119512;
    
    if (!dim_match_119511) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Value of (desugared) shape [", (long long) calc_partitions_from_partitioned_set_res_119319, "] cannot match shape of type `[", (long long) calc_partitions_from_partitioned_set_res_119318, "]i32`.", "-> #0  ftRelational.fut:267:14-54\n   #1  ftRelational.fut:232:1-269:32\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133567, bytes_133566, "mem_133567")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133331 = 0; i_133331 < calc_partitions_from_partitioned_set_res_119318; i_133331++) {
        int64_t eta_p_119509 = ((int64_t *) ext_mem_133565.mem)[i_133331];
        int64_t lifted_lambda_res_119510 = add64(offset_114183, eta_p_119509);
        
        ((int64_t *) mem_133567.mem)[i_133331] = lifted_lambda_res_119510;
    }
    if (memblock_unref(ctx, &ext_mem_133565, "ext_mem_133565") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133567, "mem_133567") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &ext_mem_133564, "ext_mem_133564") != 0)
        return 1;
    prim_out_133879 = calc_partitions_from_partitioned_set_res_119318;
    prim_out_133880 = calc_partitions_from_partitioned_set_res_119323;
    if (memblock_set(ctx, &*mem_out_p_134023, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134024, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    *out_prim_out_134025 = prim_out_133879;
    *out_prim_out_134026 = prim_out_133880;
    
  cleanup:
    {
        free(mem_133476);
        free(mem_133478);
        free(mem_133480);
        free(mem_133482);
        free(mem_133508);
        free(mem_133510);
        free(mem_133512);
        if (memblock_unref(ctx, &mem_133567, "mem_133567") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133882, "mem_param_tmp_133882") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133900, "mem_param_tmp_133900") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133899, "mem_param_tmp_133899") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133553, "mem_133553") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133551, "mem_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133538, "mem_133538") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133536, "mem_param_133536") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133533, "mem_param_133533") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133558, "ext_mem_133558") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133559, "ext_mem_133559") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133474, "mem_param_133474") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133471, "mem_param_133471") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133564, "ext_mem_133564") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133565, "ext_mem_133565") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_create_hash_table_from_partitioned_set(struct futhark_context *ctx, struct memblock *mem_out_p_134034, struct memblock *mem_out_p_134035, int64_t *out_prim_out_134036, struct memblock pXs_mem_133466, struct memblock bounds_mem_133467, struct memblock depths_mem_133468, int64_t n_114971, int64_t b_114972, int64_t dz2080U_114973, int64_t dz2081U_114974, int32_t radix_sizze_114975, int32_t maxDepth_114979, int64_t scatter_psizze_114980)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134037 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133480_cached_sizze_134038 = 0;
    unsigned char *mem_133480 = NULL;
    int64_t mem_133484_cached_sizze_134039 = 0;
    unsigned char *mem_133484 = NULL;
    int64_t mem_133516_cached_sizze_134040 = 0;
    unsigned char *mem_133516 = NULL;
    int64_t mem_133518_cached_sizze_134041 = 0;
    unsigned char *mem_133518 = NULL;
    struct memblock ext_mem_133542;
    
    ext_mem_133542.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock mem_133538;
    
    mem_133538.references = NULL;
    
    struct memblock ext_mem_133536;
    
    ext_mem_133536.references = NULL;
    
    struct memblock mem_133534;
    
    mem_133534.references = NULL;
    
    struct memblock mem_133532;
    
    mem_133532.references = NULL;
    
    struct memblock mem_133495;
    
    mem_133495.references = NULL;
    
    struct memblock mem_133494;
    
    mem_133494.references = NULL;
    
    struct memblock mem_133508;
    
    mem_133508.references = NULL;
    
    struct memblock ext_mem_133511;
    
    ext_mem_133511.references = NULL;
    
    struct memblock ext_mem_133514;
    
    ext_mem_133514.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t prim_out_133879;
    int64_t bytes_133469 = (int64_t) 8 * dz2080U_114973;
    int64_t i32_res_118501 = sext_i32_i64(radix_sizze_114975);
    bool nonnegative_118502 = sle64((int64_t) 0, i32_res_118501);
    bool nonzzero_cert_118503;
    
    if (!nonnegative_118502) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  ftRelational.fut:296:78-83\n   #1  ftRelational.fut:271:1-298:86\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t dzlz7bUZLztztZRz20U2z20Ursz7dUzg_118504 = shl64((int64_t) 1, i32_res_118501);
    int64_t bytes_133471 = (int64_t) 8 * b_114972;
    int32_t getRadix_arg1_126559 = sub32(radix_sizze_114975, 1);
    int32_t i64_res_126560 = sext_i64_i32(b_114972);
    int32_t zm_lhs_126561 = mul32(8, i64_res_126560);
    int32_t min_arg1_126562 = sub32(zm_lhs_126561, 1);
    int32_t min_res_126563 = smin32(getRadix_arg1_126559, min_arg1_126562);
    int32_t i32_arg0_126567 = sub32(i64_res_126560, 1);
    int64_t i32_res_126568 = sext_i32_i64(i32_arg0_126567);
    int32_t zm_rhs_126570 = sdiv32(min_res_126563, 8);
    int32_t zm_lhs_126571 = sub32(i64_res_126560, zm_rhs_126570);
    int32_t i32_arg0_126572 = sub32(zm_lhs_126571, 1);
    int64_t i32_res_126573 = sext_i32_i64(i32_arg0_126572);
    int64_t min_arg1_126575 = sub64(bytes_133471, (int64_t) 1);
    int64_t min_res_126576 = smin64(i32_res_126573, min_arg1_126575);
    bool x_126593 = sle64((int64_t) 0, i32_res_126568);
    bool y_126594 = slt64(i32_res_126568, b_114972);
    bool bounds_check_126595 = x_126593 && y_126594;
    bool index_certs_126596;
    
    if (!bounds_check_126595) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_126568, "] out of bounds for array of shape [", (long long) b_114972, "].", "-> #0  ftHashJoin.fut:31:48-64\n   #1  ftRelational.fut:271:1-298:86\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool x_126604 = sle64((int64_t) 0, min_res_126576);
    bool y_126605 = slt64(min_res_126576, b_114972);
    bool bounds_check_126606 = x_126604 && y_126605;
    bool index_certs_126607;
    
    if (!bounds_check_126606) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_126576, "] out of bounds for array of shape [", (long long) b_114972, "].", "-> #0  ftHashJoin.fut:32:38-54\n   #1  ftRelational.fut:271:1-298:86\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133531 = (int64_t) 8 * dzlz7bUZLztztZRz20U2z20Ursz7dUzg_118504;
    
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133880 = 0; i_133880 < dz2080U_114973; i_133880++) {
        int64_t x_133881 = (int64_t) 0 + i_133880 * (int64_t) 1;
        
        ((int64_t *) mem_133470.mem)[i_133880] = x_133881;
    }
    if (mem_133472_cached_sizze_134037 < bytes_133471) {
        err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134037, bytes_133471);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < b_114972; i_133300++) {
        int64_t zm_lhs_126557 = sub64(b_114972, i_133300);
        int64_t lifted_lambda_res_126558 = sub64(zm_lhs_126557, (int64_t) 1);
        
        ((int64_t *) mem_133472)[i_133300] = lifted_lambda_res_126558;
    }
    
    int32_t lastBit_126578 = smod32(min_res_126563, 8);
    int32_t zm_lhs_126581 = sub32(8, lastBit_126578);
    int32_t i32_arg0_126582 = sub32(zm_lhs_126581, 1);
    int8_t unsign_arg0_126583 = zext_i32_i8(i32_arg0_126582);
    int8_t unsign_arg0_126584 = lshr8((int8_t) -1, unsign_arg0_126583);
    
    if (mem_133480_cached_sizze_134038 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133480, &mem_133480_cached_sizze_134038, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133484_cached_sizze_134039 < b_114972) {
        err = lexical_realloc(ctx, &mem_133484, &mem_133484_cached_sizze_134039, b_114972);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133310 = 0; i_133310 < dz2080U_114973; i_133310++) {
        int64_t radix_to_idx_arg1_118512 = ((int64_t *) bounds_mem_133467.mem)[i_133310];
        bool x_118513 = sle64((int64_t) 0, radix_to_idx_arg1_118512);
        bool y_118514 = slt64(radix_to_idx_arg1_118512, n_114971);
        bool bounds_check_118515 = x_118513 && y_118514;
        bool index_certs_118516;
        
        if (!bounds_check_118515) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) radix_to_idx_arg1_118512, "] out of bounds for array of shape [", (long long) n_114971, "].", "-> #0  ftRelational.fut:281:46-67\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:271:1-298:86\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < b_114972; i_133304++) {
            int8_t eta_p_126588 = ((int8_t *) pXs_mem_133466.mem)[radix_to_idx_arg1_118512 * b_114972 + i_133304];
            bool cond_126589 = sle64(i_133304, i32_res_126568);
            bool cond_t_res_126590 = sle64(min_res_126576, i_133304);
            bool x_126591 = cond_126589 && cond_t_res_126590;
            int8_t lifted_lambda_res_126592;
            
            if (x_126591) {
                lifted_lambda_res_126592 = eta_p_126588;
            } else {
                lifted_lambda_res_126592 = (int8_t) 0;
            }
            ((int8_t *) mem_133484)[i_133304] = lifted_lambda_res_126592;
        }
        
        int8_t za_lhs_126597 = ((int8_t *) mem_133484)[i32_res_126568];
        int8_t mod1_x_126598 = (int8_t) -1 & za_lhs_126597;
        
        ((int8_t *) mem_133484)[i32_res_126568] = mod1_x_126598;
        
        int8_t za_lhs_126608 = ((int8_t *) mem_133484)[min_res_126576];
        int8_t tmp_126609 = unsign_arg0_126584 & za_lhs_126608;
        
        ((int8_t *) mem_133484)[min_res_126576] = tmp_126609;
        
        int64_t defunc_res_127975;
        int64_t redout_133306 = (int64_t) 0;
        
        for (int64_t i_133307 = 0; i_133307 < b_114972; i_133307++) {
            int8_t eta_p_127950 = ((int8_t *) mem_133484)[i_133307];
            int64_t eta_p_127951 = ((int64_t *) mem_133472)[i_133307];
            int64_t u8_res_127952 = zext_i8_i64(eta_p_127950);
            int64_t zlzl_rhs_127953 = mul64((int64_t) 8, eta_p_127951);
            int64_t zt_rhs_127954 = shl64((int64_t) 1, zlzl_rhs_127953);
            int64_t lifted_lambda_res_127955 = mul64(u8_res_127952, zt_rhs_127954);
            int64_t zp_res_126626 = add64(lifted_lambda_res_127955, redout_133306);
            int64_t redout_tmp_133885 = zp_res_126626;
            
            redout_133306 = redout_tmp_133885;
        }
        defunc_res_127975 = redout_133306;
        ((int64_t *) mem_133480)[i_133310] = defunc_res_127975;
    }
    
    bool cond_118522 = maxDepth_114979 == 1;
    
    if (cond_118522) {
        if (memblock_alloc(ctx, &mem_133508, dz2080U_114973, "mem_133508")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133886 = 0; nest_i_133886 < dz2080U_114973; nest_i_133886++) {
            ((bool *) mem_133508.mem)[nest_i_133886] = 1;
        }
        if (memblock_set(ctx, &ext_mem_133514, &mem_133508, "mem_133508") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133511, &mem_133508, "mem_133508") != 0)
            return 1;
    } else {
        int64_t zeze_rhs_118526 = sub64(dz2080U_114973, (int64_t) 1);
        
        if (memblock_alloc(ctx, &mem_133494, dz2080U_114973, "mem_133494")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133495, dz2080U_114973, "mem_133495")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133316 = 0; i_133316 < dz2080U_114973; i_133316++) {
            int64_t cur_i_118534 = ((int64_t *) mem_133480)[i_133316];
            bool cond_118535 = i_133316 == (int64_t) 0;
            int64_t pre_i_118536;
            
            if (cond_118535) {
                pre_i_118536 = (int64_t) -1;
            } else {
                int64_t tmp_118537 = sub64(i_133316, (int64_t) 1);
                bool x_118538 = sle64((int64_t) 0, tmp_118537);
                bool y_118539 = slt64(tmp_118537, dz2080U_114973);
                bool bounds_check_118540 = x_118538 && y_118539;
                bool index_certs_118541;
                
                if (!bounds_check_118540) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_118537, "] out of bounds for array of shape [", (long long) dz2080U_114973, "].", "-> #0  ftRelational.fut:288:42-74\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:286:10-293:8\n   #3  ftRelational.fut:271:1-298:86\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t pre_i_f_res_118542 = ((int64_t *) mem_133480)[tmp_118537];
                
                pre_i_118536 = pre_i_f_res_118542;
            }
            
            bool is_first_118543 = cur_i_118534 == pre_i_118536;
            bool is_first_118544 = !is_first_118543;
            bool cond_118545 = i_133316 == zeze_rhs_118526;
            int64_t pos_i_118546;
            
            if (cond_118545) {
                pos_i_118546 = (int64_t) -1;
            } else {
                int64_t tmp_118547 = add64((int64_t) 1, i_133316);
                bool x_118548 = sle64((int64_t) 0, tmp_118547);
                bool y_118549 = slt64(tmp_118547, dz2080U_114973);
                bool bounds_check_118550 = x_118548 && y_118549;
                bool index_certs_118551;
                
                if (!bounds_check_118550) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_118547, "] out of bounds for array of shape [", (long long) dz2080U_114973, "].", "-> #0  ftRelational.fut:290:46-78\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftRelational.fut:286:10-293:8\n   #3  ftRelational.fut:271:1-298:86\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t pos_i_f_res_118552 = ((int64_t *) mem_133480)[tmp_118547];
                
                pos_i_118546 = pos_i_f_res_118552;
            }
            
            bool is_last_118553 = cur_i_118534 == pos_i_118546;
            bool is_last_118554 = !is_last_118553;
            
            ((bool *) mem_133494.mem)[i_133316] = is_first_118544;
            ((bool *) mem_133495.mem)[i_133316] = is_last_118554;
        }
        if (memblock_set(ctx, &ext_mem_133514, &mem_133494, "mem_133494") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133511, &mem_133495, "mem_133495") != 0)
            return 1;
    }
    if (mem_133516_cached_sizze_134040 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133516, &mem_133516_cached_sizze_134040, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133518_cached_sizze_134041 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133518, &mem_133518_cached_sizze_134041, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133323 = 0; i_133323 < dz2080U_114973; i_133323++) {
        bool eta_p_127932 = ((bool *) ext_mem_133514.mem)[i_133323];
        bool eta_p_127934 = ((bool *) ext_mem_133511.mem)[i_133323];
        int64_t lifted_lambda_res_127936;
        
        if (eta_p_127932) {
            int64_t lifted_lambda_res_t_res_127983 = ((int64_t *) mem_133480)[i_133323];
            
            lifted_lambda_res_127936 = lifted_lambda_res_t_res_127983;
        } else {
            lifted_lambda_res_127936 = (int64_t) -1;
        }
        
        int64_t lifted_lambda_res_127943;
        
        if (eta_p_127934) {
            int64_t lifted_lambda_res_t_res_127988 = ((int64_t *) mem_133480)[i_133323];
            
            lifted_lambda_res_127943 = lifted_lambda_res_t_res_127988;
        } else {
            lifted_lambda_res_127943 = (int64_t) -1;
        }
        ((int64_t *) mem_133516)[i_133323] = lifted_lambda_res_127943;
        ((int64_t *) mem_133518)[i_133323] = lifted_lambda_res_127936;
    }
    if (memblock_unref(ctx, &ext_mem_133511, "ext_mem_133511") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133514, "ext_mem_133514") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133532, bytes_133531, "mem_133532")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133891 = 0; nest_i_133891 < dzlz7bUZLztztZRz20U2z20Ursz7dUzg_118504; nest_i_133891++) {
        ((int64_t *) mem_133532.mem)[nest_i_133891] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133534, bytes_133469, "mem_133534")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133534.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133518, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {dz2080U_114973});
    if (futrts_partitioned_scatter_12235(ctx, &ext_mem_133536, mem_133532, mem_133534, mem_133470, dzlz7bUZLztztZRz20U2z20Ursz7dUzg_118504, dz2080U_114973, scatter_psizze_114980) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref(ctx, &mem_133532, "mem_133532") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133534, "mem_133534") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133538, bytes_133531, "mem_133538")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133892 = 0; nest_i_133892 < dzlz7bUZLztztZRz20U2z20Ursz7dUzg_118504; nest_i_133892++) {
        ((int64_t *) mem_133538.mem)[nest_i_133892] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133540, bytes_133469, "mem_133540")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133516, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {dz2080U_114973});
    if (futrts_partitioned_scatter_12235(ctx, &ext_mem_133542, mem_133538, mem_133540, mem_133470, dzlz7bUZLztztZRz20U2z20Ursz7dUzg_118504, dz2080U_114973, scatter_psizze_114980) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133538, "mem_133538") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &ext_mem_133536, "ext_mem_133536") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &ext_mem_133542, "ext_mem_133542") != 0)
        return 1;
    prim_out_133879 = dzlz7bUZLztztZRz20U2z20Ursz7dUzg_118504;
    if (memblock_set(ctx, &*mem_out_p_134034, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134035, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    *out_prim_out_134036 = prim_out_133879;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133480);
        free(mem_133484);
        free(mem_133516);
        free(mem_133518);
        if (memblock_unref(ctx, &ext_mem_133542, "ext_mem_133542") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133538, "mem_133538") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133536, "ext_mem_133536") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133534, "mem_133534") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133532, "mem_133532") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133495, "mem_133495") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133494, "mem_133494") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133508, "mem_133508") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133511, "ext_mem_133511") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133514, "ext_mem_133514") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_GFTR(struct futhark_context *ctx, struct memblock *mem_out_p_134042, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_65436, int64_t dz2083U_65437, int64_t incr_65438, int64_t psizze_65439, int64_t pL_bytes_65441)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133511;
    
    mem_133511.references = NULL;
    
    struct memblock mem_param_tmp_133882;
    
    mem_param_tmp_133882.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock mem_133488;
    
    mem_133488.references = NULL;
    
    struct memblock mem_133486;
    
    mem_133486.references = NULL;
    
    struct memblock mem_param_133484;
    
    mem_param_133484.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133508;
    
    ext_mem_133508.references = NULL;
    
    struct memblock ext_mem_133509;
    
    ext_mem_133509.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * niz2084U_65436;
    bool zzero_118775 = psizze_65439 == (int64_t) 0;
    bool nonzzero_118776 = !zzero_118775;
    bool nonzzero_cert_118777;
    
    if (!nonzzero_118776) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftRelational.fut:52:1-53:69\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133476 = niz2084U_65436 * pL_bytes_65441;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < niz2084U_65436; i_133300++) {
        int64_t eta_p_118771 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118772 = sub64(eta_p_118771, incr_65438);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118772;
    }
    
    int64_t zm_lhs_118773 = add64(dz2083U_65437, psizze_65439);
    int64_t zs_lhs_118774 = sub64(zm_lhs_118773, (int64_t) 1);
    int64_t m_118778 = sdiv64(zs_lhs_118774, psizze_65439);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133476, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < niz2084U_65436; nest_i_133879++) {
        for (int64_t nest_i_133880 = 0; nest_i_133880 < pL_bytes_65441; nest_i_133880++) {
            ((int8_t *) mem_133477.mem)[nest_i_133879 * pL_bytes_65441 + nest_i_133880] = (int8_t) 0;
        }
    }
    
    bool loop_cond_118780 = slt64((int64_t) 0, m_118778);
    bool partitioned_gather_res_118781;
    int64_t partitioned_gather_res_118784;
    bool loop_while_118785;
    int64_t p_118788;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133484, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118785 = loop_cond_118780;
    p_118788 = (int64_t) 0;
    while (loop_while_118785) {
        int64_t lower_bound_118789 = mul64(psizze_65439, p_118788);
        int64_t min_arg1_118790 = add64(psizze_65439, lower_bound_118789);
        int64_t min_res_118791 = smin64(dz2083U_65437, min_arg1_118790);
        int64_t j_m_i_118792 = sub64(min_res_118791, lower_bound_118789);
        bool empty_slice_118793 = j_m_i_118792 == (int64_t) 0;
        int64_t m_118794 = sub64(j_m_i_118792, (int64_t) 1);
        int64_t i_p_m_t_s_118795 = add64(lower_bound_118789, m_118794);
        bool zzero_leq_i_p_m_t_s_118796 = sle64((int64_t) 0, i_p_m_t_s_118795);
        bool i_p_m_t_s_leq_w_118797 = slt64(i_p_m_t_s_118795, dz2083U_65437);
        bool zzero_lte_i_118798 = sle64((int64_t) 0, lower_bound_118789);
        bool i_lte_j_118799 = sle64(lower_bound_118789, min_res_118791);
        bool y_118800 = i_p_m_t_s_leq_w_118797 && zzero_lte_i_118798;
        bool y_118801 = zzero_leq_i_p_m_t_s_118796 && y_118800;
        bool forwards_ok_118802 = i_lte_j_118799 && y_118801;
        bool ok_or_empty_118803 = empty_slice_118793 || forwards_ok_118802;
        bool index_certs_118804;
        
        if (!ok_or_empty_118803) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118789, ":", (long long) min_res_118791, "] out of bounds for array of shape [", (long long) dz2083U_65437, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftRelational.fut:52:1-53:69\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133486, bytes_133468, "mem_133486")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133486.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_65436});
        if (memblock_alloc(ctx, &mem_133488, bytes_133476, "mem_133488")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < niz2084U_65436; i_133304++) {
            int64_t eta_p_118807 = ((int64_t *) mem_param_133480.mem)[i_133304];
            bool cond_118809 = sle64(lower_bound_118789, eta_p_118807);
            bool cond_t_res_118810 = slt64(eta_p_118807, min_res_118791);
            bool x_118811 = cond_118809 && cond_t_res_118810;
            int64_t binop_y_133493 = pL_bytes_65441 * i_133304;
            int64_t lmad_ext_133495 = pL_bytes_65441 * eta_p_118807;
            int64_t ext_133497;
            
            if (x_118811) {
                ext_133497 = lmad_ext_133495;
            } else {
                ext_133497 = binop_y_133493;
            }
            if (x_118811) {
                int64_t tmp_127931 = sub64(eta_p_118807, lower_bound_118789);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118792);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118792, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftRelational.fut:52:1-53:69\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (memblock_set(ctx, &ext_mem_133498, &ys_mem_133467, "ys_mem_133467") != 0)
                    return 1;
            } else if (memblock_set(ctx, &ext_mem_133498, &mem_param_133484, "mem_param_133484") != 0)
                return 1;
            lmad_copy_1b(ctx, 1, (uint8_t *) mem_133488.mem, i_133304 * pL_bytes_65441, (int64_t []) {(int64_t) 1}, (uint8_t *) ext_mem_133498.mem, ext_133497, (int64_t []) {(int64_t) 1}, (int64_t []) {pL_bytes_65441});
            if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
                return 1;
        }
        
        int64_t tmp_118819 = add64((int64_t) 1, p_118788);
        bool loop_cond_118820 = slt64(tmp_118819, m_118778);
        
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133486, "mem_133486") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133882, &mem_133488, "mem_133488") != 0)
            return 1;
        
        bool loop_while_tmp_133883 = loop_cond_118820;
        int64_t p_tmp_133886 = tmp_118819;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133484, &mem_param_tmp_133882, "mem_param_tmp_133882") != 0)
            return 1;
        loop_while_118785 = loop_while_tmp_133883;
        p_118788 = p_tmp_133886;
    }
    if (memblock_set(ctx, &ext_mem_133509, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133508, &mem_param_133484, "mem_param_133484") != 0)
        return 1;
    partitioned_gather_res_118781 = loop_while_118785;
    partitioned_gather_res_118784 = p_118788;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133511, bytes_133476, "mem_133511")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133511.mem, (int64_t) 0, (int64_t []) {pL_bytes_65441, (int64_t) 1}, (uint8_t *) ext_mem_133508.mem, (int64_t) 0, (int64_t []) {pL_bytes_65441, (int64_t) 1}, (int64_t []) {niz2084U_65436, pL_bytes_65441});
    if (memblock_unref(ctx, &ext_mem_133508, "ext_mem_133508") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133511, "mem_133511") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134042, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133511, "mem_133511") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133882, "mem_param_tmp_133882") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133488, "mem_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133486, "mem_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133484, "mem_param_133484") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133508, "ext_mem_133508") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133509, "ext_mem_133509") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_double(struct futhark_context *ctx, struct memblock *mem_out_p_134043, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_64972, int64_t dz2083U_64973, int64_t incr_64974, int64_t psizze_64975)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * niz2084U_64972;
    bool zzero_118773 = psizze_64975 == (int64_t) 0;
    bool nonzzero_118774 = !zzero_118773;
    bool nonzzero_cert_118775;
    
    if (!nonzzero_118774) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftRelational.fut:50:5-41\n   #2  ftRelational.fut:49:1-50:41\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < niz2084U_64972; i_133300++) {
        int64_t eta_p_118769 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118770 = sub64(eta_p_118769, incr_64974);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118770;
    }
    
    int64_t zm_lhs_118771 = add64(dz2083U_64973, psizze_64975);
    int64_t zs_lhs_118772 = sub64(zm_lhs_118771, (int64_t) 1);
    int64_t m_118776 = sdiv64(zs_lhs_118772, psizze_64975);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133468, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < niz2084U_64972; nest_i_133879++) {
        ((double *) mem_133477.mem)[nest_i_133879] = 0.0;
    }
    
    bool loop_cond_118778 = slt64((int64_t) 0, m_118776);
    bool partitioned_gather_res_118779;
    int64_t partitioned_gather_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_64975, p_118786);
        int64_t min_arg1_118788 = add64(psizze_64975, lower_bound_118787);
        int64_t min_res_118789 = smin64(dz2083U_64973, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, dz2083U_64973);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) dz2083U_64973, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftRelational.fut:50:5-41\n   #2  ftRelational.fut:49:1-50:41\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_64972});
        if (memblock_alloc(ctx, &mem_133487, bytes_133468, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < niz2084U_64972; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133480.mem)[i_133304];
            double eta_p_118806 = ((double *) mem_param_133483.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            double lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftRelational.fut:50:5-41\n   #4  ftRelational.fut:49:1-50:41\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                double tmp_127936 = ((double *) ys_mem_133467.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((double *) mem_133487.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118776);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118818;
        int64_t p_tmp_133885 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133882;
        p_118786 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118779 = loop_while_118783;
    partitioned_gather_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133468, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_64972});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134043, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_double_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134044, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_66944, int64_t n_66945, int64_t incr_66946, int64_t psizze_66947)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_param_tmp_133879;
    
    mem_param_tmp_133879.references = NULL;
    
    struct memblock mem_133486;
    
    mem_133486.references = NULL;
    
    struct memblock mem_133484;
    
    mem_133484.references = NULL;
    
    struct memblock mem_param_133482;
    
    mem_param_133482.references = NULL;
    
    struct memblock mem_param_133479;
    
    mem_param_133479.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133469 = (int64_t) 8 * ni_66944;
    bool zzero_118774 = psizze_66947 == (int64_t) 0;
    bool nonzzero_118775 = !zzero_118774;
    bool nonzzero_cert_118776;
    
    if (!nonzzero_118775) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:43:22-28\n   #1  ftRelational.fut:64:5-50\n   #2  ftRelational.fut:63:1-64:50\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < ni_66944; i_133300++) {
        int64_t eta_p_118770 = ((int64_t *) is_mem_133467.mem)[i_133300];
        int64_t lifted_lambda_res_118771 = sub64(eta_p_118770, incr_66946);
        
        ((int64_t *) mem_133470.mem)[i_133300] = lifted_lambda_res_118771;
    }
    
    int64_t zm_lhs_118772 = add64(n_66945, psizze_66947);
    int64_t zs_lhs_118773 = sub64(zm_lhs_118772, (int64_t) 1);
    int64_t m_118777 = sdiv64(zs_lhs_118773, psizze_66947);
    bool loop_cond_118778 = slt64((int64_t) 0, m_118777);
    bool partitioned_gather_over_array_res_118779;
    int64_t partitioned_gather_over_array_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133479, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133482, &preVals_mem_133466, "preVals_mem_133466") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_66947, p_118786);
        int64_t min_arg1_118788 = add64(psizze_66947, lower_bound_118787);
        int64_t min_res_118789 = smin64(n_66945, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, n_66945);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) n_66945, "].", "-> #0  ftbasics.fut:49:18-45\n   #1  ftRelational.fut:64:5-50\n   #2  ftRelational.fut:63:1-64:50\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133484, bytes_133469, "mem_133484")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133484.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133479.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_66944});
        if (memblock_alloc(ctx, &mem_133486, bytes_133469, "mem_133486")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < ni_66944; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133479.mem)[i_133304];
            double eta_p_118806 = ((double *) mem_param_133482.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            double lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:52:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:50:30-54:6\n   #3  ftRelational.fut:64:5-50\n   #4  ftRelational.fut:63:1-64:50\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                double tmp_127936 = ((double *) ys_mem_133468.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((double *) mem_133486.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118777);
        
        if (memblock_set(ctx, &mem_param_tmp_133879, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133486, "mem_133486") != 0)
            return 1;
        
        bool loop_while_tmp_133881 = loop_cond_118818;
        int64_t p_tmp_133884 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133479, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133482, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133881;
        p_118786 = p_tmp_133884;
    }
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133479, "mem_param_133479") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133497, &mem_param_133482, "mem_param_133482") != 0)
        return 1;
    partitioned_gather_over_array_res_118779 = loop_while_118783;
    partitioned_gather_over_array_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133500, bytes_133469, "mem_133500")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133497.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_66944});
    if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133500, "mem_133500") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134044, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133486, "mem_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133482, "mem_param_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133479, "mem_param_133479") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_float(struct futhark_context *ctx, struct memblock *mem_out_p_134045, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_64692, int64_t dz2083U_64693, int64_t incr_64694, int64_t psizze_64695)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * niz2084U_64692;
    bool zzero_118773 = psizze_64695 == (int64_t) 0;
    bool nonzzero_118774 = !zzero_118773;
    bool nonzzero_cert_118775;
    
    if (!nonzzero_118774) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftRelational.fut:48:5-41\n   #2  ftRelational.fut:47:1-48:41\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133476 = (int64_t) 4 * niz2084U_64692;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < niz2084U_64692; i_133300++) {
        int64_t eta_p_118769 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118770 = sub64(eta_p_118769, incr_64694);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118770;
    }
    
    int64_t zm_lhs_118771 = add64(dz2083U_64693, psizze_64695);
    int64_t zs_lhs_118772 = sub64(zm_lhs_118771, (int64_t) 1);
    int64_t m_118776 = sdiv64(zs_lhs_118772, psizze_64695);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133476, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < niz2084U_64692; nest_i_133879++) {
        ((float *) mem_133477.mem)[nest_i_133879] = 0.0F;
    }
    
    bool loop_cond_118778 = slt64((int64_t) 0, m_118776);
    bool partitioned_gather_res_118779;
    int64_t partitioned_gather_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_64695, p_118786);
        int64_t min_arg1_118788 = add64(psizze_64695, lower_bound_118787);
        int64_t min_res_118789 = smin64(dz2083U_64693, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, dz2083U_64693);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) dz2083U_64693, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftRelational.fut:48:5-41\n   #2  ftRelational.fut:47:1-48:41\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_64692});
        if (memblock_alloc(ctx, &mem_133487, bytes_133476, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < niz2084U_64692; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133480.mem)[i_133304];
            float eta_p_118806 = ((float *) mem_param_133483.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            float lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftRelational.fut:48:5-41\n   #4  ftRelational.fut:47:1-48:41\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                float tmp_127936 = ((float *) ys_mem_133467.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((float *) mem_133487.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118776);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118818;
        int64_t p_tmp_133885 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133882;
        p_118786 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118779 = loop_while_118783;
    partitioned_gather_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133476, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_64692});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134045, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_float_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134046, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_66643, int64_t n_66644, int64_t incr_66645, int64_t psizze_66646)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_param_tmp_133879;
    
    mem_param_tmp_133879.references = NULL;
    
    struct memblock mem_133486;
    
    mem_133486.references = NULL;
    
    struct memblock mem_133484;
    
    mem_133484.references = NULL;
    
    struct memblock mem_param_133482;
    
    mem_param_133482.references = NULL;
    
    struct memblock mem_param_133479;
    
    mem_param_133479.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133469 = (int64_t) 8 * ni_66643;
    bool zzero_118774 = psizze_66646 == (int64_t) 0;
    bool nonzzero_118775 = !zzero_118774;
    bool nonzzero_cert_118776;
    
    if (!nonzzero_118775) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:43:22-28\n   #1  ftRelational.fut:62:5-50\n   #2  ftRelational.fut:61:1-62:50\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133499 = (int64_t) 4 * ni_66643;
    
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < ni_66643; i_133300++) {
        int64_t eta_p_118770 = ((int64_t *) is_mem_133467.mem)[i_133300];
        int64_t lifted_lambda_res_118771 = sub64(eta_p_118770, incr_66645);
        
        ((int64_t *) mem_133470.mem)[i_133300] = lifted_lambda_res_118771;
    }
    
    int64_t zm_lhs_118772 = add64(n_66644, psizze_66646);
    int64_t zs_lhs_118773 = sub64(zm_lhs_118772, (int64_t) 1);
    int64_t m_118777 = sdiv64(zs_lhs_118773, psizze_66646);
    bool loop_cond_118778 = slt64((int64_t) 0, m_118777);
    bool partitioned_gather_over_array_res_118779;
    int64_t partitioned_gather_over_array_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133479, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133482, &preVals_mem_133466, "preVals_mem_133466") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_66646, p_118786);
        int64_t min_arg1_118788 = add64(psizze_66646, lower_bound_118787);
        int64_t min_res_118789 = smin64(n_66644, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, n_66644);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) n_66644, "].", "-> #0  ftbasics.fut:49:18-45\n   #1  ftRelational.fut:62:5-50\n   #2  ftRelational.fut:61:1-62:50\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133484, bytes_133469, "mem_133484")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133484.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133479.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_66643});
        if (memblock_alloc(ctx, &mem_133486, bytes_133499, "mem_133486")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < ni_66643; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133479.mem)[i_133304];
            float eta_p_118806 = ((float *) mem_param_133482.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            float lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:52:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:50:30-54:6\n   #3  ftRelational.fut:62:5-50\n   #4  ftRelational.fut:61:1-62:50\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                float tmp_127936 = ((float *) ys_mem_133468.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((float *) mem_133486.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118777);
        
        if (memblock_set(ctx, &mem_param_tmp_133879, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133486, "mem_133486") != 0)
            return 1;
        
        bool loop_while_tmp_133881 = loop_cond_118818;
        int64_t p_tmp_133884 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133479, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133482, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133881;
        p_118786 = p_tmp_133884;
    }
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133479, "mem_param_133479") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133497, &mem_param_133482, "mem_param_133482") != 0)
        return 1;
    partitioned_gather_over_array_res_118779 = loop_while_118783;
    partitioned_gather_over_array_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133500, bytes_133499, "mem_133500")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133497.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_66643});
    if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133500, "mem_133500") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134046, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133486, "mem_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133482, "mem_param_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133479, "mem_param_133479") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_int(struct futhark_context *ctx, struct memblock *mem_out_p_134047, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_64132, int64_t dz2083U_64133, int64_t incr_64134, int64_t psizze_64135)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * niz2084U_64132;
    bool zzero_118773 = psizze_64135 == (int64_t) 0;
    bool nonzzero_118774 = !zzero_118773;
    bool nonzzero_cert_118775;
    
    if (!nonzzero_118774) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftRelational.fut:44:5-41\n   #2  ftRelational.fut:43:1-44:41\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133476 = (int64_t) 4 * niz2084U_64132;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < niz2084U_64132; i_133300++) {
        int64_t eta_p_118769 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118770 = sub64(eta_p_118769, incr_64134);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118770;
    }
    
    int64_t zm_lhs_118771 = add64(dz2083U_64133, psizze_64135);
    int64_t zs_lhs_118772 = sub64(zm_lhs_118771, (int64_t) 1);
    int64_t m_118776 = sdiv64(zs_lhs_118772, psizze_64135);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133476, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < niz2084U_64132; nest_i_133879++) {
        ((int32_t *) mem_133477.mem)[nest_i_133879] = 0;
    }
    
    bool loop_cond_118778 = slt64((int64_t) 0, m_118776);
    bool partitioned_gather_res_118779;
    int64_t partitioned_gather_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_64135, p_118786);
        int64_t min_arg1_118788 = add64(psizze_64135, lower_bound_118787);
        int64_t min_res_118789 = smin64(dz2083U_64133, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, dz2083U_64133);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) dz2083U_64133, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftRelational.fut:44:5-41\n   #2  ftRelational.fut:43:1-44:41\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_64132});
        if (memblock_alloc(ctx, &mem_133487, bytes_133476, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < niz2084U_64132; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133480.mem)[i_133304];
            int32_t eta_p_118806 = ((int32_t *) mem_param_133483.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            int32_t lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftRelational.fut:44:5-41\n   #4  ftRelational.fut:43:1-44:41\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t tmp_127936 = ((int32_t *) ys_mem_133467.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((int32_t *) mem_133487.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118776);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118818;
        int64_t p_tmp_133885 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133882;
        p_118786 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118779 = loop_while_118783;
    partitioned_gather_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133476, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_64132});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134047, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_int_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134048, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_66041, int64_t n_66042, int64_t incr_66043, int64_t psizze_66044)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_param_tmp_133879;
    
    mem_param_tmp_133879.references = NULL;
    
    struct memblock mem_133486;
    
    mem_133486.references = NULL;
    
    struct memblock mem_133484;
    
    mem_133484.references = NULL;
    
    struct memblock mem_param_133482;
    
    mem_param_133482.references = NULL;
    
    struct memblock mem_param_133479;
    
    mem_param_133479.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133469 = (int64_t) 8 * ni_66041;
    bool zzero_118774 = psizze_66044 == (int64_t) 0;
    bool nonzzero_118775 = !zzero_118774;
    bool nonzzero_cert_118776;
    
    if (!nonzzero_118775) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:43:22-28\n   #1  ftRelational.fut:58:5-50\n   #2  ftRelational.fut:57:1-58:50\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133499 = (int64_t) 4 * ni_66041;
    
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < ni_66041; i_133300++) {
        int64_t eta_p_118770 = ((int64_t *) is_mem_133467.mem)[i_133300];
        int64_t lifted_lambda_res_118771 = sub64(eta_p_118770, incr_66043);
        
        ((int64_t *) mem_133470.mem)[i_133300] = lifted_lambda_res_118771;
    }
    
    int64_t zm_lhs_118772 = add64(n_66042, psizze_66044);
    int64_t zs_lhs_118773 = sub64(zm_lhs_118772, (int64_t) 1);
    int64_t m_118777 = sdiv64(zs_lhs_118773, psizze_66044);
    bool loop_cond_118778 = slt64((int64_t) 0, m_118777);
    bool partitioned_gather_over_array_res_118779;
    int64_t partitioned_gather_over_array_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133479, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133482, &preVals_mem_133466, "preVals_mem_133466") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_66044, p_118786);
        int64_t min_arg1_118788 = add64(psizze_66044, lower_bound_118787);
        int64_t min_res_118789 = smin64(n_66042, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, n_66042);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) n_66042, "].", "-> #0  ftbasics.fut:49:18-45\n   #1  ftRelational.fut:58:5-50\n   #2  ftRelational.fut:57:1-58:50\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133484, bytes_133469, "mem_133484")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133484.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133479.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_66041});
        if (memblock_alloc(ctx, &mem_133486, bytes_133499, "mem_133486")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < ni_66041; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133479.mem)[i_133304];
            int32_t eta_p_118806 = ((int32_t *) mem_param_133482.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            int32_t lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:52:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:50:30-54:6\n   #3  ftRelational.fut:58:5-50\n   #4  ftRelational.fut:57:1-58:50\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t tmp_127936 = ((int32_t *) ys_mem_133468.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((int32_t *) mem_133486.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118777);
        
        if (memblock_set(ctx, &mem_param_tmp_133879, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133486, "mem_133486") != 0)
            return 1;
        
        bool loop_while_tmp_133881 = loop_cond_118818;
        int64_t p_tmp_133884 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133479, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133482, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133881;
        p_118786 = p_tmp_133884;
    }
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133479, "mem_param_133479") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133497, &mem_param_133482, "mem_param_133482") != 0)
        return 1;
    partitioned_gather_over_array_res_118779 = loop_while_118783;
    partitioned_gather_over_array_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133500, bytes_133499, "mem_133500")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133497.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_66041});
    if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133500, "mem_133500") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134048, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133486, "mem_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133482, "mem_param_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133479, "mem_param_133479") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_long(struct futhark_context *ctx, struct memblock *mem_out_p_134049, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_64412, int64_t dz2083U_64413, int64_t incr_64414, int64_t psizze_64415)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * niz2084U_64412;
    bool zzero_118773 = psizze_64415 == (int64_t) 0;
    bool nonzzero_118774 = !zzero_118773;
    bool nonzzero_cert_118775;
    
    if (!nonzzero_118774) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftRelational.fut:46:5-41\n   #2  ftRelational.fut:45:1-46:41\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < niz2084U_64412; i_133300++) {
        int64_t eta_p_118769 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118770 = sub64(eta_p_118769, incr_64414);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118770;
    }
    
    int64_t zm_lhs_118771 = add64(dz2083U_64413, psizze_64415);
    int64_t zs_lhs_118772 = sub64(zm_lhs_118771, (int64_t) 1);
    int64_t m_118776 = sdiv64(zs_lhs_118772, psizze_64415);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133468, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < niz2084U_64412; nest_i_133879++) {
        ((int64_t *) mem_133477.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    bool loop_cond_118778 = slt64((int64_t) 0, m_118776);
    bool partitioned_gather_res_118779;
    int64_t partitioned_gather_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_64415, p_118786);
        int64_t min_arg1_118788 = add64(psizze_64415, lower_bound_118787);
        int64_t min_res_118789 = smin64(dz2083U_64413, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, dz2083U_64413);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) dz2083U_64413, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftRelational.fut:46:5-41\n   #2  ftRelational.fut:45:1-46:41\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_64412});
        if (memblock_alloc(ctx, &mem_133487, bytes_133468, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < niz2084U_64412; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133480.mem)[i_133304];
            int64_t eta_p_118806 = ((int64_t *) mem_param_133483.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            int64_t lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftRelational.fut:46:5-41\n   #4  ftRelational.fut:45:1-46:41\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t tmp_127936 = ((int64_t *) ys_mem_133467.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((int64_t *) mem_133487.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118776);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118818;
        int64_t p_tmp_133885 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133882;
        p_118786 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118779 = loop_while_118783;
    partitioned_gather_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133468, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_64412});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134049, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_long_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134050, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_66342, int64_t n_66343, int64_t incr_66344, int64_t psizze_66345)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_param_tmp_133879;
    
    mem_param_tmp_133879.references = NULL;
    
    struct memblock mem_133486;
    
    mem_133486.references = NULL;
    
    struct memblock mem_133484;
    
    mem_133484.references = NULL;
    
    struct memblock mem_param_133482;
    
    mem_param_133482.references = NULL;
    
    struct memblock mem_param_133479;
    
    mem_param_133479.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133469 = (int64_t) 8 * ni_66342;
    bool zzero_118774 = psizze_66345 == (int64_t) 0;
    bool nonzzero_118775 = !zzero_118774;
    bool nonzzero_cert_118776;
    
    if (!nonzzero_118775) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:43:22-28\n   #1  ftRelational.fut:60:5-50\n   #2  ftRelational.fut:59:1-60:50\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < ni_66342; i_133300++) {
        int64_t eta_p_118770 = ((int64_t *) is_mem_133467.mem)[i_133300];
        int64_t lifted_lambda_res_118771 = sub64(eta_p_118770, incr_66344);
        
        ((int64_t *) mem_133470.mem)[i_133300] = lifted_lambda_res_118771;
    }
    
    int64_t zm_lhs_118772 = add64(n_66343, psizze_66345);
    int64_t zs_lhs_118773 = sub64(zm_lhs_118772, (int64_t) 1);
    int64_t m_118777 = sdiv64(zs_lhs_118773, psizze_66345);
    bool loop_cond_118778 = slt64((int64_t) 0, m_118777);
    bool partitioned_gather_over_array_res_118779;
    int64_t partitioned_gather_over_array_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133479, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133482, &preVals_mem_133466, "preVals_mem_133466") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_66345, p_118786);
        int64_t min_arg1_118788 = add64(psizze_66345, lower_bound_118787);
        int64_t min_res_118789 = smin64(n_66343, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, n_66343);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) n_66343, "].", "-> #0  ftbasics.fut:49:18-45\n   #1  ftRelational.fut:60:5-50\n   #2  ftRelational.fut:59:1-60:50\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133484, bytes_133469, "mem_133484")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133484.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133479.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_66342});
        if (memblock_alloc(ctx, &mem_133486, bytes_133469, "mem_133486")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < ni_66342; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133479.mem)[i_133304];
            int64_t eta_p_118806 = ((int64_t *) mem_param_133482.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            int64_t lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:52:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:50:30-54:6\n   #3  ftRelational.fut:60:5-50\n   #4  ftRelational.fut:59:1-60:50\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t tmp_127936 = ((int64_t *) ys_mem_133468.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((int64_t *) mem_133486.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118777);
        
        if (memblock_set(ctx, &mem_param_tmp_133879, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133486, "mem_133486") != 0)
            return 1;
        
        bool loop_while_tmp_133881 = loop_cond_118818;
        int64_t p_tmp_133884 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133479, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133482, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133881;
        p_118786 = p_tmp_133884;
    }
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133479, "mem_param_133479") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133497, &mem_param_133482, "mem_param_133482") != 0)
        return 1;
    partitioned_gather_over_array_res_118779 = loop_while_118783;
    partitioned_gather_over_array_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133500, bytes_133469, "mem_133500")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133497.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_66342});
    if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133500, "mem_133500") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134050, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133486, "mem_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133482, "mem_param_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133479, "mem_param_133479") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_short(struct futhark_context *ctx, struct memblock *mem_out_p_134051, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t niz2084U_63852, int64_t dz2083U_63853, int64_t incr_63854, int64_t psizze_63855)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * niz2084U_63852;
    bool zzero_118773 = psizze_63855 == (int64_t) 0;
    bool nonzzero_118774 = !zzero_118773;
    bool nonzzero_cert_118775;
    
    if (!nonzzero_118774) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftRelational.fut:42:5-41\n   #2  ftRelational.fut:41:1-42:41\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133476 = (int64_t) 2 * niz2084U_63852;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < niz2084U_63852; i_133300++) {
        int64_t eta_p_118769 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118770 = sub64(eta_p_118769, incr_63854);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118770;
    }
    
    int64_t zm_lhs_118771 = add64(dz2083U_63853, psizze_63855);
    int64_t zs_lhs_118772 = sub64(zm_lhs_118771, (int64_t) 1);
    int64_t m_118776 = sdiv64(zs_lhs_118772, psizze_63855);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133476, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < niz2084U_63852; nest_i_133879++) {
        ((int16_t *) mem_133477.mem)[nest_i_133879] = (int16_t) 0;
    }
    
    bool loop_cond_118778 = slt64((int64_t) 0, m_118776);
    bool partitioned_gather_res_118779;
    int64_t partitioned_gather_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_63855, p_118786);
        int64_t min_arg1_118788 = add64(psizze_63855, lower_bound_118787);
        int64_t min_res_118789 = smin64(dz2083U_63853, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, dz2083U_63853);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) dz2083U_63853, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftRelational.fut:42:5-41\n   #2  ftRelational.fut:41:1-42:41\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_63852});
        if (memblock_alloc(ctx, &mem_133487, bytes_133476, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < niz2084U_63852; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133480.mem)[i_133304];
            int16_t eta_p_118806 = ((int16_t *) mem_param_133483.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            int16_t lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftRelational.fut:42:5-41\n   #4  ftRelational.fut:41:1-42:41\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int16_t tmp_127936 = ((int16_t *) ys_mem_133467.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((int16_t *) mem_133487.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118776);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118818;
        int64_t p_tmp_133885 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133882;
        p_118786 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118779 = loop_while_118783;
    partitioned_gather_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133476, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_2b(ctx, 1, (uint16_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint16_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {niz2084U_63852});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134051, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_gather_payloads_short_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134052, struct memblock preVals_mem_133466, struct memblock is_mem_133467, struct memblock ys_mem_133468, int64_t ni_65740, int64_t n_65741, int64_t incr_65742, int64_t psizze_65743)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_param_tmp_133879;
    
    mem_param_tmp_133879.references = NULL;
    
    struct memblock mem_133486;
    
    mem_133486.references = NULL;
    
    struct memblock mem_133484;
    
    mem_133484.references = NULL;
    
    struct memblock mem_param_133482;
    
    mem_param_133482.references = NULL;
    
    struct memblock mem_param_133479;
    
    mem_param_133479.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133469 = (int64_t) 8 * ni_65740;
    bool zzero_118774 = psizze_65743 == (int64_t) 0;
    bool nonzzero_118775 = !zzero_118774;
    bool nonzzero_cert_118776;
    
    if (!nonzzero_118775) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:43:22-28\n   #1  ftRelational.fut:56:5-50\n   #2  ftRelational.fut:55:1-56:50\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133499 = (int64_t) 2 * ni_65740;
    
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < ni_65740; i_133300++) {
        int64_t eta_p_118770 = ((int64_t *) is_mem_133467.mem)[i_133300];
        int64_t lifted_lambda_res_118771 = sub64(eta_p_118770, incr_65742);
        
        ((int64_t *) mem_133470.mem)[i_133300] = lifted_lambda_res_118771;
    }
    
    int64_t zm_lhs_118772 = add64(n_65741, psizze_65743);
    int64_t zs_lhs_118773 = sub64(zm_lhs_118772, (int64_t) 1);
    int64_t m_118777 = sdiv64(zs_lhs_118773, psizze_65743);
    bool loop_cond_118778 = slt64((int64_t) 0, m_118777);
    bool partitioned_gather_over_array_res_118779;
    int64_t partitioned_gather_over_array_res_118782;
    bool loop_while_118783;
    int64_t p_118786;
    
    if (memblock_set(ctx, &mem_param_133479, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133482, &preVals_mem_133466, "preVals_mem_133466") != 0)
        return 1;
    loop_while_118783 = loop_cond_118778;
    p_118786 = (int64_t) 0;
    while (loop_while_118783) {
        int64_t lower_bound_118787 = mul64(psizze_65743, p_118786);
        int64_t min_arg1_118788 = add64(psizze_65743, lower_bound_118787);
        int64_t min_res_118789 = smin64(n_65741, min_arg1_118788);
        int64_t j_m_i_118790 = sub64(min_res_118789, lower_bound_118787);
        bool empty_slice_118791 = j_m_i_118790 == (int64_t) 0;
        int64_t m_118792 = sub64(j_m_i_118790, (int64_t) 1);
        int64_t i_p_m_t_s_118793 = add64(lower_bound_118787, m_118792);
        bool zzero_leq_i_p_m_t_s_118794 = sle64((int64_t) 0, i_p_m_t_s_118793);
        bool i_p_m_t_s_leq_w_118795 = slt64(i_p_m_t_s_118793, n_65741);
        bool zzero_lte_i_118796 = sle64((int64_t) 0, lower_bound_118787);
        bool i_lte_j_118797 = sle64(lower_bound_118787, min_res_118789);
        bool y_118798 = i_p_m_t_s_leq_w_118795 && zzero_lte_i_118796;
        bool y_118799 = zzero_leq_i_p_m_t_s_118794 && y_118798;
        bool forwards_ok_118800 = i_lte_j_118797 && y_118799;
        bool ok_or_empty_118801 = empty_slice_118791 || forwards_ok_118800;
        bool index_certs_118802;
        
        if (!ok_or_empty_118801) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118787, ":", (long long) min_res_118789, "] out of bounds for array of shape [", (long long) n_65741, "].", "-> #0  ftbasics.fut:49:18-45\n   #1  ftRelational.fut:56:5-50\n   #2  ftRelational.fut:55:1-56:50\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133484, bytes_133469, "mem_133484")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133484.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133479.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_65740});
        if (memblock_alloc(ctx, &mem_133486, bytes_133499, "mem_133486")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < ni_65740; i_133304++) {
            int64_t eta_p_118805 = ((int64_t *) mem_param_133479.mem)[i_133304];
            int16_t eta_p_118806 = ((int16_t *) mem_param_133482.mem)[i_133304];
            bool cond_118807 = sle64(lower_bound_118787, eta_p_118805);
            bool cond_t_res_118808 = slt64(eta_p_118805, min_res_118789);
            bool x_118809 = cond_118807 && cond_t_res_118808;
            int16_t lifted_lambda_res_118810;
            
            if (x_118809) {
                int64_t tmp_127931 = sub64(eta_p_118805, lower_bound_118787);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118790);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118790, "].", "-> #0  ftbasics.fut:52:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:50:30-54:6\n   #3  ftRelational.fut:56:5-50\n   #4  ftRelational.fut:55:1-56:50\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int16_t tmp_127936 = ((int16_t *) ys_mem_133468.mem)[eta_p_118805];
                
                lifted_lambda_res_118810 = tmp_127936;
            } else {
                lifted_lambda_res_118810 = eta_p_118806;
            }
            ((int16_t *) mem_133486.mem)[i_133304] = lifted_lambda_res_118810;
        }
        
        int64_t tmp_118817 = add64((int64_t) 1, p_118786);
        bool loop_cond_118818 = slt64(tmp_118817, m_118777);
        
        if (memblock_set(ctx, &mem_param_tmp_133879, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133486, "mem_133486") != 0)
            return 1;
        
        bool loop_while_tmp_133881 = loop_cond_118818;
        int64_t p_tmp_133884 = tmp_118817;
        
        if (memblock_set(ctx, &mem_param_133479, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133482, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        loop_while_118783 = loop_while_tmp_133881;
        p_118786 = p_tmp_133884;
    }
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133479, "mem_param_133479") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133497, &mem_param_133482, "mem_param_133482") != 0)
        return 1;
    partitioned_gather_over_array_res_118779 = loop_while_118783;
    partitioned_gather_over_array_res_118782 = p_118786;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133500, bytes_133499, "mem_133500")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_2b(ctx, 1, (uint16_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint16_t *) ext_mem_133497.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ni_65740});
    if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133500, "mem_133500") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134052, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133879, "mem_param_tmp_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133486, "mem_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133484, "mem_133484") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133482, "mem_param_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133479, "mem_param_133479") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_double(struct futhark_context *ctx, struct memblock *mem_out_p_134053, struct memblock *mem_out_p_134054, struct memblock *mem_out_p_134055, int64_t *out_prim_out_134056, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_109429, int64_t nS_109430, int64_t offset_R_109433, int64_t offset_S_109434, int64_t partitionSizze_109435, int64_t scatter_psizze_109436)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133534_cached_sizze_134057 = 0;
    unsigned char *mem_133534 = NULL;
    int64_t mem_133536_cached_sizze_134058 = 0;
    unsigned char *mem_133536 = NULL;
    int64_t mem_133538_cached_sizze_134059 = 0;
    unsigned char *mem_133538 = NULL;
    int64_t mem_133540_cached_sizze_134060 = 0;
    unsigned char *mem_133540 = NULL;
    int64_t mem_133542_cached_sizze_134061 = 0;
    unsigned char *mem_133542 = NULL;
    int64_t mem_133574_cached_sizze_134062 = 0;
    unsigned char *mem_133574 = NULL;
    int64_t mem_133576_cached_sizze_134063 = 0;
    unsigned char *mem_133576 = NULL;
    int64_t mem_133584_cached_sizze_134064 = 0;
    unsigned char *mem_133584 = NULL;
    struct memblock mem_133590;
    
    mem_133590.references = NULL;
    
    struct memblock mem_133588;
    
    mem_133588.references = NULL;
    
    struct memblock mem_133586;
    
    mem_133586.references = NULL;
    
    struct memblock ext_mem_133468;
    
    ext_mem_133468.references = NULL;
    
    struct memblock mem_param_tmp_133884;
    
    mem_param_tmp_133884.references = NULL;
    
    struct memblock mem_param_tmp_133883;
    
    mem_param_tmp_133883.references = NULL;
    
    struct memblock mem_133526;
    
    mem_133526.references = NULL;
    
    struct memblock mem_133524;
    
    mem_133524.references = NULL;
    
    struct memblock mem_param_tmp_133893;
    
    mem_param_tmp_133893.references = NULL;
    
    struct memblock mem_param_tmp_133892;
    
    mem_param_tmp_133892.references = NULL;
    
    struct memblock mem_133492;
    
    mem_133492.references = NULL;
    
    struct memblock mem_133490;
    
    mem_133490.references = NULL;
    
    struct memblock ext_mem_133507;
    
    ext_mem_133507.references = NULL;
    
    struct memblock ext_mem_133510;
    
    ext_mem_133510.references = NULL;
    
    struct memblock ext_mem_133513;
    
    ext_mem_133513.references = NULL;
    
    struct memblock ext_mem_133516;
    
    ext_mem_133516.references = NULL;
    
    struct memblock mem_param_133488;
    
    mem_param_133488.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133521;
    
    ext_mem_133521.references = NULL;
    
    struct memblock ext_mem_133522;
    
    ext_mem_133522.references = NULL;
    
    struct memblock mem_133482;
    
    mem_133482.references = NULL;
    
    struct memblock mem_133480;
    
    mem_133480.references = NULL;
    
    struct memblock mem_param_133478;
    
    mem_param_133478.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock ext_mem_133531;
    
    ext_mem_133531.references = NULL;
    
    struct memblock ext_mem_133532;
    
    ext_mem_133532.references = NULL;
    
    struct memblock mem_133472;
    
    mem_133472.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t prim_out_133880;
    int64_t zm_lhs_120281 = add64(nR_109429, partitionSizze_109435);
    int64_t zs_lhs_120282 = sub64(zm_lhs_120281, (int64_t) 1);
    bool zzero_120283 = partitionSizze_109435 == (int64_t) 0;
    bool nonzzero_120284 = !zzero_120283;
    bool nonzzero_cert_120285;
    
    if (!nonzzero_120284) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftSMJ.fut:271:43-57\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t numIter_R_120286 = sdiv64(zs_lhs_120282, partitionSizze_109435);
    int64_t zm_lhs_120287 = add64(nS_109430, partitionSizze_109435);
    int64_t zs_lhs_120288 = sub64(zm_lhs_120287, (int64_t) 1);
    int64_t numIter_S_120289 = sdiv64(zs_lhs_120288, partitionSizze_109435);
    int64_t bytes_133469 = (int64_t) 8 * nR_109429;
    
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133881 = 0; nest_i_133881 < nR_109429; nest_i_133881++) {
        ((int64_t *) mem_133470.mem)[nest_i_133881] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133472, bytes_133469, "mem_133472")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133882 = 0; nest_i_133882 < nR_109429; nest_i_133882++) {
        ((int64_t *) mem_133472.mem)[nest_i_133882] = (int64_t) 0;
    }
    
    bool loop_cond_120293 = slt64((int64_t) 0, numIter_R_120286);
    bool defunc_0_mergeJoin_res_120294;
    int64_t defunc_0_mergeJoin_res_120295;
    int64_t defunc_0_mergeJoin_res_120298;
    bool loop_while_120299;
    int64_t iter_120300;
    int64_t first_relevant_in_S_120303;
    
    if (memblock_set(ctx, &mem_param_133475, &mem_133472, "mem_133472") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133478, &mem_133470, "mem_133470") != 0)
        return 1;
    loop_while_120299 = loop_cond_120293;
    iter_120300 = (int64_t) 0;
    first_relevant_in_S_120303 = (int64_t) 0;
    while (loop_while_120299) {
        int64_t tR_start_120304 = mul64(partitionSizze_109435, iter_120300);
        int64_t min_arg1_120305 = add64(partitionSizze_109435, tR_start_120304);
        int64_t min_res_120306 = smin64(nR_109429, min_arg1_120305);
        int64_t dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 = sub64(min_res_120306, tR_start_120304);
        bool empty_slice_120308 = dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 == (int64_t) 0;
        int64_t m_120309 = sub64(dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, (int64_t) 1);
        int64_t i_p_m_t_s_120310 = add64(tR_start_120304, m_120309);
        bool zzero_leq_i_p_m_t_s_120311 = sle64((int64_t) 0, i_p_m_t_s_120310);
        bool i_p_m_t_s_leq_w_120312 = slt64(i_p_m_t_s_120310, nR_109429);
        bool zzero_lte_i_120313 = sle64((int64_t) 0, tR_start_120304);
        bool i_lte_j_120314 = sle64(tR_start_120304, min_res_120306);
        bool y_120315 = i_p_m_t_s_leq_w_120312 && zzero_lte_i_120313;
        bool y_120316 = zzero_leq_i_p_m_t_s_120311 && y_120315;
        bool forwards_ok_120317 = i_lte_j_120314 && y_120316;
        bool ok_or_empty_120318 = empty_slice_120308 || forwards_ok_120317;
        bool index_certs_120319;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_109429, "].", "-> #0  ftSMJ.fut:278:17-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t bytes_133479 = (int64_t) 8 * dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307;
        bool cond_120323 = slt64(first_relevant_in_S_120303, numIter_S_120289);
        bool y_120324 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool loop_not_taken_120325 = !cond_120323;
        bool protect_assert_disj_120326 = y_120324 || loop_not_taken_120325;
        bool index_certs_120327;
        
        if (!protect_assert_disj_120326) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:293:26-34\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool x_120330 = sle64((int64_t) 0, m_120309);
        bool y_120331 = slt64(m_120309, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool bounds_check_120332 = x_120330 && y_120331;
        bool protect_assert_disj_120333 = loop_not_taken_120325 || bounds_check_120332;
        bool index_certs_120334;
        
        if (!protect_assert_disj_120333) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:294:42-61\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool index_certs_120531;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_109429, "].", "-> #0  ftSMJ.fut:199:15-63\n   #1  ftSMJ.fut:304:20-64\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:200:78-81\n   #4  ftRelational.fut:191:1-200:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133480, bytes_133479, "mem_133480")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133890 = 0; nest_i_133890 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133890++) {
            ((int64_t *) mem_133480.mem)[nest_i_133890] = (int64_t) -1;
        }
        if (memblock_alloc(ctx, &mem_133482, bytes_133479, "mem_133482")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133891 = 0; nest_i_133891 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133891++) {
            ((int64_t *) mem_133482.mem)[nest_i_133891] = (int64_t) 0;
        }
        
        double gt_lhs_120328;
        
        if (cond_120323) {
            double x_128449 = ((double *) tR_mem_133466.mem)[tR_start_120304];
            
            gt_lhs_120328 = x_128449;
        } else {
            gt_lhs_120328 = 0.0;
        }
        
        double gt_rhs_120335;
        
        if (cond_120323) {
            double x_128450 = ((double *) tR_mem_133466.mem)[i_p_m_t_s_120310];
            
            gt_rhs_120335 = x_128450;
        } else {
            gt_rhs_120335 = 0.0;
        }
        
        int64_t ext_133520;
        int64_t ext_133519;
        int64_t ext_133518;
        int64_t ext_133517;
        bool loopres_120337;
        int64_t loopres_120338;
        int64_t loopres_120341;
        bool loop_while_120342;
        int64_t s_iter_120343;
        int64_t minRelevant_120346;
        int64_t ctx_param_ext_133483;
        int64_t ctx_param_ext_133484;
        int64_t ctx_param_ext_133486;
        int64_t ctx_param_ext_133487;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133488, &mem_133480, "mem_133480") != 0)
            return 1;
        ctx_param_ext_133483 = (int64_t) 0;
        ctx_param_ext_133484 = (int64_t) 1;
        ctx_param_ext_133486 = (int64_t) 0;
        ctx_param_ext_133487 = (int64_t) 1;
        loop_while_120342 = cond_120323;
        s_iter_120343 = first_relevant_in_S_120303;
        minRelevant_120346 = first_relevant_in_S_120303;
        while (loop_while_120342) {
            int64_t tS_start_120347 = mul64(partitionSizze_109435, s_iter_120343);
            int64_t min_arg1_120348 = add64(partitionSizze_109435, tS_start_120347);
            int64_t min_res_120349 = smin64(nS_109430, min_arg1_120348);
            int64_t dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 = sub64(min_res_120349, tS_start_120347);
            bool empty_slice_120351 = dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 == (int64_t) 0;
            int64_t m_120352 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 1);
            int64_t i_p_m_t_s_120353 = add64(tS_start_120347, m_120352);
            bool zzero_leq_i_p_m_t_s_120354 = sle64((int64_t) 0, i_p_m_t_s_120353);
            bool i_p_m_t_s_leq_w_120355 = slt64(i_p_m_t_s_120353, nS_109430);
            bool zzero_lte_i_120356 = sle64((int64_t) 0, tS_start_120347);
            bool i_lte_j_120357 = sle64(tS_start_120347, min_res_120349);
            bool y_120358 = i_p_m_t_s_leq_w_120355 && zzero_lte_i_120356;
            bool y_120359 = zzero_leq_i_p_m_t_s_120354 && y_120358;
            bool forwards_ok_120360 = i_lte_j_120357 && y_120359;
            bool ok_or_empty_120361 = empty_slice_120351 || forwards_ok_120360;
            bool index_certs_120362;
            
            if (!ok_or_empty_120361) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tS_start_120347, ":", (long long) min_res_120349, "] out of bounds for array of shape [", (long long) nS_109430, "].", "-> #0  ftSMJ.fut:291:19-38\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool x_120363 = sle64((int64_t) 0, m_120352);
            bool y_120364 = slt64(m_120352, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool bounds_check_120365 = x_120363 && y_120364;
            bool index_certs_120366;
            
            if (!bounds_check_120365) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120352, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:293:40-59\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_120369 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool index_certs_120370;
            
            if (!y_120369) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:294:28-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            double gt_rhs_120367 = ((double *) tS_mem_133467.mem)[i_p_m_t_s_120353];
            bool defunc_0_gt_res_120368 = gt_rhs_120367 < gt_lhs_120328;
            double gt_lhs_120371 = ((double *) tS_mem_133467.mem)[tS_start_120347];
            bool defunc_0_gt_res_120372 = gt_rhs_120335 < gt_lhs_120371;
            bool thisStillRel_120373 = !defunc_0_gt_res_120372;
            int64_t ext_133509;
            
            if (defunc_0_gt_res_120372) {
                ext_133509 = ctx_param_ext_133483;
            } else {
                ext_133509 = (int64_t) 0;
            }
            
            int64_t ext_133508;
            
            if (defunc_0_gt_res_120372) {
                ext_133508 = ctx_param_ext_133484;
            } else {
                ext_133508 = (int64_t) 1;
            }
            
            int64_t ext_133506;
            
            if (defunc_0_gt_res_120372) {
                ext_133506 = ctx_param_ext_133486;
            } else {
                ext_133506 = (int64_t) 0;
            }
            
            int64_t ext_133505;
            
            if (defunc_0_gt_res_120372) {
                ext_133505 = ctx_param_ext_133487;
            } else {
                ext_133505 = (int64_t) 1;
            }
            
            int64_t ext_133515;
            
            if (defunc_0_gt_res_120368) {
                ext_133515 = ctx_param_ext_133483;
            } else {
                ext_133515 = ext_133509;
            }
            
            int64_t ext_133514;
            
            if (defunc_0_gt_res_120368) {
                ext_133514 = ctx_param_ext_133484;
            } else {
                ext_133514 = ext_133508;
            }
            
            int64_t ext_133512;
            
            if (defunc_0_gt_res_120368) {
                ext_133512 = ctx_param_ext_133486;
            } else {
                ext_133512 = ext_133506;
            }
            
            int64_t ext_133511;
            
            if (defunc_0_gt_res_120368) {
                ext_133511 = ctx_param_ext_133487;
            } else {
                ext_133511 = ext_133505;
            }
            
            int64_t loopres_120374;
            bool loopres_120377;
            int64_t loopres_120378;
            
            if (defunc_0_gt_res_120368) {
                int64_t tmp_128451 = add64((int64_t) 1, s_iter_120343);
                
                if (memblock_set(ctx, &ext_mem_133516, &mem_param_133485, "mem_param_133485") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &mem_param_133488, "mem_param_133488") != 0)
                    return 1;
                loopres_120374 = tmp_128451;
                loopres_120377 = 1;
                loopres_120378 = tmp_128451;
            } else {
                int64_t loopres_f_res_120380;
                bool loopres_f_res_120383;
                
                if (defunc_0_gt_res_120372) {
                    if (memblock_set(ctx, &ext_mem_133510, &mem_param_133485, "mem_param_133485") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_param_133488, "mem_param_133488") != 0)
                        return 1;
                    loopres_f_res_120380 = s_iter_120343;
                    loopres_f_res_120383 = thisStillRel_120373;
                } else {
                    bool index_certs_120384;
                    
                    if (!bounds_check_120332) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:298:50-69\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    double gt_rhs_120385 = ((double *) tR_mem_133466.mem)[i_p_m_t_s_120310];
                    bool defunc_0_gt_res_120386 = gt_rhs_120385 < gt_rhs_120367;
                    bool nextRel_120387 = !defunc_0_gt_res_120386;
                    int64_t find_joinTuples_arg3_120388 = add64(offset_S_109434, tS_start_120347);
                    int64_t max_arg1_120389 = sdiv64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 2);
                    int64_t max_res_120390 = smax64((int64_t) 1, max_arg1_120389);
                    bool loop_cond_120391 = slt64((int64_t) 0, max_res_120390);
                    
                    if (memblock_alloc(ctx, &mem_133490, bytes_133479, "mem_133490")) {
                        err = 1;
                        goto cleanup;
                    }
                    if (memblock_alloc(ctx, &mem_133492, bytes_133479, "mem_133492")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t i_133302 = 0; i_133302 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; i_133302++) {
                        int64_t eta_p_128226 = ((int64_t *) mem_param_133485.mem)[ctx_param_ext_133483 + i_133302 * ctx_param_ext_133484];
                        int64_t slice_133434 = tR_start_120304 + i_133302;
                        double eta_p_128227 = ((double *) tR_mem_133466.mem)[slice_133434];
                        int64_t eta_p_128228 = ((int64_t *) mem_param_133488.mem)[ctx_param_ext_133486 + i_133302 * ctx_param_ext_133487];
                        bool defunc_0_f_res_128229;
                        int64_t defunc_0_f_res_128230;
                        int64_t defunc_0_f_res_128231;
                        bool loop_while_128232;
                        int64_t first_match_128233;
                        int64_t step_128234;
                        
                        loop_while_128232 = loop_cond_120391;
                        first_match_128233 = (int64_t) 0;
                        step_128234 = max_res_120390;
                        while (loop_while_128232) {
                            bool x_128235 = sle64((int64_t) 0, first_match_128233);
                            bool y_128236 = slt64(first_match_128233, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                            bool bounds_check_128237 = x_128235 && y_128236;
                            bool index_certs_128238;
                            
                            if (!bounds_check_128237) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) first_match_128233, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:219:20-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:200:78-81\n   #4  ftRelational.fut:191:1-200:81\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128239 = tS_start_120347 + first_match_128233;
                            double sv_128240 = ((double *) tS_mem_133467.mem)[slice_128239];
                            bool cond_128241 = first_match_128233 == (int64_t) 0;
                            double pv_128242;
                            
                            if (cond_128241) {
                                pv_128242 = sv_128240;
                            } else {
                                int64_t tmp_128243 = sub64(first_match_128233, (int64_t) 1);
                                bool x_128244 = sle64((int64_t) 0, tmp_128243);
                                bool y_128245 = slt64(tmp_128243, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128246 = x_128244 && y_128245;
                                bool index_certs_128247;
                                
                                if (!bounds_check_128246) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128243, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:220:51-68\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:200:78-81\n   #4  ftRelational.fut:191:1-200:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128248 = tS_start_120347 + tmp_128243;
                                double pv_f_res_128249 = ((double *) tS_mem_133467.mem)[slice_128248];
                                
                                pv_128242 = pv_f_res_128249;
                            }
                            
                            bool cond_128250 = first_match_128233 == m_120352;
                            double nv_128251;
                            
                            if (cond_128250) {
                                nv_128251 = sv_128240;
                            } else {
                                int64_t tmp_128252 = add64((int64_t) 1, first_match_128233);
                                bool x_128253 = sle64((int64_t) 0, tmp_128252);
                                bool y_128254 = slt64(tmp_128252, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128255 = x_128253 && y_128254;
                                bool index_certs_128256;
                                
                                if (!bounds_check_128255) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128252, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:221:54-71\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:200:78-81\n   #4  ftRelational.fut:191:1-200:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128257 = tS_start_120347 + tmp_128252;
                                double nv_f_res_128258 = ((double *) tS_mem_133467.mem)[slice_128257];
                                
                                nv_128251 = nv_f_res_128258;
                            }
                            
                            bool defunc_0_eq_res_128259 = sv_128240 == eta_p_128227;
                            bool defunc_0_gt_res_128260 = pv_128242 < eta_p_128227;
                            bool x_128261 = !cond_128241;
                            bool y_128262 = defunc_0_gt_res_128260 && x_128261;
                            bool cond_t_res_128263 = cond_128241 || y_128262;
                            bool x_128264 = defunc_0_eq_res_128259 && cond_t_res_128263;
                            int64_t loopres_128265;
                            int64_t loopres_128266;
                            
                            if (x_128264) {
                                loopres_128265 = first_match_128233;
                                loopres_128266 = (int64_t) 0;
                            } else {
                                int64_t loopres_f_res_128267;
                                int64_t loopres_f_res_128268;
                                
                                if (defunc_0_eq_res_128259) {
                                    int64_t tmp_128452 = sub64(first_match_128233, step_128234);
                                    int64_t max_arg1_128453 = sdiv64(step_128234, (int64_t) 2);
                                    int64_t max_res_128454 = smax64((int64_t) 1, max_arg1_128453);
                                    
                                    loopres_f_res_128267 = tmp_128452;
                                    loopres_f_res_128268 = max_res_128454;
                                } else {
                                    bool defunc_0_gt_res_128272 = eta_p_128227 < sv_128240;
                                    int64_t loopres_f_res_f_res_128273;
                                    int64_t loopres_f_res_f_res_128274;
                                    
                                    if (defunc_0_gt_res_128272) {
                                        int64_t loopres_f_res_f_res_t_res_128455;
                                        int64_t loopres_f_res_f_res_t_res_128456;
                                        
                                        if (cond_t_res_128263) {
                                            loopres_f_res_f_res_t_res_128455 = (int64_t) -1;
                                            loopres_f_res_f_res_t_res_128456 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128457 = sub64(first_match_128233, step_128234);
                                            int64_t max_arg1_128458 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128459 = smax64((int64_t) 1, max_arg1_128458);
                                            
                                            loopres_f_res_f_res_t_res_128455 = tmp_128457;
                                            loopres_f_res_f_res_t_res_128456 = max_res_128459;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_t_res_128455;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_t_res_128456;
                                    } else {
                                        bool defunc_0_gt_res_128282 = eta_p_128227 < nv_128251;
                                        bool x_128283 = !cond_128250;
                                        bool y_128284 = defunc_0_gt_res_128282 && x_128283;
                                        bool cond_128285 = cond_128250 || y_128284;
                                        int64_t loopres_f_res_f_res_f_res_128286;
                                        int64_t loopres_f_res_f_res_f_res_128287;
                                        
                                        if (cond_128285) {
                                            loopres_f_res_f_res_f_res_128286 = (int64_t) -1;
                                            loopres_f_res_f_res_f_res_128287 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128288 = add64(first_match_128233, step_128234);
                                            int64_t max_arg1_128289 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128290 = smax64((int64_t) 1, max_arg1_128289);
                                            
                                            loopres_f_res_f_res_f_res_128286 = tmp_128288;
                                            loopres_f_res_f_res_f_res_128287 = max_res_128290;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_f_res_128286;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_f_res_128287;
                                    }
                                    loopres_f_res_128267 = loopres_f_res_f_res_128273;
                                    loopres_f_res_128268 = loopres_f_res_f_res_128274;
                                }
                                loopres_128265 = loopres_f_res_128267;
                                loopres_128266 = loopres_f_res_128268;
                            }
                            
                            bool loop_cond_128291 = slt64((int64_t) 0, loopres_128266);
                            bool loop_while_tmp_133905 = loop_cond_128291;
                            int64_t first_match_tmp_133906 = loopres_128265;
                            int64_t step_tmp_133907 = loopres_128266;
                            
                            loop_while_128232 = loop_while_tmp_133905;
                            first_match_128233 = first_match_tmp_133906;
                            step_128234 = step_tmp_133907;
                        }
                        defunc_0_f_res_128229 = loop_while_128232;
                        defunc_0_f_res_128230 = first_match_128233;
                        defunc_0_f_res_128231 = step_128234;
                        
                        int64_t zs_lhs_128292 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, defunc_0_f_res_128230);
                        int64_t max_arg1_128293 = sdiv64(zs_lhs_128292, (int64_t) 2);
                        int64_t max_res_128294 = smax64((int64_t) 1, max_arg1_128293);
                        bool cond_128295 = defunc_0_f_res_128230 == (int64_t) -1;
                        int64_t defunc_0_f_res_128296;
                        
                        if (cond_128295) {
                            defunc_0_f_res_128296 = (int64_t) -1;
                        } else {
                            bool loop_cond_128298 = slt64((int64_t) 0, max_res_128294);
                            bool defunc_0_f_res_f_res_128299;
                            int64_t defunc_0_f_res_f_res_128300;
                            int64_t defunc_0_f_res_f_res_128301;
                            bool loop_while_128302;
                            int64_t last_match_128303;
                            int64_t step_128304;
                            
                            loop_while_128302 = loop_cond_128298;
                            last_match_128303 = m_120352;
                            step_128304 = max_res_128294;
                            while (loop_while_128302) {
                                bool x_128305 = sle64((int64_t) 0, last_match_128303);
                                bool y_128306 = slt64(last_match_128303, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128307 = x_128305 && y_128306;
                                bool index_certs_128308;
                                
                                if (!bounds_check_128307) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) last_match_128303, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:240:20-34\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:200:78-81\n   #4  ftRelational.fut:191:1-200:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128309 = tS_start_120347 + last_match_128303;
                                double sv_128310 = ((double *) tS_mem_133467.mem)[slice_128309];
                                bool cond_128311 = last_match_128303 == m_120352;
                                double nv_128312;
                                
                                if (cond_128311) {
                                    nv_128312 = sv_128310;
                                } else {
                                    int64_t tmp_128313 = add64((int64_t) 1, last_match_128303);
                                    bool x_128314 = sle64((int64_t) 0, tmp_128313);
                                    bool y_128315 = slt64(tmp_128313, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                    bool bounds_check_128316 = x_128314 && y_128315;
                                    bool index_certs_128317;
                                    
                                    if (!bounds_check_128316) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128313, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:241:53-69\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:200:78-81\n   #4  ftRelational.fut:191:1-200:81\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128318 = tS_start_120347 + tmp_128313;
                                    double nv_f_res_128319 = ((double *) tS_mem_133467.mem)[slice_128318];
                                    
                                    nv_128312 = nv_f_res_128319;
                                }
                                
                                bool defunc_0_eq_res_128320 = sv_128310 == eta_p_128227;
                                bool defunc_0_gt_res_128321 = eta_p_128227 < nv_128312;
                                bool x_128322 = !cond_128311;
                                bool y_128323 = defunc_0_gt_res_128321 && x_128322;
                                bool cond_t_res_128324 = cond_128311 || y_128323;
                                bool x_128325 = defunc_0_eq_res_128320 && cond_t_res_128324;
                                int64_t loopres_128326;
                                int64_t loopres_128327;
                                
                                if (x_128325) {
                                    loopres_128326 = last_match_128303;
                                    loopres_128327 = (int64_t) 0;
                                } else {
                                    int64_t loopres_f_res_128328;
                                    int64_t loopres_f_res_128329;
                                    
                                    if (defunc_0_eq_res_128320) {
                                        int64_t tmp_128460 = add64(last_match_128303, step_128304);
                                        int64_t max_arg1_128461 = sdiv64(step_128304, (int64_t) 2);
                                        int64_t max_res_128462 = smax64((int64_t) 1, max_arg1_128461);
                                        
                                        loopres_f_res_128328 = tmp_128460;
                                        loopres_f_res_128329 = max_res_128462;
                                    } else {
                                        bool defunc_0_gt_res_128333 = eta_p_128227 < sv_128310;
                                        int64_t loopres_f_res_f_res_128334;
                                        int64_t loopres_f_res_f_res_128335;
                                        
                                        if (defunc_0_gt_res_128333) {
                                            int64_t tmp_128463 = sub64(last_match_128303, step_128304);
                                            int64_t max_arg1_128464 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128465 = smax64((int64_t) 1, max_arg1_128464);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128463;
                                            loopres_f_res_f_res_128335 = max_res_128465;
                                        } else {
                                            int64_t tmp_128339 = add64(last_match_128303, step_128304);
                                            int64_t max_arg1_128340 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128341 = smax64((int64_t) 1, max_arg1_128340);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128339;
                                            loopres_f_res_f_res_128335 = max_res_128341;
                                        }
                                        loopres_f_res_128328 = loopres_f_res_f_res_128334;
                                        loopres_f_res_128329 = loopres_f_res_f_res_128335;
                                    }
                                    loopres_128326 = loopres_f_res_128328;
                                    loopres_128327 = loopres_f_res_128329;
                                }
                                
                                bool loop_cond_128342 = slt64((int64_t) 0, loopres_128327);
                                bool loop_while_tmp_133908 = loop_cond_128342;
                                int64_t last_match_tmp_133909 = loopres_128326;
                                int64_t step_tmp_133910 = loopres_128327;
                                
                                loop_while_128302 = loop_while_tmp_133908;
                                last_match_128303 = last_match_tmp_133909;
                                step_128304 = step_tmp_133910;
                            }
                            defunc_0_f_res_f_res_128299 = loop_while_128302;
                            defunc_0_f_res_f_res_128300 = last_match_128303;
                            defunc_0_f_res_f_res_128301 = step_128304;
                            defunc_0_f_res_128296 = defunc_0_f_res_f_res_128300;
                        }
                        
                        bool cond_128343 = slt64(defunc_0_f_res_128230, (int64_t) 0);
                        int64_t cm_128344;
                        
                        if (cond_128343) {
                            cm_128344 = (int64_t) 0;
                        } else {
                            int64_t zp_lhs_128345 = sub64(defunc_0_f_res_128296, defunc_0_f_res_128230);
                            int64_t cm_f_res_128346 = add64((int64_t) 1, zp_lhs_128345);
                            
                            cm_128344 = cm_f_res_128346;
                        }
                        
                        int64_t lifted_lambda_res_128350;
                        
                        if (cond_128343) {
                            lifted_lambda_res_128350 = defunc_0_f_res_128230;
                        } else {
                            int64_t lifted_lambda_res_f_res_128351 = add64(find_joinTuples_arg3_120388, defunc_0_f_res_128230);
                            
                            lifted_lambda_res_128350 = lifted_lambda_res_f_res_128351;
                        }
                        
                        bool cond_128353 = slt64(eta_p_128228, (int64_t) 0);
                        int64_t lifted_lambda_res_128354;
                        
                        if (cond_128353) {
                            lifted_lambda_res_128354 = lifted_lambda_res_128350;
                        } else {
                            lifted_lambda_res_128354 = eta_p_128228;
                        }
                        
                        int64_t defunc_0_f_res_128357 = add64(eta_p_128226, cm_128344);
                        
                        ((int64_t *) mem_133490.mem)[i_133302] = defunc_0_f_res_128357;
                        ((int64_t *) mem_133492.mem)[i_133302] = lifted_lambda_res_128354;
                    }
                    
                    int64_t tmp_120527 = add64((int64_t) 1, s_iter_120343);
                    
                    if (memblock_set(ctx, &ext_mem_133510, &mem_133490, "mem_133490") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_133492, "mem_133492") != 0)
                        return 1;
                    loopres_f_res_120380 = tmp_120527;
                    loopres_f_res_120383 = nextRel_120387;
                }
                if (memblock_set(ctx, &ext_mem_133516, &ext_mem_133510, "ext_mem_133510") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &ext_mem_133507, "ext_mem_133507") != 0)
                    return 1;
                loopres_120374 = loopres_f_res_120380;
                loopres_120377 = loopres_f_res_120383;
                loopres_120378 = minRelevant_120346;
            }
            
            bool cond_120528 = slt64(loopres_120374, numIter_S_120289);
            bool x_120529 = loopres_120377 && cond_120528;
            
            if (memblock_set(ctx, &mem_param_tmp_133892, &ext_mem_133516, "ext_mem_133516") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133893, &ext_mem_133513, "ext_mem_133513") != 0)
                return 1;
            
            int64_t ctx_param_ext_tmp_133894 = ext_133515;
            int64_t ctx_param_ext_tmp_133895 = ext_133514;
            int64_t ctx_param_ext_tmp_133896 = ext_133512;
            int64_t ctx_param_ext_tmp_133897 = ext_133511;
            bool loop_while_tmp_133898 = x_120529;
            int64_t s_iter_tmp_133899 = loopres_120374;
            int64_t minRelevant_tmp_133902 = loopres_120378;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133488, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
                return 1;
            ctx_param_ext_133483 = ctx_param_ext_tmp_133894;
            ctx_param_ext_133484 = ctx_param_ext_tmp_133895;
            ctx_param_ext_133486 = ctx_param_ext_tmp_133896;
            ctx_param_ext_133487 = ctx_param_ext_tmp_133897;
            loop_while_120342 = loop_while_tmp_133898;
            s_iter_120343 = s_iter_tmp_133899;
            minRelevant_120346 = minRelevant_tmp_133902;
        }
        if (memblock_set(ctx, &ext_mem_133522, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133521, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        ext_133520 = ctx_param_ext_133483;
        ext_133519 = ctx_param_ext_133484;
        ext_133518 = ctx_param_ext_133486;
        ext_133517 = ctx_param_ext_133487;
        loopres_120337 = loop_while_120342;
        loopres_120338 = s_iter_120343;
        loopres_120341 = minRelevant_120346;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133524, bytes_133469, "mem_133524")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133478.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_109429});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133521.mem, ext_133518, (int64_t []) {ext_133517}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133526, bytes_133469, "mem_133526")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_109429});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133522.mem, ext_133520, (int64_t []) {ext_133519}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        
        int64_t tmp_120535 = add64((int64_t) 1, iter_120300);
        bool loop_cond_120536 = slt64(tmp_120535, numIter_R_120286);
        
        if (memblock_set(ctx, &mem_param_tmp_133883, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133884, &mem_133524, "mem_133524") != 0)
            return 1;
        
        bool loop_while_tmp_133885 = loop_cond_120536;
        int64_t iter_tmp_133886 = tmp_120535;
        int64_t first_relevant_in_S_tmp_133889 = loopres_120341;
        
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133478, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        loop_while_120299 = loop_while_tmp_133885;
        iter_120300 = iter_tmp_133886;
        first_relevant_in_S_120303 = first_relevant_in_S_tmp_133889;
    }
    if (memblock_set(ctx, &ext_mem_133532, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133531, &mem_param_133478, "mem_param_133478") != 0)
        return 1;
    defunc_0_mergeJoin_res_120294 = loop_while_120299;
    defunc_0_mergeJoin_res_120295 = iter_120300;
    defunc_0_mergeJoin_res_120298 = first_relevant_in_S_120303;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
        return 1;
    if (mem_133534_cached_sizze_134057 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133534, &mem_133534_cached_sizze_134057, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133536_cached_sizze_134058 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133536, &mem_133536_cached_sizze_134058, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133538_cached_sizze_134059 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133538, &mem_133538_cached_sizze_134059, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133540_cached_sizze_134060 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133540, &mem_133540_cached_sizze_134060, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133542_cached_sizze_134061 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133542, &mem_133542_cached_sizze_134061, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t discard_133324;
    int64_t discard_133325;
    int64_t defunc_res_128479;
    int64_t scanacc_133310;
    int64_t scanacc_133311;
    int64_t redout_133314;
    
    scanacc_133310 = (int64_t) 0;
    scanacc_133311 = (int64_t) 0;
    redout_133314 = (int64_t) 0;
    for (int64_t i_133318 = 0; i_133318 < nR_109429; i_133318++) {
        int64_t zg_lhs_128038 = ((int64_t *) ext_mem_133532.mem)[i_133318];
        bool cond_128039 = slt64((int64_t) 0, zg_lhs_128038);
        int64_t lifted_lambda_res_128040;
        
        if (cond_128039) {
            lifted_lambda_res_128040 = i_133318;
        } else {
            lifted_lambda_res_128040 = (int64_t) -1;
        }
        
        bool cond_128042 = sle64((int64_t) 0, lifted_lambda_res_128040);
        bool cond_t_res_128043 = slt64(lifted_lambda_res_128040, nR_109429);
        bool x_128044 = cond_128042 && cond_t_res_128043;
        int64_t lifted_lambda_res_128045;
        
        if (x_128044) {
            bool index_certs_128468;
            
            if (!x_128044) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lifted_lambda_res_128040, "] out of bounds for array of shape [", (long long) nR_109429, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftRelational.fut:200:78-81\n   #4  ftRelational.fut:191:1-200:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t lifted_lambda_res_t_res_128469 = ((int64_t *) ext_mem_133532.mem)[lifted_lambda_res_128040];
            
            lifted_lambda_res_128045 = lifted_lambda_res_t_res_128469;
        } else {
            lifted_lambda_res_128045 = (int64_t) 0;
        }
        
        bool lifted_lambda_res_128049 = slt64((int64_t) 1, lifted_lambda_res_128045);
        int64_t defunc_0_f_res_128050 = btoi_bool_i64(lifted_lambda_res_128049);
        int64_t defunc_0_op_res_120595 = add64(defunc_0_f_res_128050, scanacc_133310);
        int64_t lifted_lambda_res_120560 = add64(lifted_lambda_res_128045, scanacc_133311);
        int64_t zp_res_126101 = add64(lifted_lambda_res_128045, redout_133314);
        
        ((int64_t *) mem_133534)[i_133318] = defunc_0_op_res_120595;
        ((int64_t *) mem_133536)[i_133318] = lifted_lambda_res_120560;
        ((int64_t *) mem_133538)[i_133318] = defunc_0_f_res_128050;
        ((int64_t *) mem_133540)[i_133318] = lifted_lambda_res_128045;
        ((int64_t *) mem_133542)[i_133318] = lifted_lambda_res_128040;
        
        int64_t scanacc_tmp_133911 = defunc_0_op_res_120595;
        int64_t scanacc_tmp_133912 = lifted_lambda_res_120560;
        int64_t redout_tmp_133915 = zp_res_126101;
        
        scanacc_133310 = scanacc_tmp_133911;
        scanacc_133311 = scanacc_tmp_133912;
        redout_133314 = redout_tmp_133915;
    }
    discard_133324 = scanacc_133310;
    discard_133325 = scanacc_133311;
    defunc_res_128479 = redout_133314;
    if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
        return 1;
    
    int64_t tmp_120598 = sub64(nR_109429, (int64_t) 1);
    bool y_120600 = slt64(tmp_120598, nR_109429);
    bool x_120599 = sle64((int64_t) 0, tmp_120598);
    bool bounds_check_120601 = x_120599 && y_120600;
    bool cond_120596 = nR_109429 == (int64_t) 0;
    bool protect_assert_disj_120602 = cond_120596 || bounds_check_120601;
    bool index_certs_120603;
    
    if (!protect_assert_disj_120602) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_120598, "] out of bounds for array of shape [", (long long) nR_109429, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:200:78-81\n   #4  ftRelational.fut:191:1-200:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool x_120597 = !cond_120596;
    int64_t m_f_res_120604;
    
    if (x_120597) {
        int64_t x_128475 = ((int64_t *) mem_133534)[tmp_120598];
        
        m_f_res_120604 = x_128475;
    } else {
        m_f_res_120604 = (int64_t) 0;
    }
    
    int64_t m_120606;
    
    if (cond_120596) {
        m_120606 = (int64_t) 0;
    } else {
        m_120606 = m_f_res_120604;
    }
    
    int64_t m_120616 = sub64(m_120606, (int64_t) 1);
    bool i_p_m_t_s_leq_w_120618 = slt64(m_120616, nR_109429);
    bool zzero_leq_i_p_m_t_s_120617 = sle64((int64_t) 0, m_120616);
    bool y_120620 = zzero_leq_i_p_m_t_s_120617 && i_p_m_t_s_leq_w_120618;
    bool i_lte_j_120619 = sle64((int64_t) 0, m_120606);
    bool forwards_ok_120621 = i_lte_j_120619 && y_120620;
    bool eq_x_zz_120613 = (int64_t) 0 == m_f_res_120604;
    bool p_and_eq_x_y_120614 = x_120597 && eq_x_zz_120613;
    bool empty_slice_120615 = cond_120596 || p_and_eq_x_y_120614;
    bool ok_or_empty_120622 = empty_slice_120615 || forwards_ok_120621;
    bool index_certs_120623;
    
    if (!ok_or_empty_120622) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_120606, "] out of bounds for array of shape [", (long long) nR_109429, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:200:78-81\n   #4  ftRelational.fut:191:1-200:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133573 = (int64_t) 8 * m_120606;
    int64_t bytes_133585 = (int64_t) 8 * defunc_res_128479;
    
    if (futrts_indicesWithIncrement_11729(ctx, &ext_mem_133468, tR_mem_133466, nR_109429, offset_R_109433) != 0) {
        err = 1;
        goto cleanup;
    }
    if (mem_133574_cached_sizze_134062 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133574, &mem_133574_cached_sizze_134062, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133574, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133540, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (mem_133576_cached_sizze_134063 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133576, &mem_133576_cached_sizze_134063, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133328 = 0; i_133328 < nR_109429; i_133328++) {
        int64_t eta_p_127956 = ((int64_t *) mem_133540)[i_133328];
        int64_t zv_lhs_127958 = add64((int64_t) -1, i_133328);
        int64_t tmp_127959 = smod64(zv_lhs_127958, nR_109429);
        int64_t lifted_lambda_res_127960 = ((int64_t *) mem_133536)[tmp_127959];
        bool cond_127962 = i_133328 == (int64_t) 0;
        int64_t lifted_lambda_res_127963;
        
        if (cond_127962) {
            lifted_lambda_res_127963 = (int64_t) 0;
        } else {
            lifted_lambda_res_127963 = lifted_lambda_res_127960;
        }
        
        bool cond_127965 = slt64((int64_t) 0, eta_p_127956);
        int64_t lifted_lambda_res_127966;
        
        if (cond_127965) {
            lifted_lambda_res_127966 = lifted_lambda_res_127963;
        } else {
            lifted_lambda_res_127966 = (int64_t) -1;
        }
        ((int64_t *) mem_133576)[i_133328] = lifted_lambda_res_127966;
    }
    if (mem_133584_cached_sizze_134064 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134064, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133584, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133576, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (memblock_alloc(ctx, &mem_133586, bytes_133585, "mem_133586")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133920 = 0; nest_i_133920 < defunc_res_128479; nest_i_133920++) {
        ((int64_t *) mem_133586.mem)[nest_i_133920] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133588, bytes_133585, "mem_133588")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133921 = 0; nest_i_133921 < defunc_res_128479; nest_i_133921++) {
        ((int64_t *) mem_133588.mem)[nest_i_133921] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133590, bytes_133585, "mem_133590")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133922 = 0; nest_i_133922 < defunc_res_128479; nest_i_133922++) {
        ((double *) mem_133590.mem)[nest_i_133922] = 0.0;
    }
    for (int64_t write_iter_133330 = 0; write_iter_133330 < nR_109429; write_iter_133330++) {
        int64_t write_iv_133336 = ((int64_t *) mem_133538)[write_iter_133330];
        int64_t write_iv_133337 = ((int64_t *) mem_133534)[write_iter_133330];
        int64_t write_iv_133338 = ((int64_t *) mem_133576)[write_iter_133330];
        int64_t write_iv_133339 = ((int64_t *) mem_133540)[write_iter_133330];
        int64_t write_iv_133340 = ((int64_t *) mem_133542)[write_iter_133330];
        bool cond_128065 = sle64((int64_t) 0, write_iv_133340);
        bool cond_t_res_128066 = slt64(write_iv_133340, nR_109429);
        bool x_128067 = cond_128065 && cond_t_res_128066;
        double lifted_lambda_res_128068;
        int64_t lifted_lambda_res_128069;
        int64_t lifted_lambda_res_128070;
        
        if (x_128067) {
            bool index_certs_128470;
            
            if (!x_128067) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) write_iv_133340, "] out of bounds for array of shape [", (long long) nR_109429, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftSMJ.fut:364:7-365:57\n   #4  ftRelational.fut:200:78-81\n   #5  ftRelational.fut:191:1-200:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            double lifted_lambda_res_t_res_128471 = ((double *) tR_mem_133466.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128472 = ((int64_t *) ext_mem_133468.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128473 = ((int64_t *) ext_mem_133531.mem)[write_iv_133340];
            
            lifted_lambda_res_128068 = lifted_lambda_res_t_res_128471;
            lifted_lambda_res_128069 = lifted_lambda_res_t_res_128472;
            lifted_lambda_res_128070 = lifted_lambda_res_t_res_128473;
        } else {
            lifted_lambda_res_128068 = 0.0;
            lifted_lambda_res_128069 = (int64_t) -1;
            lifted_lambda_res_128070 = (int64_t) -1;
        }
        
        bool cond_128078 = write_iv_133336 == (int64_t) 1;
        int64_t lifted_lambda_res_128079;
        
        if (cond_128078) {
            int64_t lifted_lambda_res_t_res_128474 = sub64(write_iv_133337, (int64_t) 1);
            
            lifted_lambda_res_128079 = lifted_lambda_res_t_res_128474;
        } else {
            lifted_lambda_res_128079 = (int64_t) -1;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133584)[lifted_lambda_res_128079] = write_iv_133338;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133574)[lifted_lambda_res_128079] = write_iv_133339;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((double *) mem_133590.mem)[write_iv_133338] = lifted_lambda_res_128068;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133588.mem)[write_iv_133338] = lifted_lambda_res_128069;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133586.mem)[write_iv_133338] = lifted_lambda_res_128070;
        }
    }
    if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
        return 1;
    for (int64_t i_120636 = 0; i_120636 < m_120606; i_120636++) {
        int64_t loopres_120640 = ((int64_t *) mem_133584)[i_120636];
        int64_t loopres_120641 = ((int64_t *) mem_133574)[i_120636];
        bool x_120642 = sle64((int64_t) 0, loopres_120640);
        bool y_120643 = slt64(loopres_120640, defunc_res_128479);
        bool bounds_check_120644 = x_120642 && y_120643;
        bool index_certs_120645;
        
        if (!bounds_check_120644) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:346:52-59\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t tmp_120655 = add64(loopres_120640, loopres_120641);
        bool empty_slice_120656 = loopres_120641 == (int64_t) 0;
        int64_t m_120657 = sub64(loopres_120641, (int64_t) 1);
        int64_t i_p_m_t_s_120658 = add64(loopres_120640, m_120657);
        bool zzero_leq_i_p_m_t_s_120659 = sle64((int64_t) 0, i_p_m_t_s_120658);
        bool i_p_m_t_s_leq_w_120660 = slt64(i_p_m_t_s_120658, defunc_res_128479);
        bool i_lte_j_120661 = sle64(loopres_120640, tmp_120655);
        bool y_120662 = x_120642 && i_p_m_t_s_leq_w_120660;
        bool y_120663 = zzero_leq_i_p_m_t_s_120659 && y_120662;
        bool forwards_ok_120664 = i_lte_j_120661 && y_120663;
        bool ok_or_empty_120665 = empty_slice_120656 || forwards_ok_120664;
        bool index_certs_120666;
        
        if (!ok_or_empty_120665) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, ":", (long long) tmp_120655, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:348:8-40\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:200:78-81\n   #3  ftRelational.fut:191:1-200:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        double loopres_120646 = ((double *) mem_133590.mem)[loopres_120640];
        int64_t loopres_120647 = ((int64_t *) mem_133588.mem)[loopres_120640];
        int64_t loopres_120648 = ((int64_t *) mem_133586.mem)[loopres_120640];
        
        for (int64_t nest_i_133931 = 0; nest_i_133931 < loopres_120641; nest_i_133931++) {
            ((double *) mem_133590.mem)[loopres_120640 + nest_i_133931] = loopres_120646;
        }
        for (int64_t nest_i_133932 = 0; nest_i_133932 < loopres_120641; nest_i_133932++) {
            ((int64_t *) mem_133588.mem)[loopres_120640 + nest_i_133932] = loopres_120647;
        }
        for (int64_t i_133349 = 0; i_133349 < loopres_120641; i_133349++) {
            int64_t tmp_120654 = add64(loopres_120648, i_133349);
            
            ((int64_t *) mem_133586.mem)[loopres_120640 + i_133349] = tmp_120654;
        }
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133588, "mem_133588") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133586, "mem_133586") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133879, &mem_133590, "mem_133590") != 0)
        return 1;
    prim_out_133880 = defunc_res_128479;
    if (memblock_set(ctx, &*mem_out_p_134053, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134054, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134055, &mem_out_133879, "mem_out_133879") != 0)
        return 1;
    *out_prim_out_134056 = prim_out_133880;
    
  cleanup:
    {
        free(mem_133534);
        free(mem_133536);
        free(mem_133538);
        free(mem_133540);
        free(mem_133542);
        free(mem_133574);
        free(mem_133576);
        free(mem_133584);
        if (memblock_unref(ctx, &mem_133590, "mem_133590") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133588, "mem_133588") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133586, "mem_133586") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133524, "mem_133524") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133492, "mem_133492") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133490, "mem_133490") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133507, "ext_mem_133507") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133510, "ext_mem_133510") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133513, "ext_mem_133513") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133516, "ext_mem_133516") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133478, "mem_param_133478") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133879, "mem_out_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_float(struct futhark_context *ctx, struct memblock *mem_out_p_134065, struct memblock *mem_out_p_134066, struct memblock *mem_out_p_134067, int64_t *out_prim_out_134068, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_107305, int64_t nS_107306, int64_t offset_R_107309, int64_t offset_S_107310, int64_t partitionSizze_107311, int64_t scatter_psizze_107312)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133534_cached_sizze_134069 = 0;
    unsigned char *mem_133534 = NULL;
    int64_t mem_133536_cached_sizze_134070 = 0;
    unsigned char *mem_133536 = NULL;
    int64_t mem_133538_cached_sizze_134071 = 0;
    unsigned char *mem_133538 = NULL;
    int64_t mem_133540_cached_sizze_134072 = 0;
    unsigned char *mem_133540 = NULL;
    int64_t mem_133542_cached_sizze_134073 = 0;
    unsigned char *mem_133542 = NULL;
    int64_t mem_133574_cached_sizze_134074 = 0;
    unsigned char *mem_133574 = NULL;
    int64_t mem_133576_cached_sizze_134075 = 0;
    unsigned char *mem_133576 = NULL;
    int64_t mem_133584_cached_sizze_134076 = 0;
    unsigned char *mem_133584 = NULL;
    struct memblock mem_133590;
    
    mem_133590.references = NULL;
    
    struct memblock mem_133588;
    
    mem_133588.references = NULL;
    
    struct memblock mem_133586;
    
    mem_133586.references = NULL;
    
    struct memblock ext_mem_133468;
    
    ext_mem_133468.references = NULL;
    
    struct memblock mem_param_tmp_133884;
    
    mem_param_tmp_133884.references = NULL;
    
    struct memblock mem_param_tmp_133883;
    
    mem_param_tmp_133883.references = NULL;
    
    struct memblock mem_133526;
    
    mem_133526.references = NULL;
    
    struct memblock mem_133524;
    
    mem_133524.references = NULL;
    
    struct memblock mem_param_tmp_133893;
    
    mem_param_tmp_133893.references = NULL;
    
    struct memblock mem_param_tmp_133892;
    
    mem_param_tmp_133892.references = NULL;
    
    struct memblock mem_133492;
    
    mem_133492.references = NULL;
    
    struct memblock mem_133490;
    
    mem_133490.references = NULL;
    
    struct memblock ext_mem_133507;
    
    ext_mem_133507.references = NULL;
    
    struct memblock ext_mem_133510;
    
    ext_mem_133510.references = NULL;
    
    struct memblock ext_mem_133513;
    
    ext_mem_133513.references = NULL;
    
    struct memblock ext_mem_133516;
    
    ext_mem_133516.references = NULL;
    
    struct memblock mem_param_133488;
    
    mem_param_133488.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133521;
    
    ext_mem_133521.references = NULL;
    
    struct memblock ext_mem_133522;
    
    ext_mem_133522.references = NULL;
    
    struct memblock mem_133482;
    
    mem_133482.references = NULL;
    
    struct memblock mem_133480;
    
    mem_133480.references = NULL;
    
    struct memblock mem_param_133478;
    
    mem_param_133478.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock ext_mem_133531;
    
    ext_mem_133531.references = NULL;
    
    struct memblock ext_mem_133532;
    
    ext_mem_133532.references = NULL;
    
    struct memblock mem_133472;
    
    mem_133472.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t prim_out_133880;
    int64_t zm_lhs_120281 = add64(nR_107305, partitionSizze_107311);
    int64_t zs_lhs_120282 = sub64(zm_lhs_120281, (int64_t) 1);
    bool zzero_120283 = partitionSizze_107311 == (int64_t) 0;
    bool nonzzero_120284 = !zzero_120283;
    bool nonzzero_cert_120285;
    
    if (!nonzzero_120284) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftSMJ.fut:271:43-57\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t numIter_R_120286 = sdiv64(zs_lhs_120282, partitionSizze_107311);
    int64_t zm_lhs_120287 = add64(nS_107306, partitionSizze_107311);
    int64_t zs_lhs_120288 = sub64(zm_lhs_120287, (int64_t) 1);
    int64_t numIter_S_120289 = sdiv64(zs_lhs_120288, partitionSizze_107311);
    int64_t bytes_133469 = (int64_t) 8 * nR_107305;
    
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133881 = 0; nest_i_133881 < nR_107305; nest_i_133881++) {
        ((int64_t *) mem_133470.mem)[nest_i_133881] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133472, bytes_133469, "mem_133472")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133882 = 0; nest_i_133882 < nR_107305; nest_i_133882++) {
        ((int64_t *) mem_133472.mem)[nest_i_133882] = (int64_t) 0;
    }
    
    bool loop_cond_120293 = slt64((int64_t) 0, numIter_R_120286);
    bool defunc_0_mergeJoin_res_120294;
    int64_t defunc_0_mergeJoin_res_120295;
    int64_t defunc_0_mergeJoin_res_120298;
    bool loop_while_120299;
    int64_t iter_120300;
    int64_t first_relevant_in_S_120303;
    
    if (memblock_set(ctx, &mem_param_133475, &mem_133472, "mem_133472") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133478, &mem_133470, "mem_133470") != 0)
        return 1;
    loop_while_120299 = loop_cond_120293;
    iter_120300 = (int64_t) 0;
    first_relevant_in_S_120303 = (int64_t) 0;
    while (loop_while_120299) {
        int64_t tR_start_120304 = mul64(partitionSizze_107311, iter_120300);
        int64_t min_arg1_120305 = add64(partitionSizze_107311, tR_start_120304);
        int64_t min_res_120306 = smin64(nR_107305, min_arg1_120305);
        int64_t dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 = sub64(min_res_120306, tR_start_120304);
        bool empty_slice_120308 = dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 == (int64_t) 0;
        int64_t m_120309 = sub64(dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, (int64_t) 1);
        int64_t i_p_m_t_s_120310 = add64(tR_start_120304, m_120309);
        bool zzero_leq_i_p_m_t_s_120311 = sle64((int64_t) 0, i_p_m_t_s_120310);
        bool i_p_m_t_s_leq_w_120312 = slt64(i_p_m_t_s_120310, nR_107305);
        bool zzero_lte_i_120313 = sle64((int64_t) 0, tR_start_120304);
        bool i_lte_j_120314 = sle64(tR_start_120304, min_res_120306);
        bool y_120315 = i_p_m_t_s_leq_w_120312 && zzero_lte_i_120313;
        bool y_120316 = zzero_leq_i_p_m_t_s_120311 && y_120315;
        bool forwards_ok_120317 = i_lte_j_120314 && y_120316;
        bool ok_or_empty_120318 = empty_slice_120308 || forwards_ok_120317;
        bool index_certs_120319;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_107305, "].", "-> #0  ftSMJ.fut:278:17-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t bytes_133479 = (int64_t) 8 * dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307;
        bool cond_120323 = slt64(first_relevant_in_S_120303, numIter_S_120289);
        bool y_120324 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool loop_not_taken_120325 = !cond_120323;
        bool protect_assert_disj_120326 = y_120324 || loop_not_taken_120325;
        bool index_certs_120327;
        
        if (!protect_assert_disj_120326) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:293:26-34\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool x_120330 = sle64((int64_t) 0, m_120309);
        bool y_120331 = slt64(m_120309, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool bounds_check_120332 = x_120330 && y_120331;
        bool protect_assert_disj_120333 = loop_not_taken_120325 || bounds_check_120332;
        bool index_certs_120334;
        
        if (!protect_assert_disj_120333) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:294:42-61\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool index_certs_120531;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_107305, "].", "-> #0  ftSMJ.fut:199:15-63\n   #1  ftSMJ.fut:304:20-64\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:189:78-81\n   #4  ftRelational.fut:180:1-189:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133480, bytes_133479, "mem_133480")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133890 = 0; nest_i_133890 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133890++) {
            ((int64_t *) mem_133480.mem)[nest_i_133890] = (int64_t) -1;
        }
        if (memblock_alloc(ctx, &mem_133482, bytes_133479, "mem_133482")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133891 = 0; nest_i_133891 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133891++) {
            ((int64_t *) mem_133482.mem)[nest_i_133891] = (int64_t) 0;
        }
        
        float gt_lhs_120328;
        
        if (cond_120323) {
            float x_128449 = ((float *) tR_mem_133466.mem)[tR_start_120304];
            
            gt_lhs_120328 = x_128449;
        } else {
            gt_lhs_120328 = 0.0F;
        }
        
        float gt_rhs_120335;
        
        if (cond_120323) {
            float x_128450 = ((float *) tR_mem_133466.mem)[i_p_m_t_s_120310];
            
            gt_rhs_120335 = x_128450;
        } else {
            gt_rhs_120335 = 0.0F;
        }
        
        int64_t ext_133520;
        int64_t ext_133519;
        int64_t ext_133518;
        int64_t ext_133517;
        bool loopres_120337;
        int64_t loopres_120338;
        int64_t loopres_120341;
        bool loop_while_120342;
        int64_t s_iter_120343;
        int64_t minRelevant_120346;
        int64_t ctx_param_ext_133483;
        int64_t ctx_param_ext_133484;
        int64_t ctx_param_ext_133486;
        int64_t ctx_param_ext_133487;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133488, &mem_133480, "mem_133480") != 0)
            return 1;
        ctx_param_ext_133483 = (int64_t) 0;
        ctx_param_ext_133484 = (int64_t) 1;
        ctx_param_ext_133486 = (int64_t) 0;
        ctx_param_ext_133487 = (int64_t) 1;
        loop_while_120342 = cond_120323;
        s_iter_120343 = first_relevant_in_S_120303;
        minRelevant_120346 = first_relevant_in_S_120303;
        while (loop_while_120342) {
            int64_t tS_start_120347 = mul64(partitionSizze_107311, s_iter_120343);
            int64_t min_arg1_120348 = add64(partitionSizze_107311, tS_start_120347);
            int64_t min_res_120349 = smin64(nS_107306, min_arg1_120348);
            int64_t dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 = sub64(min_res_120349, tS_start_120347);
            bool empty_slice_120351 = dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 == (int64_t) 0;
            int64_t m_120352 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 1);
            int64_t i_p_m_t_s_120353 = add64(tS_start_120347, m_120352);
            bool zzero_leq_i_p_m_t_s_120354 = sle64((int64_t) 0, i_p_m_t_s_120353);
            bool i_p_m_t_s_leq_w_120355 = slt64(i_p_m_t_s_120353, nS_107306);
            bool zzero_lte_i_120356 = sle64((int64_t) 0, tS_start_120347);
            bool i_lte_j_120357 = sle64(tS_start_120347, min_res_120349);
            bool y_120358 = i_p_m_t_s_leq_w_120355 && zzero_lte_i_120356;
            bool y_120359 = zzero_leq_i_p_m_t_s_120354 && y_120358;
            bool forwards_ok_120360 = i_lte_j_120357 && y_120359;
            bool ok_or_empty_120361 = empty_slice_120351 || forwards_ok_120360;
            bool index_certs_120362;
            
            if (!ok_or_empty_120361) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tS_start_120347, ":", (long long) min_res_120349, "] out of bounds for array of shape [", (long long) nS_107306, "].", "-> #0  ftSMJ.fut:291:19-38\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool x_120363 = sle64((int64_t) 0, m_120352);
            bool y_120364 = slt64(m_120352, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool bounds_check_120365 = x_120363 && y_120364;
            bool index_certs_120366;
            
            if (!bounds_check_120365) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120352, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:293:40-59\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_120369 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool index_certs_120370;
            
            if (!y_120369) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:294:28-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            float gt_rhs_120367 = ((float *) tS_mem_133467.mem)[i_p_m_t_s_120353];
            bool defunc_0_gt_res_120368 = gt_rhs_120367 < gt_lhs_120328;
            float gt_lhs_120371 = ((float *) tS_mem_133467.mem)[tS_start_120347];
            bool defunc_0_gt_res_120372 = gt_rhs_120335 < gt_lhs_120371;
            bool thisStillRel_120373 = !defunc_0_gt_res_120372;
            int64_t ext_133509;
            
            if (defunc_0_gt_res_120372) {
                ext_133509 = ctx_param_ext_133483;
            } else {
                ext_133509 = (int64_t) 0;
            }
            
            int64_t ext_133508;
            
            if (defunc_0_gt_res_120372) {
                ext_133508 = ctx_param_ext_133484;
            } else {
                ext_133508 = (int64_t) 1;
            }
            
            int64_t ext_133506;
            
            if (defunc_0_gt_res_120372) {
                ext_133506 = ctx_param_ext_133486;
            } else {
                ext_133506 = (int64_t) 0;
            }
            
            int64_t ext_133505;
            
            if (defunc_0_gt_res_120372) {
                ext_133505 = ctx_param_ext_133487;
            } else {
                ext_133505 = (int64_t) 1;
            }
            
            int64_t ext_133515;
            
            if (defunc_0_gt_res_120368) {
                ext_133515 = ctx_param_ext_133483;
            } else {
                ext_133515 = ext_133509;
            }
            
            int64_t ext_133514;
            
            if (defunc_0_gt_res_120368) {
                ext_133514 = ctx_param_ext_133484;
            } else {
                ext_133514 = ext_133508;
            }
            
            int64_t ext_133512;
            
            if (defunc_0_gt_res_120368) {
                ext_133512 = ctx_param_ext_133486;
            } else {
                ext_133512 = ext_133506;
            }
            
            int64_t ext_133511;
            
            if (defunc_0_gt_res_120368) {
                ext_133511 = ctx_param_ext_133487;
            } else {
                ext_133511 = ext_133505;
            }
            
            int64_t loopres_120374;
            bool loopres_120377;
            int64_t loopres_120378;
            
            if (defunc_0_gt_res_120368) {
                int64_t tmp_128451 = add64((int64_t) 1, s_iter_120343);
                
                if (memblock_set(ctx, &ext_mem_133516, &mem_param_133485, "mem_param_133485") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &mem_param_133488, "mem_param_133488") != 0)
                    return 1;
                loopres_120374 = tmp_128451;
                loopres_120377 = 1;
                loopres_120378 = tmp_128451;
            } else {
                int64_t loopres_f_res_120380;
                bool loopres_f_res_120383;
                
                if (defunc_0_gt_res_120372) {
                    if (memblock_set(ctx, &ext_mem_133510, &mem_param_133485, "mem_param_133485") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_param_133488, "mem_param_133488") != 0)
                        return 1;
                    loopres_f_res_120380 = s_iter_120343;
                    loopres_f_res_120383 = thisStillRel_120373;
                } else {
                    bool index_certs_120384;
                    
                    if (!bounds_check_120332) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:298:50-69\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    float gt_rhs_120385 = ((float *) tR_mem_133466.mem)[i_p_m_t_s_120310];
                    bool defunc_0_gt_res_120386 = gt_rhs_120385 < gt_rhs_120367;
                    bool nextRel_120387 = !defunc_0_gt_res_120386;
                    int64_t find_joinTuples_arg3_120388 = add64(offset_S_107310, tS_start_120347);
                    int64_t max_arg1_120389 = sdiv64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 2);
                    int64_t max_res_120390 = smax64((int64_t) 1, max_arg1_120389);
                    bool loop_cond_120391 = slt64((int64_t) 0, max_res_120390);
                    
                    if (memblock_alloc(ctx, &mem_133490, bytes_133479, "mem_133490")) {
                        err = 1;
                        goto cleanup;
                    }
                    if (memblock_alloc(ctx, &mem_133492, bytes_133479, "mem_133492")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t i_133302 = 0; i_133302 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; i_133302++) {
                        int64_t eta_p_128226 = ((int64_t *) mem_param_133485.mem)[ctx_param_ext_133483 + i_133302 * ctx_param_ext_133484];
                        int64_t slice_133434 = tR_start_120304 + i_133302;
                        float eta_p_128227 = ((float *) tR_mem_133466.mem)[slice_133434];
                        int64_t eta_p_128228 = ((int64_t *) mem_param_133488.mem)[ctx_param_ext_133486 + i_133302 * ctx_param_ext_133487];
                        bool defunc_0_f_res_128229;
                        int64_t defunc_0_f_res_128230;
                        int64_t defunc_0_f_res_128231;
                        bool loop_while_128232;
                        int64_t first_match_128233;
                        int64_t step_128234;
                        
                        loop_while_128232 = loop_cond_120391;
                        first_match_128233 = (int64_t) 0;
                        step_128234 = max_res_120390;
                        while (loop_while_128232) {
                            bool x_128235 = sle64((int64_t) 0, first_match_128233);
                            bool y_128236 = slt64(first_match_128233, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                            bool bounds_check_128237 = x_128235 && y_128236;
                            bool index_certs_128238;
                            
                            if (!bounds_check_128237) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) first_match_128233, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:219:20-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:189:78-81\n   #4  ftRelational.fut:180:1-189:81\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128239 = tS_start_120347 + first_match_128233;
                            float sv_128240 = ((float *) tS_mem_133467.mem)[slice_128239];
                            bool cond_128241 = first_match_128233 == (int64_t) 0;
                            float pv_128242;
                            
                            if (cond_128241) {
                                pv_128242 = sv_128240;
                            } else {
                                int64_t tmp_128243 = sub64(first_match_128233, (int64_t) 1);
                                bool x_128244 = sle64((int64_t) 0, tmp_128243);
                                bool y_128245 = slt64(tmp_128243, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128246 = x_128244 && y_128245;
                                bool index_certs_128247;
                                
                                if (!bounds_check_128246) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128243, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:220:51-68\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:189:78-81\n   #4  ftRelational.fut:180:1-189:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128248 = tS_start_120347 + tmp_128243;
                                float pv_f_res_128249 = ((float *) tS_mem_133467.mem)[slice_128248];
                                
                                pv_128242 = pv_f_res_128249;
                            }
                            
                            bool cond_128250 = first_match_128233 == m_120352;
                            float nv_128251;
                            
                            if (cond_128250) {
                                nv_128251 = sv_128240;
                            } else {
                                int64_t tmp_128252 = add64((int64_t) 1, first_match_128233);
                                bool x_128253 = sle64((int64_t) 0, tmp_128252);
                                bool y_128254 = slt64(tmp_128252, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128255 = x_128253 && y_128254;
                                bool index_certs_128256;
                                
                                if (!bounds_check_128255) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128252, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:221:54-71\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:189:78-81\n   #4  ftRelational.fut:180:1-189:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128257 = tS_start_120347 + tmp_128252;
                                float nv_f_res_128258 = ((float *) tS_mem_133467.mem)[slice_128257];
                                
                                nv_128251 = nv_f_res_128258;
                            }
                            
                            bool defunc_0_eq_res_128259 = sv_128240 == eta_p_128227;
                            bool defunc_0_gt_res_128260 = pv_128242 < eta_p_128227;
                            bool x_128261 = !cond_128241;
                            bool y_128262 = defunc_0_gt_res_128260 && x_128261;
                            bool cond_t_res_128263 = cond_128241 || y_128262;
                            bool x_128264 = defunc_0_eq_res_128259 && cond_t_res_128263;
                            int64_t loopres_128265;
                            int64_t loopres_128266;
                            
                            if (x_128264) {
                                loopres_128265 = first_match_128233;
                                loopres_128266 = (int64_t) 0;
                            } else {
                                int64_t loopres_f_res_128267;
                                int64_t loopres_f_res_128268;
                                
                                if (defunc_0_eq_res_128259) {
                                    int64_t tmp_128452 = sub64(first_match_128233, step_128234);
                                    int64_t max_arg1_128453 = sdiv64(step_128234, (int64_t) 2);
                                    int64_t max_res_128454 = smax64((int64_t) 1, max_arg1_128453);
                                    
                                    loopres_f_res_128267 = tmp_128452;
                                    loopres_f_res_128268 = max_res_128454;
                                } else {
                                    bool defunc_0_gt_res_128272 = eta_p_128227 < sv_128240;
                                    int64_t loopres_f_res_f_res_128273;
                                    int64_t loopres_f_res_f_res_128274;
                                    
                                    if (defunc_0_gt_res_128272) {
                                        int64_t loopres_f_res_f_res_t_res_128455;
                                        int64_t loopres_f_res_f_res_t_res_128456;
                                        
                                        if (cond_t_res_128263) {
                                            loopres_f_res_f_res_t_res_128455 = (int64_t) -1;
                                            loopres_f_res_f_res_t_res_128456 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128457 = sub64(first_match_128233, step_128234);
                                            int64_t max_arg1_128458 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128459 = smax64((int64_t) 1, max_arg1_128458);
                                            
                                            loopres_f_res_f_res_t_res_128455 = tmp_128457;
                                            loopres_f_res_f_res_t_res_128456 = max_res_128459;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_t_res_128455;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_t_res_128456;
                                    } else {
                                        bool defunc_0_gt_res_128282 = eta_p_128227 < nv_128251;
                                        bool x_128283 = !cond_128250;
                                        bool y_128284 = defunc_0_gt_res_128282 && x_128283;
                                        bool cond_128285 = cond_128250 || y_128284;
                                        int64_t loopres_f_res_f_res_f_res_128286;
                                        int64_t loopres_f_res_f_res_f_res_128287;
                                        
                                        if (cond_128285) {
                                            loopres_f_res_f_res_f_res_128286 = (int64_t) -1;
                                            loopres_f_res_f_res_f_res_128287 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128288 = add64(first_match_128233, step_128234);
                                            int64_t max_arg1_128289 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128290 = smax64((int64_t) 1, max_arg1_128289);
                                            
                                            loopres_f_res_f_res_f_res_128286 = tmp_128288;
                                            loopres_f_res_f_res_f_res_128287 = max_res_128290;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_f_res_128286;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_f_res_128287;
                                    }
                                    loopres_f_res_128267 = loopres_f_res_f_res_128273;
                                    loopres_f_res_128268 = loopres_f_res_f_res_128274;
                                }
                                loopres_128265 = loopres_f_res_128267;
                                loopres_128266 = loopres_f_res_128268;
                            }
                            
                            bool loop_cond_128291 = slt64((int64_t) 0, loopres_128266);
                            bool loop_while_tmp_133905 = loop_cond_128291;
                            int64_t first_match_tmp_133906 = loopres_128265;
                            int64_t step_tmp_133907 = loopres_128266;
                            
                            loop_while_128232 = loop_while_tmp_133905;
                            first_match_128233 = first_match_tmp_133906;
                            step_128234 = step_tmp_133907;
                        }
                        defunc_0_f_res_128229 = loop_while_128232;
                        defunc_0_f_res_128230 = first_match_128233;
                        defunc_0_f_res_128231 = step_128234;
                        
                        int64_t zs_lhs_128292 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, defunc_0_f_res_128230);
                        int64_t max_arg1_128293 = sdiv64(zs_lhs_128292, (int64_t) 2);
                        int64_t max_res_128294 = smax64((int64_t) 1, max_arg1_128293);
                        bool cond_128295 = defunc_0_f_res_128230 == (int64_t) -1;
                        int64_t defunc_0_f_res_128296;
                        
                        if (cond_128295) {
                            defunc_0_f_res_128296 = (int64_t) -1;
                        } else {
                            bool loop_cond_128298 = slt64((int64_t) 0, max_res_128294);
                            bool defunc_0_f_res_f_res_128299;
                            int64_t defunc_0_f_res_f_res_128300;
                            int64_t defunc_0_f_res_f_res_128301;
                            bool loop_while_128302;
                            int64_t last_match_128303;
                            int64_t step_128304;
                            
                            loop_while_128302 = loop_cond_128298;
                            last_match_128303 = m_120352;
                            step_128304 = max_res_128294;
                            while (loop_while_128302) {
                                bool x_128305 = sle64((int64_t) 0, last_match_128303);
                                bool y_128306 = slt64(last_match_128303, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128307 = x_128305 && y_128306;
                                bool index_certs_128308;
                                
                                if (!bounds_check_128307) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) last_match_128303, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:240:20-34\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:189:78-81\n   #4  ftRelational.fut:180:1-189:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128309 = tS_start_120347 + last_match_128303;
                                float sv_128310 = ((float *) tS_mem_133467.mem)[slice_128309];
                                bool cond_128311 = last_match_128303 == m_120352;
                                float nv_128312;
                                
                                if (cond_128311) {
                                    nv_128312 = sv_128310;
                                } else {
                                    int64_t tmp_128313 = add64((int64_t) 1, last_match_128303);
                                    bool x_128314 = sle64((int64_t) 0, tmp_128313);
                                    bool y_128315 = slt64(tmp_128313, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                    bool bounds_check_128316 = x_128314 && y_128315;
                                    bool index_certs_128317;
                                    
                                    if (!bounds_check_128316) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128313, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:241:53-69\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:189:78-81\n   #4  ftRelational.fut:180:1-189:81\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128318 = tS_start_120347 + tmp_128313;
                                    float nv_f_res_128319 = ((float *) tS_mem_133467.mem)[slice_128318];
                                    
                                    nv_128312 = nv_f_res_128319;
                                }
                                
                                bool defunc_0_eq_res_128320 = sv_128310 == eta_p_128227;
                                bool defunc_0_gt_res_128321 = eta_p_128227 < nv_128312;
                                bool x_128322 = !cond_128311;
                                bool y_128323 = defunc_0_gt_res_128321 && x_128322;
                                bool cond_t_res_128324 = cond_128311 || y_128323;
                                bool x_128325 = defunc_0_eq_res_128320 && cond_t_res_128324;
                                int64_t loopres_128326;
                                int64_t loopres_128327;
                                
                                if (x_128325) {
                                    loopres_128326 = last_match_128303;
                                    loopres_128327 = (int64_t) 0;
                                } else {
                                    int64_t loopres_f_res_128328;
                                    int64_t loopres_f_res_128329;
                                    
                                    if (defunc_0_eq_res_128320) {
                                        int64_t tmp_128460 = add64(last_match_128303, step_128304);
                                        int64_t max_arg1_128461 = sdiv64(step_128304, (int64_t) 2);
                                        int64_t max_res_128462 = smax64((int64_t) 1, max_arg1_128461);
                                        
                                        loopres_f_res_128328 = tmp_128460;
                                        loopres_f_res_128329 = max_res_128462;
                                    } else {
                                        bool defunc_0_gt_res_128333 = eta_p_128227 < sv_128310;
                                        int64_t loopres_f_res_f_res_128334;
                                        int64_t loopres_f_res_f_res_128335;
                                        
                                        if (defunc_0_gt_res_128333) {
                                            int64_t tmp_128463 = sub64(last_match_128303, step_128304);
                                            int64_t max_arg1_128464 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128465 = smax64((int64_t) 1, max_arg1_128464);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128463;
                                            loopres_f_res_f_res_128335 = max_res_128465;
                                        } else {
                                            int64_t tmp_128339 = add64(last_match_128303, step_128304);
                                            int64_t max_arg1_128340 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128341 = smax64((int64_t) 1, max_arg1_128340);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128339;
                                            loopres_f_res_f_res_128335 = max_res_128341;
                                        }
                                        loopres_f_res_128328 = loopres_f_res_f_res_128334;
                                        loopres_f_res_128329 = loopres_f_res_f_res_128335;
                                    }
                                    loopres_128326 = loopres_f_res_128328;
                                    loopres_128327 = loopres_f_res_128329;
                                }
                                
                                bool loop_cond_128342 = slt64((int64_t) 0, loopres_128327);
                                bool loop_while_tmp_133908 = loop_cond_128342;
                                int64_t last_match_tmp_133909 = loopres_128326;
                                int64_t step_tmp_133910 = loopres_128327;
                                
                                loop_while_128302 = loop_while_tmp_133908;
                                last_match_128303 = last_match_tmp_133909;
                                step_128304 = step_tmp_133910;
                            }
                            defunc_0_f_res_f_res_128299 = loop_while_128302;
                            defunc_0_f_res_f_res_128300 = last_match_128303;
                            defunc_0_f_res_f_res_128301 = step_128304;
                            defunc_0_f_res_128296 = defunc_0_f_res_f_res_128300;
                        }
                        
                        bool cond_128343 = slt64(defunc_0_f_res_128230, (int64_t) 0);
                        int64_t cm_128344;
                        
                        if (cond_128343) {
                            cm_128344 = (int64_t) 0;
                        } else {
                            int64_t zp_lhs_128345 = sub64(defunc_0_f_res_128296, defunc_0_f_res_128230);
                            int64_t cm_f_res_128346 = add64((int64_t) 1, zp_lhs_128345);
                            
                            cm_128344 = cm_f_res_128346;
                        }
                        
                        int64_t lifted_lambda_res_128350;
                        
                        if (cond_128343) {
                            lifted_lambda_res_128350 = defunc_0_f_res_128230;
                        } else {
                            int64_t lifted_lambda_res_f_res_128351 = add64(find_joinTuples_arg3_120388, defunc_0_f_res_128230);
                            
                            lifted_lambda_res_128350 = lifted_lambda_res_f_res_128351;
                        }
                        
                        bool cond_128353 = slt64(eta_p_128228, (int64_t) 0);
                        int64_t lifted_lambda_res_128354;
                        
                        if (cond_128353) {
                            lifted_lambda_res_128354 = lifted_lambda_res_128350;
                        } else {
                            lifted_lambda_res_128354 = eta_p_128228;
                        }
                        
                        int64_t defunc_0_f_res_128357 = add64(eta_p_128226, cm_128344);
                        
                        ((int64_t *) mem_133490.mem)[i_133302] = defunc_0_f_res_128357;
                        ((int64_t *) mem_133492.mem)[i_133302] = lifted_lambda_res_128354;
                    }
                    
                    int64_t tmp_120527 = add64((int64_t) 1, s_iter_120343);
                    
                    if (memblock_set(ctx, &ext_mem_133510, &mem_133490, "mem_133490") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_133492, "mem_133492") != 0)
                        return 1;
                    loopres_f_res_120380 = tmp_120527;
                    loopres_f_res_120383 = nextRel_120387;
                }
                if (memblock_set(ctx, &ext_mem_133516, &ext_mem_133510, "ext_mem_133510") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &ext_mem_133507, "ext_mem_133507") != 0)
                    return 1;
                loopres_120374 = loopres_f_res_120380;
                loopres_120377 = loopres_f_res_120383;
                loopres_120378 = minRelevant_120346;
            }
            
            bool cond_120528 = slt64(loopres_120374, numIter_S_120289);
            bool x_120529 = loopres_120377 && cond_120528;
            
            if (memblock_set(ctx, &mem_param_tmp_133892, &ext_mem_133516, "ext_mem_133516") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133893, &ext_mem_133513, "ext_mem_133513") != 0)
                return 1;
            
            int64_t ctx_param_ext_tmp_133894 = ext_133515;
            int64_t ctx_param_ext_tmp_133895 = ext_133514;
            int64_t ctx_param_ext_tmp_133896 = ext_133512;
            int64_t ctx_param_ext_tmp_133897 = ext_133511;
            bool loop_while_tmp_133898 = x_120529;
            int64_t s_iter_tmp_133899 = loopres_120374;
            int64_t minRelevant_tmp_133902 = loopres_120378;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133488, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
                return 1;
            ctx_param_ext_133483 = ctx_param_ext_tmp_133894;
            ctx_param_ext_133484 = ctx_param_ext_tmp_133895;
            ctx_param_ext_133486 = ctx_param_ext_tmp_133896;
            ctx_param_ext_133487 = ctx_param_ext_tmp_133897;
            loop_while_120342 = loop_while_tmp_133898;
            s_iter_120343 = s_iter_tmp_133899;
            minRelevant_120346 = minRelevant_tmp_133902;
        }
        if (memblock_set(ctx, &ext_mem_133522, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133521, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        ext_133520 = ctx_param_ext_133483;
        ext_133519 = ctx_param_ext_133484;
        ext_133518 = ctx_param_ext_133486;
        ext_133517 = ctx_param_ext_133487;
        loopres_120337 = loop_while_120342;
        loopres_120338 = s_iter_120343;
        loopres_120341 = minRelevant_120346;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133524, bytes_133469, "mem_133524")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133478.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_107305});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133521.mem, ext_133518, (int64_t []) {ext_133517}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133526, bytes_133469, "mem_133526")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_107305});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133522.mem, ext_133520, (int64_t []) {ext_133519}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        
        int64_t tmp_120535 = add64((int64_t) 1, iter_120300);
        bool loop_cond_120536 = slt64(tmp_120535, numIter_R_120286);
        
        if (memblock_set(ctx, &mem_param_tmp_133883, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133884, &mem_133524, "mem_133524") != 0)
            return 1;
        
        bool loop_while_tmp_133885 = loop_cond_120536;
        int64_t iter_tmp_133886 = tmp_120535;
        int64_t first_relevant_in_S_tmp_133889 = loopres_120341;
        
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133478, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        loop_while_120299 = loop_while_tmp_133885;
        iter_120300 = iter_tmp_133886;
        first_relevant_in_S_120303 = first_relevant_in_S_tmp_133889;
    }
    if (memblock_set(ctx, &ext_mem_133532, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133531, &mem_param_133478, "mem_param_133478") != 0)
        return 1;
    defunc_0_mergeJoin_res_120294 = loop_while_120299;
    defunc_0_mergeJoin_res_120295 = iter_120300;
    defunc_0_mergeJoin_res_120298 = first_relevant_in_S_120303;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
        return 1;
    if (mem_133534_cached_sizze_134069 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133534, &mem_133534_cached_sizze_134069, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133536_cached_sizze_134070 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133536, &mem_133536_cached_sizze_134070, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133538_cached_sizze_134071 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133538, &mem_133538_cached_sizze_134071, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133540_cached_sizze_134072 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133540, &mem_133540_cached_sizze_134072, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133542_cached_sizze_134073 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133542, &mem_133542_cached_sizze_134073, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t discard_133324;
    int64_t discard_133325;
    int64_t defunc_res_128479;
    int64_t scanacc_133310;
    int64_t scanacc_133311;
    int64_t redout_133314;
    
    scanacc_133310 = (int64_t) 0;
    scanacc_133311 = (int64_t) 0;
    redout_133314 = (int64_t) 0;
    for (int64_t i_133318 = 0; i_133318 < nR_107305; i_133318++) {
        int64_t zg_lhs_128038 = ((int64_t *) ext_mem_133532.mem)[i_133318];
        bool cond_128039 = slt64((int64_t) 0, zg_lhs_128038);
        int64_t lifted_lambda_res_128040;
        
        if (cond_128039) {
            lifted_lambda_res_128040 = i_133318;
        } else {
            lifted_lambda_res_128040 = (int64_t) -1;
        }
        
        bool cond_128042 = sle64((int64_t) 0, lifted_lambda_res_128040);
        bool cond_t_res_128043 = slt64(lifted_lambda_res_128040, nR_107305);
        bool x_128044 = cond_128042 && cond_t_res_128043;
        int64_t lifted_lambda_res_128045;
        
        if (x_128044) {
            bool index_certs_128468;
            
            if (!x_128044) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lifted_lambda_res_128040, "] out of bounds for array of shape [", (long long) nR_107305, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftRelational.fut:189:78-81\n   #4  ftRelational.fut:180:1-189:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t lifted_lambda_res_t_res_128469 = ((int64_t *) ext_mem_133532.mem)[lifted_lambda_res_128040];
            
            lifted_lambda_res_128045 = lifted_lambda_res_t_res_128469;
        } else {
            lifted_lambda_res_128045 = (int64_t) 0;
        }
        
        bool lifted_lambda_res_128049 = slt64((int64_t) 1, lifted_lambda_res_128045);
        int64_t defunc_0_f_res_128050 = btoi_bool_i64(lifted_lambda_res_128049);
        int64_t defunc_0_op_res_120595 = add64(defunc_0_f_res_128050, scanacc_133310);
        int64_t lifted_lambda_res_120560 = add64(lifted_lambda_res_128045, scanacc_133311);
        int64_t zp_res_126101 = add64(lifted_lambda_res_128045, redout_133314);
        
        ((int64_t *) mem_133534)[i_133318] = defunc_0_op_res_120595;
        ((int64_t *) mem_133536)[i_133318] = lifted_lambda_res_120560;
        ((int64_t *) mem_133538)[i_133318] = defunc_0_f_res_128050;
        ((int64_t *) mem_133540)[i_133318] = lifted_lambda_res_128045;
        ((int64_t *) mem_133542)[i_133318] = lifted_lambda_res_128040;
        
        int64_t scanacc_tmp_133911 = defunc_0_op_res_120595;
        int64_t scanacc_tmp_133912 = lifted_lambda_res_120560;
        int64_t redout_tmp_133915 = zp_res_126101;
        
        scanacc_133310 = scanacc_tmp_133911;
        scanacc_133311 = scanacc_tmp_133912;
        redout_133314 = redout_tmp_133915;
    }
    discard_133324 = scanacc_133310;
    discard_133325 = scanacc_133311;
    defunc_res_128479 = redout_133314;
    if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
        return 1;
    
    int64_t tmp_120598 = sub64(nR_107305, (int64_t) 1);
    bool y_120600 = slt64(tmp_120598, nR_107305);
    bool x_120599 = sle64((int64_t) 0, tmp_120598);
    bool bounds_check_120601 = x_120599 && y_120600;
    bool cond_120596 = nR_107305 == (int64_t) 0;
    bool protect_assert_disj_120602 = cond_120596 || bounds_check_120601;
    bool index_certs_120603;
    
    if (!protect_assert_disj_120602) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_120598, "] out of bounds for array of shape [", (long long) nR_107305, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:189:78-81\n   #4  ftRelational.fut:180:1-189:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool x_120597 = !cond_120596;
    int64_t m_f_res_120604;
    
    if (x_120597) {
        int64_t x_128475 = ((int64_t *) mem_133534)[tmp_120598];
        
        m_f_res_120604 = x_128475;
    } else {
        m_f_res_120604 = (int64_t) 0;
    }
    
    int64_t m_120606;
    
    if (cond_120596) {
        m_120606 = (int64_t) 0;
    } else {
        m_120606 = m_f_res_120604;
    }
    
    int64_t m_120616 = sub64(m_120606, (int64_t) 1);
    bool i_p_m_t_s_leq_w_120618 = slt64(m_120616, nR_107305);
    bool zzero_leq_i_p_m_t_s_120617 = sle64((int64_t) 0, m_120616);
    bool y_120620 = zzero_leq_i_p_m_t_s_120617 && i_p_m_t_s_leq_w_120618;
    bool i_lte_j_120619 = sle64((int64_t) 0, m_120606);
    bool forwards_ok_120621 = i_lte_j_120619 && y_120620;
    bool eq_x_zz_120613 = (int64_t) 0 == m_f_res_120604;
    bool p_and_eq_x_y_120614 = x_120597 && eq_x_zz_120613;
    bool empty_slice_120615 = cond_120596 || p_and_eq_x_y_120614;
    bool ok_or_empty_120622 = empty_slice_120615 || forwards_ok_120621;
    bool index_certs_120623;
    
    if (!ok_or_empty_120622) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_120606, "] out of bounds for array of shape [", (long long) nR_107305, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:189:78-81\n   #4  ftRelational.fut:180:1-189:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133573 = (int64_t) 8 * m_120606;
    int64_t bytes_133585 = (int64_t) 8 * defunc_res_128479;
    int64_t bytes_133589 = (int64_t) 4 * defunc_res_128479;
    
    if (futrts_indicesWithIncrement_11708(ctx, &ext_mem_133468, tR_mem_133466, nR_107305, offset_R_107309) != 0) {
        err = 1;
        goto cleanup;
    }
    if (mem_133574_cached_sizze_134074 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133574, &mem_133574_cached_sizze_134074, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133574, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133540, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (mem_133576_cached_sizze_134075 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133576, &mem_133576_cached_sizze_134075, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133328 = 0; i_133328 < nR_107305; i_133328++) {
        int64_t eta_p_127956 = ((int64_t *) mem_133540)[i_133328];
        int64_t zv_lhs_127958 = add64((int64_t) -1, i_133328);
        int64_t tmp_127959 = smod64(zv_lhs_127958, nR_107305);
        int64_t lifted_lambda_res_127960 = ((int64_t *) mem_133536)[tmp_127959];
        bool cond_127962 = i_133328 == (int64_t) 0;
        int64_t lifted_lambda_res_127963;
        
        if (cond_127962) {
            lifted_lambda_res_127963 = (int64_t) 0;
        } else {
            lifted_lambda_res_127963 = lifted_lambda_res_127960;
        }
        
        bool cond_127965 = slt64((int64_t) 0, eta_p_127956);
        int64_t lifted_lambda_res_127966;
        
        if (cond_127965) {
            lifted_lambda_res_127966 = lifted_lambda_res_127963;
        } else {
            lifted_lambda_res_127966 = (int64_t) -1;
        }
        ((int64_t *) mem_133576)[i_133328] = lifted_lambda_res_127966;
    }
    if (mem_133584_cached_sizze_134076 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134076, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133584, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133576, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (memblock_alloc(ctx, &mem_133586, bytes_133585, "mem_133586")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133920 = 0; nest_i_133920 < defunc_res_128479; nest_i_133920++) {
        ((int64_t *) mem_133586.mem)[nest_i_133920] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133588, bytes_133585, "mem_133588")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133921 = 0; nest_i_133921 < defunc_res_128479; nest_i_133921++) {
        ((int64_t *) mem_133588.mem)[nest_i_133921] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133590, bytes_133589, "mem_133590")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133922 = 0; nest_i_133922 < defunc_res_128479; nest_i_133922++) {
        ((float *) mem_133590.mem)[nest_i_133922] = 0.0F;
    }
    for (int64_t write_iter_133330 = 0; write_iter_133330 < nR_107305; write_iter_133330++) {
        int64_t write_iv_133336 = ((int64_t *) mem_133538)[write_iter_133330];
        int64_t write_iv_133337 = ((int64_t *) mem_133534)[write_iter_133330];
        int64_t write_iv_133338 = ((int64_t *) mem_133576)[write_iter_133330];
        int64_t write_iv_133339 = ((int64_t *) mem_133540)[write_iter_133330];
        int64_t write_iv_133340 = ((int64_t *) mem_133542)[write_iter_133330];
        bool cond_128065 = sle64((int64_t) 0, write_iv_133340);
        bool cond_t_res_128066 = slt64(write_iv_133340, nR_107305);
        bool x_128067 = cond_128065 && cond_t_res_128066;
        float lifted_lambda_res_128068;
        int64_t lifted_lambda_res_128069;
        int64_t lifted_lambda_res_128070;
        
        if (x_128067) {
            bool index_certs_128470;
            
            if (!x_128067) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) write_iv_133340, "] out of bounds for array of shape [", (long long) nR_107305, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftSMJ.fut:364:7-365:57\n   #4  ftRelational.fut:189:78-81\n   #5  ftRelational.fut:180:1-189:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            float lifted_lambda_res_t_res_128471 = ((float *) tR_mem_133466.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128472 = ((int64_t *) ext_mem_133468.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128473 = ((int64_t *) ext_mem_133531.mem)[write_iv_133340];
            
            lifted_lambda_res_128068 = lifted_lambda_res_t_res_128471;
            lifted_lambda_res_128069 = lifted_lambda_res_t_res_128472;
            lifted_lambda_res_128070 = lifted_lambda_res_t_res_128473;
        } else {
            lifted_lambda_res_128068 = 0.0F;
            lifted_lambda_res_128069 = (int64_t) -1;
            lifted_lambda_res_128070 = (int64_t) -1;
        }
        
        bool cond_128078 = write_iv_133336 == (int64_t) 1;
        int64_t lifted_lambda_res_128079;
        
        if (cond_128078) {
            int64_t lifted_lambda_res_t_res_128474 = sub64(write_iv_133337, (int64_t) 1);
            
            lifted_lambda_res_128079 = lifted_lambda_res_t_res_128474;
        } else {
            lifted_lambda_res_128079 = (int64_t) -1;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133584)[lifted_lambda_res_128079] = write_iv_133338;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133574)[lifted_lambda_res_128079] = write_iv_133339;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((float *) mem_133590.mem)[write_iv_133338] = lifted_lambda_res_128068;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133588.mem)[write_iv_133338] = lifted_lambda_res_128069;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133586.mem)[write_iv_133338] = lifted_lambda_res_128070;
        }
    }
    if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
        return 1;
    for (int64_t i_120636 = 0; i_120636 < m_120606; i_120636++) {
        int64_t loopres_120640 = ((int64_t *) mem_133584)[i_120636];
        int64_t loopres_120641 = ((int64_t *) mem_133574)[i_120636];
        bool x_120642 = sle64((int64_t) 0, loopres_120640);
        bool y_120643 = slt64(loopres_120640, defunc_res_128479);
        bool bounds_check_120644 = x_120642 && y_120643;
        bool index_certs_120645;
        
        if (!bounds_check_120644) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:346:52-59\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t tmp_120655 = add64(loopres_120640, loopres_120641);
        bool empty_slice_120656 = loopres_120641 == (int64_t) 0;
        int64_t m_120657 = sub64(loopres_120641, (int64_t) 1);
        int64_t i_p_m_t_s_120658 = add64(loopres_120640, m_120657);
        bool zzero_leq_i_p_m_t_s_120659 = sle64((int64_t) 0, i_p_m_t_s_120658);
        bool i_p_m_t_s_leq_w_120660 = slt64(i_p_m_t_s_120658, defunc_res_128479);
        bool i_lte_j_120661 = sle64(loopres_120640, tmp_120655);
        bool y_120662 = x_120642 && i_p_m_t_s_leq_w_120660;
        bool y_120663 = zzero_leq_i_p_m_t_s_120659 && y_120662;
        bool forwards_ok_120664 = i_lte_j_120661 && y_120663;
        bool ok_or_empty_120665 = empty_slice_120656 || forwards_ok_120664;
        bool index_certs_120666;
        
        if (!ok_or_empty_120665) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, ":", (long long) tmp_120655, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:348:8-40\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:189:78-81\n   #3  ftRelational.fut:180:1-189:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        float loopres_120646 = ((float *) mem_133590.mem)[loopres_120640];
        int64_t loopres_120647 = ((int64_t *) mem_133588.mem)[loopres_120640];
        int64_t loopres_120648 = ((int64_t *) mem_133586.mem)[loopres_120640];
        
        for (int64_t nest_i_133931 = 0; nest_i_133931 < loopres_120641; nest_i_133931++) {
            ((float *) mem_133590.mem)[loopres_120640 + nest_i_133931] = loopres_120646;
        }
        for (int64_t nest_i_133932 = 0; nest_i_133932 < loopres_120641; nest_i_133932++) {
            ((int64_t *) mem_133588.mem)[loopres_120640 + nest_i_133932] = loopres_120647;
        }
        for (int64_t i_133349 = 0; i_133349 < loopres_120641; i_133349++) {
            int64_t tmp_120654 = add64(loopres_120648, i_133349);
            
            ((int64_t *) mem_133586.mem)[loopres_120640 + i_133349] = tmp_120654;
        }
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133588, "mem_133588") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133586, "mem_133586") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133879, &mem_133590, "mem_133590") != 0)
        return 1;
    prim_out_133880 = defunc_res_128479;
    if (memblock_set(ctx, &*mem_out_p_134065, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134066, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134067, &mem_out_133879, "mem_out_133879") != 0)
        return 1;
    *out_prim_out_134068 = prim_out_133880;
    
  cleanup:
    {
        free(mem_133534);
        free(mem_133536);
        free(mem_133538);
        free(mem_133540);
        free(mem_133542);
        free(mem_133574);
        free(mem_133576);
        free(mem_133584);
        if (memblock_unref(ctx, &mem_133590, "mem_133590") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133588, "mem_133588") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133586, "mem_133586") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133524, "mem_133524") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133492, "mem_133492") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133490, "mem_133490") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133507, "ext_mem_133507") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133510, "ext_mem_133510") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133513, "ext_mem_133513") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133516, "ext_mem_133516") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133478, "mem_param_133478") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133879, "mem_out_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_int(struct futhark_context *ctx, struct memblock *mem_out_p_134077, struct memblock *mem_out_p_134078, struct memblock *mem_out_p_134079, int64_t *out_prim_out_134080, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_103069, int64_t nS_103070, int64_t offset_R_103073, int64_t offset_S_103074, int64_t partitionSizze_103075, int64_t scatter_psizze_103076)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133534_cached_sizze_134081 = 0;
    unsigned char *mem_133534 = NULL;
    int64_t mem_133536_cached_sizze_134082 = 0;
    unsigned char *mem_133536 = NULL;
    int64_t mem_133538_cached_sizze_134083 = 0;
    unsigned char *mem_133538 = NULL;
    int64_t mem_133540_cached_sizze_134084 = 0;
    unsigned char *mem_133540 = NULL;
    int64_t mem_133542_cached_sizze_134085 = 0;
    unsigned char *mem_133542 = NULL;
    int64_t mem_133574_cached_sizze_134086 = 0;
    unsigned char *mem_133574 = NULL;
    int64_t mem_133576_cached_sizze_134087 = 0;
    unsigned char *mem_133576 = NULL;
    int64_t mem_133584_cached_sizze_134088 = 0;
    unsigned char *mem_133584 = NULL;
    struct memblock mem_133590;
    
    mem_133590.references = NULL;
    
    struct memblock mem_133588;
    
    mem_133588.references = NULL;
    
    struct memblock mem_133586;
    
    mem_133586.references = NULL;
    
    struct memblock ext_mem_133468;
    
    ext_mem_133468.references = NULL;
    
    struct memblock mem_param_tmp_133884;
    
    mem_param_tmp_133884.references = NULL;
    
    struct memblock mem_param_tmp_133883;
    
    mem_param_tmp_133883.references = NULL;
    
    struct memblock mem_133526;
    
    mem_133526.references = NULL;
    
    struct memblock mem_133524;
    
    mem_133524.references = NULL;
    
    struct memblock mem_param_tmp_133893;
    
    mem_param_tmp_133893.references = NULL;
    
    struct memblock mem_param_tmp_133892;
    
    mem_param_tmp_133892.references = NULL;
    
    struct memblock mem_133492;
    
    mem_133492.references = NULL;
    
    struct memblock mem_133490;
    
    mem_133490.references = NULL;
    
    struct memblock ext_mem_133507;
    
    ext_mem_133507.references = NULL;
    
    struct memblock ext_mem_133510;
    
    ext_mem_133510.references = NULL;
    
    struct memblock ext_mem_133513;
    
    ext_mem_133513.references = NULL;
    
    struct memblock ext_mem_133516;
    
    ext_mem_133516.references = NULL;
    
    struct memblock mem_param_133488;
    
    mem_param_133488.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133521;
    
    ext_mem_133521.references = NULL;
    
    struct memblock ext_mem_133522;
    
    ext_mem_133522.references = NULL;
    
    struct memblock mem_133482;
    
    mem_133482.references = NULL;
    
    struct memblock mem_133480;
    
    mem_133480.references = NULL;
    
    struct memblock mem_param_133478;
    
    mem_param_133478.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock ext_mem_133531;
    
    ext_mem_133531.references = NULL;
    
    struct memblock ext_mem_133532;
    
    ext_mem_133532.references = NULL;
    
    struct memblock mem_133472;
    
    mem_133472.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t prim_out_133880;
    int64_t zm_lhs_120281 = add64(nR_103069, partitionSizze_103075);
    int64_t zs_lhs_120282 = sub64(zm_lhs_120281, (int64_t) 1);
    bool zzero_120283 = partitionSizze_103075 == (int64_t) 0;
    bool nonzzero_120284 = !zzero_120283;
    bool nonzzero_cert_120285;
    
    if (!nonzzero_120284) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftSMJ.fut:271:43-57\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t numIter_R_120286 = sdiv64(zs_lhs_120282, partitionSizze_103075);
    int64_t zm_lhs_120287 = add64(nS_103070, partitionSizze_103075);
    int64_t zs_lhs_120288 = sub64(zm_lhs_120287, (int64_t) 1);
    int64_t numIter_S_120289 = sdiv64(zs_lhs_120288, partitionSizze_103075);
    int64_t bytes_133469 = (int64_t) 8 * nR_103069;
    
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133881 = 0; nest_i_133881 < nR_103069; nest_i_133881++) {
        ((int64_t *) mem_133470.mem)[nest_i_133881] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133472, bytes_133469, "mem_133472")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133882 = 0; nest_i_133882 < nR_103069; nest_i_133882++) {
        ((int64_t *) mem_133472.mem)[nest_i_133882] = (int64_t) 0;
    }
    
    bool loop_cond_120293 = slt64((int64_t) 0, numIter_R_120286);
    bool defunc_0_mergeJoin_res_120294;
    int64_t defunc_0_mergeJoin_res_120295;
    int64_t defunc_0_mergeJoin_res_120298;
    bool loop_while_120299;
    int64_t iter_120300;
    int64_t first_relevant_in_S_120303;
    
    if (memblock_set(ctx, &mem_param_133475, &mem_133472, "mem_133472") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133478, &mem_133470, "mem_133470") != 0)
        return 1;
    loop_while_120299 = loop_cond_120293;
    iter_120300 = (int64_t) 0;
    first_relevant_in_S_120303 = (int64_t) 0;
    while (loop_while_120299) {
        int64_t tR_start_120304 = mul64(partitionSizze_103075, iter_120300);
        int64_t min_arg1_120305 = add64(partitionSizze_103075, tR_start_120304);
        int64_t min_res_120306 = smin64(nR_103069, min_arg1_120305);
        int64_t dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 = sub64(min_res_120306, tR_start_120304);
        bool empty_slice_120308 = dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 == (int64_t) 0;
        int64_t m_120309 = sub64(dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, (int64_t) 1);
        int64_t i_p_m_t_s_120310 = add64(tR_start_120304, m_120309);
        bool zzero_leq_i_p_m_t_s_120311 = sle64((int64_t) 0, i_p_m_t_s_120310);
        bool i_p_m_t_s_leq_w_120312 = slt64(i_p_m_t_s_120310, nR_103069);
        bool zzero_lte_i_120313 = sle64((int64_t) 0, tR_start_120304);
        bool i_lte_j_120314 = sle64(tR_start_120304, min_res_120306);
        bool y_120315 = i_p_m_t_s_leq_w_120312 && zzero_lte_i_120313;
        bool y_120316 = zzero_leq_i_p_m_t_s_120311 && y_120315;
        bool forwards_ok_120317 = i_lte_j_120314 && y_120316;
        bool ok_or_empty_120318 = empty_slice_120308 || forwards_ok_120317;
        bool index_certs_120319;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_103069, "].", "-> #0  ftSMJ.fut:278:17-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t bytes_133479 = (int64_t) 8 * dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307;
        bool cond_120323 = slt64(first_relevant_in_S_120303, numIter_S_120289);
        bool y_120324 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool loop_not_taken_120325 = !cond_120323;
        bool protect_assert_disj_120326 = y_120324 || loop_not_taken_120325;
        bool index_certs_120327;
        
        if (!protect_assert_disj_120326) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:293:26-34\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool x_120330 = sle64((int64_t) 0, m_120309);
        bool y_120331 = slt64(m_120309, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool bounds_check_120332 = x_120330 && y_120331;
        bool protect_assert_disj_120333 = loop_not_taken_120325 || bounds_check_120332;
        bool index_certs_120334;
        
        if (!protect_assert_disj_120333) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:294:42-61\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool index_certs_120531;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_103069, "].", "-> #0  ftSMJ.fut:199:15-63\n   #1  ftSMJ.fut:304:20-64\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:167:78-81\n   #4  ftRelational.fut:158:1-167:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133480, bytes_133479, "mem_133480")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133890 = 0; nest_i_133890 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133890++) {
            ((int64_t *) mem_133480.mem)[nest_i_133890] = (int64_t) -1;
        }
        if (memblock_alloc(ctx, &mem_133482, bytes_133479, "mem_133482")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133891 = 0; nest_i_133891 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133891++) {
            ((int64_t *) mem_133482.mem)[nest_i_133891] = (int64_t) 0;
        }
        
        int32_t gt_lhs_120328;
        
        if (cond_120323) {
            int32_t x_128449 = ((int32_t *) tR_mem_133466.mem)[tR_start_120304];
            
            gt_lhs_120328 = x_128449;
        } else {
            gt_lhs_120328 = 0;
        }
        
        int32_t gt_rhs_120335;
        
        if (cond_120323) {
            int32_t x_128450 = ((int32_t *) tR_mem_133466.mem)[i_p_m_t_s_120310];
            
            gt_rhs_120335 = x_128450;
        } else {
            gt_rhs_120335 = 0;
        }
        
        int64_t ext_133520;
        int64_t ext_133519;
        int64_t ext_133518;
        int64_t ext_133517;
        bool loopres_120337;
        int64_t loopres_120338;
        int64_t loopres_120341;
        bool loop_while_120342;
        int64_t s_iter_120343;
        int64_t minRelevant_120346;
        int64_t ctx_param_ext_133483;
        int64_t ctx_param_ext_133484;
        int64_t ctx_param_ext_133486;
        int64_t ctx_param_ext_133487;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133488, &mem_133480, "mem_133480") != 0)
            return 1;
        ctx_param_ext_133483 = (int64_t) 0;
        ctx_param_ext_133484 = (int64_t) 1;
        ctx_param_ext_133486 = (int64_t) 0;
        ctx_param_ext_133487 = (int64_t) 1;
        loop_while_120342 = cond_120323;
        s_iter_120343 = first_relevant_in_S_120303;
        minRelevant_120346 = first_relevant_in_S_120303;
        while (loop_while_120342) {
            int64_t tS_start_120347 = mul64(partitionSizze_103075, s_iter_120343);
            int64_t min_arg1_120348 = add64(partitionSizze_103075, tS_start_120347);
            int64_t min_res_120349 = smin64(nS_103070, min_arg1_120348);
            int64_t dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 = sub64(min_res_120349, tS_start_120347);
            bool empty_slice_120351 = dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 == (int64_t) 0;
            int64_t m_120352 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 1);
            int64_t i_p_m_t_s_120353 = add64(tS_start_120347, m_120352);
            bool zzero_leq_i_p_m_t_s_120354 = sle64((int64_t) 0, i_p_m_t_s_120353);
            bool i_p_m_t_s_leq_w_120355 = slt64(i_p_m_t_s_120353, nS_103070);
            bool zzero_lte_i_120356 = sle64((int64_t) 0, tS_start_120347);
            bool i_lte_j_120357 = sle64(tS_start_120347, min_res_120349);
            bool y_120358 = i_p_m_t_s_leq_w_120355 && zzero_lte_i_120356;
            bool y_120359 = zzero_leq_i_p_m_t_s_120354 && y_120358;
            bool forwards_ok_120360 = i_lte_j_120357 && y_120359;
            bool ok_or_empty_120361 = empty_slice_120351 || forwards_ok_120360;
            bool index_certs_120362;
            
            if (!ok_or_empty_120361) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tS_start_120347, ":", (long long) min_res_120349, "] out of bounds for array of shape [", (long long) nS_103070, "].", "-> #0  ftSMJ.fut:291:19-38\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool x_120363 = sle64((int64_t) 0, m_120352);
            bool y_120364 = slt64(m_120352, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool bounds_check_120365 = x_120363 && y_120364;
            bool index_certs_120366;
            
            if (!bounds_check_120365) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120352, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:293:40-59\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_120369 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool index_certs_120370;
            
            if (!y_120369) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:294:28-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int32_t gt_rhs_120367 = ((int32_t *) tS_mem_133467.mem)[i_p_m_t_s_120353];
            bool defunc_0_gt_res_120368 = slt32(gt_rhs_120367, gt_lhs_120328);
            int32_t gt_lhs_120371 = ((int32_t *) tS_mem_133467.mem)[tS_start_120347];
            bool defunc_0_gt_res_120372 = slt32(gt_rhs_120335, gt_lhs_120371);
            bool thisStillRel_120373 = !defunc_0_gt_res_120372;
            int64_t ext_133509;
            
            if (defunc_0_gt_res_120372) {
                ext_133509 = ctx_param_ext_133483;
            } else {
                ext_133509 = (int64_t) 0;
            }
            
            int64_t ext_133508;
            
            if (defunc_0_gt_res_120372) {
                ext_133508 = ctx_param_ext_133484;
            } else {
                ext_133508 = (int64_t) 1;
            }
            
            int64_t ext_133506;
            
            if (defunc_0_gt_res_120372) {
                ext_133506 = ctx_param_ext_133486;
            } else {
                ext_133506 = (int64_t) 0;
            }
            
            int64_t ext_133505;
            
            if (defunc_0_gt_res_120372) {
                ext_133505 = ctx_param_ext_133487;
            } else {
                ext_133505 = (int64_t) 1;
            }
            
            int64_t ext_133515;
            
            if (defunc_0_gt_res_120368) {
                ext_133515 = ctx_param_ext_133483;
            } else {
                ext_133515 = ext_133509;
            }
            
            int64_t ext_133514;
            
            if (defunc_0_gt_res_120368) {
                ext_133514 = ctx_param_ext_133484;
            } else {
                ext_133514 = ext_133508;
            }
            
            int64_t ext_133512;
            
            if (defunc_0_gt_res_120368) {
                ext_133512 = ctx_param_ext_133486;
            } else {
                ext_133512 = ext_133506;
            }
            
            int64_t ext_133511;
            
            if (defunc_0_gt_res_120368) {
                ext_133511 = ctx_param_ext_133487;
            } else {
                ext_133511 = ext_133505;
            }
            
            int64_t loopres_120374;
            bool loopres_120377;
            int64_t loopres_120378;
            
            if (defunc_0_gt_res_120368) {
                int64_t tmp_128451 = add64((int64_t) 1, s_iter_120343);
                
                if (memblock_set(ctx, &ext_mem_133516, &mem_param_133485, "mem_param_133485") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &mem_param_133488, "mem_param_133488") != 0)
                    return 1;
                loopres_120374 = tmp_128451;
                loopres_120377 = 1;
                loopres_120378 = tmp_128451;
            } else {
                int64_t loopres_f_res_120380;
                bool loopres_f_res_120383;
                
                if (defunc_0_gt_res_120372) {
                    if (memblock_set(ctx, &ext_mem_133510, &mem_param_133485, "mem_param_133485") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_param_133488, "mem_param_133488") != 0)
                        return 1;
                    loopres_f_res_120380 = s_iter_120343;
                    loopres_f_res_120383 = thisStillRel_120373;
                } else {
                    bool index_certs_120384;
                    
                    if (!bounds_check_120332) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:298:50-69\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t gt_rhs_120385 = ((int32_t *) tR_mem_133466.mem)[i_p_m_t_s_120310];
                    bool defunc_0_gt_res_120386 = slt32(gt_rhs_120385, gt_rhs_120367);
                    bool nextRel_120387 = !defunc_0_gt_res_120386;
                    int64_t find_joinTuples_arg3_120388 = add64(offset_S_103074, tS_start_120347);
                    int64_t max_arg1_120389 = sdiv64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 2);
                    int64_t max_res_120390 = smax64((int64_t) 1, max_arg1_120389);
                    bool loop_cond_120391 = slt64((int64_t) 0, max_res_120390);
                    
                    if (memblock_alloc(ctx, &mem_133490, bytes_133479, "mem_133490")) {
                        err = 1;
                        goto cleanup;
                    }
                    if (memblock_alloc(ctx, &mem_133492, bytes_133479, "mem_133492")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t i_133302 = 0; i_133302 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; i_133302++) {
                        int64_t eta_p_128226 = ((int64_t *) mem_param_133485.mem)[ctx_param_ext_133483 + i_133302 * ctx_param_ext_133484];
                        int64_t slice_133434 = tR_start_120304 + i_133302;
                        int32_t eta_p_128227 = ((int32_t *) tR_mem_133466.mem)[slice_133434];
                        int64_t eta_p_128228 = ((int64_t *) mem_param_133488.mem)[ctx_param_ext_133486 + i_133302 * ctx_param_ext_133487];
                        bool defunc_0_f_res_128229;
                        int64_t defunc_0_f_res_128230;
                        int64_t defunc_0_f_res_128231;
                        bool loop_while_128232;
                        int64_t first_match_128233;
                        int64_t step_128234;
                        
                        loop_while_128232 = loop_cond_120391;
                        first_match_128233 = (int64_t) 0;
                        step_128234 = max_res_120390;
                        while (loop_while_128232) {
                            bool x_128235 = sle64((int64_t) 0, first_match_128233);
                            bool y_128236 = slt64(first_match_128233, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                            bool bounds_check_128237 = x_128235 && y_128236;
                            bool index_certs_128238;
                            
                            if (!bounds_check_128237) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) first_match_128233, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:219:20-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:167:78-81\n   #4  ftRelational.fut:158:1-167:81\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128239 = tS_start_120347 + first_match_128233;
                            int32_t sv_128240 = ((int32_t *) tS_mem_133467.mem)[slice_128239];
                            bool cond_128241 = first_match_128233 == (int64_t) 0;
                            int32_t pv_128242;
                            
                            if (cond_128241) {
                                pv_128242 = sv_128240;
                            } else {
                                int64_t tmp_128243 = sub64(first_match_128233, (int64_t) 1);
                                bool x_128244 = sle64((int64_t) 0, tmp_128243);
                                bool y_128245 = slt64(tmp_128243, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128246 = x_128244 && y_128245;
                                bool index_certs_128247;
                                
                                if (!bounds_check_128246) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128243, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:220:51-68\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:167:78-81\n   #4  ftRelational.fut:158:1-167:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128248 = tS_start_120347 + tmp_128243;
                                int32_t pv_f_res_128249 = ((int32_t *) tS_mem_133467.mem)[slice_128248];
                                
                                pv_128242 = pv_f_res_128249;
                            }
                            
                            bool cond_128250 = first_match_128233 == m_120352;
                            int32_t nv_128251;
                            
                            if (cond_128250) {
                                nv_128251 = sv_128240;
                            } else {
                                int64_t tmp_128252 = add64((int64_t) 1, first_match_128233);
                                bool x_128253 = sle64((int64_t) 0, tmp_128252);
                                bool y_128254 = slt64(tmp_128252, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128255 = x_128253 && y_128254;
                                bool index_certs_128256;
                                
                                if (!bounds_check_128255) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128252, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:221:54-71\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:167:78-81\n   #4  ftRelational.fut:158:1-167:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128257 = tS_start_120347 + tmp_128252;
                                int32_t nv_f_res_128258 = ((int32_t *) tS_mem_133467.mem)[slice_128257];
                                
                                nv_128251 = nv_f_res_128258;
                            }
                            
                            bool defunc_0_eq_res_128259 = sv_128240 == eta_p_128227;
                            bool defunc_0_gt_res_128260 = slt32(pv_128242, eta_p_128227);
                            bool x_128261 = !cond_128241;
                            bool y_128262 = defunc_0_gt_res_128260 && x_128261;
                            bool cond_t_res_128263 = cond_128241 || y_128262;
                            bool x_128264 = defunc_0_eq_res_128259 && cond_t_res_128263;
                            int64_t loopres_128265;
                            int64_t loopres_128266;
                            
                            if (x_128264) {
                                loopres_128265 = first_match_128233;
                                loopres_128266 = (int64_t) 0;
                            } else {
                                int64_t loopres_f_res_128267;
                                int64_t loopres_f_res_128268;
                                
                                if (defunc_0_eq_res_128259) {
                                    int64_t tmp_128452 = sub64(first_match_128233, step_128234);
                                    int64_t max_arg1_128453 = sdiv64(step_128234, (int64_t) 2);
                                    int64_t max_res_128454 = smax64((int64_t) 1, max_arg1_128453);
                                    
                                    loopres_f_res_128267 = tmp_128452;
                                    loopres_f_res_128268 = max_res_128454;
                                } else {
                                    bool defunc_0_gt_res_128272 = slt32(eta_p_128227, sv_128240);
                                    int64_t loopres_f_res_f_res_128273;
                                    int64_t loopres_f_res_f_res_128274;
                                    
                                    if (defunc_0_gt_res_128272) {
                                        int64_t loopres_f_res_f_res_t_res_128455;
                                        int64_t loopres_f_res_f_res_t_res_128456;
                                        
                                        if (cond_t_res_128263) {
                                            loopres_f_res_f_res_t_res_128455 = (int64_t) -1;
                                            loopres_f_res_f_res_t_res_128456 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128457 = sub64(first_match_128233, step_128234);
                                            int64_t max_arg1_128458 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128459 = smax64((int64_t) 1, max_arg1_128458);
                                            
                                            loopres_f_res_f_res_t_res_128455 = tmp_128457;
                                            loopres_f_res_f_res_t_res_128456 = max_res_128459;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_t_res_128455;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_t_res_128456;
                                    } else {
                                        bool defunc_0_gt_res_128282 = slt32(eta_p_128227, nv_128251);
                                        bool x_128283 = !cond_128250;
                                        bool y_128284 = defunc_0_gt_res_128282 && x_128283;
                                        bool cond_128285 = cond_128250 || y_128284;
                                        int64_t loopres_f_res_f_res_f_res_128286;
                                        int64_t loopres_f_res_f_res_f_res_128287;
                                        
                                        if (cond_128285) {
                                            loopres_f_res_f_res_f_res_128286 = (int64_t) -1;
                                            loopres_f_res_f_res_f_res_128287 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128288 = add64(first_match_128233, step_128234);
                                            int64_t max_arg1_128289 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128290 = smax64((int64_t) 1, max_arg1_128289);
                                            
                                            loopres_f_res_f_res_f_res_128286 = tmp_128288;
                                            loopres_f_res_f_res_f_res_128287 = max_res_128290;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_f_res_128286;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_f_res_128287;
                                    }
                                    loopres_f_res_128267 = loopres_f_res_f_res_128273;
                                    loopres_f_res_128268 = loopres_f_res_f_res_128274;
                                }
                                loopres_128265 = loopres_f_res_128267;
                                loopres_128266 = loopres_f_res_128268;
                            }
                            
                            bool loop_cond_128291 = slt64((int64_t) 0, loopres_128266);
                            bool loop_while_tmp_133905 = loop_cond_128291;
                            int64_t first_match_tmp_133906 = loopres_128265;
                            int64_t step_tmp_133907 = loopres_128266;
                            
                            loop_while_128232 = loop_while_tmp_133905;
                            first_match_128233 = first_match_tmp_133906;
                            step_128234 = step_tmp_133907;
                        }
                        defunc_0_f_res_128229 = loop_while_128232;
                        defunc_0_f_res_128230 = first_match_128233;
                        defunc_0_f_res_128231 = step_128234;
                        
                        int64_t zs_lhs_128292 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, defunc_0_f_res_128230);
                        int64_t max_arg1_128293 = sdiv64(zs_lhs_128292, (int64_t) 2);
                        int64_t max_res_128294 = smax64((int64_t) 1, max_arg1_128293);
                        bool cond_128295 = defunc_0_f_res_128230 == (int64_t) -1;
                        int64_t defunc_0_f_res_128296;
                        
                        if (cond_128295) {
                            defunc_0_f_res_128296 = (int64_t) -1;
                        } else {
                            bool loop_cond_128298 = slt64((int64_t) 0, max_res_128294);
                            bool defunc_0_f_res_f_res_128299;
                            int64_t defunc_0_f_res_f_res_128300;
                            int64_t defunc_0_f_res_f_res_128301;
                            bool loop_while_128302;
                            int64_t last_match_128303;
                            int64_t step_128304;
                            
                            loop_while_128302 = loop_cond_128298;
                            last_match_128303 = m_120352;
                            step_128304 = max_res_128294;
                            while (loop_while_128302) {
                                bool x_128305 = sle64((int64_t) 0, last_match_128303);
                                bool y_128306 = slt64(last_match_128303, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128307 = x_128305 && y_128306;
                                bool index_certs_128308;
                                
                                if (!bounds_check_128307) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) last_match_128303, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:240:20-34\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:167:78-81\n   #4  ftRelational.fut:158:1-167:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128309 = tS_start_120347 + last_match_128303;
                                int32_t sv_128310 = ((int32_t *) tS_mem_133467.mem)[slice_128309];
                                bool cond_128311 = last_match_128303 == m_120352;
                                int32_t nv_128312;
                                
                                if (cond_128311) {
                                    nv_128312 = sv_128310;
                                } else {
                                    int64_t tmp_128313 = add64((int64_t) 1, last_match_128303);
                                    bool x_128314 = sle64((int64_t) 0, tmp_128313);
                                    bool y_128315 = slt64(tmp_128313, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                    bool bounds_check_128316 = x_128314 && y_128315;
                                    bool index_certs_128317;
                                    
                                    if (!bounds_check_128316) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128313, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:241:53-69\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:167:78-81\n   #4  ftRelational.fut:158:1-167:81\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128318 = tS_start_120347 + tmp_128313;
                                    int32_t nv_f_res_128319 = ((int32_t *) tS_mem_133467.mem)[slice_128318];
                                    
                                    nv_128312 = nv_f_res_128319;
                                }
                                
                                bool defunc_0_eq_res_128320 = sv_128310 == eta_p_128227;
                                bool defunc_0_gt_res_128321 = slt32(eta_p_128227, nv_128312);
                                bool x_128322 = !cond_128311;
                                bool y_128323 = defunc_0_gt_res_128321 && x_128322;
                                bool cond_t_res_128324 = cond_128311 || y_128323;
                                bool x_128325 = defunc_0_eq_res_128320 && cond_t_res_128324;
                                int64_t loopres_128326;
                                int64_t loopres_128327;
                                
                                if (x_128325) {
                                    loopres_128326 = last_match_128303;
                                    loopres_128327 = (int64_t) 0;
                                } else {
                                    int64_t loopres_f_res_128328;
                                    int64_t loopres_f_res_128329;
                                    
                                    if (defunc_0_eq_res_128320) {
                                        int64_t tmp_128460 = add64(last_match_128303, step_128304);
                                        int64_t max_arg1_128461 = sdiv64(step_128304, (int64_t) 2);
                                        int64_t max_res_128462 = smax64((int64_t) 1, max_arg1_128461);
                                        
                                        loopres_f_res_128328 = tmp_128460;
                                        loopres_f_res_128329 = max_res_128462;
                                    } else {
                                        bool defunc_0_gt_res_128333 = slt32(eta_p_128227, sv_128310);
                                        int64_t loopres_f_res_f_res_128334;
                                        int64_t loopres_f_res_f_res_128335;
                                        
                                        if (defunc_0_gt_res_128333) {
                                            int64_t tmp_128463 = sub64(last_match_128303, step_128304);
                                            int64_t max_arg1_128464 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128465 = smax64((int64_t) 1, max_arg1_128464);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128463;
                                            loopres_f_res_f_res_128335 = max_res_128465;
                                        } else {
                                            int64_t tmp_128339 = add64(last_match_128303, step_128304);
                                            int64_t max_arg1_128340 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128341 = smax64((int64_t) 1, max_arg1_128340);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128339;
                                            loopres_f_res_f_res_128335 = max_res_128341;
                                        }
                                        loopres_f_res_128328 = loopres_f_res_f_res_128334;
                                        loopres_f_res_128329 = loopres_f_res_f_res_128335;
                                    }
                                    loopres_128326 = loopres_f_res_128328;
                                    loopres_128327 = loopres_f_res_128329;
                                }
                                
                                bool loop_cond_128342 = slt64((int64_t) 0, loopres_128327);
                                bool loop_while_tmp_133908 = loop_cond_128342;
                                int64_t last_match_tmp_133909 = loopres_128326;
                                int64_t step_tmp_133910 = loopres_128327;
                                
                                loop_while_128302 = loop_while_tmp_133908;
                                last_match_128303 = last_match_tmp_133909;
                                step_128304 = step_tmp_133910;
                            }
                            defunc_0_f_res_f_res_128299 = loop_while_128302;
                            defunc_0_f_res_f_res_128300 = last_match_128303;
                            defunc_0_f_res_f_res_128301 = step_128304;
                            defunc_0_f_res_128296 = defunc_0_f_res_f_res_128300;
                        }
                        
                        bool cond_128343 = slt64(defunc_0_f_res_128230, (int64_t) 0);
                        int64_t cm_128344;
                        
                        if (cond_128343) {
                            cm_128344 = (int64_t) 0;
                        } else {
                            int64_t zp_lhs_128345 = sub64(defunc_0_f_res_128296, defunc_0_f_res_128230);
                            int64_t cm_f_res_128346 = add64((int64_t) 1, zp_lhs_128345);
                            
                            cm_128344 = cm_f_res_128346;
                        }
                        
                        int64_t lifted_lambda_res_128350;
                        
                        if (cond_128343) {
                            lifted_lambda_res_128350 = defunc_0_f_res_128230;
                        } else {
                            int64_t lifted_lambda_res_f_res_128351 = add64(find_joinTuples_arg3_120388, defunc_0_f_res_128230);
                            
                            lifted_lambda_res_128350 = lifted_lambda_res_f_res_128351;
                        }
                        
                        bool cond_128353 = slt64(eta_p_128228, (int64_t) 0);
                        int64_t lifted_lambda_res_128354;
                        
                        if (cond_128353) {
                            lifted_lambda_res_128354 = lifted_lambda_res_128350;
                        } else {
                            lifted_lambda_res_128354 = eta_p_128228;
                        }
                        
                        int64_t defunc_0_f_res_128357 = add64(eta_p_128226, cm_128344);
                        
                        ((int64_t *) mem_133490.mem)[i_133302] = defunc_0_f_res_128357;
                        ((int64_t *) mem_133492.mem)[i_133302] = lifted_lambda_res_128354;
                    }
                    
                    int64_t tmp_120527 = add64((int64_t) 1, s_iter_120343);
                    
                    if (memblock_set(ctx, &ext_mem_133510, &mem_133490, "mem_133490") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_133492, "mem_133492") != 0)
                        return 1;
                    loopres_f_res_120380 = tmp_120527;
                    loopres_f_res_120383 = nextRel_120387;
                }
                if (memblock_set(ctx, &ext_mem_133516, &ext_mem_133510, "ext_mem_133510") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &ext_mem_133507, "ext_mem_133507") != 0)
                    return 1;
                loopres_120374 = loopres_f_res_120380;
                loopres_120377 = loopres_f_res_120383;
                loopres_120378 = minRelevant_120346;
            }
            
            bool cond_120528 = slt64(loopres_120374, numIter_S_120289);
            bool x_120529 = loopres_120377 && cond_120528;
            
            if (memblock_set(ctx, &mem_param_tmp_133892, &ext_mem_133516, "ext_mem_133516") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133893, &ext_mem_133513, "ext_mem_133513") != 0)
                return 1;
            
            int64_t ctx_param_ext_tmp_133894 = ext_133515;
            int64_t ctx_param_ext_tmp_133895 = ext_133514;
            int64_t ctx_param_ext_tmp_133896 = ext_133512;
            int64_t ctx_param_ext_tmp_133897 = ext_133511;
            bool loop_while_tmp_133898 = x_120529;
            int64_t s_iter_tmp_133899 = loopres_120374;
            int64_t minRelevant_tmp_133902 = loopres_120378;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133488, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
                return 1;
            ctx_param_ext_133483 = ctx_param_ext_tmp_133894;
            ctx_param_ext_133484 = ctx_param_ext_tmp_133895;
            ctx_param_ext_133486 = ctx_param_ext_tmp_133896;
            ctx_param_ext_133487 = ctx_param_ext_tmp_133897;
            loop_while_120342 = loop_while_tmp_133898;
            s_iter_120343 = s_iter_tmp_133899;
            minRelevant_120346 = minRelevant_tmp_133902;
        }
        if (memblock_set(ctx, &ext_mem_133522, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133521, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        ext_133520 = ctx_param_ext_133483;
        ext_133519 = ctx_param_ext_133484;
        ext_133518 = ctx_param_ext_133486;
        ext_133517 = ctx_param_ext_133487;
        loopres_120337 = loop_while_120342;
        loopres_120338 = s_iter_120343;
        loopres_120341 = minRelevant_120346;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133524, bytes_133469, "mem_133524")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133478.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_103069});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133521.mem, ext_133518, (int64_t []) {ext_133517}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133526, bytes_133469, "mem_133526")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_103069});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133522.mem, ext_133520, (int64_t []) {ext_133519}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        
        int64_t tmp_120535 = add64((int64_t) 1, iter_120300);
        bool loop_cond_120536 = slt64(tmp_120535, numIter_R_120286);
        
        if (memblock_set(ctx, &mem_param_tmp_133883, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133884, &mem_133524, "mem_133524") != 0)
            return 1;
        
        bool loop_while_tmp_133885 = loop_cond_120536;
        int64_t iter_tmp_133886 = tmp_120535;
        int64_t first_relevant_in_S_tmp_133889 = loopres_120341;
        
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133478, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        loop_while_120299 = loop_while_tmp_133885;
        iter_120300 = iter_tmp_133886;
        first_relevant_in_S_120303 = first_relevant_in_S_tmp_133889;
    }
    if (memblock_set(ctx, &ext_mem_133532, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133531, &mem_param_133478, "mem_param_133478") != 0)
        return 1;
    defunc_0_mergeJoin_res_120294 = loop_while_120299;
    defunc_0_mergeJoin_res_120295 = iter_120300;
    defunc_0_mergeJoin_res_120298 = first_relevant_in_S_120303;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
        return 1;
    if (mem_133534_cached_sizze_134081 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133534, &mem_133534_cached_sizze_134081, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133536_cached_sizze_134082 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133536, &mem_133536_cached_sizze_134082, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133538_cached_sizze_134083 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133538, &mem_133538_cached_sizze_134083, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133540_cached_sizze_134084 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133540, &mem_133540_cached_sizze_134084, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133542_cached_sizze_134085 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133542, &mem_133542_cached_sizze_134085, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t discard_133324;
    int64_t discard_133325;
    int64_t defunc_res_128479;
    int64_t scanacc_133310;
    int64_t scanacc_133311;
    int64_t redout_133314;
    
    scanacc_133310 = (int64_t) 0;
    scanacc_133311 = (int64_t) 0;
    redout_133314 = (int64_t) 0;
    for (int64_t i_133318 = 0; i_133318 < nR_103069; i_133318++) {
        int64_t zg_lhs_128038 = ((int64_t *) ext_mem_133532.mem)[i_133318];
        bool cond_128039 = slt64((int64_t) 0, zg_lhs_128038);
        int64_t lifted_lambda_res_128040;
        
        if (cond_128039) {
            lifted_lambda_res_128040 = i_133318;
        } else {
            lifted_lambda_res_128040 = (int64_t) -1;
        }
        
        bool cond_128042 = sle64((int64_t) 0, lifted_lambda_res_128040);
        bool cond_t_res_128043 = slt64(lifted_lambda_res_128040, nR_103069);
        bool x_128044 = cond_128042 && cond_t_res_128043;
        int64_t lifted_lambda_res_128045;
        
        if (x_128044) {
            bool index_certs_128468;
            
            if (!x_128044) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lifted_lambda_res_128040, "] out of bounds for array of shape [", (long long) nR_103069, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftRelational.fut:167:78-81\n   #4  ftRelational.fut:158:1-167:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t lifted_lambda_res_t_res_128469 = ((int64_t *) ext_mem_133532.mem)[lifted_lambda_res_128040];
            
            lifted_lambda_res_128045 = lifted_lambda_res_t_res_128469;
        } else {
            lifted_lambda_res_128045 = (int64_t) 0;
        }
        
        bool lifted_lambda_res_128049 = slt64((int64_t) 1, lifted_lambda_res_128045);
        int64_t defunc_0_f_res_128050 = btoi_bool_i64(lifted_lambda_res_128049);
        int64_t defunc_0_op_res_120595 = add64(defunc_0_f_res_128050, scanacc_133310);
        int64_t lifted_lambda_res_120560 = add64(lifted_lambda_res_128045, scanacc_133311);
        int64_t zp_res_126101 = add64(lifted_lambda_res_128045, redout_133314);
        
        ((int64_t *) mem_133534)[i_133318] = defunc_0_op_res_120595;
        ((int64_t *) mem_133536)[i_133318] = lifted_lambda_res_120560;
        ((int64_t *) mem_133538)[i_133318] = defunc_0_f_res_128050;
        ((int64_t *) mem_133540)[i_133318] = lifted_lambda_res_128045;
        ((int64_t *) mem_133542)[i_133318] = lifted_lambda_res_128040;
        
        int64_t scanacc_tmp_133911 = defunc_0_op_res_120595;
        int64_t scanacc_tmp_133912 = lifted_lambda_res_120560;
        int64_t redout_tmp_133915 = zp_res_126101;
        
        scanacc_133310 = scanacc_tmp_133911;
        scanacc_133311 = scanacc_tmp_133912;
        redout_133314 = redout_tmp_133915;
    }
    discard_133324 = scanacc_133310;
    discard_133325 = scanacc_133311;
    defunc_res_128479 = redout_133314;
    if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
        return 1;
    
    int64_t tmp_120598 = sub64(nR_103069, (int64_t) 1);
    bool y_120600 = slt64(tmp_120598, nR_103069);
    bool x_120599 = sle64((int64_t) 0, tmp_120598);
    bool bounds_check_120601 = x_120599 && y_120600;
    bool cond_120596 = nR_103069 == (int64_t) 0;
    bool protect_assert_disj_120602 = cond_120596 || bounds_check_120601;
    bool index_certs_120603;
    
    if (!protect_assert_disj_120602) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_120598, "] out of bounds for array of shape [", (long long) nR_103069, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:167:78-81\n   #4  ftRelational.fut:158:1-167:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool x_120597 = !cond_120596;
    int64_t m_f_res_120604;
    
    if (x_120597) {
        int64_t x_128475 = ((int64_t *) mem_133534)[tmp_120598];
        
        m_f_res_120604 = x_128475;
    } else {
        m_f_res_120604 = (int64_t) 0;
    }
    
    int64_t m_120606;
    
    if (cond_120596) {
        m_120606 = (int64_t) 0;
    } else {
        m_120606 = m_f_res_120604;
    }
    
    int64_t m_120616 = sub64(m_120606, (int64_t) 1);
    bool i_p_m_t_s_leq_w_120618 = slt64(m_120616, nR_103069);
    bool zzero_leq_i_p_m_t_s_120617 = sle64((int64_t) 0, m_120616);
    bool y_120620 = zzero_leq_i_p_m_t_s_120617 && i_p_m_t_s_leq_w_120618;
    bool i_lte_j_120619 = sle64((int64_t) 0, m_120606);
    bool forwards_ok_120621 = i_lte_j_120619 && y_120620;
    bool eq_x_zz_120613 = (int64_t) 0 == m_f_res_120604;
    bool p_and_eq_x_y_120614 = x_120597 && eq_x_zz_120613;
    bool empty_slice_120615 = cond_120596 || p_and_eq_x_y_120614;
    bool ok_or_empty_120622 = empty_slice_120615 || forwards_ok_120621;
    bool index_certs_120623;
    
    if (!ok_or_empty_120622) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_120606, "] out of bounds for array of shape [", (long long) nR_103069, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:167:78-81\n   #4  ftRelational.fut:158:1-167:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133573 = (int64_t) 8 * m_120606;
    int64_t bytes_133585 = (int64_t) 8 * defunc_res_128479;
    int64_t bytes_133589 = (int64_t) 4 * defunc_res_128479;
    
    if (futrts_indicesWithIncrement_11664(ctx, &ext_mem_133468, tR_mem_133466, nR_103069, offset_R_103073) != 0) {
        err = 1;
        goto cleanup;
    }
    if (mem_133574_cached_sizze_134086 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133574, &mem_133574_cached_sizze_134086, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133574, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133540, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (mem_133576_cached_sizze_134087 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133576, &mem_133576_cached_sizze_134087, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133328 = 0; i_133328 < nR_103069; i_133328++) {
        int64_t eta_p_127956 = ((int64_t *) mem_133540)[i_133328];
        int64_t zv_lhs_127958 = add64((int64_t) -1, i_133328);
        int64_t tmp_127959 = smod64(zv_lhs_127958, nR_103069);
        int64_t lifted_lambda_res_127960 = ((int64_t *) mem_133536)[tmp_127959];
        bool cond_127962 = i_133328 == (int64_t) 0;
        int64_t lifted_lambda_res_127963;
        
        if (cond_127962) {
            lifted_lambda_res_127963 = (int64_t) 0;
        } else {
            lifted_lambda_res_127963 = lifted_lambda_res_127960;
        }
        
        bool cond_127965 = slt64((int64_t) 0, eta_p_127956);
        int64_t lifted_lambda_res_127966;
        
        if (cond_127965) {
            lifted_lambda_res_127966 = lifted_lambda_res_127963;
        } else {
            lifted_lambda_res_127966 = (int64_t) -1;
        }
        ((int64_t *) mem_133576)[i_133328] = lifted_lambda_res_127966;
    }
    if (mem_133584_cached_sizze_134088 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134088, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133584, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133576, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (memblock_alloc(ctx, &mem_133586, bytes_133585, "mem_133586")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133920 = 0; nest_i_133920 < defunc_res_128479; nest_i_133920++) {
        ((int64_t *) mem_133586.mem)[nest_i_133920] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133588, bytes_133585, "mem_133588")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133921 = 0; nest_i_133921 < defunc_res_128479; nest_i_133921++) {
        ((int64_t *) mem_133588.mem)[nest_i_133921] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133590, bytes_133589, "mem_133590")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133922 = 0; nest_i_133922 < defunc_res_128479; nest_i_133922++) {
        ((int32_t *) mem_133590.mem)[nest_i_133922] = 0;
    }
    for (int64_t write_iter_133330 = 0; write_iter_133330 < nR_103069; write_iter_133330++) {
        int64_t write_iv_133336 = ((int64_t *) mem_133538)[write_iter_133330];
        int64_t write_iv_133337 = ((int64_t *) mem_133534)[write_iter_133330];
        int64_t write_iv_133338 = ((int64_t *) mem_133576)[write_iter_133330];
        int64_t write_iv_133339 = ((int64_t *) mem_133540)[write_iter_133330];
        int64_t write_iv_133340 = ((int64_t *) mem_133542)[write_iter_133330];
        bool cond_128065 = sle64((int64_t) 0, write_iv_133340);
        bool cond_t_res_128066 = slt64(write_iv_133340, nR_103069);
        bool x_128067 = cond_128065 && cond_t_res_128066;
        int32_t lifted_lambda_res_128068;
        int64_t lifted_lambda_res_128069;
        int64_t lifted_lambda_res_128070;
        
        if (x_128067) {
            bool index_certs_128470;
            
            if (!x_128067) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) write_iv_133340, "] out of bounds for array of shape [", (long long) nR_103069, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftSMJ.fut:364:7-365:57\n   #4  ftRelational.fut:167:78-81\n   #5  ftRelational.fut:158:1-167:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int32_t lifted_lambda_res_t_res_128471 = ((int32_t *) tR_mem_133466.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128472 = ((int64_t *) ext_mem_133468.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128473 = ((int64_t *) ext_mem_133531.mem)[write_iv_133340];
            
            lifted_lambda_res_128068 = lifted_lambda_res_t_res_128471;
            lifted_lambda_res_128069 = lifted_lambda_res_t_res_128472;
            lifted_lambda_res_128070 = lifted_lambda_res_t_res_128473;
        } else {
            lifted_lambda_res_128068 = 0;
            lifted_lambda_res_128069 = (int64_t) -1;
            lifted_lambda_res_128070 = (int64_t) -1;
        }
        
        bool cond_128078 = write_iv_133336 == (int64_t) 1;
        int64_t lifted_lambda_res_128079;
        
        if (cond_128078) {
            int64_t lifted_lambda_res_t_res_128474 = sub64(write_iv_133337, (int64_t) 1);
            
            lifted_lambda_res_128079 = lifted_lambda_res_t_res_128474;
        } else {
            lifted_lambda_res_128079 = (int64_t) -1;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133584)[lifted_lambda_res_128079] = write_iv_133338;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133574)[lifted_lambda_res_128079] = write_iv_133339;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int32_t *) mem_133590.mem)[write_iv_133338] = lifted_lambda_res_128068;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133588.mem)[write_iv_133338] = lifted_lambda_res_128069;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133586.mem)[write_iv_133338] = lifted_lambda_res_128070;
        }
    }
    if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
        return 1;
    for (int64_t i_120636 = 0; i_120636 < m_120606; i_120636++) {
        int64_t loopres_120640 = ((int64_t *) mem_133584)[i_120636];
        int64_t loopres_120641 = ((int64_t *) mem_133574)[i_120636];
        bool x_120642 = sle64((int64_t) 0, loopres_120640);
        bool y_120643 = slt64(loopres_120640, defunc_res_128479);
        bool bounds_check_120644 = x_120642 && y_120643;
        bool index_certs_120645;
        
        if (!bounds_check_120644) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:346:52-59\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t tmp_120655 = add64(loopres_120640, loopres_120641);
        bool empty_slice_120656 = loopres_120641 == (int64_t) 0;
        int64_t m_120657 = sub64(loopres_120641, (int64_t) 1);
        int64_t i_p_m_t_s_120658 = add64(loopres_120640, m_120657);
        bool zzero_leq_i_p_m_t_s_120659 = sle64((int64_t) 0, i_p_m_t_s_120658);
        bool i_p_m_t_s_leq_w_120660 = slt64(i_p_m_t_s_120658, defunc_res_128479);
        bool i_lte_j_120661 = sle64(loopres_120640, tmp_120655);
        bool y_120662 = x_120642 && i_p_m_t_s_leq_w_120660;
        bool y_120663 = zzero_leq_i_p_m_t_s_120659 && y_120662;
        bool forwards_ok_120664 = i_lte_j_120661 && y_120663;
        bool ok_or_empty_120665 = empty_slice_120656 || forwards_ok_120664;
        bool index_certs_120666;
        
        if (!ok_or_empty_120665) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, ":", (long long) tmp_120655, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:348:8-40\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:167:78-81\n   #3  ftRelational.fut:158:1-167:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int32_t loopres_120646 = ((int32_t *) mem_133590.mem)[loopres_120640];
        int64_t loopres_120647 = ((int64_t *) mem_133588.mem)[loopres_120640];
        int64_t loopres_120648 = ((int64_t *) mem_133586.mem)[loopres_120640];
        
        for (int64_t nest_i_133931 = 0; nest_i_133931 < loopres_120641; nest_i_133931++) {
            ((int32_t *) mem_133590.mem)[loopres_120640 + nest_i_133931] = loopres_120646;
        }
        for (int64_t nest_i_133932 = 0; nest_i_133932 < loopres_120641; nest_i_133932++) {
            ((int64_t *) mem_133588.mem)[loopres_120640 + nest_i_133932] = loopres_120647;
        }
        for (int64_t i_133349 = 0; i_133349 < loopres_120641; i_133349++) {
            int64_t tmp_120654 = add64(loopres_120648, i_133349);
            
            ((int64_t *) mem_133586.mem)[loopres_120640 + i_133349] = tmp_120654;
        }
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133588, "mem_133588") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133586, "mem_133586") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133879, &mem_133590, "mem_133590") != 0)
        return 1;
    prim_out_133880 = defunc_res_128479;
    if (memblock_set(ctx, &*mem_out_p_134077, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134078, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134079, &mem_out_133879, "mem_out_133879") != 0)
        return 1;
    *out_prim_out_134080 = prim_out_133880;
    
  cleanup:
    {
        free(mem_133534);
        free(mem_133536);
        free(mem_133538);
        free(mem_133540);
        free(mem_133542);
        free(mem_133574);
        free(mem_133576);
        free(mem_133584);
        if (memblock_unref(ctx, &mem_133590, "mem_133590") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133588, "mem_133588") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133586, "mem_133586") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133524, "mem_133524") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133492, "mem_133492") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133490, "mem_133490") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133507, "ext_mem_133507") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133510, "ext_mem_133510") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133513, "ext_mem_133513") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133516, "ext_mem_133516") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133478, "mem_param_133478") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133879, "mem_out_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_long(struct futhark_context *ctx, struct memblock *mem_out_p_134089, struct memblock *mem_out_p_134090, struct memblock *mem_out_p_134091, int64_t *out_prim_out_134092, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_105181, int64_t nS_105182, int64_t offset_R_105185, int64_t offset_S_105186, int64_t partitionSizze_105187, int64_t scatter_psizze_105188)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133534_cached_sizze_134093 = 0;
    unsigned char *mem_133534 = NULL;
    int64_t mem_133536_cached_sizze_134094 = 0;
    unsigned char *mem_133536 = NULL;
    int64_t mem_133538_cached_sizze_134095 = 0;
    unsigned char *mem_133538 = NULL;
    int64_t mem_133540_cached_sizze_134096 = 0;
    unsigned char *mem_133540 = NULL;
    int64_t mem_133542_cached_sizze_134097 = 0;
    unsigned char *mem_133542 = NULL;
    int64_t mem_133574_cached_sizze_134098 = 0;
    unsigned char *mem_133574 = NULL;
    int64_t mem_133576_cached_sizze_134099 = 0;
    unsigned char *mem_133576 = NULL;
    int64_t mem_133584_cached_sizze_134100 = 0;
    unsigned char *mem_133584 = NULL;
    struct memblock mem_133590;
    
    mem_133590.references = NULL;
    
    struct memblock mem_133588;
    
    mem_133588.references = NULL;
    
    struct memblock mem_133586;
    
    mem_133586.references = NULL;
    
    struct memblock ext_mem_133468;
    
    ext_mem_133468.references = NULL;
    
    struct memblock mem_param_tmp_133884;
    
    mem_param_tmp_133884.references = NULL;
    
    struct memblock mem_param_tmp_133883;
    
    mem_param_tmp_133883.references = NULL;
    
    struct memblock mem_133526;
    
    mem_133526.references = NULL;
    
    struct memblock mem_133524;
    
    mem_133524.references = NULL;
    
    struct memblock mem_param_tmp_133893;
    
    mem_param_tmp_133893.references = NULL;
    
    struct memblock mem_param_tmp_133892;
    
    mem_param_tmp_133892.references = NULL;
    
    struct memblock mem_133492;
    
    mem_133492.references = NULL;
    
    struct memblock mem_133490;
    
    mem_133490.references = NULL;
    
    struct memblock ext_mem_133507;
    
    ext_mem_133507.references = NULL;
    
    struct memblock ext_mem_133510;
    
    ext_mem_133510.references = NULL;
    
    struct memblock ext_mem_133513;
    
    ext_mem_133513.references = NULL;
    
    struct memblock ext_mem_133516;
    
    ext_mem_133516.references = NULL;
    
    struct memblock mem_param_133488;
    
    mem_param_133488.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133521;
    
    ext_mem_133521.references = NULL;
    
    struct memblock ext_mem_133522;
    
    ext_mem_133522.references = NULL;
    
    struct memblock mem_133482;
    
    mem_133482.references = NULL;
    
    struct memblock mem_133480;
    
    mem_133480.references = NULL;
    
    struct memblock mem_param_133478;
    
    mem_param_133478.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock ext_mem_133531;
    
    ext_mem_133531.references = NULL;
    
    struct memblock ext_mem_133532;
    
    ext_mem_133532.references = NULL;
    
    struct memblock mem_133472;
    
    mem_133472.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t prim_out_133880;
    int64_t zm_lhs_120281 = add64(nR_105181, partitionSizze_105187);
    int64_t zs_lhs_120282 = sub64(zm_lhs_120281, (int64_t) 1);
    bool zzero_120283 = partitionSizze_105187 == (int64_t) 0;
    bool nonzzero_120284 = !zzero_120283;
    bool nonzzero_cert_120285;
    
    if (!nonzzero_120284) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftSMJ.fut:271:43-57\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t numIter_R_120286 = sdiv64(zs_lhs_120282, partitionSizze_105187);
    int64_t zm_lhs_120287 = add64(nS_105182, partitionSizze_105187);
    int64_t zs_lhs_120288 = sub64(zm_lhs_120287, (int64_t) 1);
    int64_t numIter_S_120289 = sdiv64(zs_lhs_120288, partitionSizze_105187);
    int64_t bytes_133469 = (int64_t) 8 * nR_105181;
    
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133881 = 0; nest_i_133881 < nR_105181; nest_i_133881++) {
        ((int64_t *) mem_133470.mem)[nest_i_133881] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133472, bytes_133469, "mem_133472")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133882 = 0; nest_i_133882 < nR_105181; nest_i_133882++) {
        ((int64_t *) mem_133472.mem)[nest_i_133882] = (int64_t) 0;
    }
    
    bool loop_cond_120293 = slt64((int64_t) 0, numIter_R_120286);
    bool defunc_0_mergeJoin_res_120294;
    int64_t defunc_0_mergeJoin_res_120295;
    int64_t defunc_0_mergeJoin_res_120298;
    bool loop_while_120299;
    int64_t iter_120300;
    int64_t first_relevant_in_S_120303;
    
    if (memblock_set(ctx, &mem_param_133475, &mem_133472, "mem_133472") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133478, &mem_133470, "mem_133470") != 0)
        return 1;
    loop_while_120299 = loop_cond_120293;
    iter_120300 = (int64_t) 0;
    first_relevant_in_S_120303 = (int64_t) 0;
    while (loop_while_120299) {
        int64_t tR_start_120304 = mul64(partitionSizze_105187, iter_120300);
        int64_t min_arg1_120305 = add64(partitionSizze_105187, tR_start_120304);
        int64_t min_res_120306 = smin64(nR_105181, min_arg1_120305);
        int64_t dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 = sub64(min_res_120306, tR_start_120304);
        bool empty_slice_120308 = dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 == (int64_t) 0;
        int64_t m_120309 = sub64(dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, (int64_t) 1);
        int64_t i_p_m_t_s_120310 = add64(tR_start_120304, m_120309);
        bool zzero_leq_i_p_m_t_s_120311 = sle64((int64_t) 0, i_p_m_t_s_120310);
        bool i_p_m_t_s_leq_w_120312 = slt64(i_p_m_t_s_120310, nR_105181);
        bool zzero_lte_i_120313 = sle64((int64_t) 0, tR_start_120304);
        bool i_lte_j_120314 = sle64(tR_start_120304, min_res_120306);
        bool y_120315 = i_p_m_t_s_leq_w_120312 && zzero_lte_i_120313;
        bool y_120316 = zzero_leq_i_p_m_t_s_120311 && y_120315;
        bool forwards_ok_120317 = i_lte_j_120314 && y_120316;
        bool ok_or_empty_120318 = empty_slice_120308 || forwards_ok_120317;
        bool index_certs_120319;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_105181, "].", "-> #0  ftSMJ.fut:278:17-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t bytes_133479 = (int64_t) 8 * dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307;
        bool cond_120323 = slt64(first_relevant_in_S_120303, numIter_S_120289);
        bool y_120324 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool loop_not_taken_120325 = !cond_120323;
        bool protect_assert_disj_120326 = y_120324 || loop_not_taken_120325;
        bool index_certs_120327;
        
        if (!protect_assert_disj_120326) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:293:26-34\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool x_120330 = sle64((int64_t) 0, m_120309);
        bool y_120331 = slt64(m_120309, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool bounds_check_120332 = x_120330 && y_120331;
        bool protect_assert_disj_120333 = loop_not_taken_120325 || bounds_check_120332;
        bool index_certs_120334;
        
        if (!protect_assert_disj_120333) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:294:42-61\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool index_certs_120531;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_105181, "].", "-> #0  ftSMJ.fut:199:15-63\n   #1  ftSMJ.fut:304:20-64\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:178:78-81\n   #4  ftRelational.fut:169:1-178:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133480, bytes_133479, "mem_133480")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133890 = 0; nest_i_133890 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133890++) {
            ((int64_t *) mem_133480.mem)[nest_i_133890] = (int64_t) -1;
        }
        if (memblock_alloc(ctx, &mem_133482, bytes_133479, "mem_133482")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133891 = 0; nest_i_133891 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133891++) {
            ((int64_t *) mem_133482.mem)[nest_i_133891] = (int64_t) 0;
        }
        
        int64_t gt_lhs_120328;
        
        if (cond_120323) {
            int64_t x_128449 = ((int64_t *) tR_mem_133466.mem)[tR_start_120304];
            
            gt_lhs_120328 = x_128449;
        } else {
            gt_lhs_120328 = (int64_t) 0;
        }
        
        int64_t gt_rhs_120335;
        
        if (cond_120323) {
            int64_t x_128450 = ((int64_t *) tR_mem_133466.mem)[i_p_m_t_s_120310];
            
            gt_rhs_120335 = x_128450;
        } else {
            gt_rhs_120335 = (int64_t) 0;
        }
        
        int64_t ext_133520;
        int64_t ext_133519;
        int64_t ext_133518;
        int64_t ext_133517;
        bool loopres_120337;
        int64_t loopres_120338;
        int64_t loopres_120341;
        bool loop_while_120342;
        int64_t s_iter_120343;
        int64_t minRelevant_120346;
        int64_t ctx_param_ext_133483;
        int64_t ctx_param_ext_133484;
        int64_t ctx_param_ext_133486;
        int64_t ctx_param_ext_133487;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133488, &mem_133480, "mem_133480") != 0)
            return 1;
        ctx_param_ext_133483 = (int64_t) 0;
        ctx_param_ext_133484 = (int64_t) 1;
        ctx_param_ext_133486 = (int64_t) 0;
        ctx_param_ext_133487 = (int64_t) 1;
        loop_while_120342 = cond_120323;
        s_iter_120343 = first_relevant_in_S_120303;
        minRelevant_120346 = first_relevant_in_S_120303;
        while (loop_while_120342) {
            int64_t tS_start_120347 = mul64(partitionSizze_105187, s_iter_120343);
            int64_t min_arg1_120348 = add64(partitionSizze_105187, tS_start_120347);
            int64_t min_res_120349 = smin64(nS_105182, min_arg1_120348);
            int64_t dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 = sub64(min_res_120349, tS_start_120347);
            bool empty_slice_120351 = dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 == (int64_t) 0;
            int64_t m_120352 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 1);
            int64_t i_p_m_t_s_120353 = add64(tS_start_120347, m_120352);
            bool zzero_leq_i_p_m_t_s_120354 = sle64((int64_t) 0, i_p_m_t_s_120353);
            bool i_p_m_t_s_leq_w_120355 = slt64(i_p_m_t_s_120353, nS_105182);
            bool zzero_lte_i_120356 = sle64((int64_t) 0, tS_start_120347);
            bool i_lte_j_120357 = sle64(tS_start_120347, min_res_120349);
            bool y_120358 = i_p_m_t_s_leq_w_120355 && zzero_lte_i_120356;
            bool y_120359 = zzero_leq_i_p_m_t_s_120354 && y_120358;
            bool forwards_ok_120360 = i_lte_j_120357 && y_120359;
            bool ok_or_empty_120361 = empty_slice_120351 || forwards_ok_120360;
            bool index_certs_120362;
            
            if (!ok_or_empty_120361) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tS_start_120347, ":", (long long) min_res_120349, "] out of bounds for array of shape [", (long long) nS_105182, "].", "-> #0  ftSMJ.fut:291:19-38\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool x_120363 = sle64((int64_t) 0, m_120352);
            bool y_120364 = slt64(m_120352, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool bounds_check_120365 = x_120363 && y_120364;
            bool index_certs_120366;
            
            if (!bounds_check_120365) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120352, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:293:40-59\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_120369 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool index_certs_120370;
            
            if (!y_120369) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:294:28-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t gt_rhs_120367 = ((int64_t *) tS_mem_133467.mem)[i_p_m_t_s_120353];
            bool defunc_0_gt_res_120368 = slt64(gt_rhs_120367, gt_lhs_120328);
            int64_t gt_lhs_120371 = ((int64_t *) tS_mem_133467.mem)[tS_start_120347];
            bool defunc_0_gt_res_120372 = slt64(gt_rhs_120335, gt_lhs_120371);
            bool thisStillRel_120373 = !defunc_0_gt_res_120372;
            int64_t ext_133509;
            
            if (defunc_0_gt_res_120372) {
                ext_133509 = ctx_param_ext_133483;
            } else {
                ext_133509 = (int64_t) 0;
            }
            
            int64_t ext_133508;
            
            if (defunc_0_gt_res_120372) {
                ext_133508 = ctx_param_ext_133484;
            } else {
                ext_133508 = (int64_t) 1;
            }
            
            int64_t ext_133506;
            
            if (defunc_0_gt_res_120372) {
                ext_133506 = ctx_param_ext_133486;
            } else {
                ext_133506 = (int64_t) 0;
            }
            
            int64_t ext_133505;
            
            if (defunc_0_gt_res_120372) {
                ext_133505 = ctx_param_ext_133487;
            } else {
                ext_133505 = (int64_t) 1;
            }
            
            int64_t ext_133515;
            
            if (defunc_0_gt_res_120368) {
                ext_133515 = ctx_param_ext_133483;
            } else {
                ext_133515 = ext_133509;
            }
            
            int64_t ext_133514;
            
            if (defunc_0_gt_res_120368) {
                ext_133514 = ctx_param_ext_133484;
            } else {
                ext_133514 = ext_133508;
            }
            
            int64_t ext_133512;
            
            if (defunc_0_gt_res_120368) {
                ext_133512 = ctx_param_ext_133486;
            } else {
                ext_133512 = ext_133506;
            }
            
            int64_t ext_133511;
            
            if (defunc_0_gt_res_120368) {
                ext_133511 = ctx_param_ext_133487;
            } else {
                ext_133511 = ext_133505;
            }
            
            int64_t loopres_120374;
            bool loopres_120377;
            int64_t loopres_120378;
            
            if (defunc_0_gt_res_120368) {
                int64_t tmp_128451 = add64((int64_t) 1, s_iter_120343);
                
                if (memblock_set(ctx, &ext_mem_133516, &mem_param_133485, "mem_param_133485") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &mem_param_133488, "mem_param_133488") != 0)
                    return 1;
                loopres_120374 = tmp_128451;
                loopres_120377 = 1;
                loopres_120378 = tmp_128451;
            } else {
                int64_t loopres_f_res_120380;
                bool loopres_f_res_120383;
                
                if (defunc_0_gt_res_120372) {
                    if (memblock_set(ctx, &ext_mem_133510, &mem_param_133485, "mem_param_133485") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_param_133488, "mem_param_133488") != 0)
                        return 1;
                    loopres_f_res_120380 = s_iter_120343;
                    loopres_f_res_120383 = thisStillRel_120373;
                } else {
                    bool index_certs_120384;
                    
                    if (!bounds_check_120332) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:298:50-69\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t gt_rhs_120385 = ((int64_t *) tR_mem_133466.mem)[i_p_m_t_s_120310];
                    bool defunc_0_gt_res_120386 = slt64(gt_rhs_120385, gt_rhs_120367);
                    bool nextRel_120387 = !defunc_0_gt_res_120386;
                    int64_t find_joinTuples_arg3_120388 = add64(offset_S_105186, tS_start_120347);
                    int64_t max_arg1_120389 = sdiv64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 2);
                    int64_t max_res_120390 = smax64((int64_t) 1, max_arg1_120389);
                    bool loop_cond_120391 = slt64((int64_t) 0, max_res_120390);
                    
                    if (memblock_alloc(ctx, &mem_133490, bytes_133479, "mem_133490")) {
                        err = 1;
                        goto cleanup;
                    }
                    if (memblock_alloc(ctx, &mem_133492, bytes_133479, "mem_133492")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t i_133302 = 0; i_133302 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; i_133302++) {
                        int64_t eta_p_128226 = ((int64_t *) mem_param_133485.mem)[ctx_param_ext_133483 + i_133302 * ctx_param_ext_133484];
                        int64_t slice_133434 = tR_start_120304 + i_133302;
                        int64_t eta_p_128227 = ((int64_t *) tR_mem_133466.mem)[slice_133434];
                        int64_t eta_p_128228 = ((int64_t *) mem_param_133488.mem)[ctx_param_ext_133486 + i_133302 * ctx_param_ext_133487];
                        bool defunc_0_f_res_128229;
                        int64_t defunc_0_f_res_128230;
                        int64_t defunc_0_f_res_128231;
                        bool loop_while_128232;
                        int64_t first_match_128233;
                        int64_t step_128234;
                        
                        loop_while_128232 = loop_cond_120391;
                        first_match_128233 = (int64_t) 0;
                        step_128234 = max_res_120390;
                        while (loop_while_128232) {
                            bool x_128235 = sle64((int64_t) 0, first_match_128233);
                            bool y_128236 = slt64(first_match_128233, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                            bool bounds_check_128237 = x_128235 && y_128236;
                            bool index_certs_128238;
                            
                            if (!bounds_check_128237) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) first_match_128233, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:219:20-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:178:78-81\n   #4  ftRelational.fut:169:1-178:81\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128239 = tS_start_120347 + first_match_128233;
                            int64_t sv_128240 = ((int64_t *) tS_mem_133467.mem)[slice_128239];
                            bool cond_128241 = first_match_128233 == (int64_t) 0;
                            int64_t pv_128242;
                            
                            if (cond_128241) {
                                pv_128242 = sv_128240;
                            } else {
                                int64_t tmp_128243 = sub64(first_match_128233, (int64_t) 1);
                                bool x_128244 = sle64((int64_t) 0, tmp_128243);
                                bool y_128245 = slt64(tmp_128243, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128246 = x_128244 && y_128245;
                                bool index_certs_128247;
                                
                                if (!bounds_check_128246) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128243, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:220:51-68\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:178:78-81\n   #4  ftRelational.fut:169:1-178:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128248 = tS_start_120347 + tmp_128243;
                                int64_t pv_f_res_128249 = ((int64_t *) tS_mem_133467.mem)[slice_128248];
                                
                                pv_128242 = pv_f_res_128249;
                            }
                            
                            bool cond_128250 = first_match_128233 == m_120352;
                            int64_t nv_128251;
                            
                            if (cond_128250) {
                                nv_128251 = sv_128240;
                            } else {
                                int64_t tmp_128252 = add64((int64_t) 1, first_match_128233);
                                bool x_128253 = sle64((int64_t) 0, tmp_128252);
                                bool y_128254 = slt64(tmp_128252, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128255 = x_128253 && y_128254;
                                bool index_certs_128256;
                                
                                if (!bounds_check_128255) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128252, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:221:54-71\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:178:78-81\n   #4  ftRelational.fut:169:1-178:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128257 = tS_start_120347 + tmp_128252;
                                int64_t nv_f_res_128258 = ((int64_t *) tS_mem_133467.mem)[slice_128257];
                                
                                nv_128251 = nv_f_res_128258;
                            }
                            
                            bool defunc_0_eq_res_128259 = sv_128240 == eta_p_128227;
                            bool defunc_0_gt_res_128260 = slt64(pv_128242, eta_p_128227);
                            bool x_128261 = !cond_128241;
                            bool y_128262 = defunc_0_gt_res_128260 && x_128261;
                            bool cond_t_res_128263 = cond_128241 || y_128262;
                            bool x_128264 = defunc_0_eq_res_128259 && cond_t_res_128263;
                            int64_t loopres_128265;
                            int64_t loopres_128266;
                            
                            if (x_128264) {
                                loopres_128265 = first_match_128233;
                                loopres_128266 = (int64_t) 0;
                            } else {
                                int64_t loopres_f_res_128267;
                                int64_t loopres_f_res_128268;
                                
                                if (defunc_0_eq_res_128259) {
                                    int64_t tmp_128452 = sub64(first_match_128233, step_128234);
                                    int64_t max_arg1_128453 = sdiv64(step_128234, (int64_t) 2);
                                    int64_t max_res_128454 = smax64((int64_t) 1, max_arg1_128453);
                                    
                                    loopres_f_res_128267 = tmp_128452;
                                    loopres_f_res_128268 = max_res_128454;
                                } else {
                                    bool defunc_0_gt_res_128272 = slt64(eta_p_128227, sv_128240);
                                    int64_t loopres_f_res_f_res_128273;
                                    int64_t loopres_f_res_f_res_128274;
                                    
                                    if (defunc_0_gt_res_128272) {
                                        int64_t loopres_f_res_f_res_t_res_128455;
                                        int64_t loopres_f_res_f_res_t_res_128456;
                                        
                                        if (cond_t_res_128263) {
                                            loopres_f_res_f_res_t_res_128455 = (int64_t) -1;
                                            loopres_f_res_f_res_t_res_128456 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128457 = sub64(first_match_128233, step_128234);
                                            int64_t max_arg1_128458 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128459 = smax64((int64_t) 1, max_arg1_128458);
                                            
                                            loopres_f_res_f_res_t_res_128455 = tmp_128457;
                                            loopres_f_res_f_res_t_res_128456 = max_res_128459;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_t_res_128455;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_t_res_128456;
                                    } else {
                                        bool defunc_0_gt_res_128282 = slt64(eta_p_128227, nv_128251);
                                        bool x_128283 = !cond_128250;
                                        bool y_128284 = defunc_0_gt_res_128282 && x_128283;
                                        bool cond_128285 = cond_128250 || y_128284;
                                        int64_t loopres_f_res_f_res_f_res_128286;
                                        int64_t loopres_f_res_f_res_f_res_128287;
                                        
                                        if (cond_128285) {
                                            loopres_f_res_f_res_f_res_128286 = (int64_t) -1;
                                            loopres_f_res_f_res_f_res_128287 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128288 = add64(first_match_128233, step_128234);
                                            int64_t max_arg1_128289 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128290 = smax64((int64_t) 1, max_arg1_128289);
                                            
                                            loopres_f_res_f_res_f_res_128286 = tmp_128288;
                                            loopres_f_res_f_res_f_res_128287 = max_res_128290;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_f_res_128286;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_f_res_128287;
                                    }
                                    loopres_f_res_128267 = loopres_f_res_f_res_128273;
                                    loopres_f_res_128268 = loopres_f_res_f_res_128274;
                                }
                                loopres_128265 = loopres_f_res_128267;
                                loopres_128266 = loopres_f_res_128268;
                            }
                            
                            bool loop_cond_128291 = slt64((int64_t) 0, loopres_128266);
                            bool loop_while_tmp_133905 = loop_cond_128291;
                            int64_t first_match_tmp_133906 = loopres_128265;
                            int64_t step_tmp_133907 = loopres_128266;
                            
                            loop_while_128232 = loop_while_tmp_133905;
                            first_match_128233 = first_match_tmp_133906;
                            step_128234 = step_tmp_133907;
                        }
                        defunc_0_f_res_128229 = loop_while_128232;
                        defunc_0_f_res_128230 = first_match_128233;
                        defunc_0_f_res_128231 = step_128234;
                        
                        int64_t zs_lhs_128292 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, defunc_0_f_res_128230);
                        int64_t max_arg1_128293 = sdiv64(zs_lhs_128292, (int64_t) 2);
                        int64_t max_res_128294 = smax64((int64_t) 1, max_arg1_128293);
                        bool cond_128295 = defunc_0_f_res_128230 == (int64_t) -1;
                        int64_t defunc_0_f_res_128296;
                        
                        if (cond_128295) {
                            defunc_0_f_res_128296 = (int64_t) -1;
                        } else {
                            bool loop_cond_128298 = slt64((int64_t) 0, max_res_128294);
                            bool defunc_0_f_res_f_res_128299;
                            int64_t defunc_0_f_res_f_res_128300;
                            int64_t defunc_0_f_res_f_res_128301;
                            bool loop_while_128302;
                            int64_t last_match_128303;
                            int64_t step_128304;
                            
                            loop_while_128302 = loop_cond_128298;
                            last_match_128303 = m_120352;
                            step_128304 = max_res_128294;
                            while (loop_while_128302) {
                                bool x_128305 = sle64((int64_t) 0, last_match_128303);
                                bool y_128306 = slt64(last_match_128303, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128307 = x_128305 && y_128306;
                                bool index_certs_128308;
                                
                                if (!bounds_check_128307) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) last_match_128303, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:240:20-34\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:178:78-81\n   #4  ftRelational.fut:169:1-178:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128309 = tS_start_120347 + last_match_128303;
                                int64_t sv_128310 = ((int64_t *) tS_mem_133467.mem)[slice_128309];
                                bool cond_128311 = last_match_128303 == m_120352;
                                int64_t nv_128312;
                                
                                if (cond_128311) {
                                    nv_128312 = sv_128310;
                                } else {
                                    int64_t tmp_128313 = add64((int64_t) 1, last_match_128303);
                                    bool x_128314 = sle64((int64_t) 0, tmp_128313);
                                    bool y_128315 = slt64(tmp_128313, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                    bool bounds_check_128316 = x_128314 && y_128315;
                                    bool index_certs_128317;
                                    
                                    if (!bounds_check_128316) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128313, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:241:53-69\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:178:78-81\n   #4  ftRelational.fut:169:1-178:81\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128318 = tS_start_120347 + tmp_128313;
                                    int64_t nv_f_res_128319 = ((int64_t *) tS_mem_133467.mem)[slice_128318];
                                    
                                    nv_128312 = nv_f_res_128319;
                                }
                                
                                bool defunc_0_eq_res_128320 = sv_128310 == eta_p_128227;
                                bool defunc_0_gt_res_128321 = slt64(eta_p_128227, nv_128312);
                                bool x_128322 = !cond_128311;
                                bool y_128323 = defunc_0_gt_res_128321 && x_128322;
                                bool cond_t_res_128324 = cond_128311 || y_128323;
                                bool x_128325 = defunc_0_eq_res_128320 && cond_t_res_128324;
                                int64_t loopres_128326;
                                int64_t loopres_128327;
                                
                                if (x_128325) {
                                    loopres_128326 = last_match_128303;
                                    loopres_128327 = (int64_t) 0;
                                } else {
                                    int64_t loopres_f_res_128328;
                                    int64_t loopres_f_res_128329;
                                    
                                    if (defunc_0_eq_res_128320) {
                                        int64_t tmp_128460 = add64(last_match_128303, step_128304);
                                        int64_t max_arg1_128461 = sdiv64(step_128304, (int64_t) 2);
                                        int64_t max_res_128462 = smax64((int64_t) 1, max_arg1_128461);
                                        
                                        loopres_f_res_128328 = tmp_128460;
                                        loopres_f_res_128329 = max_res_128462;
                                    } else {
                                        bool defunc_0_gt_res_128333 = slt64(eta_p_128227, sv_128310);
                                        int64_t loopres_f_res_f_res_128334;
                                        int64_t loopres_f_res_f_res_128335;
                                        
                                        if (defunc_0_gt_res_128333) {
                                            int64_t tmp_128463 = sub64(last_match_128303, step_128304);
                                            int64_t max_arg1_128464 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128465 = smax64((int64_t) 1, max_arg1_128464);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128463;
                                            loopres_f_res_f_res_128335 = max_res_128465;
                                        } else {
                                            int64_t tmp_128339 = add64(last_match_128303, step_128304);
                                            int64_t max_arg1_128340 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128341 = smax64((int64_t) 1, max_arg1_128340);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128339;
                                            loopres_f_res_f_res_128335 = max_res_128341;
                                        }
                                        loopres_f_res_128328 = loopres_f_res_f_res_128334;
                                        loopres_f_res_128329 = loopres_f_res_f_res_128335;
                                    }
                                    loopres_128326 = loopres_f_res_128328;
                                    loopres_128327 = loopres_f_res_128329;
                                }
                                
                                bool loop_cond_128342 = slt64((int64_t) 0, loopres_128327);
                                bool loop_while_tmp_133908 = loop_cond_128342;
                                int64_t last_match_tmp_133909 = loopres_128326;
                                int64_t step_tmp_133910 = loopres_128327;
                                
                                loop_while_128302 = loop_while_tmp_133908;
                                last_match_128303 = last_match_tmp_133909;
                                step_128304 = step_tmp_133910;
                            }
                            defunc_0_f_res_f_res_128299 = loop_while_128302;
                            defunc_0_f_res_f_res_128300 = last_match_128303;
                            defunc_0_f_res_f_res_128301 = step_128304;
                            defunc_0_f_res_128296 = defunc_0_f_res_f_res_128300;
                        }
                        
                        bool cond_128343 = slt64(defunc_0_f_res_128230, (int64_t) 0);
                        int64_t cm_128344;
                        
                        if (cond_128343) {
                            cm_128344 = (int64_t) 0;
                        } else {
                            int64_t zp_lhs_128345 = sub64(defunc_0_f_res_128296, defunc_0_f_res_128230);
                            int64_t cm_f_res_128346 = add64((int64_t) 1, zp_lhs_128345);
                            
                            cm_128344 = cm_f_res_128346;
                        }
                        
                        int64_t lifted_lambda_res_128350;
                        
                        if (cond_128343) {
                            lifted_lambda_res_128350 = defunc_0_f_res_128230;
                        } else {
                            int64_t lifted_lambda_res_f_res_128351 = add64(find_joinTuples_arg3_120388, defunc_0_f_res_128230);
                            
                            lifted_lambda_res_128350 = lifted_lambda_res_f_res_128351;
                        }
                        
                        bool cond_128353 = slt64(eta_p_128228, (int64_t) 0);
                        int64_t lifted_lambda_res_128354;
                        
                        if (cond_128353) {
                            lifted_lambda_res_128354 = lifted_lambda_res_128350;
                        } else {
                            lifted_lambda_res_128354 = eta_p_128228;
                        }
                        
                        int64_t defunc_0_f_res_128357 = add64(eta_p_128226, cm_128344);
                        
                        ((int64_t *) mem_133490.mem)[i_133302] = defunc_0_f_res_128357;
                        ((int64_t *) mem_133492.mem)[i_133302] = lifted_lambda_res_128354;
                    }
                    
                    int64_t tmp_120527 = add64((int64_t) 1, s_iter_120343);
                    
                    if (memblock_set(ctx, &ext_mem_133510, &mem_133490, "mem_133490") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_133492, "mem_133492") != 0)
                        return 1;
                    loopres_f_res_120380 = tmp_120527;
                    loopres_f_res_120383 = nextRel_120387;
                }
                if (memblock_set(ctx, &ext_mem_133516, &ext_mem_133510, "ext_mem_133510") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &ext_mem_133507, "ext_mem_133507") != 0)
                    return 1;
                loopres_120374 = loopres_f_res_120380;
                loopres_120377 = loopres_f_res_120383;
                loopres_120378 = minRelevant_120346;
            }
            
            bool cond_120528 = slt64(loopres_120374, numIter_S_120289);
            bool x_120529 = loopres_120377 && cond_120528;
            
            if (memblock_set(ctx, &mem_param_tmp_133892, &ext_mem_133516, "ext_mem_133516") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133893, &ext_mem_133513, "ext_mem_133513") != 0)
                return 1;
            
            int64_t ctx_param_ext_tmp_133894 = ext_133515;
            int64_t ctx_param_ext_tmp_133895 = ext_133514;
            int64_t ctx_param_ext_tmp_133896 = ext_133512;
            int64_t ctx_param_ext_tmp_133897 = ext_133511;
            bool loop_while_tmp_133898 = x_120529;
            int64_t s_iter_tmp_133899 = loopres_120374;
            int64_t minRelevant_tmp_133902 = loopres_120378;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133488, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
                return 1;
            ctx_param_ext_133483 = ctx_param_ext_tmp_133894;
            ctx_param_ext_133484 = ctx_param_ext_tmp_133895;
            ctx_param_ext_133486 = ctx_param_ext_tmp_133896;
            ctx_param_ext_133487 = ctx_param_ext_tmp_133897;
            loop_while_120342 = loop_while_tmp_133898;
            s_iter_120343 = s_iter_tmp_133899;
            minRelevant_120346 = minRelevant_tmp_133902;
        }
        if (memblock_set(ctx, &ext_mem_133522, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133521, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        ext_133520 = ctx_param_ext_133483;
        ext_133519 = ctx_param_ext_133484;
        ext_133518 = ctx_param_ext_133486;
        ext_133517 = ctx_param_ext_133487;
        loopres_120337 = loop_while_120342;
        loopres_120338 = s_iter_120343;
        loopres_120341 = minRelevant_120346;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133524, bytes_133469, "mem_133524")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133478.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_105181});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133521.mem, ext_133518, (int64_t []) {ext_133517}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133526, bytes_133469, "mem_133526")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_105181});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133522.mem, ext_133520, (int64_t []) {ext_133519}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        
        int64_t tmp_120535 = add64((int64_t) 1, iter_120300);
        bool loop_cond_120536 = slt64(tmp_120535, numIter_R_120286);
        
        if (memblock_set(ctx, &mem_param_tmp_133883, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133884, &mem_133524, "mem_133524") != 0)
            return 1;
        
        bool loop_while_tmp_133885 = loop_cond_120536;
        int64_t iter_tmp_133886 = tmp_120535;
        int64_t first_relevant_in_S_tmp_133889 = loopres_120341;
        
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133478, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        loop_while_120299 = loop_while_tmp_133885;
        iter_120300 = iter_tmp_133886;
        first_relevant_in_S_120303 = first_relevant_in_S_tmp_133889;
    }
    if (memblock_set(ctx, &ext_mem_133532, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133531, &mem_param_133478, "mem_param_133478") != 0)
        return 1;
    defunc_0_mergeJoin_res_120294 = loop_while_120299;
    defunc_0_mergeJoin_res_120295 = iter_120300;
    defunc_0_mergeJoin_res_120298 = first_relevant_in_S_120303;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
        return 1;
    if (mem_133534_cached_sizze_134093 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133534, &mem_133534_cached_sizze_134093, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133536_cached_sizze_134094 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133536, &mem_133536_cached_sizze_134094, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133538_cached_sizze_134095 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133538, &mem_133538_cached_sizze_134095, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133540_cached_sizze_134096 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133540, &mem_133540_cached_sizze_134096, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133542_cached_sizze_134097 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133542, &mem_133542_cached_sizze_134097, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t discard_133324;
    int64_t discard_133325;
    int64_t defunc_res_128479;
    int64_t scanacc_133310;
    int64_t scanacc_133311;
    int64_t redout_133314;
    
    scanacc_133310 = (int64_t) 0;
    scanacc_133311 = (int64_t) 0;
    redout_133314 = (int64_t) 0;
    for (int64_t i_133318 = 0; i_133318 < nR_105181; i_133318++) {
        int64_t zg_lhs_128038 = ((int64_t *) ext_mem_133532.mem)[i_133318];
        bool cond_128039 = slt64((int64_t) 0, zg_lhs_128038);
        int64_t lifted_lambda_res_128040;
        
        if (cond_128039) {
            lifted_lambda_res_128040 = i_133318;
        } else {
            lifted_lambda_res_128040 = (int64_t) -1;
        }
        
        bool cond_128042 = sle64((int64_t) 0, lifted_lambda_res_128040);
        bool cond_t_res_128043 = slt64(lifted_lambda_res_128040, nR_105181);
        bool x_128044 = cond_128042 && cond_t_res_128043;
        int64_t lifted_lambda_res_128045;
        
        if (x_128044) {
            bool index_certs_128468;
            
            if (!x_128044) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lifted_lambda_res_128040, "] out of bounds for array of shape [", (long long) nR_105181, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftRelational.fut:178:78-81\n   #4  ftRelational.fut:169:1-178:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t lifted_lambda_res_t_res_128469 = ((int64_t *) ext_mem_133532.mem)[lifted_lambda_res_128040];
            
            lifted_lambda_res_128045 = lifted_lambda_res_t_res_128469;
        } else {
            lifted_lambda_res_128045 = (int64_t) 0;
        }
        
        bool lifted_lambda_res_128049 = slt64((int64_t) 1, lifted_lambda_res_128045);
        int64_t defunc_0_f_res_128050 = btoi_bool_i64(lifted_lambda_res_128049);
        int64_t defunc_0_op_res_120595 = add64(defunc_0_f_res_128050, scanacc_133310);
        int64_t lifted_lambda_res_120560 = add64(lifted_lambda_res_128045, scanacc_133311);
        int64_t zp_res_126101 = add64(lifted_lambda_res_128045, redout_133314);
        
        ((int64_t *) mem_133534)[i_133318] = defunc_0_op_res_120595;
        ((int64_t *) mem_133536)[i_133318] = lifted_lambda_res_120560;
        ((int64_t *) mem_133538)[i_133318] = defunc_0_f_res_128050;
        ((int64_t *) mem_133540)[i_133318] = lifted_lambda_res_128045;
        ((int64_t *) mem_133542)[i_133318] = lifted_lambda_res_128040;
        
        int64_t scanacc_tmp_133911 = defunc_0_op_res_120595;
        int64_t scanacc_tmp_133912 = lifted_lambda_res_120560;
        int64_t redout_tmp_133915 = zp_res_126101;
        
        scanacc_133310 = scanacc_tmp_133911;
        scanacc_133311 = scanacc_tmp_133912;
        redout_133314 = redout_tmp_133915;
    }
    discard_133324 = scanacc_133310;
    discard_133325 = scanacc_133311;
    defunc_res_128479 = redout_133314;
    if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
        return 1;
    
    int64_t tmp_120598 = sub64(nR_105181, (int64_t) 1);
    bool y_120600 = slt64(tmp_120598, nR_105181);
    bool x_120599 = sle64((int64_t) 0, tmp_120598);
    bool bounds_check_120601 = x_120599 && y_120600;
    bool cond_120596 = nR_105181 == (int64_t) 0;
    bool protect_assert_disj_120602 = cond_120596 || bounds_check_120601;
    bool index_certs_120603;
    
    if (!protect_assert_disj_120602) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_120598, "] out of bounds for array of shape [", (long long) nR_105181, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:178:78-81\n   #4  ftRelational.fut:169:1-178:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool x_120597 = !cond_120596;
    int64_t m_f_res_120604;
    
    if (x_120597) {
        int64_t x_128475 = ((int64_t *) mem_133534)[tmp_120598];
        
        m_f_res_120604 = x_128475;
    } else {
        m_f_res_120604 = (int64_t) 0;
    }
    
    int64_t m_120606;
    
    if (cond_120596) {
        m_120606 = (int64_t) 0;
    } else {
        m_120606 = m_f_res_120604;
    }
    
    int64_t m_120616 = sub64(m_120606, (int64_t) 1);
    bool i_p_m_t_s_leq_w_120618 = slt64(m_120616, nR_105181);
    bool zzero_leq_i_p_m_t_s_120617 = sle64((int64_t) 0, m_120616);
    bool y_120620 = zzero_leq_i_p_m_t_s_120617 && i_p_m_t_s_leq_w_120618;
    bool i_lte_j_120619 = sle64((int64_t) 0, m_120606);
    bool forwards_ok_120621 = i_lte_j_120619 && y_120620;
    bool eq_x_zz_120613 = (int64_t) 0 == m_f_res_120604;
    bool p_and_eq_x_y_120614 = x_120597 && eq_x_zz_120613;
    bool empty_slice_120615 = cond_120596 || p_and_eq_x_y_120614;
    bool ok_or_empty_120622 = empty_slice_120615 || forwards_ok_120621;
    bool index_certs_120623;
    
    if (!ok_or_empty_120622) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_120606, "] out of bounds for array of shape [", (long long) nR_105181, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:178:78-81\n   #4  ftRelational.fut:169:1-178:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133573 = (int64_t) 8 * m_120606;
    int64_t bytes_133585 = (int64_t) 8 * defunc_res_128479;
    
    if (futrts_indicesWithIncrement_11686(ctx, &ext_mem_133468, tR_mem_133466, nR_105181, offset_R_105185) != 0) {
        err = 1;
        goto cleanup;
    }
    if (mem_133574_cached_sizze_134098 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133574, &mem_133574_cached_sizze_134098, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133574, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133540, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (mem_133576_cached_sizze_134099 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133576, &mem_133576_cached_sizze_134099, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133328 = 0; i_133328 < nR_105181; i_133328++) {
        int64_t eta_p_127956 = ((int64_t *) mem_133540)[i_133328];
        int64_t zv_lhs_127958 = add64((int64_t) -1, i_133328);
        int64_t tmp_127959 = smod64(zv_lhs_127958, nR_105181);
        int64_t lifted_lambda_res_127960 = ((int64_t *) mem_133536)[tmp_127959];
        bool cond_127962 = i_133328 == (int64_t) 0;
        int64_t lifted_lambda_res_127963;
        
        if (cond_127962) {
            lifted_lambda_res_127963 = (int64_t) 0;
        } else {
            lifted_lambda_res_127963 = lifted_lambda_res_127960;
        }
        
        bool cond_127965 = slt64((int64_t) 0, eta_p_127956);
        int64_t lifted_lambda_res_127966;
        
        if (cond_127965) {
            lifted_lambda_res_127966 = lifted_lambda_res_127963;
        } else {
            lifted_lambda_res_127966 = (int64_t) -1;
        }
        ((int64_t *) mem_133576)[i_133328] = lifted_lambda_res_127966;
    }
    if (mem_133584_cached_sizze_134100 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134100, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133584, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133576, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (memblock_alloc(ctx, &mem_133586, bytes_133585, "mem_133586")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133920 = 0; nest_i_133920 < defunc_res_128479; nest_i_133920++) {
        ((int64_t *) mem_133586.mem)[nest_i_133920] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133588, bytes_133585, "mem_133588")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133921 = 0; nest_i_133921 < defunc_res_128479; nest_i_133921++) {
        ((int64_t *) mem_133588.mem)[nest_i_133921] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133590, bytes_133585, "mem_133590")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133922 = 0; nest_i_133922 < defunc_res_128479; nest_i_133922++) {
        ((int64_t *) mem_133590.mem)[nest_i_133922] = (int64_t) 0;
    }
    for (int64_t write_iter_133330 = 0; write_iter_133330 < nR_105181; write_iter_133330++) {
        int64_t write_iv_133336 = ((int64_t *) mem_133538)[write_iter_133330];
        int64_t write_iv_133337 = ((int64_t *) mem_133534)[write_iter_133330];
        int64_t write_iv_133338 = ((int64_t *) mem_133576)[write_iter_133330];
        int64_t write_iv_133339 = ((int64_t *) mem_133540)[write_iter_133330];
        int64_t write_iv_133340 = ((int64_t *) mem_133542)[write_iter_133330];
        bool cond_128065 = sle64((int64_t) 0, write_iv_133340);
        bool cond_t_res_128066 = slt64(write_iv_133340, nR_105181);
        bool x_128067 = cond_128065 && cond_t_res_128066;
        int64_t lifted_lambda_res_128068;
        int64_t lifted_lambda_res_128069;
        int64_t lifted_lambda_res_128070;
        
        if (x_128067) {
            bool index_certs_128470;
            
            if (!x_128067) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) write_iv_133340, "] out of bounds for array of shape [", (long long) nR_105181, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftSMJ.fut:364:7-365:57\n   #4  ftRelational.fut:178:78-81\n   #5  ftRelational.fut:169:1-178:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t lifted_lambda_res_t_res_128471 = ((int64_t *) tR_mem_133466.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128472 = ((int64_t *) ext_mem_133468.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128473 = ((int64_t *) ext_mem_133531.mem)[write_iv_133340];
            
            lifted_lambda_res_128068 = lifted_lambda_res_t_res_128471;
            lifted_lambda_res_128069 = lifted_lambda_res_t_res_128472;
            lifted_lambda_res_128070 = lifted_lambda_res_t_res_128473;
        } else {
            lifted_lambda_res_128068 = (int64_t) 0;
            lifted_lambda_res_128069 = (int64_t) -1;
            lifted_lambda_res_128070 = (int64_t) -1;
        }
        
        bool cond_128078 = write_iv_133336 == (int64_t) 1;
        int64_t lifted_lambda_res_128079;
        
        if (cond_128078) {
            int64_t lifted_lambda_res_t_res_128474 = sub64(write_iv_133337, (int64_t) 1);
            
            lifted_lambda_res_128079 = lifted_lambda_res_t_res_128474;
        } else {
            lifted_lambda_res_128079 = (int64_t) -1;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133584)[lifted_lambda_res_128079] = write_iv_133338;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133574)[lifted_lambda_res_128079] = write_iv_133339;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133590.mem)[write_iv_133338] = lifted_lambda_res_128068;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133588.mem)[write_iv_133338] = lifted_lambda_res_128069;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133586.mem)[write_iv_133338] = lifted_lambda_res_128070;
        }
    }
    if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
        return 1;
    for (int64_t i_120636 = 0; i_120636 < m_120606; i_120636++) {
        int64_t loopres_120640 = ((int64_t *) mem_133584)[i_120636];
        int64_t loopres_120641 = ((int64_t *) mem_133574)[i_120636];
        bool x_120642 = sle64((int64_t) 0, loopres_120640);
        bool y_120643 = slt64(loopres_120640, defunc_res_128479);
        bool bounds_check_120644 = x_120642 && y_120643;
        bool index_certs_120645;
        
        if (!bounds_check_120644) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:346:52-59\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t tmp_120655 = add64(loopres_120640, loopres_120641);
        bool empty_slice_120656 = loopres_120641 == (int64_t) 0;
        int64_t m_120657 = sub64(loopres_120641, (int64_t) 1);
        int64_t i_p_m_t_s_120658 = add64(loopres_120640, m_120657);
        bool zzero_leq_i_p_m_t_s_120659 = sle64((int64_t) 0, i_p_m_t_s_120658);
        bool i_p_m_t_s_leq_w_120660 = slt64(i_p_m_t_s_120658, defunc_res_128479);
        bool i_lte_j_120661 = sle64(loopres_120640, tmp_120655);
        bool y_120662 = x_120642 && i_p_m_t_s_leq_w_120660;
        bool y_120663 = zzero_leq_i_p_m_t_s_120659 && y_120662;
        bool forwards_ok_120664 = i_lte_j_120661 && y_120663;
        bool ok_or_empty_120665 = empty_slice_120656 || forwards_ok_120664;
        bool index_certs_120666;
        
        if (!ok_or_empty_120665) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, ":", (long long) tmp_120655, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:348:8-40\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:178:78-81\n   #3  ftRelational.fut:169:1-178:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t loopres_120646 = ((int64_t *) mem_133590.mem)[loopres_120640];
        int64_t loopres_120647 = ((int64_t *) mem_133588.mem)[loopres_120640];
        int64_t loopres_120648 = ((int64_t *) mem_133586.mem)[loopres_120640];
        
        for (int64_t nest_i_133931 = 0; nest_i_133931 < loopres_120641; nest_i_133931++) {
            ((int64_t *) mem_133590.mem)[loopres_120640 + nest_i_133931] = loopres_120646;
        }
        for (int64_t nest_i_133932 = 0; nest_i_133932 < loopres_120641; nest_i_133932++) {
            ((int64_t *) mem_133588.mem)[loopres_120640 + nest_i_133932] = loopres_120647;
        }
        for (int64_t i_133349 = 0; i_133349 < loopres_120641; i_133349++) {
            int64_t tmp_120654 = add64(loopres_120648, i_133349);
            
            ((int64_t *) mem_133586.mem)[loopres_120640 + i_133349] = tmp_120654;
        }
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133588, "mem_133588") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133586, "mem_133586") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133879, &mem_133590, "mem_133590") != 0)
        return 1;
    prim_out_133880 = defunc_res_128479;
    if (memblock_set(ctx, &*mem_out_p_134089, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134090, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134091, &mem_out_133879, "mem_out_133879") != 0)
        return 1;
    *out_prim_out_134092 = prim_out_133880;
    
  cleanup:
    {
        free(mem_133534);
        free(mem_133536);
        free(mem_133538);
        free(mem_133540);
        free(mem_133542);
        free(mem_133574);
        free(mem_133576);
        free(mem_133584);
        if (memblock_unref(ctx, &mem_133590, "mem_133590") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133588, "mem_133588") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133586, "mem_133586") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133524, "mem_133524") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133492, "mem_133492") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133490, "mem_133490") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133507, "ext_mem_133507") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133510, "ext_mem_133510") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133513, "ext_mem_133513") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133516, "ext_mem_133516") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133478, "mem_param_133478") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133879, "mem_out_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_inner_SMJ_short(struct futhark_context *ctx, struct memblock *mem_out_p_134101, struct memblock *mem_out_p_134102, struct memblock *mem_out_p_134103, int64_t *out_prim_out_134104, struct memblock tR_mem_133466, struct memblock tS_mem_133467, int64_t nR_100945, int64_t nS_100946, int64_t offset_R_100949, int64_t offset_S_100950, int64_t partitionSizze_100951, int64_t scatter_psizze_100952)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133534_cached_sizze_134105 = 0;
    unsigned char *mem_133534 = NULL;
    int64_t mem_133536_cached_sizze_134106 = 0;
    unsigned char *mem_133536 = NULL;
    int64_t mem_133538_cached_sizze_134107 = 0;
    unsigned char *mem_133538 = NULL;
    int64_t mem_133540_cached_sizze_134108 = 0;
    unsigned char *mem_133540 = NULL;
    int64_t mem_133542_cached_sizze_134109 = 0;
    unsigned char *mem_133542 = NULL;
    int64_t mem_133574_cached_sizze_134110 = 0;
    unsigned char *mem_133574 = NULL;
    int64_t mem_133576_cached_sizze_134111 = 0;
    unsigned char *mem_133576 = NULL;
    int64_t mem_133584_cached_sizze_134112 = 0;
    unsigned char *mem_133584 = NULL;
    struct memblock mem_133590;
    
    mem_133590.references = NULL;
    
    struct memblock mem_133588;
    
    mem_133588.references = NULL;
    
    struct memblock mem_133586;
    
    mem_133586.references = NULL;
    
    struct memblock ext_mem_133468;
    
    ext_mem_133468.references = NULL;
    
    struct memblock mem_param_tmp_133884;
    
    mem_param_tmp_133884.references = NULL;
    
    struct memblock mem_param_tmp_133883;
    
    mem_param_tmp_133883.references = NULL;
    
    struct memblock mem_133526;
    
    mem_133526.references = NULL;
    
    struct memblock mem_133524;
    
    mem_133524.references = NULL;
    
    struct memblock mem_param_tmp_133893;
    
    mem_param_tmp_133893.references = NULL;
    
    struct memblock mem_param_tmp_133892;
    
    mem_param_tmp_133892.references = NULL;
    
    struct memblock mem_133492;
    
    mem_133492.references = NULL;
    
    struct memblock mem_133490;
    
    mem_133490.references = NULL;
    
    struct memblock ext_mem_133507;
    
    ext_mem_133507.references = NULL;
    
    struct memblock ext_mem_133510;
    
    ext_mem_133510.references = NULL;
    
    struct memblock ext_mem_133513;
    
    ext_mem_133513.references = NULL;
    
    struct memblock ext_mem_133516;
    
    ext_mem_133516.references = NULL;
    
    struct memblock mem_param_133488;
    
    mem_param_133488.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133521;
    
    ext_mem_133521.references = NULL;
    
    struct memblock ext_mem_133522;
    
    ext_mem_133522.references = NULL;
    
    struct memblock mem_133482;
    
    mem_133482.references = NULL;
    
    struct memblock mem_133480;
    
    mem_133480.references = NULL;
    
    struct memblock mem_param_133478;
    
    mem_param_133478.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock ext_mem_133531;
    
    ext_mem_133531.references = NULL;
    
    struct memblock ext_mem_133532;
    
    ext_mem_133532.references = NULL;
    
    struct memblock mem_133472;
    
    mem_133472.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t prim_out_133880;
    int64_t zm_lhs_120281 = add64(nR_100945, partitionSizze_100951);
    int64_t zs_lhs_120282 = sub64(zm_lhs_120281, (int64_t) 1);
    bool zzero_120283 = partitionSizze_100951 == (int64_t) 0;
    bool nonzzero_120284 = !zzero_120283;
    bool nonzzero_cert_120285;
    
    if (!nonzzero_120284) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftSMJ.fut:271:43-57\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t numIter_R_120286 = sdiv64(zs_lhs_120282, partitionSizze_100951);
    int64_t zm_lhs_120287 = add64(nS_100946, partitionSizze_100951);
    int64_t zs_lhs_120288 = sub64(zm_lhs_120287, (int64_t) 1);
    int64_t numIter_S_120289 = sdiv64(zs_lhs_120288, partitionSizze_100951);
    int64_t bytes_133469 = (int64_t) 8 * nR_100945;
    
    if (memblock_alloc(ctx, &mem_133470, bytes_133469, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133881 = 0; nest_i_133881 < nR_100945; nest_i_133881++) {
        ((int64_t *) mem_133470.mem)[nest_i_133881] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133472, bytes_133469, "mem_133472")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133882 = 0; nest_i_133882 < nR_100945; nest_i_133882++) {
        ((int64_t *) mem_133472.mem)[nest_i_133882] = (int64_t) 0;
    }
    
    bool loop_cond_120293 = slt64((int64_t) 0, numIter_R_120286);
    bool defunc_0_mergeJoin_res_120294;
    int64_t defunc_0_mergeJoin_res_120295;
    int64_t defunc_0_mergeJoin_res_120298;
    bool loop_while_120299;
    int64_t iter_120300;
    int64_t first_relevant_in_S_120303;
    
    if (memblock_set(ctx, &mem_param_133475, &mem_133472, "mem_133472") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133478, &mem_133470, "mem_133470") != 0)
        return 1;
    loop_while_120299 = loop_cond_120293;
    iter_120300 = (int64_t) 0;
    first_relevant_in_S_120303 = (int64_t) 0;
    while (loop_while_120299) {
        int64_t tR_start_120304 = mul64(partitionSizze_100951, iter_120300);
        int64_t min_arg1_120305 = add64(partitionSizze_100951, tR_start_120304);
        int64_t min_res_120306 = smin64(nR_100945, min_arg1_120305);
        int64_t dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 = sub64(min_res_120306, tR_start_120304);
        bool empty_slice_120308 = dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307 == (int64_t) 0;
        int64_t m_120309 = sub64(dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, (int64_t) 1);
        int64_t i_p_m_t_s_120310 = add64(tR_start_120304, m_120309);
        bool zzero_leq_i_p_m_t_s_120311 = sle64((int64_t) 0, i_p_m_t_s_120310);
        bool i_p_m_t_s_leq_w_120312 = slt64(i_p_m_t_s_120310, nR_100945);
        bool zzero_lte_i_120313 = sle64((int64_t) 0, tR_start_120304);
        bool i_lte_j_120314 = sle64(tR_start_120304, min_res_120306);
        bool y_120315 = i_p_m_t_s_leq_w_120312 && zzero_lte_i_120313;
        bool y_120316 = zzero_leq_i_p_m_t_s_120311 && y_120315;
        bool forwards_ok_120317 = i_lte_j_120314 && y_120316;
        bool ok_or_empty_120318 = empty_slice_120308 || forwards_ok_120317;
        bool index_certs_120319;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_100945, "].", "-> #0  ftSMJ.fut:278:17-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t bytes_133479 = (int64_t) 8 * dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307;
        bool cond_120323 = slt64(first_relevant_in_S_120303, numIter_S_120289);
        bool y_120324 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool loop_not_taken_120325 = !cond_120323;
        bool protect_assert_disj_120326 = y_120324 || loop_not_taken_120325;
        bool index_certs_120327;
        
        if (!protect_assert_disj_120326) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:293:26-34\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool x_120330 = sle64((int64_t) 0, m_120309);
        bool y_120331 = slt64(m_120309, dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307);
        bool bounds_check_120332 = x_120330 && y_120331;
        bool protect_assert_disj_120333 = loop_not_taken_120325 || bounds_check_120332;
        bool index_certs_120334;
        
        if (!protect_assert_disj_120333) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:294:42-61\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool index_certs_120531;
        
        if (!ok_or_empty_120318) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tR_start_120304, ":", (long long) min_res_120306, "] out of bounds for array of shape [", (long long) nR_100945, "].", "-> #0  ftSMJ.fut:199:15-63\n   #1  ftSMJ.fut:304:20-64\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:156:78-81\n   #4  ftRelational.fut:147:1-156:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133480, bytes_133479, "mem_133480")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133890 = 0; nest_i_133890 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133890++) {
            ((int64_t *) mem_133480.mem)[nest_i_133890] = (int64_t) -1;
        }
        if (memblock_alloc(ctx, &mem_133482, bytes_133479, "mem_133482")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t nest_i_133891 = 0; nest_i_133891 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; nest_i_133891++) {
            ((int64_t *) mem_133482.mem)[nest_i_133891] = (int64_t) 0;
        }
        
        int16_t gt_lhs_120328;
        
        if (cond_120323) {
            int16_t x_128449 = ((int16_t *) tR_mem_133466.mem)[tR_start_120304];
            
            gt_lhs_120328 = x_128449;
        } else {
            gt_lhs_120328 = (int16_t) 0;
        }
        
        int16_t gt_rhs_120335;
        
        if (cond_120323) {
            int16_t x_128450 = ((int16_t *) tR_mem_133466.mem)[i_p_m_t_s_120310];
            
            gt_rhs_120335 = x_128450;
        } else {
            gt_rhs_120335 = (int16_t) 0;
        }
        
        int64_t ext_133520;
        int64_t ext_133519;
        int64_t ext_133518;
        int64_t ext_133517;
        bool loopres_120337;
        int64_t loopres_120338;
        int64_t loopres_120341;
        bool loop_while_120342;
        int64_t s_iter_120343;
        int64_t minRelevant_120346;
        int64_t ctx_param_ext_133483;
        int64_t ctx_param_ext_133484;
        int64_t ctx_param_ext_133486;
        int64_t ctx_param_ext_133487;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133488, &mem_133480, "mem_133480") != 0)
            return 1;
        ctx_param_ext_133483 = (int64_t) 0;
        ctx_param_ext_133484 = (int64_t) 1;
        ctx_param_ext_133486 = (int64_t) 0;
        ctx_param_ext_133487 = (int64_t) 1;
        loop_while_120342 = cond_120323;
        s_iter_120343 = first_relevant_in_S_120303;
        minRelevant_120346 = first_relevant_in_S_120303;
        while (loop_while_120342) {
            int64_t tS_start_120347 = mul64(partitionSizze_100951, s_iter_120343);
            int64_t min_arg1_120348 = add64(partitionSizze_100951, tS_start_120347);
            int64_t min_res_120349 = smin64(nS_100946, min_arg1_120348);
            int64_t dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 = sub64(min_res_120349, tS_start_120347);
            bool empty_slice_120351 = dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350 == (int64_t) 0;
            int64_t m_120352 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 1);
            int64_t i_p_m_t_s_120353 = add64(tS_start_120347, m_120352);
            bool zzero_leq_i_p_m_t_s_120354 = sle64((int64_t) 0, i_p_m_t_s_120353);
            bool i_p_m_t_s_leq_w_120355 = slt64(i_p_m_t_s_120353, nS_100946);
            bool zzero_lte_i_120356 = sle64((int64_t) 0, tS_start_120347);
            bool i_lte_j_120357 = sle64(tS_start_120347, min_res_120349);
            bool y_120358 = i_p_m_t_s_leq_w_120355 && zzero_lte_i_120356;
            bool y_120359 = zzero_leq_i_p_m_t_s_120354 && y_120358;
            bool forwards_ok_120360 = i_lte_j_120357 && y_120359;
            bool ok_or_empty_120361 = empty_slice_120351 || forwards_ok_120360;
            bool index_certs_120362;
            
            if (!ok_or_empty_120361) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tS_start_120347, ":", (long long) min_res_120349, "] out of bounds for array of shape [", (long long) nS_100946, "].", "-> #0  ftSMJ.fut:291:19-38\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool x_120363 = sle64((int64_t) 0, m_120352);
            bool y_120364 = slt64(m_120352, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool bounds_check_120365 = x_120363 && y_120364;
            bool index_certs_120366;
            
            if (!bounds_check_120365) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120352, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:293:40-59\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_120369 = slt64((int64_t) 0, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
            bool index_certs_120370;
            
            if (!y_120369) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:294:28-36\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int16_t gt_rhs_120367 = ((int16_t *) tS_mem_133467.mem)[i_p_m_t_s_120353];
            bool defunc_0_gt_res_120368 = slt16(gt_rhs_120367, gt_lhs_120328);
            int16_t gt_lhs_120371 = ((int16_t *) tS_mem_133467.mem)[tS_start_120347];
            bool defunc_0_gt_res_120372 = slt16(gt_rhs_120335, gt_lhs_120371);
            bool thisStillRel_120373 = !defunc_0_gt_res_120372;
            int64_t ext_133509;
            
            if (defunc_0_gt_res_120372) {
                ext_133509 = ctx_param_ext_133483;
            } else {
                ext_133509 = (int64_t) 0;
            }
            
            int64_t ext_133508;
            
            if (defunc_0_gt_res_120372) {
                ext_133508 = ctx_param_ext_133484;
            } else {
                ext_133508 = (int64_t) 1;
            }
            
            int64_t ext_133506;
            
            if (defunc_0_gt_res_120372) {
                ext_133506 = ctx_param_ext_133486;
            } else {
                ext_133506 = (int64_t) 0;
            }
            
            int64_t ext_133505;
            
            if (defunc_0_gt_res_120372) {
                ext_133505 = ctx_param_ext_133487;
            } else {
                ext_133505 = (int64_t) 1;
            }
            
            int64_t ext_133515;
            
            if (defunc_0_gt_res_120368) {
                ext_133515 = ctx_param_ext_133483;
            } else {
                ext_133515 = ext_133509;
            }
            
            int64_t ext_133514;
            
            if (defunc_0_gt_res_120368) {
                ext_133514 = ctx_param_ext_133484;
            } else {
                ext_133514 = ext_133508;
            }
            
            int64_t ext_133512;
            
            if (defunc_0_gt_res_120368) {
                ext_133512 = ctx_param_ext_133486;
            } else {
                ext_133512 = ext_133506;
            }
            
            int64_t ext_133511;
            
            if (defunc_0_gt_res_120368) {
                ext_133511 = ctx_param_ext_133487;
            } else {
                ext_133511 = ext_133505;
            }
            
            int64_t loopres_120374;
            bool loopres_120377;
            int64_t loopres_120378;
            
            if (defunc_0_gt_res_120368) {
                int64_t tmp_128451 = add64((int64_t) 1, s_iter_120343);
                
                if (memblock_set(ctx, &ext_mem_133516, &mem_param_133485, "mem_param_133485") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &mem_param_133488, "mem_param_133488") != 0)
                    return 1;
                loopres_120374 = tmp_128451;
                loopres_120377 = 1;
                loopres_120378 = tmp_128451;
            } else {
                int64_t loopres_f_res_120380;
                bool loopres_f_res_120383;
                
                if (defunc_0_gt_res_120372) {
                    if (memblock_set(ctx, &ext_mem_133510, &mem_param_133485, "mem_param_133485") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_param_133488, "mem_param_133488") != 0)
                        return 1;
                    loopres_f_res_120380 = s_iter_120343;
                    loopres_f_res_120383 = thisStillRel_120373;
                } else {
                    bool index_certs_120384;
                    
                    if (!bounds_check_120332) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307, "].", "-> #0  ftSMJ.fut:298:50-69\n   #1  ftSMJ.fut:364:79-81\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int16_t gt_rhs_120385 = ((int16_t *) tR_mem_133466.mem)[i_p_m_t_s_120310];
                    bool defunc_0_gt_res_120386 = slt16(gt_rhs_120385, gt_rhs_120367);
                    bool nextRel_120387 = !defunc_0_gt_res_120386;
                    int64_t find_joinTuples_arg3_120388 = add64(offset_S_100950, tS_start_120347);
                    int64_t max_arg1_120389 = sdiv64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, (int64_t) 2);
                    int64_t max_res_120390 = smax64((int64_t) 1, max_arg1_120389);
                    bool loop_cond_120391 = slt64((int64_t) 0, max_res_120390);
                    
                    if (memblock_alloc(ctx, &mem_133490, bytes_133479, "mem_133490")) {
                        err = 1;
                        goto cleanup;
                    }
                    if (memblock_alloc(ctx, &mem_133492, bytes_133479, "mem_133492")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t i_133302 = 0; i_133302 < dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307; i_133302++) {
                        int64_t eta_p_128226 = ((int64_t *) mem_param_133485.mem)[ctx_param_ext_133483 + i_133302 * ctx_param_ext_133484];
                        int64_t slice_133434 = tR_start_120304 + i_133302;
                        int16_t eta_p_128227 = ((int16_t *) tR_mem_133466.mem)[slice_133434];
                        int64_t eta_p_128228 = ((int64_t *) mem_param_133488.mem)[ctx_param_ext_133486 + i_133302 * ctx_param_ext_133487];
                        bool defunc_0_f_res_128229;
                        int64_t defunc_0_f_res_128230;
                        int64_t defunc_0_f_res_128231;
                        bool loop_while_128232;
                        int64_t first_match_128233;
                        int64_t step_128234;
                        
                        loop_while_128232 = loop_cond_120391;
                        first_match_128233 = (int64_t) 0;
                        step_128234 = max_res_120390;
                        while (loop_while_128232) {
                            bool x_128235 = sle64((int64_t) 0, first_match_128233);
                            bool y_128236 = slt64(first_match_128233, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                            bool bounds_check_128237 = x_128235 && y_128236;
                            bool index_certs_128238;
                            
                            if (!bounds_check_128237) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) first_match_128233, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:219:20-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:156:78-81\n   #4  ftRelational.fut:147:1-156:81\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128239 = tS_start_120347 + first_match_128233;
                            int16_t sv_128240 = ((int16_t *) tS_mem_133467.mem)[slice_128239];
                            bool cond_128241 = first_match_128233 == (int64_t) 0;
                            int16_t pv_128242;
                            
                            if (cond_128241) {
                                pv_128242 = sv_128240;
                            } else {
                                int64_t tmp_128243 = sub64(first_match_128233, (int64_t) 1);
                                bool x_128244 = sle64((int64_t) 0, tmp_128243);
                                bool y_128245 = slt64(tmp_128243, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128246 = x_128244 && y_128245;
                                bool index_certs_128247;
                                
                                if (!bounds_check_128246) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128243, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:220:51-68\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:156:78-81\n   #4  ftRelational.fut:147:1-156:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128248 = tS_start_120347 + tmp_128243;
                                int16_t pv_f_res_128249 = ((int16_t *) tS_mem_133467.mem)[slice_128248];
                                
                                pv_128242 = pv_f_res_128249;
                            }
                            
                            bool cond_128250 = first_match_128233 == m_120352;
                            int16_t nv_128251;
                            
                            if (cond_128250) {
                                nv_128251 = sv_128240;
                            } else {
                                int64_t tmp_128252 = add64((int64_t) 1, first_match_128233);
                                bool x_128253 = sle64((int64_t) 0, tmp_128252);
                                bool y_128254 = slt64(tmp_128252, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128255 = x_128253 && y_128254;
                                bool index_certs_128256;
                                
                                if (!bounds_check_128255) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128252, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:221:54-71\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:156:78-81\n   #4  ftRelational.fut:147:1-156:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128257 = tS_start_120347 + tmp_128252;
                                int16_t nv_f_res_128258 = ((int16_t *) tS_mem_133467.mem)[slice_128257];
                                
                                nv_128251 = nv_f_res_128258;
                            }
                            
                            bool defunc_0_eq_res_128259 = sv_128240 == eta_p_128227;
                            bool defunc_0_gt_res_128260 = slt16(pv_128242, eta_p_128227);
                            bool x_128261 = !cond_128241;
                            bool y_128262 = defunc_0_gt_res_128260 && x_128261;
                            bool cond_t_res_128263 = cond_128241 || y_128262;
                            bool x_128264 = defunc_0_eq_res_128259 && cond_t_res_128263;
                            int64_t loopres_128265;
                            int64_t loopres_128266;
                            
                            if (x_128264) {
                                loopres_128265 = first_match_128233;
                                loopres_128266 = (int64_t) 0;
                            } else {
                                int64_t loopres_f_res_128267;
                                int64_t loopres_f_res_128268;
                                
                                if (defunc_0_eq_res_128259) {
                                    int64_t tmp_128452 = sub64(first_match_128233, step_128234);
                                    int64_t max_arg1_128453 = sdiv64(step_128234, (int64_t) 2);
                                    int64_t max_res_128454 = smax64((int64_t) 1, max_arg1_128453);
                                    
                                    loopres_f_res_128267 = tmp_128452;
                                    loopres_f_res_128268 = max_res_128454;
                                } else {
                                    bool defunc_0_gt_res_128272 = slt16(eta_p_128227, sv_128240);
                                    int64_t loopres_f_res_f_res_128273;
                                    int64_t loopres_f_res_f_res_128274;
                                    
                                    if (defunc_0_gt_res_128272) {
                                        int64_t loopres_f_res_f_res_t_res_128455;
                                        int64_t loopres_f_res_f_res_t_res_128456;
                                        
                                        if (cond_t_res_128263) {
                                            loopres_f_res_f_res_t_res_128455 = (int64_t) -1;
                                            loopres_f_res_f_res_t_res_128456 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128457 = sub64(first_match_128233, step_128234);
                                            int64_t max_arg1_128458 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128459 = smax64((int64_t) 1, max_arg1_128458);
                                            
                                            loopres_f_res_f_res_t_res_128455 = tmp_128457;
                                            loopres_f_res_f_res_t_res_128456 = max_res_128459;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_t_res_128455;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_t_res_128456;
                                    } else {
                                        bool defunc_0_gt_res_128282 = slt16(eta_p_128227, nv_128251);
                                        bool x_128283 = !cond_128250;
                                        bool y_128284 = defunc_0_gt_res_128282 && x_128283;
                                        bool cond_128285 = cond_128250 || y_128284;
                                        int64_t loopres_f_res_f_res_f_res_128286;
                                        int64_t loopres_f_res_f_res_f_res_128287;
                                        
                                        if (cond_128285) {
                                            loopres_f_res_f_res_f_res_128286 = (int64_t) -1;
                                            loopres_f_res_f_res_f_res_128287 = (int64_t) 0;
                                        } else {
                                            int64_t tmp_128288 = add64(first_match_128233, step_128234);
                                            int64_t max_arg1_128289 = sdiv64(step_128234, (int64_t) 2);
                                            int64_t max_res_128290 = smax64((int64_t) 1, max_arg1_128289);
                                            
                                            loopres_f_res_f_res_f_res_128286 = tmp_128288;
                                            loopres_f_res_f_res_f_res_128287 = max_res_128290;
                                        }
                                        loopres_f_res_f_res_128273 = loopres_f_res_f_res_f_res_128286;
                                        loopres_f_res_f_res_128274 = loopres_f_res_f_res_f_res_128287;
                                    }
                                    loopres_f_res_128267 = loopres_f_res_f_res_128273;
                                    loopres_f_res_128268 = loopres_f_res_f_res_128274;
                                }
                                loopres_128265 = loopres_f_res_128267;
                                loopres_128266 = loopres_f_res_128268;
                            }
                            
                            bool loop_cond_128291 = slt64((int64_t) 0, loopres_128266);
                            bool loop_while_tmp_133905 = loop_cond_128291;
                            int64_t first_match_tmp_133906 = loopres_128265;
                            int64_t step_tmp_133907 = loopres_128266;
                            
                            loop_while_128232 = loop_while_tmp_133905;
                            first_match_128233 = first_match_tmp_133906;
                            step_128234 = step_tmp_133907;
                        }
                        defunc_0_f_res_128229 = loop_while_128232;
                        defunc_0_f_res_128230 = first_match_128233;
                        defunc_0_f_res_128231 = step_128234;
                        
                        int64_t zs_lhs_128292 = sub64(dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, defunc_0_f_res_128230);
                        int64_t max_arg1_128293 = sdiv64(zs_lhs_128292, (int64_t) 2);
                        int64_t max_res_128294 = smax64((int64_t) 1, max_arg1_128293);
                        bool cond_128295 = defunc_0_f_res_128230 == (int64_t) -1;
                        int64_t defunc_0_f_res_128296;
                        
                        if (cond_128295) {
                            defunc_0_f_res_128296 = (int64_t) -1;
                        } else {
                            bool loop_cond_128298 = slt64((int64_t) 0, max_res_128294);
                            bool defunc_0_f_res_f_res_128299;
                            int64_t defunc_0_f_res_f_res_128300;
                            int64_t defunc_0_f_res_f_res_128301;
                            bool loop_while_128302;
                            int64_t last_match_128303;
                            int64_t step_128304;
                            
                            loop_while_128302 = loop_cond_128298;
                            last_match_128303 = m_120352;
                            step_128304 = max_res_128294;
                            while (loop_while_128302) {
                                bool x_128305 = sle64((int64_t) 0, last_match_128303);
                                bool y_128306 = slt64(last_match_128303, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                bool bounds_check_128307 = x_128305 && y_128306;
                                bool index_certs_128308;
                                
                                if (!bounds_check_128307) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) last_match_128303, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:240:20-34\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:156:78-81\n   #4  ftRelational.fut:147:1-156:81\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_128309 = tS_start_120347 + last_match_128303;
                                int16_t sv_128310 = ((int16_t *) tS_mem_133467.mem)[slice_128309];
                                bool cond_128311 = last_match_128303 == m_120352;
                                int16_t nv_128312;
                                
                                if (cond_128311) {
                                    nv_128312 = sv_128310;
                                } else {
                                    int64_t tmp_128313 = add64((int64_t) 1, last_match_128303);
                                    bool x_128314 = sle64((int64_t) 0, tmp_128313);
                                    bool y_128315 = slt64(tmp_128313, dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350);
                                    bool bounds_check_128316 = x_128314 && y_128315;
                                    bool index_certs_128317;
                                    
                                    if (!bounds_check_128316) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128313, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20UtS_endz20UtS_startz7dUzg_120350, "].", "-> #0  ftSMJ.fut:241:53-69\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:79-81\n   #3  ftRelational.fut:156:78-81\n   #4  ftRelational.fut:147:1-156:81\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128318 = tS_start_120347 + tmp_128313;
                                    int16_t nv_f_res_128319 = ((int16_t *) tS_mem_133467.mem)[slice_128318];
                                    
                                    nv_128312 = nv_f_res_128319;
                                }
                                
                                bool defunc_0_eq_res_128320 = sv_128310 == eta_p_128227;
                                bool defunc_0_gt_res_128321 = slt16(eta_p_128227, nv_128312);
                                bool x_128322 = !cond_128311;
                                bool y_128323 = defunc_0_gt_res_128321 && x_128322;
                                bool cond_t_res_128324 = cond_128311 || y_128323;
                                bool x_128325 = defunc_0_eq_res_128320 && cond_t_res_128324;
                                int64_t loopres_128326;
                                int64_t loopres_128327;
                                
                                if (x_128325) {
                                    loopres_128326 = last_match_128303;
                                    loopres_128327 = (int64_t) 0;
                                } else {
                                    int64_t loopres_f_res_128328;
                                    int64_t loopres_f_res_128329;
                                    
                                    if (defunc_0_eq_res_128320) {
                                        int64_t tmp_128460 = add64(last_match_128303, step_128304);
                                        int64_t max_arg1_128461 = sdiv64(step_128304, (int64_t) 2);
                                        int64_t max_res_128462 = smax64((int64_t) 1, max_arg1_128461);
                                        
                                        loopres_f_res_128328 = tmp_128460;
                                        loopres_f_res_128329 = max_res_128462;
                                    } else {
                                        bool defunc_0_gt_res_128333 = slt16(eta_p_128227, sv_128310);
                                        int64_t loopres_f_res_f_res_128334;
                                        int64_t loopres_f_res_f_res_128335;
                                        
                                        if (defunc_0_gt_res_128333) {
                                            int64_t tmp_128463 = sub64(last_match_128303, step_128304);
                                            int64_t max_arg1_128464 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128465 = smax64((int64_t) 1, max_arg1_128464);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128463;
                                            loopres_f_res_f_res_128335 = max_res_128465;
                                        } else {
                                            int64_t tmp_128339 = add64(last_match_128303, step_128304);
                                            int64_t max_arg1_128340 = sdiv64(step_128304, (int64_t) 2);
                                            int64_t max_res_128341 = smax64((int64_t) 1, max_arg1_128340);
                                            
                                            loopres_f_res_f_res_128334 = tmp_128339;
                                            loopres_f_res_f_res_128335 = max_res_128341;
                                        }
                                        loopres_f_res_128328 = loopres_f_res_f_res_128334;
                                        loopres_f_res_128329 = loopres_f_res_f_res_128335;
                                    }
                                    loopres_128326 = loopres_f_res_128328;
                                    loopres_128327 = loopres_f_res_128329;
                                }
                                
                                bool loop_cond_128342 = slt64((int64_t) 0, loopres_128327);
                                bool loop_while_tmp_133908 = loop_cond_128342;
                                int64_t last_match_tmp_133909 = loopres_128326;
                                int64_t step_tmp_133910 = loopres_128327;
                                
                                loop_while_128302 = loop_while_tmp_133908;
                                last_match_128303 = last_match_tmp_133909;
                                step_128304 = step_tmp_133910;
                            }
                            defunc_0_f_res_f_res_128299 = loop_while_128302;
                            defunc_0_f_res_f_res_128300 = last_match_128303;
                            defunc_0_f_res_f_res_128301 = step_128304;
                            defunc_0_f_res_128296 = defunc_0_f_res_f_res_128300;
                        }
                        
                        bool cond_128343 = slt64(defunc_0_f_res_128230, (int64_t) 0);
                        int64_t cm_128344;
                        
                        if (cond_128343) {
                            cm_128344 = (int64_t) 0;
                        } else {
                            int64_t zp_lhs_128345 = sub64(defunc_0_f_res_128296, defunc_0_f_res_128230);
                            int64_t cm_f_res_128346 = add64((int64_t) 1, zp_lhs_128345);
                            
                            cm_128344 = cm_f_res_128346;
                        }
                        
                        int64_t lifted_lambda_res_128350;
                        
                        if (cond_128343) {
                            lifted_lambda_res_128350 = defunc_0_f_res_128230;
                        } else {
                            int64_t lifted_lambda_res_f_res_128351 = add64(find_joinTuples_arg3_120388, defunc_0_f_res_128230);
                            
                            lifted_lambda_res_128350 = lifted_lambda_res_f_res_128351;
                        }
                        
                        bool cond_128353 = slt64(eta_p_128228, (int64_t) 0);
                        int64_t lifted_lambda_res_128354;
                        
                        if (cond_128353) {
                            lifted_lambda_res_128354 = lifted_lambda_res_128350;
                        } else {
                            lifted_lambda_res_128354 = eta_p_128228;
                        }
                        
                        int64_t defunc_0_f_res_128357 = add64(eta_p_128226, cm_128344);
                        
                        ((int64_t *) mem_133490.mem)[i_133302] = defunc_0_f_res_128357;
                        ((int64_t *) mem_133492.mem)[i_133302] = lifted_lambda_res_128354;
                    }
                    
                    int64_t tmp_120527 = add64((int64_t) 1, s_iter_120343);
                    
                    if (memblock_set(ctx, &ext_mem_133510, &mem_133490, "mem_133490") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133507, &mem_133492, "mem_133492") != 0)
                        return 1;
                    loopres_f_res_120380 = tmp_120527;
                    loopres_f_res_120383 = nextRel_120387;
                }
                if (memblock_set(ctx, &ext_mem_133516, &ext_mem_133510, "ext_mem_133510") != 0)
                    return 1;
                if (memblock_set(ctx, &ext_mem_133513, &ext_mem_133507, "ext_mem_133507") != 0)
                    return 1;
                loopres_120374 = loopres_f_res_120380;
                loopres_120377 = loopres_f_res_120383;
                loopres_120378 = minRelevant_120346;
            }
            
            bool cond_120528 = slt64(loopres_120374, numIter_S_120289);
            bool x_120529 = loopres_120377 && cond_120528;
            
            if (memblock_set(ctx, &mem_param_tmp_133892, &ext_mem_133516, "ext_mem_133516") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133893, &ext_mem_133513, "ext_mem_133513") != 0)
                return 1;
            
            int64_t ctx_param_ext_tmp_133894 = ext_133515;
            int64_t ctx_param_ext_tmp_133895 = ext_133514;
            int64_t ctx_param_ext_tmp_133896 = ext_133512;
            int64_t ctx_param_ext_tmp_133897 = ext_133511;
            bool loop_while_tmp_133898 = x_120529;
            int64_t s_iter_tmp_133899 = loopres_120374;
            int64_t minRelevant_tmp_133902 = loopres_120378;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133488, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
                return 1;
            ctx_param_ext_133483 = ctx_param_ext_tmp_133894;
            ctx_param_ext_133484 = ctx_param_ext_tmp_133895;
            ctx_param_ext_133486 = ctx_param_ext_tmp_133896;
            ctx_param_ext_133487 = ctx_param_ext_tmp_133897;
            loop_while_120342 = loop_while_tmp_133898;
            s_iter_120343 = s_iter_tmp_133899;
            minRelevant_120346 = minRelevant_tmp_133902;
        }
        if (memblock_set(ctx, &ext_mem_133522, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133521, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        ext_133520 = ctx_param_ext_133483;
        ext_133519 = ctx_param_ext_133484;
        ext_133518 = ctx_param_ext_133486;
        ext_133517 = ctx_param_ext_133487;
        loopres_120337 = loop_while_120342;
        loopres_120338 = s_iter_120343;
        loopres_120341 = minRelevant_120346;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133524, bytes_133469, "mem_133524")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133478.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_100945});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133524.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133521.mem, ext_133518, (int64_t []) {ext_133517}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_133526, bytes_133469, "mem_133526")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {nR_100945});
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133526.mem, tR_start_120304, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133522.mem, ext_133520, (int64_t []) {ext_133519}, (int64_t []) {dzlz7bUZLzmZRz20UtR_endz20UtR_startz7dUzg_120307});
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        
        int64_t tmp_120535 = add64((int64_t) 1, iter_120300);
        bool loop_cond_120536 = slt64(tmp_120535, numIter_R_120286);
        
        if (memblock_set(ctx, &mem_param_tmp_133883, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133884, &mem_133524, "mem_133524") != 0)
            return 1;
        
        bool loop_while_tmp_133885 = loop_cond_120536;
        int64_t iter_tmp_133886 = tmp_120535;
        int64_t first_relevant_in_S_tmp_133889 = loopres_120341;
        
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133478, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        loop_while_120299 = loop_while_tmp_133885;
        iter_120300 = iter_tmp_133886;
        first_relevant_in_S_120303 = first_relevant_in_S_tmp_133889;
    }
    if (memblock_set(ctx, &ext_mem_133532, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133531, &mem_param_133478, "mem_param_133478") != 0)
        return 1;
    defunc_0_mergeJoin_res_120294 = loop_while_120299;
    defunc_0_mergeJoin_res_120295 = iter_120300;
    defunc_0_mergeJoin_res_120298 = first_relevant_in_S_120303;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
        return 1;
    if (mem_133534_cached_sizze_134105 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133534, &mem_133534_cached_sizze_134105, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133536_cached_sizze_134106 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133536, &mem_133536_cached_sizze_134106, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133538_cached_sizze_134107 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133538, &mem_133538_cached_sizze_134107, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133540_cached_sizze_134108 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133540, &mem_133540_cached_sizze_134108, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133542_cached_sizze_134109 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133542, &mem_133542_cached_sizze_134109, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t discard_133324;
    int64_t discard_133325;
    int64_t defunc_res_128479;
    int64_t scanacc_133310;
    int64_t scanacc_133311;
    int64_t redout_133314;
    
    scanacc_133310 = (int64_t) 0;
    scanacc_133311 = (int64_t) 0;
    redout_133314 = (int64_t) 0;
    for (int64_t i_133318 = 0; i_133318 < nR_100945; i_133318++) {
        int64_t zg_lhs_128038 = ((int64_t *) ext_mem_133532.mem)[i_133318];
        bool cond_128039 = slt64((int64_t) 0, zg_lhs_128038);
        int64_t lifted_lambda_res_128040;
        
        if (cond_128039) {
            lifted_lambda_res_128040 = i_133318;
        } else {
            lifted_lambda_res_128040 = (int64_t) -1;
        }
        
        bool cond_128042 = sle64((int64_t) 0, lifted_lambda_res_128040);
        bool cond_t_res_128043 = slt64(lifted_lambda_res_128040, nR_100945);
        bool x_128044 = cond_128042 && cond_t_res_128043;
        int64_t lifted_lambda_res_128045;
        
        if (x_128044) {
            bool index_certs_128468;
            
            if (!x_128044) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lifted_lambda_res_128040, "] out of bounds for array of shape [", (long long) nR_100945, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftRelational.fut:156:78-81\n   #4  ftRelational.fut:147:1-156:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t lifted_lambda_res_t_res_128469 = ((int64_t *) ext_mem_133532.mem)[lifted_lambda_res_128040];
            
            lifted_lambda_res_128045 = lifted_lambda_res_t_res_128469;
        } else {
            lifted_lambda_res_128045 = (int64_t) 0;
        }
        
        bool lifted_lambda_res_128049 = slt64((int64_t) 1, lifted_lambda_res_128045);
        int64_t defunc_0_f_res_128050 = btoi_bool_i64(lifted_lambda_res_128049);
        int64_t defunc_0_op_res_120595 = add64(defunc_0_f_res_128050, scanacc_133310);
        int64_t lifted_lambda_res_120560 = add64(lifted_lambda_res_128045, scanacc_133311);
        int64_t zp_res_126101 = add64(lifted_lambda_res_128045, redout_133314);
        
        ((int64_t *) mem_133534)[i_133318] = defunc_0_op_res_120595;
        ((int64_t *) mem_133536)[i_133318] = lifted_lambda_res_120560;
        ((int64_t *) mem_133538)[i_133318] = defunc_0_f_res_128050;
        ((int64_t *) mem_133540)[i_133318] = lifted_lambda_res_128045;
        ((int64_t *) mem_133542)[i_133318] = lifted_lambda_res_128040;
        
        int64_t scanacc_tmp_133911 = defunc_0_op_res_120595;
        int64_t scanacc_tmp_133912 = lifted_lambda_res_120560;
        int64_t redout_tmp_133915 = zp_res_126101;
        
        scanacc_133310 = scanacc_tmp_133911;
        scanacc_133311 = scanacc_tmp_133912;
        redout_133314 = redout_tmp_133915;
    }
    discard_133324 = scanacc_133310;
    discard_133325 = scanacc_133311;
    defunc_res_128479 = redout_133314;
    if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
        return 1;
    
    int64_t tmp_120598 = sub64(nR_100945, (int64_t) 1);
    bool y_120600 = slt64(tmp_120598, nR_100945);
    bool x_120599 = sle64((int64_t) 0, tmp_120598);
    bool bounds_check_120601 = x_120599 && y_120600;
    bool cond_120596 = nR_100945 == (int64_t) 0;
    bool protect_assert_disj_120602 = cond_120596 || bounds_check_120601;
    bool index_certs_120603;
    
    if (!protect_assert_disj_120602) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_120598, "] out of bounds for array of shape [", (long long) nR_100945, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:156:78-81\n   #4  ftRelational.fut:147:1-156:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool x_120597 = !cond_120596;
    int64_t m_f_res_120604;
    
    if (x_120597) {
        int64_t x_128475 = ((int64_t *) mem_133534)[tmp_120598];
        
        m_f_res_120604 = x_128475;
    } else {
        m_f_res_120604 = (int64_t) 0;
    }
    
    int64_t m_120606;
    
    if (cond_120596) {
        m_120606 = (int64_t) 0;
    } else {
        m_120606 = m_f_res_120604;
    }
    
    int64_t m_120616 = sub64(m_120606, (int64_t) 1);
    bool i_p_m_t_s_leq_w_120618 = slt64(m_120616, nR_100945);
    bool zzero_leq_i_p_m_t_s_120617 = sle64((int64_t) 0, m_120616);
    bool y_120620 = zzero_leq_i_p_m_t_s_120617 && i_p_m_t_s_leq_w_120618;
    bool i_lte_j_120619 = sle64((int64_t) 0, m_120606);
    bool forwards_ok_120621 = i_lte_j_120619 && y_120620;
    bool eq_x_zz_120613 = (int64_t) 0 == m_f_res_120604;
    bool p_and_eq_x_y_120614 = x_120597 && eq_x_zz_120613;
    bool empty_slice_120615 = cond_120596 || p_and_eq_x_y_120614;
    bool ok_or_empty_120622 = empty_slice_120615 || forwards_ok_120621;
    bool index_certs_120623;
    
    if (!ok_or_empty_120622) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_120606, "] out of bounds for array of shape [", (long long) nR_100945, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:364:7-365:57\n   #3  ftRelational.fut:156:78-81\n   #4  ftRelational.fut:147:1-156:81\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133573 = (int64_t) 8 * m_120606;
    int64_t bytes_133585 = (int64_t) 8 * defunc_res_128479;
    int64_t bytes_133589 = (int64_t) 2 * defunc_res_128479;
    
    if (futrts_indicesWithIncrement_11643(ctx, &ext_mem_133468, tR_mem_133466, nR_100945, offset_R_100949) != 0) {
        err = 1;
        goto cleanup;
    }
    if (mem_133574_cached_sizze_134110 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133574, &mem_133574_cached_sizze_134110, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133574, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133540, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (mem_133576_cached_sizze_134111 < bytes_133469) {
        err = lexical_realloc(ctx, &mem_133576, &mem_133576_cached_sizze_134111, bytes_133469);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133328 = 0; i_133328 < nR_100945; i_133328++) {
        int64_t eta_p_127956 = ((int64_t *) mem_133540)[i_133328];
        int64_t zv_lhs_127958 = add64((int64_t) -1, i_133328);
        int64_t tmp_127959 = smod64(zv_lhs_127958, nR_100945);
        int64_t lifted_lambda_res_127960 = ((int64_t *) mem_133536)[tmp_127959];
        bool cond_127962 = i_133328 == (int64_t) 0;
        int64_t lifted_lambda_res_127963;
        
        if (cond_127962) {
            lifted_lambda_res_127963 = (int64_t) 0;
        } else {
            lifted_lambda_res_127963 = lifted_lambda_res_127960;
        }
        
        bool cond_127965 = slt64((int64_t) 0, eta_p_127956);
        int64_t lifted_lambda_res_127966;
        
        if (cond_127965) {
            lifted_lambda_res_127966 = lifted_lambda_res_127963;
        } else {
            lifted_lambda_res_127966 = (int64_t) -1;
        }
        ((int64_t *) mem_133576)[i_133328] = lifted_lambda_res_127966;
    }
    if (mem_133584_cached_sizze_134112 < bytes_133573) {
        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134112, bytes_133573);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133584, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133576, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120606});
    if (memblock_alloc(ctx, &mem_133586, bytes_133585, "mem_133586")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133920 = 0; nest_i_133920 < defunc_res_128479; nest_i_133920++) {
        ((int64_t *) mem_133586.mem)[nest_i_133920] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133588, bytes_133585, "mem_133588")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133921 = 0; nest_i_133921 < defunc_res_128479; nest_i_133921++) {
        ((int64_t *) mem_133588.mem)[nest_i_133921] = (int64_t) -1;
    }
    if (memblock_alloc(ctx, &mem_133590, bytes_133589, "mem_133590")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133922 = 0; nest_i_133922 < defunc_res_128479; nest_i_133922++) {
        ((int16_t *) mem_133590.mem)[nest_i_133922] = (int16_t) 0;
    }
    for (int64_t write_iter_133330 = 0; write_iter_133330 < nR_100945; write_iter_133330++) {
        int64_t write_iv_133336 = ((int64_t *) mem_133538)[write_iter_133330];
        int64_t write_iv_133337 = ((int64_t *) mem_133534)[write_iter_133330];
        int64_t write_iv_133338 = ((int64_t *) mem_133576)[write_iter_133330];
        int64_t write_iv_133339 = ((int64_t *) mem_133540)[write_iter_133330];
        int64_t write_iv_133340 = ((int64_t *) mem_133542)[write_iter_133330];
        bool cond_128065 = sle64((int64_t) 0, write_iv_133340);
        bool cond_t_res_128066 = slt64(write_iv_133340, nR_100945);
        bool x_128067 = cond_128065 && cond_t_res_128066;
        int16_t lifted_lambda_res_128068;
        int64_t lifted_lambda_res_128069;
        int64_t lifted_lambda_res_128070;
        
        if (x_128067) {
            bool index_certs_128470;
            
            if (!x_128067) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) write_iv_133340, "] out of bounds for array of shape [", (long long) nR_100945, "].", "-> #0  ftbasics.fut:19:42-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:19:9-64\n   #3  ftSMJ.fut:364:7-365:57\n   #4  ftRelational.fut:156:78-81\n   #5  ftRelational.fut:147:1-156:81\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int16_t lifted_lambda_res_t_res_128471 = ((int16_t *) tR_mem_133466.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128472 = ((int64_t *) ext_mem_133468.mem)[write_iv_133340];
            int64_t lifted_lambda_res_t_res_128473 = ((int64_t *) ext_mem_133531.mem)[write_iv_133340];
            
            lifted_lambda_res_128068 = lifted_lambda_res_t_res_128471;
            lifted_lambda_res_128069 = lifted_lambda_res_t_res_128472;
            lifted_lambda_res_128070 = lifted_lambda_res_t_res_128473;
        } else {
            lifted_lambda_res_128068 = (int16_t) 0;
            lifted_lambda_res_128069 = (int64_t) -1;
            lifted_lambda_res_128070 = (int64_t) -1;
        }
        
        bool cond_128078 = write_iv_133336 == (int64_t) 1;
        int64_t lifted_lambda_res_128079;
        
        if (cond_128078) {
            int64_t lifted_lambda_res_t_res_128474 = sub64(write_iv_133337, (int64_t) 1);
            
            lifted_lambda_res_128079 = lifted_lambda_res_t_res_128474;
        } else {
            lifted_lambda_res_128079 = (int64_t) -1;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133584)[lifted_lambda_res_128079] = write_iv_133338;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_128079) && slt64(lifted_lambda_res_128079, m_120606)) {
            ((int64_t *) mem_133574)[lifted_lambda_res_128079] = write_iv_133339;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int16_t *) mem_133590.mem)[write_iv_133338] = lifted_lambda_res_128068;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133588.mem)[write_iv_133338] = lifted_lambda_res_128069;
        }
        if (sle64((int64_t) 0, write_iv_133338) && slt64(write_iv_133338, defunc_res_128479)) {
            ((int64_t *) mem_133586.mem)[write_iv_133338] = lifted_lambda_res_128070;
        }
    }
    if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
        return 1;
    for (int64_t i_120636 = 0; i_120636 < m_120606; i_120636++) {
        int64_t loopres_120640 = ((int64_t *) mem_133584)[i_120636];
        int64_t loopres_120641 = ((int64_t *) mem_133574)[i_120636];
        bool x_120642 = sle64((int64_t) 0, loopres_120640);
        bool y_120643 = slt64(loopres_120640, defunc_res_128479);
        bool bounds_check_120644 = x_120642 && y_120643;
        bool index_certs_120645;
        
        if (!bounds_check_120644) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:346:52-59\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t tmp_120655 = add64(loopres_120640, loopres_120641);
        bool empty_slice_120656 = loopres_120641 == (int64_t) 0;
        int64_t m_120657 = sub64(loopres_120641, (int64_t) 1);
        int64_t i_p_m_t_s_120658 = add64(loopres_120640, m_120657);
        bool zzero_leq_i_p_m_t_s_120659 = sle64((int64_t) 0, i_p_m_t_s_120658);
        bool i_p_m_t_s_leq_w_120660 = slt64(i_p_m_t_s_120658, defunc_res_128479);
        bool i_lte_j_120661 = sle64(loopres_120640, tmp_120655);
        bool y_120662 = x_120642 && i_p_m_t_s_leq_w_120660;
        bool y_120663 = zzero_leq_i_p_m_t_s_120659 && y_120662;
        bool forwards_ok_120664 = i_lte_j_120661 && y_120663;
        bool ok_or_empty_120665 = empty_slice_120656 || forwards_ok_120664;
        bool index_certs_120666;
        
        if (!ok_or_empty_120665) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) loopres_120640, ":", (long long) tmp_120655, "] out of bounds for array of shape [", (long long) defunc_res_128479, "].", "-> #0  ftSMJ.fut:348:8-40\n   #1  ftSMJ.fut:364:7-365:57\n   #2  ftRelational.fut:156:78-81\n   #3  ftRelational.fut:147:1-156:81\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int16_t loopres_120646 = ((int16_t *) mem_133590.mem)[loopres_120640];
        int64_t loopres_120647 = ((int64_t *) mem_133588.mem)[loopres_120640];
        int64_t loopres_120648 = ((int64_t *) mem_133586.mem)[loopres_120640];
        
        for (int64_t nest_i_133931 = 0; nest_i_133931 < loopres_120641; nest_i_133931++) {
            ((int16_t *) mem_133590.mem)[loopres_120640 + nest_i_133931] = loopres_120646;
        }
        for (int64_t nest_i_133932 = 0; nest_i_133932 < loopres_120641; nest_i_133932++) {
            ((int64_t *) mem_133588.mem)[loopres_120640 + nest_i_133932] = loopres_120647;
        }
        for (int64_t i_133349 = 0; i_133349 < loopres_120641; i_133349++) {
            int64_t tmp_120654 = add64(loopres_120648, i_133349);
            
            ((int64_t *) mem_133586.mem)[loopres_120640 + i_133349] = tmp_120654;
        }
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133588, "mem_133588") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133586, "mem_133586") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133879, &mem_133590, "mem_133590") != 0)
        return 1;
    prim_out_133880 = defunc_res_128479;
    if (memblock_set(ctx, &*mem_out_p_134101, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134102, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134103, &mem_out_133879, "mem_out_133879") != 0)
        return 1;
    *out_prim_out_134104 = prim_out_133880;
    
  cleanup:
    {
        free(mem_133534);
        free(mem_133536);
        free(mem_133538);
        free(mem_133540);
        free(mem_133542);
        free(mem_133574);
        free(mem_133576);
        free(mem_133584);
        if (memblock_unref(ctx, &mem_133590, "mem_133590") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133588, "mem_133588") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133586, "mem_133586") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133468, "ext_mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133526, "mem_133526") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133524, "mem_133524") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133492, "mem_133492") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133490, "mem_133490") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133507, "ext_mem_133507") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133510, "ext_mem_133510") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133513, "ext_mem_133513") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133516, "ext_mem_133516") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133488, "mem_param_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133521, "ext_mem_133521") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133522, "ext_mem_133522") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133482, "mem_133482") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133480, "mem_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133478, "mem_param_133478") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133532, "ext_mem_133532") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133472, "mem_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133879, "mem_out_133879") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_max_idx(struct futhark_context *ctx, int64_t *out_prim_out_134113, struct memblock eta_p_mem_133466, int64_t nz2080U_61900)
{
    (void) ctx;
    
    int err = 0;
    int64_t prim_out_133877;
    int64_t defunc_0_reduce_res_127931;
    int64_t redout_133298 = (int64_t) -9223372036854775808;
    
    for (int64_t i_133299 = 0; i_133299 < nz2080U_61900; i_133299++) {
        int64_t x_118493 = ((int64_t *) eta_p_mem_133466.mem)[i_133299];
        int64_t max_res_118496 = smax64(x_118493, redout_133298);
        int64_t redout_tmp_133878 = max_res_118496;
        
        redout_133298 = redout_tmp_133878;
    }
    defunc_0_reduce_res_127931 = redout_133298;
    prim_out_133877 = defunc_0_reduce_res_127931;
    *out_prim_out_134113 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_double(struct futhark_context *ctx, struct memblock *mem_out_p_134114, struct memblock *mem_out_p_134115, struct memblock xs_mem_133466, int64_t n_98615, int64_t incr_98616)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134116 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134117 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134118 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134119 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134120 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134121 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134122 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134123 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134124 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134125 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_98615;
    bool cond_125539 = sle64(n_98615, (int64_t) 1);
    int64_t zs_lhs_125540 = sub64(n_98615, (int64_t) 1);
    int64_t zp_rhs_125541 = sdiv_safe64(zs_lhs_125540, (int64_t) 20);
    int64_t min_num_blocks_125542 = add64((int64_t) 1, zp_rhs_125541);
    bool loop_cond_125543 = slt64((int64_t) 1, min_num_blocks_125542);
    bool smallest_pow_2_geq_than_res_125544;
    int64_t smallest_pow_2_geq_than_res_125545;
    bool loop_while_125546;
    int64_t x_125547;
    
    loop_while_125546 = loop_cond_125543;
    x_125547 = (int64_t) 1;
    while (loop_while_125546) {
        int64_t loopres_125548 = mul64((int64_t) 2, x_125547);
        bool loop_cond_125549 = slt64(loopres_125548, min_num_blocks_125542);
        bool loop_while_tmp_133879 = loop_cond_125549;
        int64_t x_tmp_133880 = loopres_125548;
        
        loop_while_125546 = loop_while_tmp_133879;
        x_125547 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125544 = loop_while_125546;
    smallest_pow_2_geq_than_res_125545 = x_125547;
    
    bool zzero_125550 = smallest_pow_2_geq_than_res_125545 == (int64_t) 0;
    bool nonzzero_125551 = !zzero_125550;
    bool protect_assert_disj_125552 = cond_125539 || nonzzero_125551;
    bool nonzzero_cert_125553;
    
    if (!protect_assert_disj_125552) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:143:35-39\n   #5  ftRelational.fut:142:9-143:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125554 = sdiv_safe64(zs_lhs_125540, smallest_pow_2_geq_than_res_125545);
    int64_t block_sizze_125555 = add64((int64_t) 1, zp_rhs_125554);
    bool y_125561 = slt64((int64_t) 0, n_98615);
    bool protect_assert_disj_133752 = cond_125539 || y_125561;
    bool index_certs_125562;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_98615, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:143:35-39\n   #5  ftRelational.fut:142:9-143:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125576 = slt64(smallest_pow_2_geq_than_res_125545, (int64_t) 0);
    bool valid_125577 = !bounds_invalid_upwards_125576;
    bool protect_assert_disj_133760 = cond_125539 || valid_125577;
    bool range_valid_c_125578;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125545, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:143:35-39\n   #6  ftRelational.fut:142:9-143:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125580 = slt64(block_sizze_125555, (int64_t) 0);
    bool valid_125581 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_133762 = cond_125539 || valid_125581;
    bool range_valid_c_125582;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125555, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125584 = sle64(block_sizze_125555, (int64_t) 1);
    int64_t tmp_125585 = sub64(block_sizze_125555, (int64_t) 2);
    bool bounds_invalid_upwards_125586 = slt64(tmp_125585, (int64_t) 0);
    bool valid_125588 = !bounds_invalid_upwards_125586;
    bool protect_assert_disj_125589 = cond_125584 || valid_125588;
    bool protect_assert_disj_133764 = cond_125539 || protect_assert_disj_125589;
    bool range_valid_c_125590;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125585, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (futrts_indicesWithIncrement_11729(ctx, &ext_mem_133467, xs_mem_133466, n_98615, incr_98616) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_98615; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125556 = smallest_pow_2_geq_than_res_125545 * block_sizze_125555;
    bool x_133747 = !cond_125539;
    int64_t greatest_divisor_leq_than_arg1_125559 = mul64((int64_t) 2, block_sizze_125555);
    int64_t merge_block_sizze_125560;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125559) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125560 = x_133749;
    } else {
        merge_block_sizze_125560 = (int64_t) 0;
    }
    
    double reduce_arg1_125563;
    
    if (x_133747) {
        double x_133753 = ((double *) xs_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125563 = x_133753;
    } else {
        reduce_arg1_125563 = 0.0;
    }
    
    double defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        double x_133755;
        int64_t x_133756;
        double redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125563;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_98615; i_133300++) {
            double x_125567 = ((double *) xs_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125573 = redout_133298 <= x_125567;
            double defunc_0_op_res_125574;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125574 = x_125567;
            } else {
                defunc_0_op_res_125574 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125575;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125575 = i_133300;
            } else {
                defunc_0_op_res_125575 = redout_133299;
            }
            
            double redout_tmp_133883 = defunc_0_op_res_125574;
            int64_t redout_tmp_133884 = defunc_0_op_res_125575;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = 0.0;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125587 = add64((int64_t) 1, tmp_125585);
    int64_t binop_x_133470 = (int64_t) 8 * smallest_pow_2_geq_than_res_125545;
    int64_t bytes_133471 = block_sizze_125555 * binop_x_133470;
    int64_t bytes_133484 = (int64_t) 8 * block_sizze_125555;
    bool loop_cond_125662 = slt64(block_sizze_125555, flat_dim_125556);
    bool zzero_125663 = merge_block_sizze_125560 == (int64_t) 0;
    bool nonzzero_125664 = !zzero_125663;
    
    if (cond_125539) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134116 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134116, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134117 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134117, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134118 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134118, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134119 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134119, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125545; i_133312++) {
            int64_t zp_lhs_125594 = mul64(block_sizze_125555, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125555; i_133305++) {
                int64_t k_125598 = add64(zp_lhs_125594, i_133305);
                bool cond_125599 = slt64(k_125598, n_98615);
                double lifted_lambda_res_125600;
                int64_t lifted_lambda_res_125601;
                
                if (cond_125599) {
                    bool x_127931 = sle64((int64_t) 0, k_125598);
                    bool bounds_check_127932 = cond_125599 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125598, "] out of bounds for array of shape [", (long long) n_98615, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:143:35-39\n   #9  ftRelational.fut:142:9-143:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    double lifted_lambda_res_t_res_127934 = ((double *) xs_mem_133466.mem)[k_125598];
                    
                    lifted_lambda_res_125600 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125601 = k_125598;
                } else {
                    lifted_lambda_res_125600 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125601 = defunc_0_reduce_res_128079;
                }
                ((double *) mem_133485)[i_133305] = lifted_lambda_res_125600;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125601;
            }
            if (!cond_125584) {
                for (int64_t i_125611 = 0; i_125611 < distance_125587; i_125611++) {
                    int64_t gt_arg1_125614 = add64((int64_t) 1, i_125611);
                    bool x_125615 = sle64((int64_t) 0, gt_arg1_125614);
                    bool y_125616 = slt64(gt_arg1_125614, block_sizze_125555);
                    bool bounds_check_125617 = x_125615 && y_125616;
                    bool index_certs_125618;
                    
                    if (!bounds_check_125617) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125614, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125620 = slt64(i_125611, block_sizze_125555);
                    bool index_certs_125621;
                    
                    if (!y_125620) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125611, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    double gt_arg1_125619 = ((double *) mem_133485)[gt_arg1_125614];
                    double gt_arg0_125622 = ((double *) mem_133485)[i_125611];
                    bool defunc_0_leq_res_125623 = gt_arg0_125622 <= gt_arg1_125619;
                    bool defunc_0_lifted_gt_res_125624 = !defunc_0_leq_res_125623;
                    bool s_125625;
                    int64_t s_125628;
                    bool loop_while_125629;
                    int64_t j_125632;
                    
                    loop_while_125629 = defunc_0_lifted_gt_res_125624;
                    j_125632 = i_125611;
                    while (loop_while_125629) {
                        bool x_125633 = sle64((int64_t) 0, j_125632);
                        bool y_125634 = slt64(j_125632, block_sizze_125555);
                        bool bounds_check_125635 = x_125633 && y_125634;
                        bool index_certs_125636;
                        
                        if (!bounds_check_125635) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125632, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125639 = add64((int64_t) 1, j_125632);
                        bool x_125640 = sle64((int64_t) 0, copy_arg0_125639);
                        bool y_125641 = slt64(copy_arg0_125639, block_sizze_125555);
                        bool bounds_check_125642 = x_125640 && y_125641;
                        bool index_certs_125643;
                        
                        if (!bounds_check_125642) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125639, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        double copy_arg0_125637 = ((double *) mem_133485)[j_125632];
                        int64_t copy_arg0_125638 = ((int64_t *) mem_133487)[j_125632];
                        double copy_arg0_125644 = ((double *) mem_133485)[copy_arg0_125639];
                        int64_t copy_arg0_125645 = ((int64_t *) mem_133487)[copy_arg0_125639];
                        
                        ((double *) mem_133485)[j_125632] = copy_arg0_125644;
                        ((int64_t *) mem_133487)[j_125632] = copy_arg0_125645;
                        ((double *) mem_133485)[copy_arg0_125639] = copy_arg0_125637;
                        ((int64_t *) mem_133487)[copy_arg0_125639] = copy_arg0_125638;
                        
                        int64_t tmp_125650 = sub64(j_125632, (int64_t) 1);
                        bool cond_125651 = sle64((int64_t) 0, tmp_125650);
                        bool loop_cond_125652;
                        
                        if (cond_125651) {
                            bool y_127936 = slt64(tmp_125650, block_sizze_125555);
                            bool bounds_check_127937 = cond_125651 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125650, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            double gt_arg1_127935 = ((double *) mem_133485)[j_125632];
                            double gt_arg0_127939 = ((double *) mem_133485)[tmp_125650];
                            bool defunc_0_leq_res_127940 = gt_arg0_127939 <= gt_arg1_127935;
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125652 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125652 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125652;
                        int64_t j_tmp_133894 = tmp_125650;
                        
                        loop_while_125629 = loop_while_tmp_133891;
                        j_125632 = j_tmp_133894;
                    }
                    s_125625 = loop_while_125629;
                    s_125628 = j_125632;
                }
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133472, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint64_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        if (memblock_alloc(ctx, &mem_133544, bytes_133471, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        
        int64_t data_125665;
        bool data_125666;
        int64_t data_125669;
        int64_t loop_dz2084Uz2082U_125670;
        bool loop_while_125671;
        int64_t stride_125674;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125670 = flat_dim_125556;
        loop_while_125671 = loop_cond_125662;
        stride_125674 = block_sizze_125555;
        while (loop_while_125671) {
            int64_t next_stride_125675 = mul64((int64_t) 2, stride_125674);
            bool zzero_125676 = next_stride_125675 == (int64_t) 0;
            bool nonzzero_125677 = !zzero_125676;
            bool nonzzero_cert_125678;
            
            if (!nonzzero_125677) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:143:35-39\n   #5  ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125679 = sdiv64(flat_dim_125556, next_stride_125675);
            bool bounds_invalid_upwards_125680 = slt64(num_merges_125679, (int64_t) 0);
            bool valid_125681 = !bounds_invalid_upwards_125680;
            bool range_valid_c_125682;
            
            if (!valid_125681) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125679, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:143:35-39\n   #6  ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125684 = sub64(next_stride_125675, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125685 = sle64((int64_t) 0, m_125684);
            bool cond_125687 = slt64(next_stride_125675, (int64_t) 10);
            bool protect_assert_disj_125688 = nonzzero_125664 || cond_125687;
            bool nonzzero_cert_125689;
            
            if (!protect_assert_disj_125688) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125690 = smod_safe64(next_stride_125675, merge_block_sizze_125560);
            bool num_blocks_125691 = zeze_lhs_125690 == (int64_t) 0;
            bool protect_assert_disj_125692 = cond_125687 || num_blocks_125691;
            bool assert_c_125693;
            
            if (!protect_assert_disj_125692) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125695 = sdiv_safe64(next_stride_125675, merge_block_sizze_125560);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696 = add64((int64_t) 1, num_blocks_125695);
            int64_t j_m_i_125697 = sub64(next_stride_125675, stride_125674);
            int64_t flat_dim_125698 = merge_block_sizze_125560 * num_blocks_125695;
            bool bounds_invalid_upwards_125699 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, (int64_t) 0);
            bool empty_slice_125700 = j_m_i_125697 == (int64_t) 0;
            int64_t m_125701 = sub64(j_m_i_125697, (int64_t) 1);
            bool zzero_lte_i_125702 = sle64((int64_t) 0, stride_125674);
            bool i_lte_j_125703 = sle64(stride_125674, next_stride_125675);
            bool empty_slice_125704 = stride_125674 == (int64_t) 0;
            int64_t m_125705 = sub64(stride_125674, (int64_t) 1);
            bool bounds_invalid_upwards_125706 = slt64(num_blocks_125695, (int64_t) 0);
            bool cond_125707 = slt64((int64_t) 0, stride_125674);
            bool valid_125708 = !bounds_invalid_upwards_125699;
            int64_t i_p_m_t_s_125709 = add64(stride_125674, m_125701);
            bool zzero_leq_i_p_m_t_s_125710 = sle64((int64_t) 0, m_125705);
            bool i_p_m_t_s_leq_w_125711 = slt64(m_125705, next_stride_125675);
            bool valid_125712 = !bounds_invalid_upwards_125706;
            bool i_p_m_t_s_leq_w_125713 = slt64(m_125684, flat_dim_125698);
            bool y_125714 = slt64((int64_t) 0, j_m_i_125697);
            bool protect_assert_disj_125715 = cond_125687 || valid_125708;
            bool range_valid_c_125716;
            
            if (!protect_assert_disj_125715) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:143:35-39\n   #10 ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125717 = sle64((int64_t) 0, i_p_m_t_s_125709);
            bool i_p_m_t_s_leq_w_125718 = slt64(i_p_m_t_s_125709, next_stride_125675);
            bool y_125719 = zzero_leq_i_p_m_t_s_125710 && i_p_m_t_s_leq_w_125711;
            bool protect_assert_disj_125720 = cond_125687 || valid_125712;
            bool range_valid_c_125721;
            
            if (!protect_assert_disj_125720) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125695, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:143:35-39\n   #9  ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125722 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125713;
            bool y_125723 = zzero_lte_i_125702 && i_p_m_t_s_leq_w_125718;
            bool forwards_ok_125724 = zzero_lte_i_125702 && y_125719;
            bool ok_or_empty_125725 = zzero_125676 || y_125722;
            bool protect_assert_disj_125726 = cond_125707 || y_125714;
            bool y_125727 = zzero_leq_i_p_m_t_s_125717 && y_125723;
            bool ok_or_empty_125728 = empty_slice_125704 || forwards_ok_125724;
            bool protect_assert_disj_125729 = cond_125687 || ok_or_empty_125725;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) flat_dim_125698, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:143:35-39\n   #9  ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125731 = !cond_125687;
            bool protect_assert_disj_125732 = protect_assert_disj_125726 || loop_not_taken_125731;
            bool index_certs_125733;
            
            if (!protect_assert_disj_125732) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:143:35-39\n   #10 ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125734 = i_lte_j_125703 && y_125727;
            bool protect_assert_disj_125735 = cond_125687 || ok_or_empty_125728;
            bool index_certs_125736;
            
            if (!protect_assert_disj_125735) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:143:35-39\n   #11 ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125737 = ok_or_empty_125728 || loop_not_taken_125731;
            bool index_certs_125738;
            
            if (!protect_assert_disj_125737) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125739 = empty_slice_125700 || forwards_ok_125734;
            bool protect_assert_disj_125740 = cond_125687 || ok_or_empty_125739;
            bool index_certs_125741;
            
            if (!protect_assert_disj_125740) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:143:35-39\n   #11 ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125742 = loop_not_taken_125731 || ok_or_empty_125739;
            bool index_certs_125743;
            
            if (!protect_assert_disj_125742) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 8 * num_merges_125679;
            int64_t bytes_133553 = next_stride_125675 * binop_x_133552;
            bool i_lte_j_125686 = sle64((int64_t) 0, next_stride_125675);
            
            if (mem_133554_cached_sizze_134120 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134120, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134121 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134121, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696;
            int64_t binop_x_133582 = (int64_t) 8 * num_blocks_125695;
            int64_t bytes_133583 = merge_block_sizze_125560 * binop_x_133582;
            int64_t bytes_133628 = (int64_t) 16 * stride_125674;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125679; i_133333++) {
                int64_t start_125747 = mul64(next_stride_125675, i_133333);
                int64_t j_m_i_125748 = sub64(loop_dz2084Uz2082U_125670, start_125747);
                bool empty_slice_125749 = j_m_i_125748 == (int64_t) 0;
                int64_t m_125750 = sub64(j_m_i_125748, (int64_t) 1);
                int64_t i_p_m_t_s_125751 = add64(start_125747, m_125750);
                bool zzero_leq_i_p_m_t_s_125752 = sle64((int64_t) 0, i_p_m_t_s_125751);
                bool i_p_m_t_s_leq_w_125753 = slt64(i_p_m_t_s_125751, loop_dz2084Uz2082U_125670);
                bool zzero_lte_i_125754 = sle64((int64_t) 0, start_125747);
                bool i_lte_j_125755 = sle64(start_125747, loop_dz2084Uz2082U_125670);
                bool y_125756 = i_p_m_t_s_leq_w_125753 && zzero_lte_i_125754;
                bool y_125757 = zzero_leq_i_p_m_t_s_125752 && y_125756;
                bool forwards_ok_125758 = i_lte_j_125755 && y_125757;
                bool ok_or_empty_125759 = empty_slice_125749 || forwards_ok_125758;
                bool index_certs_125760;
                
                if (!ok_or_empty_125759) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125747, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125670, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125761 = slt64(m_125684, j_m_i_125748);
                bool y_125762 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125761;
                bool forwards_ok_125763 = i_lte_j_125686 && y_125762;
                bool ok_or_empty_125764 = zzero_125676 || forwards_ok_125763;
                bool index_certs_125765;
                
                if (!ok_or_empty_125764) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) j_m_i_125748, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:143:35-39\n   #8  ftRelational.fut:142:9-143:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125687) {
                    double dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125707) {
                        double head_res_127969 = ((double *) mem_param_133548.mem)[start_125747];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125747];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125674 + start_125747;
                        double head_res_127972 = ((double *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125675; nest_i_133904++) {
                        ((double *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133628, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125675; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125675; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125697;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125674);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125697);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:143:35-39\n   #9  ftRelational.fut:142:9-143:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:143:35-39\n   #9  ftRelational.fut:142:9-143:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125674 + j_127983;
                                int64_t slice_127993 = start_125747 + slice_127992;
                                double leq_arg1_127994 = ((double *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125747 + i_127980;
                                double leq_arg0_127999 = ((double *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = leq_arg0_127999 <= leq_arg1_127994;
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        double loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125674);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:143:35-39\n   #9  ftRelational.fut:142:9-143:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125747 + i_127980;
                            double tmp_128010 = ((double *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125697);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:143:35-39\n   #9  ftRelational.fut:142:9-143:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125674 + j_127983;
                            int64_t slice_128017 = start_125747 + slice_128016;
                            double tmp_128018 = ((double *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((double *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134122 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134122, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134123 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134123, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696; i_133319++) {
                        int64_t split_count_arg3_125827 = mul64(merge_block_sizze_125560, i_133319);
                        int64_t defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125828, &defunc_0_split_count_res_125829, &defunc_0_split_count_res_125830, &defunc_0_split_count_res_125831, &defunc_0_split_count_res_125832, (int64_t) 0, stride_125674, (int64_t) 0, j_m_i_125697, split_count_arg3_125827) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125833 = slt64((int64_t) 0, defunc_0_split_count_res_125832);
                        bool defunc_0_split_count_res_125834;
                        int64_t defunc_0_split_count_res_125835;
                        int64_t defunc_0_split_count_res_125836;
                        int64_t defunc_0_split_count_res_125837;
                        int64_t defunc_0_split_count_res_125838;
                        int64_t defunc_0_split_count_res_125839;
                        bool loop_while_125840;
                        int64_t ss_125841;
                        int64_t ss_125842;
                        int64_t tt_125843;
                        int64_t tt_125844;
                        int64_t count_125845;
                        
                        loop_while_125840 = loop_cond_125833;
                        ss_125841 = defunc_0_split_count_res_125828;
                        ss_125842 = defunc_0_split_count_res_125829;
                        tt_125843 = defunc_0_split_count_res_125830;
                        tt_125844 = defunc_0_split_count_res_125831;
                        count_125845 = defunc_0_split_count_res_125832;
                        while (loop_while_125840) {
                            int64_t zlze_lhs_125846 = sub64(ss_125842, ss_125841);
                            bool cond_125847 = sle64(zlze_lhs_125846, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125848;
                            int64_t defunc_0_lifted_step_res_125849;
                            int64_t defunc_0_lifted_step_res_125850;
                            int64_t defunc_0_lifted_step_res_125851;
                            
                            if (cond_125847) {
                                int64_t tmp_128022 = add64(tt_125843, count_125845);
                                
                                defunc_0_lifted_step_res_125848 = ss_125841;
                                defunc_0_lifted_step_res_125849 = tmp_128022;
                                defunc_0_lifted_step_res_125850 = tt_125844;
                                defunc_0_lifted_step_res_125851 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125853 = sub64(tt_125844, tt_125843);
                                bool cond_125854 = sle64(zlze_lhs_125853, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125855;
                                int64_t defunc_0_lifted_step_res_f_res_125856;
                                int64_t defunc_0_lifted_step_res_f_res_125857;
                                int64_t defunc_0_lifted_step_res_f_res_125858;
                                
                                if (cond_125854) {
                                    int64_t tmp_128023 = add64(ss_125841, count_125845);
                                    
                                    defunc_0_lifted_step_res_f_res_125855 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125856 = tt_125843;
                                    defunc_0_lifted_step_res_f_res_125857 = tt_125844;
                                    defunc_0_lifted_step_res_f_res_125858 = (int64_t) 0;
                                } else {
                                    bool cond_125860 = count_125845 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125861;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125862;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125863;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125864;
                                    
                                    if (cond_125860) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125841);
                                        bool y_128026 = slt64(ss_125841, stride_125674);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125841, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:143:35-39\n   #13 ftRelational.fut:142:9-143:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125843);
                                        bool y_128032 = slt64(tt_125843, j_m_i_125697);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125843, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:143:35-39\n   #13 ftRelational.fut:142:9-143:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125747 + ss_125841;
                                        double leq_arg1_128030 = ((double *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125674 + tt_125843;
                                        int64_t slice_128036 = start_125747 + slice_128035;
                                        double leq_arg0_128037 = ((double *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = leq_arg0_128037 <= leq_arg1_128030;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125843);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125841;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125841);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125843;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = tt_125844;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = (int64_t) 0;
                                    } else {
                                        int64_t m_125883 = sdiv64(count_125845, (int64_t) 2);
                                        int64_t n_125884 = sub64(count_125845, m_125883);
                                        bool cond_125885 = n_125884 == (int64_t) 0;
                                        int64_t zgze_lhs_125886 = add64(ss_125841, m_125883);
                                        bool cond_f_res_125887 = sle64(ss_125842, zgze_lhs_125886);
                                        bool x_125888 = !cond_125885;
                                        bool y_125889 = cond_f_res_125887 && x_125888;
                                        bool cond_125890 = cond_125885 || y_125889;
                                        bool leq_y_x_125891;
                                        
                                        if (cond_125890) {
                                            leq_y_x_125891 = 1;
                                        } else {
                                            bool x_125892 = sle64((int64_t) 0, zgze_lhs_125886);
                                            bool y_125893 = slt64(zgze_lhs_125886, stride_125674);
                                            bool bounds_check_125894 = x_125892 && y_125893;
                                            bool index_certs_125895;
                                            
                                            if (!bounds_check_125894) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125886, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:143:35-39\n   #13 ftRelational.fut:142:9-143:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125898 = add64(tt_125843, n_125884);
                                            int64_t leq_arg0_125899 = sub64(zm_lhs_125898, (int64_t) 1);
                                            bool x_125900 = sle64((int64_t) 0, leq_arg0_125899);
                                            bool y_125901 = slt64(leq_arg0_125899, j_m_i_125697);
                                            bool bounds_check_125902 = x_125900 && y_125901;
                                            bool index_certs_125903;
                                            
                                            if (!bounds_check_125902) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125899, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:143:35-39\n   #13 ftRelational.fut:142:9-143:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125896 = start_125747 + zgze_lhs_125886;
                                            double leq_arg1_125897 = ((double *) mem_param_133548.mem)[slice_125896];
                                            int64_t slice_125904 = stride_125674 + leq_arg0_125899;
                                            int64_t slice_125905 = start_125747 + slice_125904;
                                            double leq_arg0_125906 = ((double *) mem_param_133548.mem)[slice_125905];
                                            bool defunc_0_leq_res_125907 = leq_arg0_125906 <= leq_arg1_125897;
                                            
                                            leq_y_x_125891 = defunc_0_leq_res_125907;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                        
                                        if (leq_y_x_125891) {
                                            int64_t tmp_128043 = add64(tt_125843, n_125884);
                                            int64_t tmp_128044 = sub64(count_125845, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tt_125844;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = tmp_128044;
                                        } else {
                                            int64_t tmp_125913 = add64(tt_125843, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tt_125843;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tmp_125913;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = count_125845;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = ss_125841;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                    }
                                    defunc_0_lifted_step_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_125861;
                                    defunc_0_lifted_step_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_125862;
                                    defunc_0_lifted_step_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_125863;
                                    defunc_0_lifted_step_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_125864;
                                }
                                defunc_0_lifted_step_res_125848 = defunc_0_lifted_step_res_f_res_125855;
                                defunc_0_lifted_step_res_125849 = defunc_0_lifted_step_res_f_res_125856;
                                defunc_0_lifted_step_res_125850 = defunc_0_lifted_step_res_f_res_125857;
                                defunc_0_lifted_step_res_125851 = defunc_0_lifted_step_res_f_res_125858;
                            }
                            
                            int64_t loopres_125914;
                            int64_t loopres_125915;
                            int64_t loopres_125916;
                            int64_t loopres_125917;
                            int64_t loopres_125918;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125914, &loopres_125915, &loopres_125916, &loopres_125917, &loopres_125918, defunc_0_lifted_step_res_125848, ss_125842, defunc_0_lifted_step_res_125849, defunc_0_lifted_step_res_125850, defunc_0_lifted_step_res_125851) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125919 = slt64((int64_t) 0, loopres_125918);
                            bool loop_while_tmp_133911 = loop_cond_125919;
                            int64_t ss_tmp_133912 = loopres_125914;
                            int64_t ss_tmp_133913 = loopres_125915;
                            int64_t tt_tmp_133914 = loopres_125916;
                            int64_t tt_tmp_133915 = loopres_125917;
                            int64_t count_tmp_133916 = loopres_125918;
                            
                            loop_while_125840 = loop_while_tmp_133911;
                            ss_125841 = ss_tmp_133912;
                            ss_125842 = ss_tmp_133913;
                            tt_125843 = tt_tmp_133914;
                            tt_125844 = tt_tmp_133915;
                            count_125845 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125834 = loop_while_125840;
                        defunc_0_split_count_res_125835 = ss_125841;
                        defunc_0_split_count_res_125836 = ss_125842;
                        defunc_0_split_count_res_125837 = tt_125843;
                        defunc_0_split_count_res_125838 = tt_125844;
                        defunc_0_split_count_res_125839 = count_125845;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125835;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125837;
                    }
                    if (mem_133584_cached_sizze_134124 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134124, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134125 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134125, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125695; i_133326++) {
                        bool y_125925 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool index_certs_125927;
                        
                        if (!y_125925) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:143:35-39\n   #10 ftRelational.fut:142:9-143:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125928 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125930 = add64((int64_t) 1, i_133326);
                        bool x_125931 = sle64((int64_t) 0, tmp_125930);
                        bool y_125932 = slt64(tmp_125930, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool bounds_check_125933 = x_125931 && y_125932;
                        bool index_certs_125934;
                        
                        if (!bounds_check_125933) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125930, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:143:35-39\n   #10 ftRelational.fut:142:9-143:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125935 = ((int64_t *) mem_133567)[tmp_125930];
                        int64_t defunc_0_f_res_125936 = ((int64_t *) mem_133569)[tmp_125930];
                        int64_t merge_sequential_arg2_125937 = add64(stride_125674, defunc_0_f_res_125929);
                        int64_t merge_sequential_arg2_125938 = add64(stride_125674, defunc_0_f_res_125936);
                        int64_t j_m_i_125939 = sub64(merge_sequential_arg2_125938, merge_sequential_arg2_125937);
                        bool empty_slice_125940 = j_m_i_125939 == (int64_t) 0;
                        int64_t m_125941 = sub64(j_m_i_125939, (int64_t) 1);
                        int64_t i_p_m_t_s_125942 = add64(merge_sequential_arg2_125937, m_125941);
                        bool zzero_leq_i_p_m_t_s_125943 = sle64((int64_t) 0, i_p_m_t_s_125942);
                        bool i_p_m_t_s_leq_w_125944 = slt64(i_p_m_t_s_125942, next_stride_125675);
                        bool zzero_lte_i_125945 = sle64((int64_t) 0, merge_sequential_arg2_125937);
                        bool i_lte_j_125946 = sle64(merge_sequential_arg2_125937, merge_sequential_arg2_125938);
                        bool y_125947 = i_p_m_t_s_leq_w_125944 && zzero_lte_i_125945;
                        bool y_125948 = zzero_leq_i_p_m_t_s_125943 && y_125947;
                        bool forwards_ok_125949 = i_lte_j_125946 && y_125948;
                        bool ok_or_empty_125950 = empty_slice_125940 || forwards_ok_125949;
                        bool index_certs_125951;
                        
                        if (!ok_or_empty_125950) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125937, ":", (long long) merge_sequential_arg2_125938, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:143:35-39\n   #10 ftRelational.fut:142:9-143:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125952 = sub64(defunc_0_f_res_125935, defunc_0_f_res_125928);
                        bool empty_slice_125953 = j_m_i_125952 == (int64_t) 0;
                        int64_t m_125954 = sub64(j_m_i_125952, (int64_t) 1);
                        int64_t i_p_m_t_s_125955 = add64(defunc_0_f_res_125928, m_125954);
                        bool zzero_leq_i_p_m_t_s_125956 = sle64((int64_t) 0, i_p_m_t_s_125955);
                        bool i_p_m_t_s_leq_w_125957 = slt64(i_p_m_t_s_125955, next_stride_125675);
                        bool zzero_lte_i_125958 = sle64((int64_t) 0, defunc_0_f_res_125928);
                        bool i_lte_j_125959 = sle64(defunc_0_f_res_125928, defunc_0_f_res_125935);
                        bool y_125960 = i_p_m_t_s_leq_w_125957 && zzero_lte_i_125958;
                        bool y_125961 = zzero_leq_i_p_m_t_s_125956 && y_125960;
                        bool forwards_ok_125962 = i_lte_j_125959 && y_125961;
                        bool ok_or_empty_125963 = empty_slice_125953 || forwards_ok_125962;
                        bool index_certs_125964;
                        
                        if (!ok_or_empty_125963) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125928, ":", (long long) defunc_0_f_res_125935, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:143:35-39\n   #10 ftRelational.fut:142:9-143:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125965 = slt64((int64_t) 0, j_m_i_125952);
                        double dummy_125966;
                        int64_t dummy_125967;
                        
                        if (cond_125965) {
                            bool index_certs_128045;
                            
                            if (!cond_125965) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:143:35-39\n   #12 ftRelational.fut:142:9-143:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125747 + defunc_0_f_res_125928;
                            double head_res_128047 = ((double *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125966 = head_res_128047;
                            dummy_125967 = head_res_128048;
                        } else {
                            bool y_125972 = slt64((int64_t) 0, j_m_i_125939);
                            bool index_certs_125973;
                            
                            if (!y_125972) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:143:35-39\n   #12 ftRelational.fut:142:9-143:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125974 = start_125747 + merge_sequential_arg2_125937;
                            double head_res_125975 = ((double *) mem_param_133548.mem)[slice_125974];
                            int64_t head_res_125976 = ((int64_t *) mem_param_133551.mem)[slice_125974];
                            
                            dummy_125966 = head_res_125975;
                            dummy_125967 = head_res_125976;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125560; nest_i_133919++) {
                            ((double *) mem_133584)[i_133326 * merge_block_sizze_125560 + nest_i_133919] = dummy_125966;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125560; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + nest_i_133920] = dummy_125967;
                        }
                        
                        int64_t data_125979;
                        int64_t i_125983 = (int64_t) 0;
                        
                        for (int64_t k_125982 = 0; k_125982 < merge_block_sizze_125560; k_125982++) {
                            int64_t j_125986 = sub64(k_125982, i_125983);
                            bool cond_125987 = j_125986 == j_m_i_125939;
                            bool cond_125988;
                            
                            if (cond_125987) {
                                cond_125988 = 1;
                            } else {
                                bool cond_125989 = slt64(i_125983, j_m_i_125952);
                                bool cond_f_res_125990;
                                
                                if (cond_125989) {
                                    bool x_128049 = sle64((int64_t) 0, j_125986);
                                    bool y_128050 = slt64(j_125986, j_m_i_125939);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:143:35-39\n   #11 ftRelational.fut:142:9-143:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125983);
                                    bool bounds_check_128057 = cond_125989 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:143:35-39\n   #11 ftRelational.fut:142:9-143:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125937 + j_125986;
                                    int64_t slice_128054 = start_125747 + slice_128053;
                                    double leq_arg1_128055 = ((double *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125928 + i_125983;
                                    int64_t slice_128060 = start_125747 + slice_128059;
                                    double leq_arg0_128061 = ((double *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = leq_arg0_128061 <= leq_arg1_128055;
                                    
                                    cond_f_res_125990 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125990 = 0;
                                }
                                cond_125988 = cond_f_res_125990;
                            }
                            
                            int64_t loopres_126005;
                            double loopres_126006;
                            int64_t loopres_126007;
                            
                            if (cond_125988) {
                                bool x_128064 = sle64((int64_t) 0, i_125983);
                                bool y_128065 = slt64(i_125983, j_m_i_125952);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:143:35-39\n   #11 ftRelational.fut:142:9-143:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125983);
                                int64_t slice_128068 = defunc_0_f_res_125928 + i_125983;
                                int64_t slice_128069 = start_125747 + slice_128068;
                                double tmp_128070 = ((double *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_126005 = tmp_128063;
                                loopres_126006 = tmp_128070;
                                loopres_126007 = tmp_128071;
                            } else {
                                bool x_126017 = sle64((int64_t) 0, j_125986);
                                bool y_126018 = slt64(j_125986, j_m_i_125939);
                                bool bounds_check_126019 = x_126017 && y_126018;
                                bool index_certs_126020;
                                
                                if (!bounds_check_126019) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:143:35-39\n   #11 ftRelational.fut:142:9-143:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126021 = merge_sequential_arg2_125937 + j_125986;
                                int64_t slice_126022 = start_125747 + slice_126021;
                                double tmp_126023 = ((double *) mem_param_133548.mem)[slice_126022];
                                int64_t tmp_126024 = ((int64_t *) mem_param_133551.mem)[slice_126022];
                                
                                loopres_126005 = i_125983;
                                loopres_126006 = tmp_126023;
                                loopres_126007 = tmp_126024;
                            }
                            ((double *) mem_133584)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126006;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126007;
                            
                            int64_t i_tmp_133921 = loopres_126005;
                            
                            i_125983 = i_tmp_133921;
                        }
                        data_125979 = i_125983;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint64_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133583, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133554, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126031 = next_stride_125675 * num_merges_125679;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint64_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            if (memblock_alloc(ctx, &mem_133664, bytes_133553, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            
            bool loop_cond_126034 = slt64(next_stride_125675, flat_dim_125556);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126031;
            bool loop_while_tmp_133898 = loop_cond_126034;
            int64_t stride_tmp_133901 = next_stride_125675;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125670 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125671 = loop_while_tmp_133898;
            stride_125674 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125665 = loop_dz2084Uz2082U_125670;
        data_125666 = loop_while_125671;
        data_125669 = stride_125674;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126035 = n_98615 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126036 = sle64((int64_t) 0, zs_lhs_125540);
        bool i_p_m_t_s_leq_w_126037 = slt64(zs_lhs_125540, data_125665);
        bool y_126038 = zzero_leq_i_p_m_t_s_126036 && i_p_m_t_s_leq_w_126037;
        bool ok_or_empty_126039 = empty_slice_126035 || y_126038;
        bool index_certs_126040;
        
        if (!ok_or_empty_126039) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_98615, "] out of bounds for array of shape [", (long long) data_125665, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:143:35-39\n   #6  ftRelational.fut:142:9-143:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133468, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133468, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_98615; i_133340++) {
        int64_t eta_p_126048 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126049 = sle64((int64_t) 0, eta_p_126048);
        bool y_126050 = slt64(eta_p_126048, n_98615);
        bool bounds_check_126051 = x_126049 && y_126050;
        bool index_certs_126052;
        
        if (!bounds_check_126051) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126048, "] out of bounds for array of shape [", (long long) n_98615, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:143:35-39\n   #5  ftRelational.fut:142:9-143:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t lifted_lambda_res_126053 = ((int64_t *) ext_mem_133467.mem)[eta_p_126048];
        double lifted_lambda_res_126054 = ((double *) xs_mem_133466.mem)[eta_p_126048];
        
        ((int64_t *) mem_133676.mem)[i_133340] = lifted_lambda_res_126053;
        ((double *) mem_133678.mem)[i_133340] = lifted_lambda_res_126054;
    }
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134114, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134115, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_float(struct futhark_context *ctx, struct memblock *mem_out_p_134126, struct memblock *mem_out_p_134127, struct memblock xs_mem_133466, int64_t n_96470, int64_t incr_96471)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134128 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134129 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134130 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134131 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134132 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134133 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134134 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134135 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134136 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134137 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_96470;
    bool cond_125539 = sle64(n_96470, (int64_t) 1);
    int64_t zs_lhs_125540 = sub64(n_96470, (int64_t) 1);
    int64_t zp_rhs_125541 = sdiv_safe64(zs_lhs_125540, (int64_t) 20);
    int64_t min_num_blocks_125542 = add64((int64_t) 1, zp_rhs_125541);
    bool loop_cond_125543 = slt64((int64_t) 1, min_num_blocks_125542);
    bool smallest_pow_2_geq_than_res_125544;
    int64_t smallest_pow_2_geq_than_res_125545;
    bool loop_while_125546;
    int64_t x_125547;
    
    loop_while_125546 = loop_cond_125543;
    x_125547 = (int64_t) 1;
    while (loop_while_125546) {
        int64_t loopres_125548 = mul64((int64_t) 2, x_125547);
        bool loop_cond_125549 = slt64(loopres_125548, min_num_blocks_125542);
        bool loop_while_tmp_133879 = loop_cond_125549;
        int64_t x_tmp_133880 = loopres_125548;
        
        loop_while_125546 = loop_while_tmp_133879;
        x_125547 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125544 = loop_while_125546;
    smallest_pow_2_geq_than_res_125545 = x_125547;
    
    bool zzero_125550 = smallest_pow_2_geq_than_res_125545 == (int64_t) 0;
    bool nonzzero_125551 = !zzero_125550;
    bool protect_assert_disj_125552 = cond_125539 || nonzzero_125551;
    bool nonzzero_cert_125553;
    
    if (!protect_assert_disj_125552) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:141:35-39\n   #5  ftRelational.fut:140:9-141:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125554 = sdiv_safe64(zs_lhs_125540, smallest_pow_2_geq_than_res_125545);
    int64_t block_sizze_125555 = add64((int64_t) 1, zp_rhs_125554);
    bool y_125561 = slt64((int64_t) 0, n_96470);
    bool protect_assert_disj_133752 = cond_125539 || y_125561;
    bool index_certs_125562;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_96470, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:141:35-39\n   #5  ftRelational.fut:140:9-141:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125576 = slt64(smallest_pow_2_geq_than_res_125545, (int64_t) 0);
    bool valid_125577 = !bounds_invalid_upwards_125576;
    bool protect_assert_disj_133760 = cond_125539 || valid_125577;
    bool range_valid_c_125578;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125545, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:141:35-39\n   #6  ftRelational.fut:140:9-141:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125580 = slt64(block_sizze_125555, (int64_t) 0);
    bool valid_125581 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_133762 = cond_125539 || valid_125581;
    bool range_valid_c_125582;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125555, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125584 = sle64(block_sizze_125555, (int64_t) 1);
    int64_t tmp_125585 = sub64(block_sizze_125555, (int64_t) 2);
    bool bounds_invalid_upwards_125586 = slt64(tmp_125585, (int64_t) 0);
    bool valid_125588 = !bounds_invalid_upwards_125586;
    bool protect_assert_disj_125589 = cond_125584 || valid_125588;
    bool protect_assert_disj_133764 = cond_125539 || protect_assert_disj_125589;
    bool range_valid_c_125590;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125585, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133677 = (int64_t) 4 * n_96470;
    
    if (futrts_indicesWithIncrement_11708(ctx, &ext_mem_133467, xs_mem_133466, n_96470, incr_96471) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_96470; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125556 = smallest_pow_2_geq_than_res_125545 * block_sizze_125555;
    bool x_133747 = !cond_125539;
    int64_t greatest_divisor_leq_than_arg1_125559 = mul64((int64_t) 2, block_sizze_125555);
    int64_t merge_block_sizze_125560;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125559) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125560 = x_133749;
    } else {
        merge_block_sizze_125560 = (int64_t) 0;
    }
    
    float reduce_arg1_125563;
    
    if (x_133747) {
        float x_133753 = ((float *) xs_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125563 = x_133753;
    } else {
        reduce_arg1_125563 = 0.0F;
    }
    
    float defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        float x_133755;
        int64_t x_133756;
        float redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125563;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_96470; i_133300++) {
            float x_125567 = ((float *) xs_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125573 = redout_133298 <= x_125567;
            float defunc_0_op_res_125574;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125574 = x_125567;
            } else {
                defunc_0_op_res_125574 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125575;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125575 = i_133300;
            } else {
                defunc_0_op_res_125575 = redout_133299;
            }
            
            float redout_tmp_133883 = defunc_0_op_res_125574;
            int64_t redout_tmp_133884 = defunc_0_op_res_125575;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = 0.0F;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125587 = add64((int64_t) 1, tmp_125585);
    int64_t binop_x_133470 = (int64_t) 4 * smallest_pow_2_geq_than_res_125545;
    int64_t bytes_133471 = block_sizze_125555 * binop_x_133470;
    int64_t binop_x_133473 = (int64_t) 8 * smallest_pow_2_geq_than_res_125545;
    int64_t bytes_133474 = block_sizze_125555 * binop_x_133473;
    int64_t bytes_133484 = (int64_t) 4 * block_sizze_125555;
    int64_t bytes_133486 = (int64_t) 8 * block_sizze_125555;
    bool loop_cond_125662 = slt64(block_sizze_125555, flat_dim_125556);
    bool zzero_125663 = merge_block_sizze_125560 == (int64_t) 0;
    bool nonzzero_125664 = !zzero_125663;
    
    if (cond_125539) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134128 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134128, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134129 < bytes_133474) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134129, bytes_133474);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134130 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134130, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134131 < bytes_133486) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134131, bytes_133486);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125545; i_133312++) {
            int64_t zp_lhs_125594 = mul64(block_sizze_125555, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125555; i_133305++) {
                int64_t k_125598 = add64(zp_lhs_125594, i_133305);
                bool cond_125599 = slt64(k_125598, n_96470);
                float lifted_lambda_res_125600;
                int64_t lifted_lambda_res_125601;
                
                if (cond_125599) {
                    bool x_127931 = sle64((int64_t) 0, k_125598);
                    bool bounds_check_127932 = cond_125599 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125598, "] out of bounds for array of shape [", (long long) n_96470, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:141:35-39\n   #9  ftRelational.fut:140:9-141:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    float lifted_lambda_res_t_res_127934 = ((float *) xs_mem_133466.mem)[k_125598];
                    
                    lifted_lambda_res_125600 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125601 = k_125598;
                } else {
                    lifted_lambda_res_125600 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125601 = defunc_0_reduce_res_128079;
                }
                ((float *) mem_133485)[i_133305] = lifted_lambda_res_125600;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125601;
            }
            if (!cond_125584) {
                for (int64_t i_125611 = 0; i_125611 < distance_125587; i_125611++) {
                    int64_t gt_arg1_125614 = add64((int64_t) 1, i_125611);
                    bool x_125615 = sle64((int64_t) 0, gt_arg1_125614);
                    bool y_125616 = slt64(gt_arg1_125614, block_sizze_125555);
                    bool bounds_check_125617 = x_125615 && y_125616;
                    bool index_certs_125618;
                    
                    if (!bounds_check_125617) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125614, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125620 = slt64(i_125611, block_sizze_125555);
                    bool index_certs_125621;
                    
                    if (!y_125620) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125611, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    float gt_arg1_125619 = ((float *) mem_133485)[gt_arg1_125614];
                    float gt_arg0_125622 = ((float *) mem_133485)[i_125611];
                    bool defunc_0_leq_res_125623 = gt_arg0_125622 <= gt_arg1_125619;
                    bool defunc_0_lifted_gt_res_125624 = !defunc_0_leq_res_125623;
                    bool s_125625;
                    int64_t s_125628;
                    bool loop_while_125629;
                    int64_t j_125632;
                    
                    loop_while_125629 = defunc_0_lifted_gt_res_125624;
                    j_125632 = i_125611;
                    while (loop_while_125629) {
                        bool x_125633 = sle64((int64_t) 0, j_125632);
                        bool y_125634 = slt64(j_125632, block_sizze_125555);
                        bool bounds_check_125635 = x_125633 && y_125634;
                        bool index_certs_125636;
                        
                        if (!bounds_check_125635) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125632, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125639 = add64((int64_t) 1, j_125632);
                        bool x_125640 = sle64((int64_t) 0, copy_arg0_125639);
                        bool y_125641 = slt64(copy_arg0_125639, block_sizze_125555);
                        bool bounds_check_125642 = x_125640 && y_125641;
                        bool index_certs_125643;
                        
                        if (!bounds_check_125642) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125639, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        float copy_arg0_125637 = ((float *) mem_133485)[j_125632];
                        int64_t copy_arg0_125638 = ((int64_t *) mem_133487)[j_125632];
                        float copy_arg0_125644 = ((float *) mem_133485)[copy_arg0_125639];
                        int64_t copy_arg0_125645 = ((int64_t *) mem_133487)[copy_arg0_125639];
                        
                        ((float *) mem_133485)[j_125632] = copy_arg0_125644;
                        ((int64_t *) mem_133487)[j_125632] = copy_arg0_125645;
                        ((float *) mem_133485)[copy_arg0_125639] = copy_arg0_125637;
                        ((int64_t *) mem_133487)[copy_arg0_125639] = copy_arg0_125638;
                        
                        int64_t tmp_125650 = sub64(j_125632, (int64_t) 1);
                        bool cond_125651 = sle64((int64_t) 0, tmp_125650);
                        bool loop_cond_125652;
                        
                        if (cond_125651) {
                            bool y_127936 = slt64(tmp_125650, block_sizze_125555);
                            bool bounds_check_127937 = cond_125651 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125650, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            float gt_arg1_127935 = ((float *) mem_133485)[j_125632];
                            float gt_arg0_127939 = ((float *) mem_133485)[tmp_125650];
                            bool defunc_0_leq_res_127940 = gt_arg0_127939 <= gt_arg1_127935;
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125652 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125652 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125652;
                        int64_t j_tmp_133894 = tmp_125650;
                        
                        loop_while_125629 = loop_while_tmp_133891;
                        j_125632 = j_tmp_133894;
                    }
                    s_125625 = loop_while_125629;
                    s_125628 = j_125632;
                }
            }
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133472, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_4b(ctx, 2, (uint32_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint32_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        if (memblock_alloc(ctx, &mem_133544, bytes_133474, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        
        int64_t data_125665;
        bool data_125666;
        int64_t data_125669;
        int64_t loop_dz2084Uz2082U_125670;
        bool loop_while_125671;
        int64_t stride_125674;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125670 = flat_dim_125556;
        loop_while_125671 = loop_cond_125662;
        stride_125674 = block_sizze_125555;
        while (loop_while_125671) {
            int64_t next_stride_125675 = mul64((int64_t) 2, stride_125674);
            bool zzero_125676 = next_stride_125675 == (int64_t) 0;
            bool nonzzero_125677 = !zzero_125676;
            bool nonzzero_cert_125678;
            
            if (!nonzzero_125677) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:141:35-39\n   #5  ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125679 = sdiv64(flat_dim_125556, next_stride_125675);
            bool bounds_invalid_upwards_125680 = slt64(num_merges_125679, (int64_t) 0);
            bool valid_125681 = !bounds_invalid_upwards_125680;
            bool range_valid_c_125682;
            
            if (!valid_125681) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125679, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:141:35-39\n   #6  ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125684 = sub64(next_stride_125675, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125685 = sle64((int64_t) 0, m_125684);
            bool cond_125687 = slt64(next_stride_125675, (int64_t) 10);
            bool protect_assert_disj_125688 = nonzzero_125664 || cond_125687;
            bool nonzzero_cert_125689;
            
            if (!protect_assert_disj_125688) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125690 = smod_safe64(next_stride_125675, merge_block_sizze_125560);
            bool num_blocks_125691 = zeze_lhs_125690 == (int64_t) 0;
            bool protect_assert_disj_125692 = cond_125687 || num_blocks_125691;
            bool assert_c_125693;
            
            if (!protect_assert_disj_125692) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125695 = sdiv_safe64(next_stride_125675, merge_block_sizze_125560);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696 = add64((int64_t) 1, num_blocks_125695);
            int64_t j_m_i_125697 = sub64(next_stride_125675, stride_125674);
            int64_t flat_dim_125698 = merge_block_sizze_125560 * num_blocks_125695;
            bool bounds_invalid_upwards_125699 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, (int64_t) 0);
            bool empty_slice_125700 = j_m_i_125697 == (int64_t) 0;
            int64_t m_125701 = sub64(j_m_i_125697, (int64_t) 1);
            bool zzero_lte_i_125702 = sle64((int64_t) 0, stride_125674);
            bool i_lte_j_125703 = sle64(stride_125674, next_stride_125675);
            bool empty_slice_125704 = stride_125674 == (int64_t) 0;
            int64_t m_125705 = sub64(stride_125674, (int64_t) 1);
            bool bounds_invalid_upwards_125706 = slt64(num_blocks_125695, (int64_t) 0);
            bool cond_125707 = slt64((int64_t) 0, stride_125674);
            bool valid_125708 = !bounds_invalid_upwards_125699;
            int64_t i_p_m_t_s_125709 = add64(stride_125674, m_125701);
            bool zzero_leq_i_p_m_t_s_125710 = sle64((int64_t) 0, m_125705);
            bool i_p_m_t_s_leq_w_125711 = slt64(m_125705, next_stride_125675);
            bool valid_125712 = !bounds_invalid_upwards_125706;
            bool i_p_m_t_s_leq_w_125713 = slt64(m_125684, flat_dim_125698);
            bool y_125714 = slt64((int64_t) 0, j_m_i_125697);
            bool protect_assert_disj_125715 = cond_125687 || valid_125708;
            bool range_valid_c_125716;
            
            if (!protect_assert_disj_125715) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:141:35-39\n   #10 ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125717 = sle64((int64_t) 0, i_p_m_t_s_125709);
            bool i_p_m_t_s_leq_w_125718 = slt64(i_p_m_t_s_125709, next_stride_125675);
            bool y_125719 = zzero_leq_i_p_m_t_s_125710 && i_p_m_t_s_leq_w_125711;
            bool protect_assert_disj_125720 = cond_125687 || valid_125712;
            bool range_valid_c_125721;
            
            if (!protect_assert_disj_125720) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125695, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:141:35-39\n   #9  ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125722 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125713;
            bool y_125723 = zzero_lte_i_125702 && i_p_m_t_s_leq_w_125718;
            bool forwards_ok_125724 = zzero_lte_i_125702 && y_125719;
            bool ok_or_empty_125725 = zzero_125676 || y_125722;
            bool protect_assert_disj_125726 = cond_125707 || y_125714;
            bool y_125727 = zzero_leq_i_p_m_t_s_125717 && y_125723;
            bool ok_or_empty_125728 = empty_slice_125704 || forwards_ok_125724;
            bool protect_assert_disj_125729 = cond_125687 || ok_or_empty_125725;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) flat_dim_125698, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:141:35-39\n   #9  ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125731 = !cond_125687;
            bool protect_assert_disj_125732 = protect_assert_disj_125726 || loop_not_taken_125731;
            bool index_certs_125733;
            
            if (!protect_assert_disj_125732) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:141:35-39\n   #10 ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125734 = i_lte_j_125703 && y_125727;
            bool protect_assert_disj_125735 = cond_125687 || ok_or_empty_125728;
            bool index_certs_125736;
            
            if (!protect_assert_disj_125735) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:141:35-39\n   #11 ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125737 = ok_or_empty_125728 || loop_not_taken_125731;
            bool index_certs_125738;
            
            if (!protect_assert_disj_125737) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125739 = empty_slice_125700 || forwards_ok_125734;
            bool protect_assert_disj_125740 = cond_125687 || ok_or_empty_125739;
            bool index_certs_125741;
            
            if (!protect_assert_disj_125740) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:141:35-39\n   #11 ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125742 = loop_not_taken_125731 || ok_or_empty_125739;
            bool index_certs_125743;
            
            if (!protect_assert_disj_125742) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 4 * num_merges_125679;
            int64_t bytes_133553 = next_stride_125675 * binop_x_133552;
            int64_t binop_x_133555 = (int64_t) 8 * num_merges_125679;
            int64_t bytes_133556 = next_stride_125675 * binop_x_133555;
            bool i_lte_j_125686 = sle64((int64_t) 0, next_stride_125675);
            
            if (mem_133554_cached_sizze_134132 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134132, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134133 < bytes_133556) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134133, bytes_133556);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696;
            int64_t binop_x_133582 = (int64_t) 4 * num_blocks_125695;
            int64_t bytes_133583 = merge_block_sizze_125560 * binop_x_133582;
            int64_t binop_x_133585 = (int64_t) 8 * num_blocks_125695;
            int64_t bytes_133586 = merge_block_sizze_125560 * binop_x_133585;
            int64_t bytes_133628 = (int64_t) 8 * stride_125674;
            int64_t bytes_133630 = (int64_t) 16 * stride_125674;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125679; i_133333++) {
                int64_t start_125747 = mul64(next_stride_125675, i_133333);
                int64_t j_m_i_125748 = sub64(loop_dz2084Uz2082U_125670, start_125747);
                bool empty_slice_125749 = j_m_i_125748 == (int64_t) 0;
                int64_t m_125750 = sub64(j_m_i_125748, (int64_t) 1);
                int64_t i_p_m_t_s_125751 = add64(start_125747, m_125750);
                bool zzero_leq_i_p_m_t_s_125752 = sle64((int64_t) 0, i_p_m_t_s_125751);
                bool i_p_m_t_s_leq_w_125753 = slt64(i_p_m_t_s_125751, loop_dz2084Uz2082U_125670);
                bool zzero_lte_i_125754 = sle64((int64_t) 0, start_125747);
                bool i_lte_j_125755 = sle64(start_125747, loop_dz2084Uz2082U_125670);
                bool y_125756 = i_p_m_t_s_leq_w_125753 && zzero_lte_i_125754;
                bool y_125757 = zzero_leq_i_p_m_t_s_125752 && y_125756;
                bool forwards_ok_125758 = i_lte_j_125755 && y_125757;
                bool ok_or_empty_125759 = empty_slice_125749 || forwards_ok_125758;
                bool index_certs_125760;
                
                if (!ok_or_empty_125759) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125747, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125670, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125761 = slt64(m_125684, j_m_i_125748);
                bool y_125762 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125761;
                bool forwards_ok_125763 = i_lte_j_125686 && y_125762;
                bool ok_or_empty_125764 = zzero_125676 || forwards_ok_125763;
                bool index_certs_125765;
                
                if (!ok_or_empty_125764) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) j_m_i_125748, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:141:35-39\n   #8  ftRelational.fut:140:9-141:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125687) {
                    float dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125707) {
                        float head_res_127969 = ((float *) mem_param_133548.mem)[start_125747];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125747];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125674 + start_125747;
                        float head_res_127972 = ((float *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125675; nest_i_133904++) {
                        ((float *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133630, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125675; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125675; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125697;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125674);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125697);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:141:35-39\n   #9  ftRelational.fut:140:9-141:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:141:35-39\n   #9  ftRelational.fut:140:9-141:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125674 + j_127983;
                                int64_t slice_127993 = start_125747 + slice_127992;
                                float leq_arg1_127994 = ((float *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125747 + i_127980;
                                float leq_arg0_127999 = ((float *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = leq_arg0_127999 <= leq_arg1_127994;
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        float loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125674);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:141:35-39\n   #9  ftRelational.fut:140:9-141:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125747 + i_127980;
                            float tmp_128010 = ((float *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125697);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:141:35-39\n   #9  ftRelational.fut:140:9-141:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125674 + j_127983;
                            int64_t slice_128017 = start_125747 + slice_128016;
                            float tmp_128018 = ((float *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((float *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134134 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134134, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134135 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134135, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696; i_133319++) {
                        int64_t split_count_arg3_125827 = mul64(merge_block_sizze_125560, i_133319);
                        int64_t defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125828, &defunc_0_split_count_res_125829, &defunc_0_split_count_res_125830, &defunc_0_split_count_res_125831, &defunc_0_split_count_res_125832, (int64_t) 0, stride_125674, (int64_t) 0, j_m_i_125697, split_count_arg3_125827) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125833 = slt64((int64_t) 0, defunc_0_split_count_res_125832);
                        bool defunc_0_split_count_res_125834;
                        int64_t defunc_0_split_count_res_125835;
                        int64_t defunc_0_split_count_res_125836;
                        int64_t defunc_0_split_count_res_125837;
                        int64_t defunc_0_split_count_res_125838;
                        int64_t defunc_0_split_count_res_125839;
                        bool loop_while_125840;
                        int64_t ss_125841;
                        int64_t ss_125842;
                        int64_t tt_125843;
                        int64_t tt_125844;
                        int64_t count_125845;
                        
                        loop_while_125840 = loop_cond_125833;
                        ss_125841 = defunc_0_split_count_res_125828;
                        ss_125842 = defunc_0_split_count_res_125829;
                        tt_125843 = defunc_0_split_count_res_125830;
                        tt_125844 = defunc_0_split_count_res_125831;
                        count_125845 = defunc_0_split_count_res_125832;
                        while (loop_while_125840) {
                            int64_t zlze_lhs_125846 = sub64(ss_125842, ss_125841);
                            bool cond_125847 = sle64(zlze_lhs_125846, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125848;
                            int64_t defunc_0_lifted_step_res_125849;
                            int64_t defunc_0_lifted_step_res_125850;
                            int64_t defunc_0_lifted_step_res_125851;
                            
                            if (cond_125847) {
                                int64_t tmp_128022 = add64(tt_125843, count_125845);
                                
                                defunc_0_lifted_step_res_125848 = ss_125841;
                                defunc_0_lifted_step_res_125849 = tmp_128022;
                                defunc_0_lifted_step_res_125850 = tt_125844;
                                defunc_0_lifted_step_res_125851 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125853 = sub64(tt_125844, tt_125843);
                                bool cond_125854 = sle64(zlze_lhs_125853, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125855;
                                int64_t defunc_0_lifted_step_res_f_res_125856;
                                int64_t defunc_0_lifted_step_res_f_res_125857;
                                int64_t defunc_0_lifted_step_res_f_res_125858;
                                
                                if (cond_125854) {
                                    int64_t tmp_128023 = add64(ss_125841, count_125845);
                                    
                                    defunc_0_lifted_step_res_f_res_125855 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125856 = tt_125843;
                                    defunc_0_lifted_step_res_f_res_125857 = tt_125844;
                                    defunc_0_lifted_step_res_f_res_125858 = (int64_t) 0;
                                } else {
                                    bool cond_125860 = count_125845 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125861;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125862;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125863;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125864;
                                    
                                    if (cond_125860) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125841);
                                        bool y_128026 = slt64(ss_125841, stride_125674);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125841, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:141:35-39\n   #13 ftRelational.fut:140:9-141:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125843);
                                        bool y_128032 = slt64(tt_125843, j_m_i_125697);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125843, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:141:35-39\n   #13 ftRelational.fut:140:9-141:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125747 + ss_125841;
                                        float leq_arg1_128030 = ((float *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125674 + tt_125843;
                                        int64_t slice_128036 = start_125747 + slice_128035;
                                        float leq_arg0_128037 = ((float *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = leq_arg0_128037 <= leq_arg1_128030;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125843);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125841;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125841);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125843;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = tt_125844;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = (int64_t) 0;
                                    } else {
                                        int64_t m_125883 = sdiv64(count_125845, (int64_t) 2);
                                        int64_t n_125884 = sub64(count_125845, m_125883);
                                        bool cond_125885 = n_125884 == (int64_t) 0;
                                        int64_t zgze_lhs_125886 = add64(ss_125841, m_125883);
                                        bool cond_f_res_125887 = sle64(ss_125842, zgze_lhs_125886);
                                        bool x_125888 = !cond_125885;
                                        bool y_125889 = cond_f_res_125887 && x_125888;
                                        bool cond_125890 = cond_125885 || y_125889;
                                        bool leq_y_x_125891;
                                        
                                        if (cond_125890) {
                                            leq_y_x_125891 = 1;
                                        } else {
                                            bool x_125892 = sle64((int64_t) 0, zgze_lhs_125886);
                                            bool y_125893 = slt64(zgze_lhs_125886, stride_125674);
                                            bool bounds_check_125894 = x_125892 && y_125893;
                                            bool index_certs_125895;
                                            
                                            if (!bounds_check_125894) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125886, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:141:35-39\n   #13 ftRelational.fut:140:9-141:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125898 = add64(tt_125843, n_125884);
                                            int64_t leq_arg0_125899 = sub64(zm_lhs_125898, (int64_t) 1);
                                            bool x_125900 = sle64((int64_t) 0, leq_arg0_125899);
                                            bool y_125901 = slt64(leq_arg0_125899, j_m_i_125697);
                                            bool bounds_check_125902 = x_125900 && y_125901;
                                            bool index_certs_125903;
                                            
                                            if (!bounds_check_125902) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125899, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:141:35-39\n   #13 ftRelational.fut:140:9-141:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125896 = start_125747 + zgze_lhs_125886;
                                            float leq_arg1_125897 = ((float *) mem_param_133548.mem)[slice_125896];
                                            int64_t slice_125904 = stride_125674 + leq_arg0_125899;
                                            int64_t slice_125905 = start_125747 + slice_125904;
                                            float leq_arg0_125906 = ((float *) mem_param_133548.mem)[slice_125905];
                                            bool defunc_0_leq_res_125907 = leq_arg0_125906 <= leq_arg1_125897;
                                            
                                            leq_y_x_125891 = defunc_0_leq_res_125907;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                        
                                        if (leq_y_x_125891) {
                                            int64_t tmp_128043 = add64(tt_125843, n_125884);
                                            int64_t tmp_128044 = sub64(count_125845, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tt_125844;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = tmp_128044;
                                        } else {
                                            int64_t tmp_125913 = add64(tt_125843, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tt_125843;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tmp_125913;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = count_125845;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = ss_125841;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                    }
                                    defunc_0_lifted_step_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_125861;
                                    defunc_0_lifted_step_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_125862;
                                    defunc_0_lifted_step_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_125863;
                                    defunc_0_lifted_step_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_125864;
                                }
                                defunc_0_lifted_step_res_125848 = defunc_0_lifted_step_res_f_res_125855;
                                defunc_0_lifted_step_res_125849 = defunc_0_lifted_step_res_f_res_125856;
                                defunc_0_lifted_step_res_125850 = defunc_0_lifted_step_res_f_res_125857;
                                defunc_0_lifted_step_res_125851 = defunc_0_lifted_step_res_f_res_125858;
                            }
                            
                            int64_t loopres_125914;
                            int64_t loopres_125915;
                            int64_t loopres_125916;
                            int64_t loopres_125917;
                            int64_t loopres_125918;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125914, &loopres_125915, &loopres_125916, &loopres_125917, &loopres_125918, defunc_0_lifted_step_res_125848, ss_125842, defunc_0_lifted_step_res_125849, defunc_0_lifted_step_res_125850, defunc_0_lifted_step_res_125851) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125919 = slt64((int64_t) 0, loopres_125918);
                            bool loop_while_tmp_133911 = loop_cond_125919;
                            int64_t ss_tmp_133912 = loopres_125914;
                            int64_t ss_tmp_133913 = loopres_125915;
                            int64_t tt_tmp_133914 = loopres_125916;
                            int64_t tt_tmp_133915 = loopres_125917;
                            int64_t count_tmp_133916 = loopres_125918;
                            
                            loop_while_125840 = loop_while_tmp_133911;
                            ss_125841 = ss_tmp_133912;
                            ss_125842 = ss_tmp_133913;
                            tt_125843 = tt_tmp_133914;
                            tt_125844 = tt_tmp_133915;
                            count_125845 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125834 = loop_while_125840;
                        defunc_0_split_count_res_125835 = ss_125841;
                        defunc_0_split_count_res_125836 = ss_125842;
                        defunc_0_split_count_res_125837 = tt_125843;
                        defunc_0_split_count_res_125838 = tt_125844;
                        defunc_0_split_count_res_125839 = count_125845;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125835;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125837;
                    }
                    if (mem_133584_cached_sizze_134136 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134136, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134137 < bytes_133586) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134137, bytes_133586);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125695; i_133326++) {
                        bool y_125925 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool index_certs_125927;
                        
                        if (!y_125925) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:141:35-39\n   #10 ftRelational.fut:140:9-141:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125928 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125930 = add64((int64_t) 1, i_133326);
                        bool x_125931 = sle64((int64_t) 0, tmp_125930);
                        bool y_125932 = slt64(tmp_125930, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool bounds_check_125933 = x_125931 && y_125932;
                        bool index_certs_125934;
                        
                        if (!bounds_check_125933) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125930, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:141:35-39\n   #10 ftRelational.fut:140:9-141:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125935 = ((int64_t *) mem_133567)[tmp_125930];
                        int64_t defunc_0_f_res_125936 = ((int64_t *) mem_133569)[tmp_125930];
                        int64_t merge_sequential_arg2_125937 = add64(stride_125674, defunc_0_f_res_125929);
                        int64_t merge_sequential_arg2_125938 = add64(stride_125674, defunc_0_f_res_125936);
                        int64_t j_m_i_125939 = sub64(merge_sequential_arg2_125938, merge_sequential_arg2_125937);
                        bool empty_slice_125940 = j_m_i_125939 == (int64_t) 0;
                        int64_t m_125941 = sub64(j_m_i_125939, (int64_t) 1);
                        int64_t i_p_m_t_s_125942 = add64(merge_sequential_arg2_125937, m_125941);
                        bool zzero_leq_i_p_m_t_s_125943 = sle64((int64_t) 0, i_p_m_t_s_125942);
                        bool i_p_m_t_s_leq_w_125944 = slt64(i_p_m_t_s_125942, next_stride_125675);
                        bool zzero_lte_i_125945 = sle64((int64_t) 0, merge_sequential_arg2_125937);
                        bool i_lte_j_125946 = sle64(merge_sequential_arg2_125937, merge_sequential_arg2_125938);
                        bool y_125947 = i_p_m_t_s_leq_w_125944 && zzero_lte_i_125945;
                        bool y_125948 = zzero_leq_i_p_m_t_s_125943 && y_125947;
                        bool forwards_ok_125949 = i_lte_j_125946 && y_125948;
                        bool ok_or_empty_125950 = empty_slice_125940 || forwards_ok_125949;
                        bool index_certs_125951;
                        
                        if (!ok_or_empty_125950) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125937, ":", (long long) merge_sequential_arg2_125938, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:141:35-39\n   #10 ftRelational.fut:140:9-141:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125952 = sub64(defunc_0_f_res_125935, defunc_0_f_res_125928);
                        bool empty_slice_125953 = j_m_i_125952 == (int64_t) 0;
                        int64_t m_125954 = sub64(j_m_i_125952, (int64_t) 1);
                        int64_t i_p_m_t_s_125955 = add64(defunc_0_f_res_125928, m_125954);
                        bool zzero_leq_i_p_m_t_s_125956 = sle64((int64_t) 0, i_p_m_t_s_125955);
                        bool i_p_m_t_s_leq_w_125957 = slt64(i_p_m_t_s_125955, next_stride_125675);
                        bool zzero_lte_i_125958 = sle64((int64_t) 0, defunc_0_f_res_125928);
                        bool i_lte_j_125959 = sle64(defunc_0_f_res_125928, defunc_0_f_res_125935);
                        bool y_125960 = i_p_m_t_s_leq_w_125957 && zzero_lte_i_125958;
                        bool y_125961 = zzero_leq_i_p_m_t_s_125956 && y_125960;
                        bool forwards_ok_125962 = i_lte_j_125959 && y_125961;
                        bool ok_or_empty_125963 = empty_slice_125953 || forwards_ok_125962;
                        bool index_certs_125964;
                        
                        if (!ok_or_empty_125963) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125928, ":", (long long) defunc_0_f_res_125935, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:141:35-39\n   #10 ftRelational.fut:140:9-141:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125965 = slt64((int64_t) 0, j_m_i_125952);
                        float dummy_125966;
                        int64_t dummy_125967;
                        
                        if (cond_125965) {
                            bool index_certs_128045;
                            
                            if (!cond_125965) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:141:35-39\n   #12 ftRelational.fut:140:9-141:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125747 + defunc_0_f_res_125928;
                            float head_res_128047 = ((float *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125966 = head_res_128047;
                            dummy_125967 = head_res_128048;
                        } else {
                            bool y_125972 = slt64((int64_t) 0, j_m_i_125939);
                            bool index_certs_125973;
                            
                            if (!y_125972) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:141:35-39\n   #12 ftRelational.fut:140:9-141:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125974 = start_125747 + merge_sequential_arg2_125937;
                            float head_res_125975 = ((float *) mem_param_133548.mem)[slice_125974];
                            int64_t head_res_125976 = ((int64_t *) mem_param_133551.mem)[slice_125974];
                            
                            dummy_125966 = head_res_125975;
                            dummy_125967 = head_res_125976;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125560; nest_i_133919++) {
                            ((float *) mem_133584)[i_133326 * merge_block_sizze_125560 + nest_i_133919] = dummy_125966;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125560; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + nest_i_133920] = dummy_125967;
                        }
                        
                        int64_t data_125979;
                        int64_t i_125983 = (int64_t) 0;
                        
                        for (int64_t k_125982 = 0; k_125982 < merge_block_sizze_125560; k_125982++) {
                            int64_t j_125986 = sub64(k_125982, i_125983);
                            bool cond_125987 = j_125986 == j_m_i_125939;
                            bool cond_125988;
                            
                            if (cond_125987) {
                                cond_125988 = 1;
                            } else {
                                bool cond_125989 = slt64(i_125983, j_m_i_125952);
                                bool cond_f_res_125990;
                                
                                if (cond_125989) {
                                    bool x_128049 = sle64((int64_t) 0, j_125986);
                                    bool y_128050 = slt64(j_125986, j_m_i_125939);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:141:35-39\n   #11 ftRelational.fut:140:9-141:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125983);
                                    bool bounds_check_128057 = cond_125989 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:141:35-39\n   #11 ftRelational.fut:140:9-141:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125937 + j_125986;
                                    int64_t slice_128054 = start_125747 + slice_128053;
                                    float leq_arg1_128055 = ((float *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125928 + i_125983;
                                    int64_t slice_128060 = start_125747 + slice_128059;
                                    float leq_arg0_128061 = ((float *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = leq_arg0_128061 <= leq_arg1_128055;
                                    
                                    cond_f_res_125990 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125990 = 0;
                                }
                                cond_125988 = cond_f_res_125990;
                            }
                            
                            int64_t loopres_126005;
                            float loopres_126006;
                            int64_t loopres_126007;
                            
                            if (cond_125988) {
                                bool x_128064 = sle64((int64_t) 0, i_125983);
                                bool y_128065 = slt64(i_125983, j_m_i_125952);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:141:35-39\n   #11 ftRelational.fut:140:9-141:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125983);
                                int64_t slice_128068 = defunc_0_f_res_125928 + i_125983;
                                int64_t slice_128069 = start_125747 + slice_128068;
                                float tmp_128070 = ((float *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_126005 = tmp_128063;
                                loopres_126006 = tmp_128070;
                                loopres_126007 = tmp_128071;
                            } else {
                                bool x_126017 = sle64((int64_t) 0, j_125986);
                                bool y_126018 = slt64(j_125986, j_m_i_125939);
                                bool bounds_check_126019 = x_126017 && y_126018;
                                bool index_certs_126020;
                                
                                if (!bounds_check_126019) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:141:35-39\n   #11 ftRelational.fut:140:9-141:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126021 = merge_sequential_arg2_125937 + j_125986;
                                int64_t slice_126022 = start_125747 + slice_126021;
                                float tmp_126023 = ((float *) mem_param_133548.mem)[slice_126022];
                                int64_t tmp_126024 = ((int64_t *) mem_param_133551.mem)[slice_126022];
                                
                                loopres_126005 = i_125983;
                                loopres_126006 = tmp_126023;
                                loopres_126007 = tmp_126024;
                            }
                            ((float *) mem_133584)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126006;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126007;
                            
                            int64_t i_tmp_133921 = loopres_126005;
                            
                            i_125983 = i_tmp_133921;
                        }
                        data_125979 = i_125983;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_4b(ctx, 2, (uint32_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint32_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133586, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_4b(ctx, 1, (uint32_t *) mem_133554, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126031 = next_stride_125675 * num_merges_125679;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_4b(ctx, 2, (uint32_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint32_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            if (memblock_alloc(ctx, &mem_133664, bytes_133556, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            
            bool loop_cond_126034 = slt64(next_stride_125675, flat_dim_125556);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126031;
            bool loop_while_tmp_133898 = loop_cond_126034;
            int64_t stride_tmp_133901 = next_stride_125675;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125670 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125671 = loop_while_tmp_133898;
            stride_125674 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125665 = loop_dz2084Uz2082U_125670;
        data_125666 = loop_while_125671;
        data_125669 = stride_125674;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126035 = n_96470 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126036 = sle64((int64_t) 0, zs_lhs_125540);
        bool i_p_m_t_s_leq_w_126037 = slt64(zs_lhs_125540, data_125665);
        bool y_126038 = zzero_leq_i_p_m_t_s_126036 && i_p_m_t_s_leq_w_126037;
        bool ok_or_empty_126039 = empty_slice_126035 || y_126038;
        bool index_certs_126040;
        
        if (!ok_or_empty_126039) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_96470, "] out of bounds for array of shape [", (long long) data_125665, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:141:35-39\n   #6  ftRelational.fut:140:9-141:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133468, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133677, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_96470; i_133340++) {
        int64_t eta_p_126048 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126049 = sle64((int64_t) 0, eta_p_126048);
        bool y_126050 = slt64(eta_p_126048, n_96470);
        bool bounds_check_126051 = x_126049 && y_126050;
        bool index_certs_126052;
        
        if (!bounds_check_126051) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126048, "] out of bounds for array of shape [", (long long) n_96470, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:141:35-39\n   #5  ftRelational.fut:140:9-141:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t lifted_lambda_res_126053 = ((int64_t *) ext_mem_133467.mem)[eta_p_126048];
        float lifted_lambda_res_126054 = ((float *) xs_mem_133466.mem)[eta_p_126048];
        
        ((int64_t *) mem_133676.mem)[i_133340] = lifted_lambda_res_126053;
        ((float *) mem_133678.mem)[i_133340] = lifted_lambda_res_126054;
    }
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134126, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134127, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_int(struct futhark_context *ctx, struct memblock *mem_out_p_134138, struct memblock *mem_out_p_134139, struct memblock xs_mem_133466, int64_t n_92184, int64_t incr_92185)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134140 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134141 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134142 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134143 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134144 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134145 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134146 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134147 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134148 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134149 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_92184;
    bool cond_125539 = sle64(n_92184, (int64_t) 1);
    int64_t zs_lhs_125540 = sub64(n_92184, (int64_t) 1);
    int64_t zp_rhs_125541 = sdiv_safe64(zs_lhs_125540, (int64_t) 20);
    int64_t min_num_blocks_125542 = add64((int64_t) 1, zp_rhs_125541);
    bool loop_cond_125543 = slt64((int64_t) 1, min_num_blocks_125542);
    bool smallest_pow_2_geq_than_res_125544;
    int64_t smallest_pow_2_geq_than_res_125545;
    bool loop_while_125546;
    int64_t x_125547;
    
    loop_while_125546 = loop_cond_125543;
    x_125547 = (int64_t) 1;
    while (loop_while_125546) {
        int64_t loopres_125548 = mul64((int64_t) 2, x_125547);
        bool loop_cond_125549 = slt64(loopres_125548, min_num_blocks_125542);
        bool loop_while_tmp_133879 = loop_cond_125549;
        int64_t x_tmp_133880 = loopres_125548;
        
        loop_while_125546 = loop_while_tmp_133879;
        x_125547 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125544 = loop_while_125546;
    smallest_pow_2_geq_than_res_125545 = x_125547;
    
    bool zzero_125550 = smallest_pow_2_geq_than_res_125545 == (int64_t) 0;
    bool nonzzero_125551 = !zzero_125550;
    bool protect_assert_disj_125552 = cond_125539 || nonzzero_125551;
    bool nonzzero_cert_125553;
    
    if (!protect_assert_disj_125552) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:137:35-39\n   #5  ftRelational.fut:136:9-137:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125554 = sdiv_safe64(zs_lhs_125540, smallest_pow_2_geq_than_res_125545);
    int64_t block_sizze_125555 = add64((int64_t) 1, zp_rhs_125554);
    bool y_125561 = slt64((int64_t) 0, n_92184);
    bool protect_assert_disj_133752 = cond_125539 || y_125561;
    bool index_certs_125562;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_92184, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:137:35-39\n   #5  ftRelational.fut:136:9-137:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125576 = slt64(smallest_pow_2_geq_than_res_125545, (int64_t) 0);
    bool valid_125577 = !bounds_invalid_upwards_125576;
    bool protect_assert_disj_133760 = cond_125539 || valid_125577;
    bool range_valid_c_125578;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125545, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:137:35-39\n   #6  ftRelational.fut:136:9-137:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125580 = slt64(block_sizze_125555, (int64_t) 0);
    bool valid_125581 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_133762 = cond_125539 || valid_125581;
    bool range_valid_c_125582;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125555, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125584 = sle64(block_sizze_125555, (int64_t) 1);
    int64_t tmp_125585 = sub64(block_sizze_125555, (int64_t) 2);
    bool bounds_invalid_upwards_125586 = slt64(tmp_125585, (int64_t) 0);
    bool valid_125588 = !bounds_invalid_upwards_125586;
    bool protect_assert_disj_125589 = cond_125584 || valid_125588;
    bool protect_assert_disj_133764 = cond_125539 || protect_assert_disj_125589;
    bool range_valid_c_125590;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125585, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133677 = (int64_t) 4 * n_92184;
    
    if (futrts_indicesWithIncrement_11664(ctx, &ext_mem_133467, xs_mem_133466, n_92184, incr_92185) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_92184; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125556 = smallest_pow_2_geq_than_res_125545 * block_sizze_125555;
    bool x_133747 = !cond_125539;
    int64_t greatest_divisor_leq_than_arg1_125559 = mul64((int64_t) 2, block_sizze_125555);
    int64_t merge_block_sizze_125560;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125559) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125560 = x_133749;
    } else {
        merge_block_sizze_125560 = (int64_t) 0;
    }
    
    int32_t reduce_arg1_125563;
    
    if (x_133747) {
        int32_t x_133753 = ((int32_t *) xs_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125563 = x_133753;
    } else {
        reduce_arg1_125563 = 0;
    }
    
    int32_t defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        int32_t x_133755;
        int64_t x_133756;
        int32_t redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125563;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_92184; i_133300++) {
            int32_t x_125567 = ((int32_t *) xs_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125573 = sle32(redout_133298, x_125567);
            int32_t defunc_0_op_res_125574;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125574 = x_125567;
            } else {
                defunc_0_op_res_125574 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125575;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125575 = i_133300;
            } else {
                defunc_0_op_res_125575 = redout_133299;
            }
            
            int32_t redout_tmp_133883 = defunc_0_op_res_125574;
            int64_t redout_tmp_133884 = defunc_0_op_res_125575;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = 0;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125587 = add64((int64_t) 1, tmp_125585);
    int64_t binop_x_133470 = (int64_t) 4 * smallest_pow_2_geq_than_res_125545;
    int64_t bytes_133471 = block_sizze_125555 * binop_x_133470;
    int64_t binop_x_133473 = (int64_t) 8 * smallest_pow_2_geq_than_res_125545;
    int64_t bytes_133474 = block_sizze_125555 * binop_x_133473;
    int64_t bytes_133484 = (int64_t) 4 * block_sizze_125555;
    int64_t bytes_133486 = (int64_t) 8 * block_sizze_125555;
    bool loop_cond_125662 = slt64(block_sizze_125555, flat_dim_125556);
    bool zzero_125663 = merge_block_sizze_125560 == (int64_t) 0;
    bool nonzzero_125664 = !zzero_125663;
    
    if (cond_125539) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134140 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134140, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134141 < bytes_133474) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134141, bytes_133474);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134142 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134142, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134143 < bytes_133486) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134143, bytes_133486);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125545; i_133312++) {
            int64_t zp_lhs_125594 = mul64(block_sizze_125555, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125555; i_133305++) {
                int64_t k_125598 = add64(zp_lhs_125594, i_133305);
                bool cond_125599 = slt64(k_125598, n_92184);
                int32_t lifted_lambda_res_125600;
                int64_t lifted_lambda_res_125601;
                
                if (cond_125599) {
                    bool x_127931 = sle64((int64_t) 0, k_125598);
                    bool bounds_check_127932 = cond_125599 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125598, "] out of bounds for array of shape [", (long long) n_92184, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:137:35-39\n   #9  ftRelational.fut:136:9-137:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t lifted_lambda_res_t_res_127934 = ((int32_t *) xs_mem_133466.mem)[k_125598];
                    
                    lifted_lambda_res_125600 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125601 = k_125598;
                } else {
                    lifted_lambda_res_125600 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125601 = defunc_0_reduce_res_128079;
                }
                ((int32_t *) mem_133485)[i_133305] = lifted_lambda_res_125600;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125601;
            }
            if (!cond_125584) {
                for (int64_t i_125611 = 0; i_125611 < distance_125587; i_125611++) {
                    int64_t gt_arg1_125614 = add64((int64_t) 1, i_125611);
                    bool x_125615 = sle64((int64_t) 0, gt_arg1_125614);
                    bool y_125616 = slt64(gt_arg1_125614, block_sizze_125555);
                    bool bounds_check_125617 = x_125615 && y_125616;
                    bool index_certs_125618;
                    
                    if (!bounds_check_125617) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125614, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125620 = slt64(i_125611, block_sizze_125555);
                    bool index_certs_125621;
                    
                    if (!y_125620) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125611, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t gt_arg1_125619 = ((int32_t *) mem_133485)[gt_arg1_125614];
                    int32_t gt_arg0_125622 = ((int32_t *) mem_133485)[i_125611];
                    bool defunc_0_leq_res_125623 = sle32(gt_arg0_125622, gt_arg1_125619);
                    bool defunc_0_lifted_gt_res_125624 = !defunc_0_leq_res_125623;
                    bool s_125625;
                    int64_t s_125628;
                    bool loop_while_125629;
                    int64_t j_125632;
                    
                    loop_while_125629 = defunc_0_lifted_gt_res_125624;
                    j_125632 = i_125611;
                    while (loop_while_125629) {
                        bool x_125633 = sle64((int64_t) 0, j_125632);
                        bool y_125634 = slt64(j_125632, block_sizze_125555);
                        bool bounds_check_125635 = x_125633 && y_125634;
                        bool index_certs_125636;
                        
                        if (!bounds_check_125635) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125632, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125639 = add64((int64_t) 1, j_125632);
                        bool x_125640 = sle64((int64_t) 0, copy_arg0_125639);
                        bool y_125641 = slt64(copy_arg0_125639, block_sizze_125555);
                        bool bounds_check_125642 = x_125640 && y_125641;
                        bool index_certs_125643;
                        
                        if (!bounds_check_125642) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125639, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t copy_arg0_125637 = ((int32_t *) mem_133485)[j_125632];
                        int64_t copy_arg0_125638 = ((int64_t *) mem_133487)[j_125632];
                        int32_t copy_arg0_125644 = ((int32_t *) mem_133485)[copy_arg0_125639];
                        int64_t copy_arg0_125645 = ((int64_t *) mem_133487)[copy_arg0_125639];
                        
                        ((int32_t *) mem_133485)[j_125632] = copy_arg0_125644;
                        ((int64_t *) mem_133487)[j_125632] = copy_arg0_125645;
                        ((int32_t *) mem_133485)[copy_arg0_125639] = copy_arg0_125637;
                        ((int64_t *) mem_133487)[copy_arg0_125639] = copy_arg0_125638;
                        
                        int64_t tmp_125650 = sub64(j_125632, (int64_t) 1);
                        bool cond_125651 = sle64((int64_t) 0, tmp_125650);
                        bool loop_cond_125652;
                        
                        if (cond_125651) {
                            bool y_127936 = slt64(tmp_125650, block_sizze_125555);
                            bool bounds_check_127937 = cond_125651 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125650, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t gt_arg1_127935 = ((int32_t *) mem_133485)[j_125632];
                            int32_t gt_arg0_127939 = ((int32_t *) mem_133485)[tmp_125650];
                            bool defunc_0_leq_res_127940 = sle32(gt_arg0_127939, gt_arg1_127935);
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125652 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125652 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125652;
                        int64_t j_tmp_133894 = tmp_125650;
                        
                        loop_while_125629 = loop_while_tmp_133891;
                        j_125632 = j_tmp_133894;
                    }
                    s_125625 = loop_while_125629;
                    s_125628 = j_125632;
                }
            }
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133472, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_4b(ctx, 2, (uint32_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint32_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        if (memblock_alloc(ctx, &mem_133544, bytes_133474, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        
        int64_t data_125665;
        bool data_125666;
        int64_t data_125669;
        int64_t loop_dz2084Uz2082U_125670;
        bool loop_while_125671;
        int64_t stride_125674;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125670 = flat_dim_125556;
        loop_while_125671 = loop_cond_125662;
        stride_125674 = block_sizze_125555;
        while (loop_while_125671) {
            int64_t next_stride_125675 = mul64((int64_t) 2, stride_125674);
            bool zzero_125676 = next_stride_125675 == (int64_t) 0;
            bool nonzzero_125677 = !zzero_125676;
            bool nonzzero_cert_125678;
            
            if (!nonzzero_125677) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:137:35-39\n   #5  ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125679 = sdiv64(flat_dim_125556, next_stride_125675);
            bool bounds_invalid_upwards_125680 = slt64(num_merges_125679, (int64_t) 0);
            bool valid_125681 = !bounds_invalid_upwards_125680;
            bool range_valid_c_125682;
            
            if (!valid_125681) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125679, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:137:35-39\n   #6  ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125684 = sub64(next_stride_125675, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125685 = sle64((int64_t) 0, m_125684);
            bool cond_125687 = slt64(next_stride_125675, (int64_t) 10);
            bool protect_assert_disj_125688 = nonzzero_125664 || cond_125687;
            bool nonzzero_cert_125689;
            
            if (!protect_assert_disj_125688) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125690 = smod_safe64(next_stride_125675, merge_block_sizze_125560);
            bool num_blocks_125691 = zeze_lhs_125690 == (int64_t) 0;
            bool protect_assert_disj_125692 = cond_125687 || num_blocks_125691;
            bool assert_c_125693;
            
            if (!protect_assert_disj_125692) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125695 = sdiv_safe64(next_stride_125675, merge_block_sizze_125560);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696 = add64((int64_t) 1, num_blocks_125695);
            int64_t j_m_i_125697 = sub64(next_stride_125675, stride_125674);
            int64_t flat_dim_125698 = merge_block_sizze_125560 * num_blocks_125695;
            bool bounds_invalid_upwards_125699 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, (int64_t) 0);
            bool empty_slice_125700 = j_m_i_125697 == (int64_t) 0;
            int64_t m_125701 = sub64(j_m_i_125697, (int64_t) 1);
            bool zzero_lte_i_125702 = sle64((int64_t) 0, stride_125674);
            bool i_lte_j_125703 = sle64(stride_125674, next_stride_125675);
            bool empty_slice_125704 = stride_125674 == (int64_t) 0;
            int64_t m_125705 = sub64(stride_125674, (int64_t) 1);
            bool bounds_invalid_upwards_125706 = slt64(num_blocks_125695, (int64_t) 0);
            bool cond_125707 = slt64((int64_t) 0, stride_125674);
            bool valid_125708 = !bounds_invalid_upwards_125699;
            int64_t i_p_m_t_s_125709 = add64(stride_125674, m_125701);
            bool zzero_leq_i_p_m_t_s_125710 = sle64((int64_t) 0, m_125705);
            bool i_p_m_t_s_leq_w_125711 = slt64(m_125705, next_stride_125675);
            bool valid_125712 = !bounds_invalid_upwards_125706;
            bool i_p_m_t_s_leq_w_125713 = slt64(m_125684, flat_dim_125698);
            bool y_125714 = slt64((int64_t) 0, j_m_i_125697);
            bool protect_assert_disj_125715 = cond_125687 || valid_125708;
            bool range_valid_c_125716;
            
            if (!protect_assert_disj_125715) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:137:35-39\n   #10 ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125717 = sle64((int64_t) 0, i_p_m_t_s_125709);
            bool i_p_m_t_s_leq_w_125718 = slt64(i_p_m_t_s_125709, next_stride_125675);
            bool y_125719 = zzero_leq_i_p_m_t_s_125710 && i_p_m_t_s_leq_w_125711;
            bool protect_assert_disj_125720 = cond_125687 || valid_125712;
            bool range_valid_c_125721;
            
            if (!protect_assert_disj_125720) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125695, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:137:35-39\n   #9  ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125722 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125713;
            bool y_125723 = zzero_lte_i_125702 && i_p_m_t_s_leq_w_125718;
            bool forwards_ok_125724 = zzero_lte_i_125702 && y_125719;
            bool ok_or_empty_125725 = zzero_125676 || y_125722;
            bool protect_assert_disj_125726 = cond_125707 || y_125714;
            bool y_125727 = zzero_leq_i_p_m_t_s_125717 && y_125723;
            bool ok_or_empty_125728 = empty_slice_125704 || forwards_ok_125724;
            bool protect_assert_disj_125729 = cond_125687 || ok_or_empty_125725;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) flat_dim_125698, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:137:35-39\n   #9  ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125731 = !cond_125687;
            bool protect_assert_disj_125732 = protect_assert_disj_125726 || loop_not_taken_125731;
            bool index_certs_125733;
            
            if (!protect_assert_disj_125732) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:137:35-39\n   #10 ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125734 = i_lte_j_125703 && y_125727;
            bool protect_assert_disj_125735 = cond_125687 || ok_or_empty_125728;
            bool index_certs_125736;
            
            if (!protect_assert_disj_125735) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:137:35-39\n   #11 ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125737 = ok_or_empty_125728 || loop_not_taken_125731;
            bool index_certs_125738;
            
            if (!protect_assert_disj_125737) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125739 = empty_slice_125700 || forwards_ok_125734;
            bool protect_assert_disj_125740 = cond_125687 || ok_or_empty_125739;
            bool index_certs_125741;
            
            if (!protect_assert_disj_125740) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:137:35-39\n   #11 ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125742 = loop_not_taken_125731 || ok_or_empty_125739;
            bool index_certs_125743;
            
            if (!protect_assert_disj_125742) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 4 * num_merges_125679;
            int64_t bytes_133553 = next_stride_125675 * binop_x_133552;
            int64_t binop_x_133555 = (int64_t) 8 * num_merges_125679;
            int64_t bytes_133556 = next_stride_125675 * binop_x_133555;
            bool i_lte_j_125686 = sle64((int64_t) 0, next_stride_125675);
            
            if (mem_133554_cached_sizze_134144 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134144, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134145 < bytes_133556) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134145, bytes_133556);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696;
            int64_t binop_x_133582 = (int64_t) 4 * num_blocks_125695;
            int64_t bytes_133583 = merge_block_sizze_125560 * binop_x_133582;
            int64_t binop_x_133585 = (int64_t) 8 * num_blocks_125695;
            int64_t bytes_133586 = merge_block_sizze_125560 * binop_x_133585;
            int64_t bytes_133628 = (int64_t) 8 * stride_125674;
            int64_t bytes_133630 = (int64_t) 16 * stride_125674;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125679; i_133333++) {
                int64_t start_125747 = mul64(next_stride_125675, i_133333);
                int64_t j_m_i_125748 = sub64(loop_dz2084Uz2082U_125670, start_125747);
                bool empty_slice_125749 = j_m_i_125748 == (int64_t) 0;
                int64_t m_125750 = sub64(j_m_i_125748, (int64_t) 1);
                int64_t i_p_m_t_s_125751 = add64(start_125747, m_125750);
                bool zzero_leq_i_p_m_t_s_125752 = sle64((int64_t) 0, i_p_m_t_s_125751);
                bool i_p_m_t_s_leq_w_125753 = slt64(i_p_m_t_s_125751, loop_dz2084Uz2082U_125670);
                bool zzero_lte_i_125754 = sle64((int64_t) 0, start_125747);
                bool i_lte_j_125755 = sle64(start_125747, loop_dz2084Uz2082U_125670);
                bool y_125756 = i_p_m_t_s_leq_w_125753 && zzero_lte_i_125754;
                bool y_125757 = zzero_leq_i_p_m_t_s_125752 && y_125756;
                bool forwards_ok_125758 = i_lte_j_125755 && y_125757;
                bool ok_or_empty_125759 = empty_slice_125749 || forwards_ok_125758;
                bool index_certs_125760;
                
                if (!ok_or_empty_125759) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125747, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125670, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125761 = slt64(m_125684, j_m_i_125748);
                bool y_125762 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125761;
                bool forwards_ok_125763 = i_lte_j_125686 && y_125762;
                bool ok_or_empty_125764 = zzero_125676 || forwards_ok_125763;
                bool index_certs_125765;
                
                if (!ok_or_empty_125764) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) j_m_i_125748, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:137:35-39\n   #8  ftRelational.fut:136:9-137:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125687) {
                    int32_t dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125707) {
                        int32_t head_res_127969 = ((int32_t *) mem_param_133548.mem)[start_125747];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125747];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125674 + start_125747;
                        int32_t head_res_127972 = ((int32_t *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125675; nest_i_133904++) {
                        ((int32_t *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133630, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125675; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125675; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125697;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125674);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125697);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:137:35-39\n   #9  ftRelational.fut:136:9-137:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:137:35-39\n   #9  ftRelational.fut:136:9-137:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125674 + j_127983;
                                int64_t slice_127993 = start_125747 + slice_127992;
                                int32_t leq_arg1_127994 = ((int32_t *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125747 + i_127980;
                                int32_t leq_arg0_127999 = ((int32_t *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = sle32(leq_arg0_127999, leq_arg1_127994);
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        int32_t loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125674);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:137:35-39\n   #9  ftRelational.fut:136:9-137:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125747 + i_127980;
                            int32_t tmp_128010 = ((int32_t *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125697);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:137:35-39\n   #9  ftRelational.fut:136:9-137:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125674 + j_127983;
                            int64_t slice_128017 = start_125747 + slice_128016;
                            int32_t tmp_128018 = ((int32_t *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((int32_t *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134146 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134146, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134147 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134147, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696; i_133319++) {
                        int64_t split_count_arg3_125827 = mul64(merge_block_sizze_125560, i_133319);
                        int64_t defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125828, &defunc_0_split_count_res_125829, &defunc_0_split_count_res_125830, &defunc_0_split_count_res_125831, &defunc_0_split_count_res_125832, (int64_t) 0, stride_125674, (int64_t) 0, j_m_i_125697, split_count_arg3_125827) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125833 = slt64((int64_t) 0, defunc_0_split_count_res_125832);
                        bool defunc_0_split_count_res_125834;
                        int64_t defunc_0_split_count_res_125835;
                        int64_t defunc_0_split_count_res_125836;
                        int64_t defunc_0_split_count_res_125837;
                        int64_t defunc_0_split_count_res_125838;
                        int64_t defunc_0_split_count_res_125839;
                        bool loop_while_125840;
                        int64_t ss_125841;
                        int64_t ss_125842;
                        int64_t tt_125843;
                        int64_t tt_125844;
                        int64_t count_125845;
                        
                        loop_while_125840 = loop_cond_125833;
                        ss_125841 = defunc_0_split_count_res_125828;
                        ss_125842 = defunc_0_split_count_res_125829;
                        tt_125843 = defunc_0_split_count_res_125830;
                        tt_125844 = defunc_0_split_count_res_125831;
                        count_125845 = defunc_0_split_count_res_125832;
                        while (loop_while_125840) {
                            int64_t zlze_lhs_125846 = sub64(ss_125842, ss_125841);
                            bool cond_125847 = sle64(zlze_lhs_125846, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125848;
                            int64_t defunc_0_lifted_step_res_125849;
                            int64_t defunc_0_lifted_step_res_125850;
                            int64_t defunc_0_lifted_step_res_125851;
                            
                            if (cond_125847) {
                                int64_t tmp_128022 = add64(tt_125843, count_125845);
                                
                                defunc_0_lifted_step_res_125848 = ss_125841;
                                defunc_0_lifted_step_res_125849 = tmp_128022;
                                defunc_0_lifted_step_res_125850 = tt_125844;
                                defunc_0_lifted_step_res_125851 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125853 = sub64(tt_125844, tt_125843);
                                bool cond_125854 = sle64(zlze_lhs_125853, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125855;
                                int64_t defunc_0_lifted_step_res_f_res_125856;
                                int64_t defunc_0_lifted_step_res_f_res_125857;
                                int64_t defunc_0_lifted_step_res_f_res_125858;
                                
                                if (cond_125854) {
                                    int64_t tmp_128023 = add64(ss_125841, count_125845);
                                    
                                    defunc_0_lifted_step_res_f_res_125855 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125856 = tt_125843;
                                    defunc_0_lifted_step_res_f_res_125857 = tt_125844;
                                    defunc_0_lifted_step_res_f_res_125858 = (int64_t) 0;
                                } else {
                                    bool cond_125860 = count_125845 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125861;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125862;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125863;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125864;
                                    
                                    if (cond_125860) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125841);
                                        bool y_128026 = slt64(ss_125841, stride_125674);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125841, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:137:35-39\n   #13 ftRelational.fut:136:9-137:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125843);
                                        bool y_128032 = slt64(tt_125843, j_m_i_125697);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125843, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:137:35-39\n   #13 ftRelational.fut:136:9-137:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125747 + ss_125841;
                                        int32_t leq_arg1_128030 = ((int32_t *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125674 + tt_125843;
                                        int64_t slice_128036 = start_125747 + slice_128035;
                                        int32_t leq_arg0_128037 = ((int32_t *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = sle32(leq_arg0_128037, leq_arg1_128030);
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125843);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125841;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125841);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125843;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = tt_125844;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = (int64_t) 0;
                                    } else {
                                        int64_t m_125883 = sdiv64(count_125845, (int64_t) 2);
                                        int64_t n_125884 = sub64(count_125845, m_125883);
                                        bool cond_125885 = n_125884 == (int64_t) 0;
                                        int64_t zgze_lhs_125886 = add64(ss_125841, m_125883);
                                        bool cond_f_res_125887 = sle64(ss_125842, zgze_lhs_125886);
                                        bool x_125888 = !cond_125885;
                                        bool y_125889 = cond_f_res_125887 && x_125888;
                                        bool cond_125890 = cond_125885 || y_125889;
                                        bool leq_y_x_125891;
                                        
                                        if (cond_125890) {
                                            leq_y_x_125891 = 1;
                                        } else {
                                            bool x_125892 = sle64((int64_t) 0, zgze_lhs_125886);
                                            bool y_125893 = slt64(zgze_lhs_125886, stride_125674);
                                            bool bounds_check_125894 = x_125892 && y_125893;
                                            bool index_certs_125895;
                                            
                                            if (!bounds_check_125894) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125886, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:137:35-39\n   #13 ftRelational.fut:136:9-137:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125898 = add64(tt_125843, n_125884);
                                            int64_t leq_arg0_125899 = sub64(zm_lhs_125898, (int64_t) 1);
                                            bool x_125900 = sle64((int64_t) 0, leq_arg0_125899);
                                            bool y_125901 = slt64(leq_arg0_125899, j_m_i_125697);
                                            bool bounds_check_125902 = x_125900 && y_125901;
                                            bool index_certs_125903;
                                            
                                            if (!bounds_check_125902) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125899, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:137:35-39\n   #13 ftRelational.fut:136:9-137:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125896 = start_125747 + zgze_lhs_125886;
                                            int32_t leq_arg1_125897 = ((int32_t *) mem_param_133548.mem)[slice_125896];
                                            int64_t slice_125904 = stride_125674 + leq_arg0_125899;
                                            int64_t slice_125905 = start_125747 + slice_125904;
                                            int32_t leq_arg0_125906 = ((int32_t *) mem_param_133548.mem)[slice_125905];
                                            bool defunc_0_leq_res_125907 = sle32(leq_arg0_125906, leq_arg1_125897);
                                            
                                            leq_y_x_125891 = defunc_0_leq_res_125907;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                        
                                        if (leq_y_x_125891) {
                                            int64_t tmp_128043 = add64(tt_125843, n_125884);
                                            int64_t tmp_128044 = sub64(count_125845, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tt_125844;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = tmp_128044;
                                        } else {
                                            int64_t tmp_125913 = add64(tt_125843, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tt_125843;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tmp_125913;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = count_125845;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = ss_125841;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                    }
                                    defunc_0_lifted_step_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_125861;
                                    defunc_0_lifted_step_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_125862;
                                    defunc_0_lifted_step_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_125863;
                                    defunc_0_lifted_step_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_125864;
                                }
                                defunc_0_lifted_step_res_125848 = defunc_0_lifted_step_res_f_res_125855;
                                defunc_0_lifted_step_res_125849 = defunc_0_lifted_step_res_f_res_125856;
                                defunc_0_lifted_step_res_125850 = defunc_0_lifted_step_res_f_res_125857;
                                defunc_0_lifted_step_res_125851 = defunc_0_lifted_step_res_f_res_125858;
                            }
                            
                            int64_t loopres_125914;
                            int64_t loopres_125915;
                            int64_t loopres_125916;
                            int64_t loopres_125917;
                            int64_t loopres_125918;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125914, &loopres_125915, &loopres_125916, &loopres_125917, &loopres_125918, defunc_0_lifted_step_res_125848, ss_125842, defunc_0_lifted_step_res_125849, defunc_0_lifted_step_res_125850, defunc_0_lifted_step_res_125851) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125919 = slt64((int64_t) 0, loopres_125918);
                            bool loop_while_tmp_133911 = loop_cond_125919;
                            int64_t ss_tmp_133912 = loopres_125914;
                            int64_t ss_tmp_133913 = loopres_125915;
                            int64_t tt_tmp_133914 = loopres_125916;
                            int64_t tt_tmp_133915 = loopres_125917;
                            int64_t count_tmp_133916 = loopres_125918;
                            
                            loop_while_125840 = loop_while_tmp_133911;
                            ss_125841 = ss_tmp_133912;
                            ss_125842 = ss_tmp_133913;
                            tt_125843 = tt_tmp_133914;
                            tt_125844 = tt_tmp_133915;
                            count_125845 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125834 = loop_while_125840;
                        defunc_0_split_count_res_125835 = ss_125841;
                        defunc_0_split_count_res_125836 = ss_125842;
                        defunc_0_split_count_res_125837 = tt_125843;
                        defunc_0_split_count_res_125838 = tt_125844;
                        defunc_0_split_count_res_125839 = count_125845;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125835;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125837;
                    }
                    if (mem_133584_cached_sizze_134148 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134148, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134149 < bytes_133586) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134149, bytes_133586);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125695; i_133326++) {
                        bool y_125925 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool index_certs_125927;
                        
                        if (!y_125925) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:137:35-39\n   #10 ftRelational.fut:136:9-137:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125928 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125930 = add64((int64_t) 1, i_133326);
                        bool x_125931 = sle64((int64_t) 0, tmp_125930);
                        bool y_125932 = slt64(tmp_125930, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool bounds_check_125933 = x_125931 && y_125932;
                        bool index_certs_125934;
                        
                        if (!bounds_check_125933) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125930, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:137:35-39\n   #10 ftRelational.fut:136:9-137:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125935 = ((int64_t *) mem_133567)[tmp_125930];
                        int64_t defunc_0_f_res_125936 = ((int64_t *) mem_133569)[tmp_125930];
                        int64_t merge_sequential_arg2_125937 = add64(stride_125674, defunc_0_f_res_125929);
                        int64_t merge_sequential_arg2_125938 = add64(stride_125674, defunc_0_f_res_125936);
                        int64_t j_m_i_125939 = sub64(merge_sequential_arg2_125938, merge_sequential_arg2_125937);
                        bool empty_slice_125940 = j_m_i_125939 == (int64_t) 0;
                        int64_t m_125941 = sub64(j_m_i_125939, (int64_t) 1);
                        int64_t i_p_m_t_s_125942 = add64(merge_sequential_arg2_125937, m_125941);
                        bool zzero_leq_i_p_m_t_s_125943 = sle64((int64_t) 0, i_p_m_t_s_125942);
                        bool i_p_m_t_s_leq_w_125944 = slt64(i_p_m_t_s_125942, next_stride_125675);
                        bool zzero_lte_i_125945 = sle64((int64_t) 0, merge_sequential_arg2_125937);
                        bool i_lte_j_125946 = sle64(merge_sequential_arg2_125937, merge_sequential_arg2_125938);
                        bool y_125947 = i_p_m_t_s_leq_w_125944 && zzero_lte_i_125945;
                        bool y_125948 = zzero_leq_i_p_m_t_s_125943 && y_125947;
                        bool forwards_ok_125949 = i_lte_j_125946 && y_125948;
                        bool ok_or_empty_125950 = empty_slice_125940 || forwards_ok_125949;
                        bool index_certs_125951;
                        
                        if (!ok_or_empty_125950) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125937, ":", (long long) merge_sequential_arg2_125938, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:137:35-39\n   #10 ftRelational.fut:136:9-137:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125952 = sub64(defunc_0_f_res_125935, defunc_0_f_res_125928);
                        bool empty_slice_125953 = j_m_i_125952 == (int64_t) 0;
                        int64_t m_125954 = sub64(j_m_i_125952, (int64_t) 1);
                        int64_t i_p_m_t_s_125955 = add64(defunc_0_f_res_125928, m_125954);
                        bool zzero_leq_i_p_m_t_s_125956 = sle64((int64_t) 0, i_p_m_t_s_125955);
                        bool i_p_m_t_s_leq_w_125957 = slt64(i_p_m_t_s_125955, next_stride_125675);
                        bool zzero_lte_i_125958 = sle64((int64_t) 0, defunc_0_f_res_125928);
                        bool i_lte_j_125959 = sle64(defunc_0_f_res_125928, defunc_0_f_res_125935);
                        bool y_125960 = i_p_m_t_s_leq_w_125957 && zzero_lte_i_125958;
                        bool y_125961 = zzero_leq_i_p_m_t_s_125956 && y_125960;
                        bool forwards_ok_125962 = i_lte_j_125959 && y_125961;
                        bool ok_or_empty_125963 = empty_slice_125953 || forwards_ok_125962;
                        bool index_certs_125964;
                        
                        if (!ok_or_empty_125963) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125928, ":", (long long) defunc_0_f_res_125935, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:137:35-39\n   #10 ftRelational.fut:136:9-137:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125965 = slt64((int64_t) 0, j_m_i_125952);
                        int32_t dummy_125966;
                        int64_t dummy_125967;
                        
                        if (cond_125965) {
                            bool index_certs_128045;
                            
                            if (!cond_125965) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:137:35-39\n   #12 ftRelational.fut:136:9-137:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125747 + defunc_0_f_res_125928;
                            int32_t head_res_128047 = ((int32_t *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125966 = head_res_128047;
                            dummy_125967 = head_res_128048;
                        } else {
                            bool y_125972 = slt64((int64_t) 0, j_m_i_125939);
                            bool index_certs_125973;
                            
                            if (!y_125972) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:137:35-39\n   #12 ftRelational.fut:136:9-137:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125974 = start_125747 + merge_sequential_arg2_125937;
                            int32_t head_res_125975 = ((int32_t *) mem_param_133548.mem)[slice_125974];
                            int64_t head_res_125976 = ((int64_t *) mem_param_133551.mem)[slice_125974];
                            
                            dummy_125966 = head_res_125975;
                            dummy_125967 = head_res_125976;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125560; nest_i_133919++) {
                            ((int32_t *) mem_133584)[i_133326 * merge_block_sizze_125560 + nest_i_133919] = dummy_125966;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125560; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + nest_i_133920] = dummy_125967;
                        }
                        
                        int64_t data_125979;
                        int64_t i_125983 = (int64_t) 0;
                        
                        for (int64_t k_125982 = 0; k_125982 < merge_block_sizze_125560; k_125982++) {
                            int64_t j_125986 = sub64(k_125982, i_125983);
                            bool cond_125987 = j_125986 == j_m_i_125939;
                            bool cond_125988;
                            
                            if (cond_125987) {
                                cond_125988 = 1;
                            } else {
                                bool cond_125989 = slt64(i_125983, j_m_i_125952);
                                bool cond_f_res_125990;
                                
                                if (cond_125989) {
                                    bool x_128049 = sle64((int64_t) 0, j_125986);
                                    bool y_128050 = slt64(j_125986, j_m_i_125939);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:137:35-39\n   #11 ftRelational.fut:136:9-137:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125983);
                                    bool bounds_check_128057 = cond_125989 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:137:35-39\n   #11 ftRelational.fut:136:9-137:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125937 + j_125986;
                                    int64_t slice_128054 = start_125747 + slice_128053;
                                    int32_t leq_arg1_128055 = ((int32_t *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125928 + i_125983;
                                    int64_t slice_128060 = start_125747 + slice_128059;
                                    int32_t leq_arg0_128061 = ((int32_t *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = sle32(leq_arg0_128061, leq_arg1_128055);
                                    
                                    cond_f_res_125990 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125990 = 0;
                                }
                                cond_125988 = cond_f_res_125990;
                            }
                            
                            int64_t loopres_126005;
                            int32_t loopres_126006;
                            int64_t loopres_126007;
                            
                            if (cond_125988) {
                                bool x_128064 = sle64((int64_t) 0, i_125983);
                                bool y_128065 = slt64(i_125983, j_m_i_125952);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:137:35-39\n   #11 ftRelational.fut:136:9-137:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125983);
                                int64_t slice_128068 = defunc_0_f_res_125928 + i_125983;
                                int64_t slice_128069 = start_125747 + slice_128068;
                                int32_t tmp_128070 = ((int32_t *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_126005 = tmp_128063;
                                loopres_126006 = tmp_128070;
                                loopres_126007 = tmp_128071;
                            } else {
                                bool x_126017 = sle64((int64_t) 0, j_125986);
                                bool y_126018 = slt64(j_125986, j_m_i_125939);
                                bool bounds_check_126019 = x_126017 && y_126018;
                                bool index_certs_126020;
                                
                                if (!bounds_check_126019) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:137:35-39\n   #11 ftRelational.fut:136:9-137:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126021 = merge_sequential_arg2_125937 + j_125986;
                                int64_t slice_126022 = start_125747 + slice_126021;
                                int32_t tmp_126023 = ((int32_t *) mem_param_133548.mem)[slice_126022];
                                int64_t tmp_126024 = ((int64_t *) mem_param_133551.mem)[slice_126022];
                                
                                loopres_126005 = i_125983;
                                loopres_126006 = tmp_126023;
                                loopres_126007 = tmp_126024;
                            }
                            ((int32_t *) mem_133584)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126006;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126007;
                            
                            int64_t i_tmp_133921 = loopres_126005;
                            
                            i_125983 = i_tmp_133921;
                        }
                        data_125979 = i_125983;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_4b(ctx, 2, (uint32_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint32_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133586, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_4b(ctx, 1, (uint32_t *) mem_133554, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126031 = next_stride_125675 * num_merges_125679;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_4b(ctx, 2, (uint32_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint32_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            if (memblock_alloc(ctx, &mem_133664, bytes_133556, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            
            bool loop_cond_126034 = slt64(next_stride_125675, flat_dim_125556);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126031;
            bool loop_while_tmp_133898 = loop_cond_126034;
            int64_t stride_tmp_133901 = next_stride_125675;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125670 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125671 = loop_while_tmp_133898;
            stride_125674 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125665 = loop_dz2084Uz2082U_125670;
        data_125666 = loop_while_125671;
        data_125669 = stride_125674;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126035 = n_92184 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126036 = sle64((int64_t) 0, zs_lhs_125540);
        bool i_p_m_t_s_leq_w_126037 = slt64(zs_lhs_125540, data_125665);
        bool y_126038 = zzero_leq_i_p_m_t_s_126036 && i_p_m_t_s_leq_w_126037;
        bool ok_or_empty_126039 = empty_slice_126035 || y_126038;
        bool index_certs_126040;
        
        if (!ok_or_empty_126039) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_92184, "] out of bounds for array of shape [", (long long) data_125665, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:137:35-39\n   #6  ftRelational.fut:136:9-137:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133468, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133677, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_92184; i_133340++) {
        int64_t eta_p_126048 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126049 = sle64((int64_t) 0, eta_p_126048);
        bool y_126050 = slt64(eta_p_126048, n_92184);
        bool bounds_check_126051 = x_126049 && y_126050;
        bool index_certs_126052;
        
        if (!bounds_check_126051) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126048, "] out of bounds for array of shape [", (long long) n_92184, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:137:35-39\n   #5  ftRelational.fut:136:9-137:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t lifted_lambda_res_126053 = ((int64_t *) ext_mem_133467.mem)[eta_p_126048];
        int32_t lifted_lambda_res_126054 = ((int32_t *) xs_mem_133466.mem)[eta_p_126048];
        
        ((int64_t *) mem_133676.mem)[i_133340] = lifted_lambda_res_126053;
        ((int32_t *) mem_133678.mem)[i_133340] = lifted_lambda_res_126054;
    }
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134138, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134139, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_long(struct futhark_context *ctx, struct memblock *mem_out_p_134150, struct memblock *mem_out_p_134151, struct memblock xs_mem_133466, int64_t n_94325, int64_t incr_94326)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134152 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134153 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134154 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134155 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134156 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134157 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134158 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134159 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134160 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134161 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_94325;
    bool cond_125539 = sle64(n_94325, (int64_t) 1);
    int64_t zs_lhs_125540 = sub64(n_94325, (int64_t) 1);
    int64_t zp_rhs_125541 = sdiv_safe64(zs_lhs_125540, (int64_t) 20);
    int64_t min_num_blocks_125542 = add64((int64_t) 1, zp_rhs_125541);
    bool loop_cond_125543 = slt64((int64_t) 1, min_num_blocks_125542);
    bool smallest_pow_2_geq_than_res_125544;
    int64_t smallest_pow_2_geq_than_res_125545;
    bool loop_while_125546;
    int64_t x_125547;
    
    loop_while_125546 = loop_cond_125543;
    x_125547 = (int64_t) 1;
    while (loop_while_125546) {
        int64_t loopres_125548 = mul64((int64_t) 2, x_125547);
        bool loop_cond_125549 = slt64(loopres_125548, min_num_blocks_125542);
        bool loop_while_tmp_133879 = loop_cond_125549;
        int64_t x_tmp_133880 = loopres_125548;
        
        loop_while_125546 = loop_while_tmp_133879;
        x_125547 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125544 = loop_while_125546;
    smallest_pow_2_geq_than_res_125545 = x_125547;
    
    bool zzero_125550 = smallest_pow_2_geq_than_res_125545 == (int64_t) 0;
    bool nonzzero_125551 = !zzero_125550;
    bool protect_assert_disj_125552 = cond_125539 || nonzzero_125551;
    bool nonzzero_cert_125553;
    
    if (!protect_assert_disj_125552) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:139:35-39\n   #5  ftRelational.fut:138:9-139:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125554 = sdiv_safe64(zs_lhs_125540, smallest_pow_2_geq_than_res_125545);
    int64_t block_sizze_125555 = add64((int64_t) 1, zp_rhs_125554);
    bool y_125561 = slt64((int64_t) 0, n_94325);
    bool protect_assert_disj_133752 = cond_125539 || y_125561;
    bool index_certs_125562;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_94325, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:139:35-39\n   #5  ftRelational.fut:138:9-139:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125576 = slt64(smallest_pow_2_geq_than_res_125545, (int64_t) 0);
    bool valid_125577 = !bounds_invalid_upwards_125576;
    bool protect_assert_disj_133760 = cond_125539 || valid_125577;
    bool range_valid_c_125578;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125545, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:139:35-39\n   #6  ftRelational.fut:138:9-139:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125580 = slt64(block_sizze_125555, (int64_t) 0);
    bool valid_125581 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_133762 = cond_125539 || valid_125581;
    bool range_valid_c_125582;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125555, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125584 = sle64(block_sizze_125555, (int64_t) 1);
    int64_t tmp_125585 = sub64(block_sizze_125555, (int64_t) 2);
    bool bounds_invalid_upwards_125586 = slt64(tmp_125585, (int64_t) 0);
    bool valid_125588 = !bounds_invalid_upwards_125586;
    bool protect_assert_disj_125589 = cond_125584 || valid_125588;
    bool protect_assert_disj_133764 = cond_125539 || protect_assert_disj_125589;
    bool range_valid_c_125590;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125585, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (futrts_indicesWithIncrement_11686(ctx, &ext_mem_133467, xs_mem_133466, n_94325, incr_94326) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_94325; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125556 = smallest_pow_2_geq_than_res_125545 * block_sizze_125555;
    bool x_133747 = !cond_125539;
    int64_t greatest_divisor_leq_than_arg1_125559 = mul64((int64_t) 2, block_sizze_125555);
    int64_t merge_block_sizze_125560;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125559) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125560 = x_133749;
    } else {
        merge_block_sizze_125560 = (int64_t) 0;
    }
    
    int64_t reduce_arg1_125563;
    
    if (x_133747) {
        int64_t x_133753 = ((int64_t *) xs_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125563 = x_133753;
    } else {
        reduce_arg1_125563 = (int64_t) 0;
    }
    
    int64_t defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        int64_t x_133755;
        int64_t x_133756;
        int64_t redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125563;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_94325; i_133300++) {
            int64_t x_125567 = ((int64_t *) xs_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125573 = sle64(redout_133298, x_125567);
            int64_t defunc_0_op_res_125574;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125574 = x_125567;
            } else {
                defunc_0_op_res_125574 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125575;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125575 = i_133300;
            } else {
                defunc_0_op_res_125575 = redout_133299;
            }
            
            int64_t redout_tmp_133883 = defunc_0_op_res_125574;
            int64_t redout_tmp_133884 = defunc_0_op_res_125575;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = (int64_t) 0;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125587 = add64((int64_t) 1, tmp_125585);
    int64_t binop_x_133470 = (int64_t) 8 * smallest_pow_2_geq_than_res_125545;
    int64_t bytes_133471 = block_sizze_125555 * binop_x_133470;
    int64_t bytes_133484 = (int64_t) 8 * block_sizze_125555;
    bool loop_cond_125662 = slt64(block_sizze_125555, flat_dim_125556);
    bool zzero_125663 = merge_block_sizze_125560 == (int64_t) 0;
    bool nonzzero_125664 = !zzero_125663;
    
    if (cond_125539) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134152 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134152, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134153 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134153, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134154 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134154, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134155 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134155, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125545; i_133312++) {
            int64_t zp_lhs_125594 = mul64(block_sizze_125555, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125555; i_133305++) {
                int64_t k_125598 = add64(zp_lhs_125594, i_133305);
                bool cond_125599 = slt64(k_125598, n_94325);
                int64_t lifted_lambda_res_125600;
                int64_t lifted_lambda_res_125601;
                
                if (cond_125599) {
                    bool x_127931 = sle64((int64_t) 0, k_125598);
                    bool bounds_check_127932 = cond_125599 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125598, "] out of bounds for array of shape [", (long long) n_94325, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:139:35-39\n   #9  ftRelational.fut:138:9-139:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t lifted_lambda_res_t_res_127934 = ((int64_t *) xs_mem_133466.mem)[k_125598];
                    
                    lifted_lambda_res_125600 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125601 = k_125598;
                } else {
                    lifted_lambda_res_125600 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125601 = defunc_0_reduce_res_128079;
                }
                ((int64_t *) mem_133485)[i_133305] = lifted_lambda_res_125600;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125601;
            }
            if (!cond_125584) {
                for (int64_t i_125611 = 0; i_125611 < distance_125587; i_125611++) {
                    int64_t gt_arg1_125614 = add64((int64_t) 1, i_125611);
                    bool x_125615 = sle64((int64_t) 0, gt_arg1_125614);
                    bool y_125616 = slt64(gt_arg1_125614, block_sizze_125555);
                    bool bounds_check_125617 = x_125615 && y_125616;
                    bool index_certs_125618;
                    
                    if (!bounds_check_125617) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125614, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125620 = slt64(i_125611, block_sizze_125555);
                    bool index_certs_125621;
                    
                    if (!y_125620) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125611, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t gt_arg1_125619 = ((int64_t *) mem_133485)[gt_arg1_125614];
                    int64_t gt_arg0_125622 = ((int64_t *) mem_133485)[i_125611];
                    bool defunc_0_leq_res_125623 = sle64(gt_arg0_125622, gt_arg1_125619);
                    bool defunc_0_lifted_gt_res_125624 = !defunc_0_leq_res_125623;
                    bool s_125625;
                    int64_t s_125628;
                    bool loop_while_125629;
                    int64_t j_125632;
                    
                    loop_while_125629 = defunc_0_lifted_gt_res_125624;
                    j_125632 = i_125611;
                    while (loop_while_125629) {
                        bool x_125633 = sle64((int64_t) 0, j_125632);
                        bool y_125634 = slt64(j_125632, block_sizze_125555);
                        bool bounds_check_125635 = x_125633 && y_125634;
                        bool index_certs_125636;
                        
                        if (!bounds_check_125635) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125632, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125639 = add64((int64_t) 1, j_125632);
                        bool x_125640 = sle64((int64_t) 0, copy_arg0_125639);
                        bool y_125641 = slt64(copy_arg0_125639, block_sizze_125555);
                        bool bounds_check_125642 = x_125640 && y_125641;
                        bool index_certs_125643;
                        
                        if (!bounds_check_125642) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125639, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125637 = ((int64_t *) mem_133485)[j_125632];
                        int64_t copy_arg0_125638 = ((int64_t *) mem_133487)[j_125632];
                        int64_t copy_arg0_125644 = ((int64_t *) mem_133485)[copy_arg0_125639];
                        int64_t copy_arg0_125645 = ((int64_t *) mem_133487)[copy_arg0_125639];
                        
                        ((int64_t *) mem_133485)[j_125632] = copy_arg0_125644;
                        ((int64_t *) mem_133487)[j_125632] = copy_arg0_125645;
                        ((int64_t *) mem_133485)[copy_arg0_125639] = copy_arg0_125637;
                        ((int64_t *) mem_133487)[copy_arg0_125639] = copy_arg0_125638;
                        
                        int64_t tmp_125650 = sub64(j_125632, (int64_t) 1);
                        bool cond_125651 = sle64((int64_t) 0, tmp_125650);
                        bool loop_cond_125652;
                        
                        if (cond_125651) {
                            bool y_127936 = slt64(tmp_125650, block_sizze_125555);
                            bool bounds_check_127937 = cond_125651 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125650, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t gt_arg1_127935 = ((int64_t *) mem_133485)[j_125632];
                            int64_t gt_arg0_127939 = ((int64_t *) mem_133485)[tmp_125650];
                            bool defunc_0_leq_res_127940 = sle64(gt_arg0_127939, gt_arg1_127935);
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125652 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125652 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125652;
                        int64_t j_tmp_133894 = tmp_125650;
                        
                        loop_while_125629 = loop_while_tmp_133891;
                        j_125632 = j_tmp_133894;
                    }
                    s_125625 = loop_while_125629;
                    s_125628 = j_125632;
                }
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133472, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint64_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        if (memblock_alloc(ctx, &mem_133544, bytes_133471, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        
        int64_t data_125665;
        bool data_125666;
        int64_t data_125669;
        int64_t loop_dz2084Uz2082U_125670;
        bool loop_while_125671;
        int64_t stride_125674;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125670 = flat_dim_125556;
        loop_while_125671 = loop_cond_125662;
        stride_125674 = block_sizze_125555;
        while (loop_while_125671) {
            int64_t next_stride_125675 = mul64((int64_t) 2, stride_125674);
            bool zzero_125676 = next_stride_125675 == (int64_t) 0;
            bool nonzzero_125677 = !zzero_125676;
            bool nonzzero_cert_125678;
            
            if (!nonzzero_125677) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:139:35-39\n   #5  ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125679 = sdiv64(flat_dim_125556, next_stride_125675);
            bool bounds_invalid_upwards_125680 = slt64(num_merges_125679, (int64_t) 0);
            bool valid_125681 = !bounds_invalid_upwards_125680;
            bool range_valid_c_125682;
            
            if (!valid_125681) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125679, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:139:35-39\n   #6  ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125684 = sub64(next_stride_125675, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125685 = sle64((int64_t) 0, m_125684);
            bool cond_125687 = slt64(next_stride_125675, (int64_t) 10);
            bool protect_assert_disj_125688 = nonzzero_125664 || cond_125687;
            bool nonzzero_cert_125689;
            
            if (!protect_assert_disj_125688) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125690 = smod_safe64(next_stride_125675, merge_block_sizze_125560);
            bool num_blocks_125691 = zeze_lhs_125690 == (int64_t) 0;
            bool protect_assert_disj_125692 = cond_125687 || num_blocks_125691;
            bool assert_c_125693;
            
            if (!protect_assert_disj_125692) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125695 = sdiv_safe64(next_stride_125675, merge_block_sizze_125560);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696 = add64((int64_t) 1, num_blocks_125695);
            int64_t j_m_i_125697 = sub64(next_stride_125675, stride_125674);
            int64_t flat_dim_125698 = merge_block_sizze_125560 * num_blocks_125695;
            bool bounds_invalid_upwards_125699 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, (int64_t) 0);
            bool empty_slice_125700 = j_m_i_125697 == (int64_t) 0;
            int64_t m_125701 = sub64(j_m_i_125697, (int64_t) 1);
            bool zzero_lte_i_125702 = sle64((int64_t) 0, stride_125674);
            bool i_lte_j_125703 = sle64(stride_125674, next_stride_125675);
            bool empty_slice_125704 = stride_125674 == (int64_t) 0;
            int64_t m_125705 = sub64(stride_125674, (int64_t) 1);
            bool bounds_invalid_upwards_125706 = slt64(num_blocks_125695, (int64_t) 0);
            bool cond_125707 = slt64((int64_t) 0, stride_125674);
            bool valid_125708 = !bounds_invalid_upwards_125699;
            int64_t i_p_m_t_s_125709 = add64(stride_125674, m_125701);
            bool zzero_leq_i_p_m_t_s_125710 = sle64((int64_t) 0, m_125705);
            bool i_p_m_t_s_leq_w_125711 = slt64(m_125705, next_stride_125675);
            bool valid_125712 = !bounds_invalid_upwards_125706;
            bool i_p_m_t_s_leq_w_125713 = slt64(m_125684, flat_dim_125698);
            bool y_125714 = slt64((int64_t) 0, j_m_i_125697);
            bool protect_assert_disj_125715 = cond_125687 || valid_125708;
            bool range_valid_c_125716;
            
            if (!protect_assert_disj_125715) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:139:35-39\n   #10 ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125717 = sle64((int64_t) 0, i_p_m_t_s_125709);
            bool i_p_m_t_s_leq_w_125718 = slt64(i_p_m_t_s_125709, next_stride_125675);
            bool y_125719 = zzero_leq_i_p_m_t_s_125710 && i_p_m_t_s_leq_w_125711;
            bool protect_assert_disj_125720 = cond_125687 || valid_125712;
            bool range_valid_c_125721;
            
            if (!protect_assert_disj_125720) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125695, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:139:35-39\n   #9  ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125722 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125713;
            bool y_125723 = zzero_lte_i_125702 && i_p_m_t_s_leq_w_125718;
            bool forwards_ok_125724 = zzero_lte_i_125702 && y_125719;
            bool ok_or_empty_125725 = zzero_125676 || y_125722;
            bool protect_assert_disj_125726 = cond_125707 || y_125714;
            bool y_125727 = zzero_leq_i_p_m_t_s_125717 && y_125723;
            bool ok_or_empty_125728 = empty_slice_125704 || forwards_ok_125724;
            bool protect_assert_disj_125729 = cond_125687 || ok_or_empty_125725;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) flat_dim_125698, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:139:35-39\n   #9  ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125731 = !cond_125687;
            bool protect_assert_disj_125732 = protect_assert_disj_125726 || loop_not_taken_125731;
            bool index_certs_125733;
            
            if (!protect_assert_disj_125732) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:139:35-39\n   #10 ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125734 = i_lte_j_125703 && y_125727;
            bool protect_assert_disj_125735 = cond_125687 || ok_or_empty_125728;
            bool index_certs_125736;
            
            if (!protect_assert_disj_125735) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:139:35-39\n   #11 ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125737 = ok_or_empty_125728 || loop_not_taken_125731;
            bool index_certs_125738;
            
            if (!protect_assert_disj_125737) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125739 = empty_slice_125700 || forwards_ok_125734;
            bool protect_assert_disj_125740 = cond_125687 || ok_or_empty_125739;
            bool index_certs_125741;
            
            if (!protect_assert_disj_125740) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:139:35-39\n   #11 ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125742 = loop_not_taken_125731 || ok_or_empty_125739;
            bool index_certs_125743;
            
            if (!protect_assert_disj_125742) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 8 * num_merges_125679;
            int64_t bytes_133553 = next_stride_125675 * binop_x_133552;
            bool i_lte_j_125686 = sle64((int64_t) 0, next_stride_125675);
            
            if (mem_133554_cached_sizze_134156 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134156, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134157 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134157, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696;
            int64_t binop_x_133582 = (int64_t) 8 * num_blocks_125695;
            int64_t bytes_133583 = merge_block_sizze_125560 * binop_x_133582;
            int64_t bytes_133628 = (int64_t) 16 * stride_125674;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125679; i_133333++) {
                int64_t start_125747 = mul64(next_stride_125675, i_133333);
                int64_t j_m_i_125748 = sub64(loop_dz2084Uz2082U_125670, start_125747);
                bool empty_slice_125749 = j_m_i_125748 == (int64_t) 0;
                int64_t m_125750 = sub64(j_m_i_125748, (int64_t) 1);
                int64_t i_p_m_t_s_125751 = add64(start_125747, m_125750);
                bool zzero_leq_i_p_m_t_s_125752 = sle64((int64_t) 0, i_p_m_t_s_125751);
                bool i_p_m_t_s_leq_w_125753 = slt64(i_p_m_t_s_125751, loop_dz2084Uz2082U_125670);
                bool zzero_lte_i_125754 = sle64((int64_t) 0, start_125747);
                bool i_lte_j_125755 = sle64(start_125747, loop_dz2084Uz2082U_125670);
                bool y_125756 = i_p_m_t_s_leq_w_125753 && zzero_lte_i_125754;
                bool y_125757 = zzero_leq_i_p_m_t_s_125752 && y_125756;
                bool forwards_ok_125758 = i_lte_j_125755 && y_125757;
                bool ok_or_empty_125759 = empty_slice_125749 || forwards_ok_125758;
                bool index_certs_125760;
                
                if (!ok_or_empty_125759) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125747, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125670, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125761 = slt64(m_125684, j_m_i_125748);
                bool y_125762 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125761;
                bool forwards_ok_125763 = i_lte_j_125686 && y_125762;
                bool ok_or_empty_125764 = zzero_125676 || forwards_ok_125763;
                bool index_certs_125765;
                
                if (!ok_or_empty_125764) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) j_m_i_125748, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:139:35-39\n   #8  ftRelational.fut:138:9-139:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125687) {
                    int64_t dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125707) {
                        int64_t head_res_127969 = ((int64_t *) mem_param_133548.mem)[start_125747];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125747];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125674 + start_125747;
                        int64_t head_res_127972 = ((int64_t *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125675; nest_i_133904++) {
                        ((int64_t *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133628, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125675; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125675; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125697;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125674);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125697);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:139:35-39\n   #9  ftRelational.fut:138:9-139:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:139:35-39\n   #9  ftRelational.fut:138:9-139:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125674 + j_127983;
                                int64_t slice_127993 = start_125747 + slice_127992;
                                int64_t leq_arg1_127994 = ((int64_t *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125747 + i_127980;
                                int64_t leq_arg0_127999 = ((int64_t *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = sle64(leq_arg0_127999, leq_arg1_127994);
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        int64_t loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125674);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:139:35-39\n   #9  ftRelational.fut:138:9-139:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125747 + i_127980;
                            int64_t tmp_128010 = ((int64_t *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125697);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:139:35-39\n   #9  ftRelational.fut:138:9-139:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125674 + j_127983;
                            int64_t slice_128017 = start_125747 + slice_128016;
                            int64_t tmp_128018 = ((int64_t *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((int64_t *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134158 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134158, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134159 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134159, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696; i_133319++) {
                        int64_t split_count_arg3_125827 = mul64(merge_block_sizze_125560, i_133319);
                        int64_t defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125828, &defunc_0_split_count_res_125829, &defunc_0_split_count_res_125830, &defunc_0_split_count_res_125831, &defunc_0_split_count_res_125832, (int64_t) 0, stride_125674, (int64_t) 0, j_m_i_125697, split_count_arg3_125827) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125833 = slt64((int64_t) 0, defunc_0_split_count_res_125832);
                        bool defunc_0_split_count_res_125834;
                        int64_t defunc_0_split_count_res_125835;
                        int64_t defunc_0_split_count_res_125836;
                        int64_t defunc_0_split_count_res_125837;
                        int64_t defunc_0_split_count_res_125838;
                        int64_t defunc_0_split_count_res_125839;
                        bool loop_while_125840;
                        int64_t ss_125841;
                        int64_t ss_125842;
                        int64_t tt_125843;
                        int64_t tt_125844;
                        int64_t count_125845;
                        
                        loop_while_125840 = loop_cond_125833;
                        ss_125841 = defunc_0_split_count_res_125828;
                        ss_125842 = defunc_0_split_count_res_125829;
                        tt_125843 = defunc_0_split_count_res_125830;
                        tt_125844 = defunc_0_split_count_res_125831;
                        count_125845 = defunc_0_split_count_res_125832;
                        while (loop_while_125840) {
                            int64_t zlze_lhs_125846 = sub64(ss_125842, ss_125841);
                            bool cond_125847 = sle64(zlze_lhs_125846, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125848;
                            int64_t defunc_0_lifted_step_res_125849;
                            int64_t defunc_0_lifted_step_res_125850;
                            int64_t defunc_0_lifted_step_res_125851;
                            
                            if (cond_125847) {
                                int64_t tmp_128022 = add64(tt_125843, count_125845);
                                
                                defunc_0_lifted_step_res_125848 = ss_125841;
                                defunc_0_lifted_step_res_125849 = tmp_128022;
                                defunc_0_lifted_step_res_125850 = tt_125844;
                                defunc_0_lifted_step_res_125851 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125853 = sub64(tt_125844, tt_125843);
                                bool cond_125854 = sle64(zlze_lhs_125853, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125855;
                                int64_t defunc_0_lifted_step_res_f_res_125856;
                                int64_t defunc_0_lifted_step_res_f_res_125857;
                                int64_t defunc_0_lifted_step_res_f_res_125858;
                                
                                if (cond_125854) {
                                    int64_t tmp_128023 = add64(ss_125841, count_125845);
                                    
                                    defunc_0_lifted_step_res_f_res_125855 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125856 = tt_125843;
                                    defunc_0_lifted_step_res_f_res_125857 = tt_125844;
                                    defunc_0_lifted_step_res_f_res_125858 = (int64_t) 0;
                                } else {
                                    bool cond_125860 = count_125845 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125861;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125862;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125863;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125864;
                                    
                                    if (cond_125860) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125841);
                                        bool y_128026 = slt64(ss_125841, stride_125674);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125841, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:139:35-39\n   #13 ftRelational.fut:138:9-139:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125843);
                                        bool y_128032 = slt64(tt_125843, j_m_i_125697);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125843, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:139:35-39\n   #13 ftRelational.fut:138:9-139:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125747 + ss_125841;
                                        int64_t leq_arg1_128030 = ((int64_t *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125674 + tt_125843;
                                        int64_t slice_128036 = start_125747 + slice_128035;
                                        int64_t leq_arg0_128037 = ((int64_t *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = sle64(leq_arg0_128037, leq_arg1_128030);
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125843);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125841;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125841);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125843;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = tt_125844;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = (int64_t) 0;
                                    } else {
                                        int64_t m_125883 = sdiv64(count_125845, (int64_t) 2);
                                        int64_t n_125884 = sub64(count_125845, m_125883);
                                        bool cond_125885 = n_125884 == (int64_t) 0;
                                        int64_t zgze_lhs_125886 = add64(ss_125841, m_125883);
                                        bool cond_f_res_125887 = sle64(ss_125842, zgze_lhs_125886);
                                        bool x_125888 = !cond_125885;
                                        bool y_125889 = cond_f_res_125887 && x_125888;
                                        bool cond_125890 = cond_125885 || y_125889;
                                        bool leq_y_x_125891;
                                        
                                        if (cond_125890) {
                                            leq_y_x_125891 = 1;
                                        } else {
                                            bool x_125892 = sle64((int64_t) 0, zgze_lhs_125886);
                                            bool y_125893 = slt64(zgze_lhs_125886, stride_125674);
                                            bool bounds_check_125894 = x_125892 && y_125893;
                                            bool index_certs_125895;
                                            
                                            if (!bounds_check_125894) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125886, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:139:35-39\n   #13 ftRelational.fut:138:9-139:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125898 = add64(tt_125843, n_125884);
                                            int64_t leq_arg0_125899 = sub64(zm_lhs_125898, (int64_t) 1);
                                            bool x_125900 = sle64((int64_t) 0, leq_arg0_125899);
                                            bool y_125901 = slt64(leq_arg0_125899, j_m_i_125697);
                                            bool bounds_check_125902 = x_125900 && y_125901;
                                            bool index_certs_125903;
                                            
                                            if (!bounds_check_125902) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125899, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:139:35-39\n   #13 ftRelational.fut:138:9-139:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125896 = start_125747 + zgze_lhs_125886;
                                            int64_t leq_arg1_125897 = ((int64_t *) mem_param_133548.mem)[slice_125896];
                                            int64_t slice_125904 = stride_125674 + leq_arg0_125899;
                                            int64_t slice_125905 = start_125747 + slice_125904;
                                            int64_t leq_arg0_125906 = ((int64_t *) mem_param_133548.mem)[slice_125905];
                                            bool defunc_0_leq_res_125907 = sle64(leq_arg0_125906, leq_arg1_125897);
                                            
                                            leq_y_x_125891 = defunc_0_leq_res_125907;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                        
                                        if (leq_y_x_125891) {
                                            int64_t tmp_128043 = add64(tt_125843, n_125884);
                                            int64_t tmp_128044 = sub64(count_125845, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tt_125844;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = tmp_128044;
                                        } else {
                                            int64_t tmp_125913 = add64(tt_125843, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tt_125843;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tmp_125913;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = count_125845;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = ss_125841;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                    }
                                    defunc_0_lifted_step_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_125861;
                                    defunc_0_lifted_step_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_125862;
                                    defunc_0_lifted_step_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_125863;
                                    defunc_0_lifted_step_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_125864;
                                }
                                defunc_0_lifted_step_res_125848 = defunc_0_lifted_step_res_f_res_125855;
                                defunc_0_lifted_step_res_125849 = defunc_0_lifted_step_res_f_res_125856;
                                defunc_0_lifted_step_res_125850 = defunc_0_lifted_step_res_f_res_125857;
                                defunc_0_lifted_step_res_125851 = defunc_0_lifted_step_res_f_res_125858;
                            }
                            
                            int64_t loopres_125914;
                            int64_t loopres_125915;
                            int64_t loopres_125916;
                            int64_t loopres_125917;
                            int64_t loopres_125918;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125914, &loopres_125915, &loopres_125916, &loopres_125917, &loopres_125918, defunc_0_lifted_step_res_125848, ss_125842, defunc_0_lifted_step_res_125849, defunc_0_lifted_step_res_125850, defunc_0_lifted_step_res_125851) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125919 = slt64((int64_t) 0, loopres_125918);
                            bool loop_while_tmp_133911 = loop_cond_125919;
                            int64_t ss_tmp_133912 = loopres_125914;
                            int64_t ss_tmp_133913 = loopres_125915;
                            int64_t tt_tmp_133914 = loopres_125916;
                            int64_t tt_tmp_133915 = loopres_125917;
                            int64_t count_tmp_133916 = loopres_125918;
                            
                            loop_while_125840 = loop_while_tmp_133911;
                            ss_125841 = ss_tmp_133912;
                            ss_125842 = ss_tmp_133913;
                            tt_125843 = tt_tmp_133914;
                            tt_125844 = tt_tmp_133915;
                            count_125845 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125834 = loop_while_125840;
                        defunc_0_split_count_res_125835 = ss_125841;
                        defunc_0_split_count_res_125836 = ss_125842;
                        defunc_0_split_count_res_125837 = tt_125843;
                        defunc_0_split_count_res_125838 = tt_125844;
                        defunc_0_split_count_res_125839 = count_125845;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125835;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125837;
                    }
                    if (mem_133584_cached_sizze_134160 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134160, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134161 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134161, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125695; i_133326++) {
                        bool y_125925 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool index_certs_125927;
                        
                        if (!y_125925) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:139:35-39\n   #10 ftRelational.fut:138:9-139:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125928 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125930 = add64((int64_t) 1, i_133326);
                        bool x_125931 = sle64((int64_t) 0, tmp_125930);
                        bool y_125932 = slt64(tmp_125930, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool bounds_check_125933 = x_125931 && y_125932;
                        bool index_certs_125934;
                        
                        if (!bounds_check_125933) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125930, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:139:35-39\n   #10 ftRelational.fut:138:9-139:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125935 = ((int64_t *) mem_133567)[tmp_125930];
                        int64_t defunc_0_f_res_125936 = ((int64_t *) mem_133569)[tmp_125930];
                        int64_t merge_sequential_arg2_125937 = add64(stride_125674, defunc_0_f_res_125929);
                        int64_t merge_sequential_arg2_125938 = add64(stride_125674, defunc_0_f_res_125936);
                        int64_t j_m_i_125939 = sub64(merge_sequential_arg2_125938, merge_sequential_arg2_125937);
                        bool empty_slice_125940 = j_m_i_125939 == (int64_t) 0;
                        int64_t m_125941 = sub64(j_m_i_125939, (int64_t) 1);
                        int64_t i_p_m_t_s_125942 = add64(merge_sequential_arg2_125937, m_125941);
                        bool zzero_leq_i_p_m_t_s_125943 = sle64((int64_t) 0, i_p_m_t_s_125942);
                        bool i_p_m_t_s_leq_w_125944 = slt64(i_p_m_t_s_125942, next_stride_125675);
                        bool zzero_lte_i_125945 = sle64((int64_t) 0, merge_sequential_arg2_125937);
                        bool i_lte_j_125946 = sle64(merge_sequential_arg2_125937, merge_sequential_arg2_125938);
                        bool y_125947 = i_p_m_t_s_leq_w_125944 && zzero_lte_i_125945;
                        bool y_125948 = zzero_leq_i_p_m_t_s_125943 && y_125947;
                        bool forwards_ok_125949 = i_lte_j_125946 && y_125948;
                        bool ok_or_empty_125950 = empty_slice_125940 || forwards_ok_125949;
                        bool index_certs_125951;
                        
                        if (!ok_or_empty_125950) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125937, ":", (long long) merge_sequential_arg2_125938, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:139:35-39\n   #10 ftRelational.fut:138:9-139:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125952 = sub64(defunc_0_f_res_125935, defunc_0_f_res_125928);
                        bool empty_slice_125953 = j_m_i_125952 == (int64_t) 0;
                        int64_t m_125954 = sub64(j_m_i_125952, (int64_t) 1);
                        int64_t i_p_m_t_s_125955 = add64(defunc_0_f_res_125928, m_125954);
                        bool zzero_leq_i_p_m_t_s_125956 = sle64((int64_t) 0, i_p_m_t_s_125955);
                        bool i_p_m_t_s_leq_w_125957 = slt64(i_p_m_t_s_125955, next_stride_125675);
                        bool zzero_lte_i_125958 = sle64((int64_t) 0, defunc_0_f_res_125928);
                        bool i_lte_j_125959 = sle64(defunc_0_f_res_125928, defunc_0_f_res_125935);
                        bool y_125960 = i_p_m_t_s_leq_w_125957 && zzero_lte_i_125958;
                        bool y_125961 = zzero_leq_i_p_m_t_s_125956 && y_125960;
                        bool forwards_ok_125962 = i_lte_j_125959 && y_125961;
                        bool ok_or_empty_125963 = empty_slice_125953 || forwards_ok_125962;
                        bool index_certs_125964;
                        
                        if (!ok_or_empty_125963) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125928, ":", (long long) defunc_0_f_res_125935, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:139:35-39\n   #10 ftRelational.fut:138:9-139:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125965 = slt64((int64_t) 0, j_m_i_125952);
                        int64_t dummy_125966;
                        int64_t dummy_125967;
                        
                        if (cond_125965) {
                            bool index_certs_128045;
                            
                            if (!cond_125965) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:139:35-39\n   #12 ftRelational.fut:138:9-139:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125747 + defunc_0_f_res_125928;
                            int64_t head_res_128047 = ((int64_t *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125966 = head_res_128047;
                            dummy_125967 = head_res_128048;
                        } else {
                            bool y_125972 = slt64((int64_t) 0, j_m_i_125939);
                            bool index_certs_125973;
                            
                            if (!y_125972) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:139:35-39\n   #12 ftRelational.fut:138:9-139:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125974 = start_125747 + merge_sequential_arg2_125937;
                            int64_t head_res_125975 = ((int64_t *) mem_param_133548.mem)[slice_125974];
                            int64_t head_res_125976 = ((int64_t *) mem_param_133551.mem)[slice_125974];
                            
                            dummy_125966 = head_res_125975;
                            dummy_125967 = head_res_125976;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125560; nest_i_133919++) {
                            ((int64_t *) mem_133584)[i_133326 * merge_block_sizze_125560 + nest_i_133919] = dummy_125966;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125560; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + nest_i_133920] = dummy_125967;
                        }
                        
                        int64_t data_125979;
                        int64_t i_125983 = (int64_t) 0;
                        
                        for (int64_t k_125982 = 0; k_125982 < merge_block_sizze_125560; k_125982++) {
                            int64_t j_125986 = sub64(k_125982, i_125983);
                            bool cond_125987 = j_125986 == j_m_i_125939;
                            bool cond_125988;
                            
                            if (cond_125987) {
                                cond_125988 = 1;
                            } else {
                                bool cond_125989 = slt64(i_125983, j_m_i_125952);
                                bool cond_f_res_125990;
                                
                                if (cond_125989) {
                                    bool x_128049 = sle64((int64_t) 0, j_125986);
                                    bool y_128050 = slt64(j_125986, j_m_i_125939);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:139:35-39\n   #11 ftRelational.fut:138:9-139:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125983);
                                    bool bounds_check_128057 = cond_125989 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:139:35-39\n   #11 ftRelational.fut:138:9-139:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125937 + j_125986;
                                    int64_t slice_128054 = start_125747 + slice_128053;
                                    int64_t leq_arg1_128055 = ((int64_t *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125928 + i_125983;
                                    int64_t slice_128060 = start_125747 + slice_128059;
                                    int64_t leq_arg0_128061 = ((int64_t *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = sle64(leq_arg0_128061, leq_arg1_128055);
                                    
                                    cond_f_res_125990 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125990 = 0;
                                }
                                cond_125988 = cond_f_res_125990;
                            }
                            
                            int64_t loopres_126005;
                            int64_t loopres_126006;
                            int64_t loopres_126007;
                            
                            if (cond_125988) {
                                bool x_128064 = sle64((int64_t) 0, i_125983);
                                bool y_128065 = slt64(i_125983, j_m_i_125952);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:139:35-39\n   #11 ftRelational.fut:138:9-139:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125983);
                                int64_t slice_128068 = defunc_0_f_res_125928 + i_125983;
                                int64_t slice_128069 = start_125747 + slice_128068;
                                int64_t tmp_128070 = ((int64_t *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_126005 = tmp_128063;
                                loopres_126006 = tmp_128070;
                                loopres_126007 = tmp_128071;
                            } else {
                                bool x_126017 = sle64((int64_t) 0, j_125986);
                                bool y_126018 = slt64(j_125986, j_m_i_125939);
                                bool bounds_check_126019 = x_126017 && y_126018;
                                bool index_certs_126020;
                                
                                if (!bounds_check_126019) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:139:35-39\n   #11 ftRelational.fut:138:9-139:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126021 = merge_sequential_arg2_125937 + j_125986;
                                int64_t slice_126022 = start_125747 + slice_126021;
                                int64_t tmp_126023 = ((int64_t *) mem_param_133548.mem)[slice_126022];
                                int64_t tmp_126024 = ((int64_t *) mem_param_133551.mem)[slice_126022];
                                
                                loopres_126005 = i_125983;
                                loopres_126006 = tmp_126023;
                                loopres_126007 = tmp_126024;
                            }
                            ((int64_t *) mem_133584)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126006;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126007;
                            
                            int64_t i_tmp_133921 = loopres_126005;
                            
                            i_125983 = i_tmp_133921;
                        }
                        data_125979 = i_125983;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint64_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133583, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133554, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126031 = next_stride_125675 * num_merges_125679;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint64_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            if (memblock_alloc(ctx, &mem_133664, bytes_133553, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            
            bool loop_cond_126034 = slt64(next_stride_125675, flat_dim_125556);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126031;
            bool loop_while_tmp_133898 = loop_cond_126034;
            int64_t stride_tmp_133901 = next_stride_125675;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125670 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125671 = loop_while_tmp_133898;
            stride_125674 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125665 = loop_dz2084Uz2082U_125670;
        data_125666 = loop_while_125671;
        data_125669 = stride_125674;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126035 = n_94325 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126036 = sle64((int64_t) 0, zs_lhs_125540);
        bool i_p_m_t_s_leq_w_126037 = slt64(zs_lhs_125540, data_125665);
        bool y_126038 = zzero_leq_i_p_m_t_s_126036 && i_p_m_t_s_leq_w_126037;
        bool ok_or_empty_126039 = empty_slice_126035 || y_126038;
        bool index_certs_126040;
        
        if (!ok_or_empty_126039) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_94325, "] out of bounds for array of shape [", (long long) data_125665, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:139:35-39\n   #6  ftRelational.fut:138:9-139:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133468, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133468, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_94325; i_133340++) {
        int64_t eta_p_126048 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126049 = sle64((int64_t) 0, eta_p_126048);
        bool y_126050 = slt64(eta_p_126048, n_94325);
        bool bounds_check_126051 = x_126049 && y_126050;
        bool index_certs_126052;
        
        if (!bounds_check_126051) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126048, "] out of bounds for array of shape [", (long long) n_94325, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:139:35-39\n   #5  ftRelational.fut:138:9-139:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t lifted_lambda_res_126053 = ((int64_t *) ext_mem_133467.mem)[eta_p_126048];
        int64_t lifted_lambda_res_126054 = ((int64_t *) xs_mem_133466.mem)[eta_p_126048];
        
        ((int64_t *) mem_133676.mem)[i_133340] = lifted_lambda_res_126053;
        ((int64_t *) mem_133678.mem)[i_133340] = lifted_lambda_res_126054;
    }
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134150, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134151, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortColumn_short(struct futhark_context *ctx, struct memblock *mem_out_p_134162, struct memblock *mem_out_p_134163, struct memblock xs_mem_133466, int64_t n_90039, int64_t incr_90040)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134164 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134165 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134166 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134167 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134168 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134169 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134170 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134171 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134172 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134173 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_90039;
    bool cond_125539 = sle64(n_90039, (int64_t) 1);
    int64_t zs_lhs_125540 = sub64(n_90039, (int64_t) 1);
    int64_t zp_rhs_125541 = sdiv_safe64(zs_lhs_125540, (int64_t) 20);
    int64_t min_num_blocks_125542 = add64((int64_t) 1, zp_rhs_125541);
    bool loop_cond_125543 = slt64((int64_t) 1, min_num_blocks_125542);
    bool smallest_pow_2_geq_than_res_125544;
    int64_t smallest_pow_2_geq_than_res_125545;
    bool loop_while_125546;
    int64_t x_125547;
    
    loop_while_125546 = loop_cond_125543;
    x_125547 = (int64_t) 1;
    while (loop_while_125546) {
        int64_t loopres_125548 = mul64((int64_t) 2, x_125547);
        bool loop_cond_125549 = slt64(loopres_125548, min_num_blocks_125542);
        bool loop_while_tmp_133879 = loop_cond_125549;
        int64_t x_tmp_133880 = loopres_125548;
        
        loop_while_125546 = loop_while_tmp_133879;
        x_125547 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125544 = loop_while_125546;
    smallest_pow_2_geq_than_res_125545 = x_125547;
    
    bool zzero_125550 = smallest_pow_2_geq_than_res_125545 == (int64_t) 0;
    bool nonzzero_125551 = !zzero_125550;
    bool protect_assert_disj_125552 = cond_125539 || nonzzero_125551;
    bool nonzzero_cert_125553;
    
    if (!protect_assert_disj_125552) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:135:35-39\n   #5  ftRelational.fut:134:9-135:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125554 = sdiv_safe64(zs_lhs_125540, smallest_pow_2_geq_than_res_125545);
    int64_t block_sizze_125555 = add64((int64_t) 1, zp_rhs_125554);
    bool y_125561 = slt64((int64_t) 0, n_90039);
    bool protect_assert_disj_133752 = cond_125539 || y_125561;
    bool index_certs_125562;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_90039, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:135:35-39\n   #5  ftRelational.fut:134:9-135:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125576 = slt64(smallest_pow_2_geq_than_res_125545, (int64_t) 0);
    bool valid_125577 = !bounds_invalid_upwards_125576;
    bool protect_assert_disj_133760 = cond_125539 || valid_125577;
    bool range_valid_c_125578;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125545, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:135:35-39\n   #6  ftRelational.fut:134:9-135:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125580 = slt64(block_sizze_125555, (int64_t) 0);
    bool valid_125581 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_133762 = cond_125539 || valid_125581;
    bool range_valid_c_125582;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125555, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125584 = sle64(block_sizze_125555, (int64_t) 1);
    int64_t tmp_125585 = sub64(block_sizze_125555, (int64_t) 2);
    bool bounds_invalid_upwards_125586 = slt64(tmp_125585, (int64_t) 0);
    bool valid_125588 = !bounds_invalid_upwards_125586;
    bool protect_assert_disj_125589 = cond_125584 || valid_125588;
    bool protect_assert_disj_133764 = cond_125539 || protect_assert_disj_125589;
    bool range_valid_c_125590;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125585, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133677 = (int64_t) 2 * n_90039;
    
    if (futrts_indicesWithIncrement_11643(ctx, &ext_mem_133467, xs_mem_133466, n_90039, incr_90040) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_90039; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125556 = smallest_pow_2_geq_than_res_125545 * block_sizze_125555;
    bool x_133747 = !cond_125539;
    int64_t greatest_divisor_leq_than_arg1_125559 = mul64((int64_t) 2, block_sizze_125555);
    int64_t merge_block_sizze_125560;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125559) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125560 = x_133749;
    } else {
        merge_block_sizze_125560 = (int64_t) 0;
    }
    
    int16_t reduce_arg1_125563;
    
    if (x_133747) {
        int16_t x_133753 = ((int16_t *) xs_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125563 = x_133753;
    } else {
        reduce_arg1_125563 = (int16_t) 0;
    }
    
    int16_t defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        int16_t x_133755;
        int64_t x_133756;
        int16_t redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125563;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_90039; i_133300++) {
            int16_t x_125567 = ((int16_t *) xs_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125573 = sle16(redout_133298, x_125567);
            int16_t defunc_0_op_res_125574;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125574 = x_125567;
            } else {
                defunc_0_op_res_125574 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125575;
            
            if (defunc_0_leq_res_125573) {
                defunc_0_op_res_125575 = i_133300;
            } else {
                defunc_0_op_res_125575 = redout_133299;
            }
            
            int16_t redout_tmp_133883 = defunc_0_op_res_125574;
            int64_t redout_tmp_133884 = defunc_0_op_res_125575;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = (int16_t) 0;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125587 = add64((int64_t) 1, tmp_125585);
    int64_t binop_x_133470 = (int64_t) 2 * smallest_pow_2_geq_than_res_125545;
    int64_t bytes_133471 = block_sizze_125555 * binop_x_133470;
    int64_t binop_x_133473 = (int64_t) 8 * smallest_pow_2_geq_than_res_125545;
    int64_t bytes_133474 = block_sizze_125555 * binop_x_133473;
    int64_t bytes_133486 = (int64_t) 8 * block_sizze_125555;
    bool loop_cond_125662 = slt64(block_sizze_125555, flat_dim_125556);
    bool zzero_125663 = merge_block_sizze_125560 == (int64_t) 0;
    bool nonzzero_125664 = !zzero_125663;
    
    if (cond_125539) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134164 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134164, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134165 < bytes_133474) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134165, bytes_133474);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134166 < greatest_divisor_leq_than_arg1_125559) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134166, greatest_divisor_leq_than_arg1_125559);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134167 < bytes_133486) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134167, bytes_133486);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125545; i_133312++) {
            int64_t zp_lhs_125594 = mul64(block_sizze_125555, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125555; i_133305++) {
                int64_t k_125598 = add64(zp_lhs_125594, i_133305);
                bool cond_125599 = slt64(k_125598, n_90039);
                int16_t lifted_lambda_res_125600;
                int64_t lifted_lambda_res_125601;
                
                if (cond_125599) {
                    bool x_127931 = sle64((int64_t) 0, k_125598);
                    bool bounds_check_127932 = cond_125599 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125598, "] out of bounds for array of shape [", (long long) n_90039, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:135:35-39\n   #9  ftRelational.fut:134:9-135:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int16_t lifted_lambda_res_t_res_127934 = ((int16_t *) xs_mem_133466.mem)[k_125598];
                    
                    lifted_lambda_res_125600 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125601 = k_125598;
                } else {
                    lifted_lambda_res_125600 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125601 = defunc_0_reduce_res_128079;
                }
                ((int16_t *) mem_133485)[i_133305] = lifted_lambda_res_125600;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125601;
            }
            if (!cond_125584) {
                for (int64_t i_125611 = 0; i_125611 < distance_125587; i_125611++) {
                    int64_t gt_arg1_125614 = add64((int64_t) 1, i_125611);
                    bool x_125615 = sle64((int64_t) 0, gt_arg1_125614);
                    bool y_125616 = slt64(gt_arg1_125614, block_sizze_125555);
                    bool bounds_check_125617 = x_125615 && y_125616;
                    bool index_certs_125618;
                    
                    if (!bounds_check_125617) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125614, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125620 = slt64(i_125611, block_sizze_125555);
                    bool index_certs_125621;
                    
                    if (!y_125620) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125611, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int16_t gt_arg1_125619 = ((int16_t *) mem_133485)[gt_arg1_125614];
                    int16_t gt_arg0_125622 = ((int16_t *) mem_133485)[i_125611];
                    bool defunc_0_leq_res_125623 = sle16(gt_arg0_125622, gt_arg1_125619);
                    bool defunc_0_lifted_gt_res_125624 = !defunc_0_leq_res_125623;
                    bool s_125625;
                    int64_t s_125628;
                    bool loop_while_125629;
                    int64_t j_125632;
                    
                    loop_while_125629 = defunc_0_lifted_gt_res_125624;
                    j_125632 = i_125611;
                    while (loop_while_125629) {
                        bool x_125633 = sle64((int64_t) 0, j_125632);
                        bool y_125634 = slt64(j_125632, block_sizze_125555);
                        bool bounds_check_125635 = x_125633 && y_125634;
                        bool index_certs_125636;
                        
                        if (!bounds_check_125635) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125632, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125639 = add64((int64_t) 1, j_125632);
                        bool x_125640 = sle64((int64_t) 0, copy_arg0_125639);
                        bool y_125641 = slt64(copy_arg0_125639, block_sizze_125555);
                        bool bounds_check_125642 = x_125640 && y_125641;
                        bool index_certs_125643;
                        
                        if (!bounds_check_125642) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125639, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int16_t copy_arg0_125637 = ((int16_t *) mem_133485)[j_125632];
                        int64_t copy_arg0_125638 = ((int64_t *) mem_133487)[j_125632];
                        int16_t copy_arg0_125644 = ((int16_t *) mem_133485)[copy_arg0_125639];
                        int64_t copy_arg0_125645 = ((int64_t *) mem_133487)[copy_arg0_125639];
                        
                        ((int16_t *) mem_133485)[j_125632] = copy_arg0_125644;
                        ((int64_t *) mem_133487)[j_125632] = copy_arg0_125645;
                        ((int16_t *) mem_133485)[copy_arg0_125639] = copy_arg0_125637;
                        ((int64_t *) mem_133487)[copy_arg0_125639] = copy_arg0_125638;
                        
                        int64_t tmp_125650 = sub64(j_125632, (int64_t) 1);
                        bool cond_125651 = sle64((int64_t) 0, tmp_125650);
                        bool loop_cond_125652;
                        
                        if (cond_125651) {
                            bool y_127936 = slt64(tmp_125650, block_sizze_125555);
                            bool bounds_check_127937 = cond_125651 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125650, "] out of bounds for array of shape [", (long long) block_sizze_125555, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int16_t gt_arg1_127935 = ((int16_t *) mem_133485)[j_125632];
                            int16_t gt_arg0_127939 = ((int16_t *) mem_133485)[tmp_125650];
                            bool defunc_0_leq_res_127940 = sle16(gt_arg0_127939, gt_arg1_127935);
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125652 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125652 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125652;
                        int64_t j_tmp_133894 = tmp_125650;
                        
                        loop_while_125629 = loop_while_tmp_133891;
                        j_125632 = j_tmp_133894;
                    }
                    s_125625 = loop_while_125629;
                    s_125628 = j_125632;
                }
            }
            lmad_copy_2b(ctx, 1, (uint16_t *) mem_133472, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint16_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125555, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125555});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_2b(ctx, 2, (uint16_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint16_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        if (memblock_alloc(ctx, &mem_133544, bytes_133474, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125555, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125545, block_sizze_125555});
        
        int64_t data_125665;
        bool data_125666;
        int64_t data_125669;
        int64_t loop_dz2084Uz2082U_125670;
        bool loop_while_125671;
        int64_t stride_125674;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125670 = flat_dim_125556;
        loop_while_125671 = loop_cond_125662;
        stride_125674 = block_sizze_125555;
        while (loop_while_125671) {
            int64_t next_stride_125675 = mul64((int64_t) 2, stride_125674);
            bool zzero_125676 = next_stride_125675 == (int64_t) 0;
            bool nonzzero_125677 = !zzero_125676;
            bool nonzzero_cert_125678;
            
            if (!nonzzero_125677) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:135:35-39\n   #5  ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125679 = sdiv64(flat_dim_125556, next_stride_125675);
            bool bounds_invalid_upwards_125680 = slt64(num_merges_125679, (int64_t) 0);
            bool valid_125681 = !bounds_invalid_upwards_125680;
            bool range_valid_c_125682;
            
            if (!valid_125681) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125679, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:135:35-39\n   #6  ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125684 = sub64(next_stride_125675, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125685 = sle64((int64_t) 0, m_125684);
            bool cond_125687 = slt64(next_stride_125675, (int64_t) 10);
            bool protect_assert_disj_125688 = nonzzero_125664 || cond_125687;
            bool nonzzero_cert_125689;
            
            if (!protect_assert_disj_125688) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125690 = smod_safe64(next_stride_125675, merge_block_sizze_125560);
            bool num_blocks_125691 = zeze_lhs_125690 == (int64_t) 0;
            bool protect_assert_disj_125692 = cond_125687 || num_blocks_125691;
            bool assert_c_125693;
            
            if (!protect_assert_disj_125692) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125695 = sdiv_safe64(next_stride_125675, merge_block_sizze_125560);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696 = add64((int64_t) 1, num_blocks_125695);
            int64_t j_m_i_125697 = sub64(next_stride_125675, stride_125674);
            int64_t flat_dim_125698 = merge_block_sizze_125560 * num_blocks_125695;
            bool bounds_invalid_upwards_125699 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, (int64_t) 0);
            bool empty_slice_125700 = j_m_i_125697 == (int64_t) 0;
            int64_t m_125701 = sub64(j_m_i_125697, (int64_t) 1);
            bool zzero_lte_i_125702 = sle64((int64_t) 0, stride_125674);
            bool i_lte_j_125703 = sle64(stride_125674, next_stride_125675);
            bool empty_slice_125704 = stride_125674 == (int64_t) 0;
            int64_t m_125705 = sub64(stride_125674, (int64_t) 1);
            bool bounds_invalid_upwards_125706 = slt64(num_blocks_125695, (int64_t) 0);
            bool cond_125707 = slt64((int64_t) 0, stride_125674);
            bool valid_125708 = !bounds_invalid_upwards_125699;
            int64_t i_p_m_t_s_125709 = add64(stride_125674, m_125701);
            bool zzero_leq_i_p_m_t_s_125710 = sle64((int64_t) 0, m_125705);
            bool i_p_m_t_s_leq_w_125711 = slt64(m_125705, next_stride_125675);
            bool valid_125712 = !bounds_invalid_upwards_125706;
            bool i_p_m_t_s_leq_w_125713 = slt64(m_125684, flat_dim_125698);
            bool y_125714 = slt64((int64_t) 0, j_m_i_125697);
            bool protect_assert_disj_125715 = cond_125687 || valid_125708;
            bool range_valid_c_125716;
            
            if (!protect_assert_disj_125715) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:135:35-39\n   #10 ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125717 = sle64((int64_t) 0, i_p_m_t_s_125709);
            bool i_p_m_t_s_leq_w_125718 = slt64(i_p_m_t_s_125709, next_stride_125675);
            bool y_125719 = zzero_leq_i_p_m_t_s_125710 && i_p_m_t_s_leq_w_125711;
            bool protect_assert_disj_125720 = cond_125687 || valid_125712;
            bool range_valid_c_125721;
            
            if (!protect_assert_disj_125720) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125695, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:135:35-39\n   #9  ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125722 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125713;
            bool y_125723 = zzero_lte_i_125702 && i_p_m_t_s_leq_w_125718;
            bool forwards_ok_125724 = zzero_lte_i_125702 && y_125719;
            bool ok_or_empty_125725 = zzero_125676 || y_125722;
            bool protect_assert_disj_125726 = cond_125707 || y_125714;
            bool y_125727 = zzero_leq_i_p_m_t_s_125717 && y_125723;
            bool ok_or_empty_125728 = empty_slice_125704 || forwards_ok_125724;
            bool protect_assert_disj_125729 = cond_125687 || ok_or_empty_125725;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) flat_dim_125698, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:135:35-39\n   #9  ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125731 = !cond_125687;
            bool protect_assert_disj_125732 = protect_assert_disj_125726 || loop_not_taken_125731;
            bool index_certs_125733;
            
            if (!protect_assert_disj_125732) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:135:35-39\n   #10 ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125734 = i_lte_j_125703 && y_125727;
            bool protect_assert_disj_125735 = cond_125687 || ok_or_empty_125728;
            bool index_certs_125736;
            
            if (!protect_assert_disj_125735) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:135:35-39\n   #11 ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125737 = ok_or_empty_125728 || loop_not_taken_125731;
            bool index_certs_125738;
            
            if (!protect_assert_disj_125737) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125674, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125739 = empty_slice_125700 || forwards_ok_125734;
            bool protect_assert_disj_125740 = cond_125687 || ok_or_empty_125739;
            bool index_certs_125741;
            
            if (!protect_assert_disj_125740) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:135:35-39\n   #11 ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125742 = loop_not_taken_125731 || ok_or_empty_125739;
            bool index_certs_125743;
            
            if (!protect_assert_disj_125742) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125674, ":] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 2 * num_merges_125679;
            int64_t bytes_133553 = next_stride_125675 * binop_x_133552;
            int64_t binop_x_133555 = (int64_t) 8 * num_merges_125679;
            int64_t bytes_133556 = next_stride_125675 * binop_x_133555;
            bool i_lte_j_125686 = sle64((int64_t) 0, next_stride_125675);
            
            if (mem_133554_cached_sizze_134168 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134168, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134169 < bytes_133556) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134169, bytes_133556);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696;
            int64_t binop_x_133582 = (int64_t) 2 * num_blocks_125695;
            int64_t bytes_133583 = merge_block_sizze_125560 * binop_x_133582;
            int64_t binop_x_133585 = (int64_t) 8 * num_blocks_125695;
            int64_t bytes_133586 = merge_block_sizze_125560 * binop_x_133585;
            int64_t bytes_133628 = (int64_t) 4 * stride_125674;
            int64_t bytes_133630 = (int64_t) 16 * stride_125674;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125679; i_133333++) {
                int64_t start_125747 = mul64(next_stride_125675, i_133333);
                int64_t j_m_i_125748 = sub64(loop_dz2084Uz2082U_125670, start_125747);
                bool empty_slice_125749 = j_m_i_125748 == (int64_t) 0;
                int64_t m_125750 = sub64(j_m_i_125748, (int64_t) 1);
                int64_t i_p_m_t_s_125751 = add64(start_125747, m_125750);
                bool zzero_leq_i_p_m_t_s_125752 = sle64((int64_t) 0, i_p_m_t_s_125751);
                bool i_p_m_t_s_leq_w_125753 = slt64(i_p_m_t_s_125751, loop_dz2084Uz2082U_125670);
                bool zzero_lte_i_125754 = sle64((int64_t) 0, start_125747);
                bool i_lte_j_125755 = sle64(start_125747, loop_dz2084Uz2082U_125670);
                bool y_125756 = i_p_m_t_s_leq_w_125753 && zzero_lte_i_125754;
                bool y_125757 = zzero_leq_i_p_m_t_s_125752 && y_125756;
                bool forwards_ok_125758 = i_lte_j_125755 && y_125757;
                bool ok_or_empty_125759 = empty_slice_125749 || forwards_ok_125758;
                bool index_certs_125760;
                
                if (!ok_or_empty_125759) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125747, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125670, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125761 = slt64(m_125684, j_m_i_125748);
                bool y_125762 = zzero_leq_i_p_m_t_s_125685 && i_p_m_t_s_leq_w_125761;
                bool forwards_ok_125763 = i_lte_j_125686 && y_125762;
                bool ok_or_empty_125764 = zzero_125676 || forwards_ok_125763;
                bool index_certs_125765;
                
                if (!ok_or_empty_125764) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125675, "] out of bounds for array of shape [", (long long) j_m_i_125748, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:152:60-63\n   #7  ftRelational.fut:135:35-39\n   #8  ftRelational.fut:134:9-135:39\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125687) {
                    int16_t dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125707) {
                        int16_t head_res_127969 = ((int16_t *) mem_param_133548.mem)[start_125747];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125747];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125674 + start_125747;
                        int16_t head_res_127972 = ((int16_t *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125675; nest_i_133904++) {
                        ((int16_t *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133630, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125675; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125675; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125697;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125674);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125697);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:135:35-39\n   #9  ftRelational.fut:134:9-135:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:135:35-39\n   #9  ftRelational.fut:134:9-135:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125674 + j_127983;
                                int64_t slice_127993 = start_125747 + slice_127992;
                                int16_t leq_arg1_127994 = ((int16_t *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125747 + i_127980;
                                int16_t leq_arg0_127999 = ((int16_t *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = sle16(leq_arg0_127999, leq_arg1_127994);
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        int16_t loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125674);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:135:35-39\n   #9  ftRelational.fut:134:9-135:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125747 + i_127980;
                            int16_t tmp_128010 = ((int16_t *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125697);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:152:60-63\n   #8  ftRelational.fut:135:35-39\n   #9  ftRelational.fut:134:9-135:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125674 + j_127983;
                            int64_t slice_128017 = start_125747 + slice_128016;
                            int16_t tmp_128018 = ((int16_t *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((int16_t *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134170 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134170, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134171 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134171, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696; i_133319++) {
                        int64_t split_count_arg3_125827 = mul64(merge_block_sizze_125560, i_133319);
                        int64_t defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125828, &defunc_0_split_count_res_125829, &defunc_0_split_count_res_125830, &defunc_0_split_count_res_125831, &defunc_0_split_count_res_125832, (int64_t) 0, stride_125674, (int64_t) 0, j_m_i_125697, split_count_arg3_125827) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125833 = slt64((int64_t) 0, defunc_0_split_count_res_125832);
                        bool defunc_0_split_count_res_125834;
                        int64_t defunc_0_split_count_res_125835;
                        int64_t defunc_0_split_count_res_125836;
                        int64_t defunc_0_split_count_res_125837;
                        int64_t defunc_0_split_count_res_125838;
                        int64_t defunc_0_split_count_res_125839;
                        bool loop_while_125840;
                        int64_t ss_125841;
                        int64_t ss_125842;
                        int64_t tt_125843;
                        int64_t tt_125844;
                        int64_t count_125845;
                        
                        loop_while_125840 = loop_cond_125833;
                        ss_125841 = defunc_0_split_count_res_125828;
                        ss_125842 = defunc_0_split_count_res_125829;
                        tt_125843 = defunc_0_split_count_res_125830;
                        tt_125844 = defunc_0_split_count_res_125831;
                        count_125845 = defunc_0_split_count_res_125832;
                        while (loop_while_125840) {
                            int64_t zlze_lhs_125846 = sub64(ss_125842, ss_125841);
                            bool cond_125847 = sle64(zlze_lhs_125846, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125848;
                            int64_t defunc_0_lifted_step_res_125849;
                            int64_t defunc_0_lifted_step_res_125850;
                            int64_t defunc_0_lifted_step_res_125851;
                            
                            if (cond_125847) {
                                int64_t tmp_128022 = add64(tt_125843, count_125845);
                                
                                defunc_0_lifted_step_res_125848 = ss_125841;
                                defunc_0_lifted_step_res_125849 = tmp_128022;
                                defunc_0_lifted_step_res_125850 = tt_125844;
                                defunc_0_lifted_step_res_125851 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125853 = sub64(tt_125844, tt_125843);
                                bool cond_125854 = sle64(zlze_lhs_125853, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125855;
                                int64_t defunc_0_lifted_step_res_f_res_125856;
                                int64_t defunc_0_lifted_step_res_f_res_125857;
                                int64_t defunc_0_lifted_step_res_f_res_125858;
                                
                                if (cond_125854) {
                                    int64_t tmp_128023 = add64(ss_125841, count_125845);
                                    
                                    defunc_0_lifted_step_res_f_res_125855 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125856 = tt_125843;
                                    defunc_0_lifted_step_res_f_res_125857 = tt_125844;
                                    defunc_0_lifted_step_res_f_res_125858 = (int64_t) 0;
                                } else {
                                    bool cond_125860 = count_125845 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125861;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125862;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125863;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125864;
                                    
                                    if (cond_125860) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125841);
                                        bool y_128026 = slt64(ss_125841, stride_125674);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125841, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:135:35-39\n   #13 ftRelational.fut:134:9-135:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125843);
                                        bool y_128032 = slt64(tt_125843, j_m_i_125697);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125843, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:135:35-39\n   #13 ftRelational.fut:134:9-135:39\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125747 + ss_125841;
                                        int16_t leq_arg1_128030 = ((int16_t *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125674 + tt_125843;
                                        int64_t slice_128036 = start_125747 + slice_128035;
                                        int16_t leq_arg0_128037 = ((int16_t *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = sle16(leq_arg0_128037, leq_arg1_128030);
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125843);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125841;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125841);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125843;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = tt_125844;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = (int64_t) 0;
                                    } else {
                                        int64_t m_125883 = sdiv64(count_125845, (int64_t) 2);
                                        int64_t n_125884 = sub64(count_125845, m_125883);
                                        bool cond_125885 = n_125884 == (int64_t) 0;
                                        int64_t zgze_lhs_125886 = add64(ss_125841, m_125883);
                                        bool cond_f_res_125887 = sle64(ss_125842, zgze_lhs_125886);
                                        bool x_125888 = !cond_125885;
                                        bool y_125889 = cond_f_res_125887 && x_125888;
                                        bool cond_125890 = cond_125885 || y_125889;
                                        bool leq_y_x_125891;
                                        
                                        if (cond_125890) {
                                            leq_y_x_125891 = 1;
                                        } else {
                                            bool x_125892 = sle64((int64_t) 0, zgze_lhs_125886);
                                            bool y_125893 = slt64(zgze_lhs_125886, stride_125674);
                                            bool bounds_check_125894 = x_125892 && y_125893;
                                            bool index_certs_125895;
                                            
                                            if (!bounds_check_125894) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125886, "] out of bounds for array of shape [", (long long) stride_125674, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:135:35-39\n   #13 ftRelational.fut:134:9-135:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125898 = add64(tt_125843, n_125884);
                                            int64_t leq_arg0_125899 = sub64(zm_lhs_125898, (int64_t) 1);
                                            bool x_125900 = sle64((int64_t) 0, leq_arg0_125899);
                                            bool y_125901 = slt64(leq_arg0_125899, j_m_i_125697);
                                            bool bounds_check_125902 = x_125900 && y_125901;
                                            bool index_certs_125903;
                                            
                                            if (!bounds_check_125902) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125899, "] out of bounds for array of shape [", (long long) j_m_i_125697, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:152:60-63\n   #12 ftRelational.fut:135:35-39\n   #13 ftRelational.fut:134:9-135:39\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125896 = start_125747 + zgze_lhs_125886;
                                            int16_t leq_arg1_125897 = ((int16_t *) mem_param_133548.mem)[slice_125896];
                                            int64_t slice_125904 = stride_125674 + leq_arg0_125899;
                                            int64_t slice_125905 = start_125747 + slice_125904;
                                            int16_t leq_arg0_125906 = ((int16_t *) mem_param_133548.mem)[slice_125905];
                                            bool defunc_0_leq_res_125907 = sle16(leq_arg0_125906, leq_arg1_125897);
                                            
                                            leq_y_x_125891 = defunc_0_leq_res_125907;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                        
                                        if (leq_y_x_125891) {
                                            int64_t tmp_128043 = add64(tt_125843, n_125884);
                                            int64_t tmp_128044 = sub64(count_125845, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tt_125844;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = tmp_128044;
                                        } else {
                                            int64_t tmp_125913 = add64(tt_125843, n_125884);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125908 = tt_125843;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125909 = tmp_125913;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125910 = count_125845;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125861 = ss_125841;
                                        defunc_0_lifted_step_res_f_res_f_res_125862 = defunc_0_lifted_step_res_f_res_f_res_f_res_125908;
                                        defunc_0_lifted_step_res_f_res_f_res_125863 = defunc_0_lifted_step_res_f_res_f_res_f_res_125909;
                                        defunc_0_lifted_step_res_f_res_f_res_125864 = defunc_0_lifted_step_res_f_res_f_res_f_res_125910;
                                    }
                                    defunc_0_lifted_step_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_125861;
                                    defunc_0_lifted_step_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_125862;
                                    defunc_0_lifted_step_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_125863;
                                    defunc_0_lifted_step_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_125864;
                                }
                                defunc_0_lifted_step_res_125848 = defunc_0_lifted_step_res_f_res_125855;
                                defunc_0_lifted_step_res_125849 = defunc_0_lifted_step_res_f_res_125856;
                                defunc_0_lifted_step_res_125850 = defunc_0_lifted_step_res_f_res_125857;
                                defunc_0_lifted_step_res_125851 = defunc_0_lifted_step_res_f_res_125858;
                            }
                            
                            int64_t loopres_125914;
                            int64_t loopres_125915;
                            int64_t loopres_125916;
                            int64_t loopres_125917;
                            int64_t loopres_125918;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125914, &loopres_125915, &loopres_125916, &loopres_125917, &loopres_125918, defunc_0_lifted_step_res_125848, ss_125842, defunc_0_lifted_step_res_125849, defunc_0_lifted_step_res_125850, defunc_0_lifted_step_res_125851) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125919 = slt64((int64_t) 0, loopres_125918);
                            bool loop_while_tmp_133911 = loop_cond_125919;
                            int64_t ss_tmp_133912 = loopres_125914;
                            int64_t ss_tmp_133913 = loopres_125915;
                            int64_t tt_tmp_133914 = loopres_125916;
                            int64_t tt_tmp_133915 = loopres_125917;
                            int64_t count_tmp_133916 = loopres_125918;
                            
                            loop_while_125840 = loop_while_tmp_133911;
                            ss_125841 = ss_tmp_133912;
                            ss_125842 = ss_tmp_133913;
                            tt_125843 = tt_tmp_133914;
                            tt_125844 = tt_tmp_133915;
                            count_125845 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125834 = loop_while_125840;
                        defunc_0_split_count_res_125835 = ss_125841;
                        defunc_0_split_count_res_125836 = ss_125842;
                        defunc_0_split_count_res_125837 = tt_125843;
                        defunc_0_split_count_res_125838 = tt_125844;
                        defunc_0_split_count_res_125839 = count_125845;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125835;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125837;
                    }
                    if (mem_133584_cached_sizze_134172 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134172, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134173 < bytes_133586) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134173, bytes_133586);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125695; i_133326++) {
                        bool y_125925 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool index_certs_125927;
                        
                        if (!y_125925) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:135:35-39\n   #10 ftRelational.fut:134:9-135:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125928 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125930 = add64((int64_t) 1, i_133326);
                        bool x_125931 = sle64((int64_t) 0, tmp_125930);
                        bool y_125932 = slt64(tmp_125930, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696);
                        bool bounds_check_125933 = x_125931 && y_125932;
                        bool index_certs_125934;
                        
                        if (!bounds_check_125933) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125930, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125696, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:135:35-39\n   #10 ftRelational.fut:134:9-135:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125935 = ((int64_t *) mem_133567)[tmp_125930];
                        int64_t defunc_0_f_res_125936 = ((int64_t *) mem_133569)[tmp_125930];
                        int64_t merge_sequential_arg2_125937 = add64(stride_125674, defunc_0_f_res_125929);
                        int64_t merge_sequential_arg2_125938 = add64(stride_125674, defunc_0_f_res_125936);
                        int64_t j_m_i_125939 = sub64(merge_sequential_arg2_125938, merge_sequential_arg2_125937);
                        bool empty_slice_125940 = j_m_i_125939 == (int64_t) 0;
                        int64_t m_125941 = sub64(j_m_i_125939, (int64_t) 1);
                        int64_t i_p_m_t_s_125942 = add64(merge_sequential_arg2_125937, m_125941);
                        bool zzero_leq_i_p_m_t_s_125943 = sle64((int64_t) 0, i_p_m_t_s_125942);
                        bool i_p_m_t_s_leq_w_125944 = slt64(i_p_m_t_s_125942, next_stride_125675);
                        bool zzero_lte_i_125945 = sle64((int64_t) 0, merge_sequential_arg2_125937);
                        bool i_lte_j_125946 = sle64(merge_sequential_arg2_125937, merge_sequential_arg2_125938);
                        bool y_125947 = i_p_m_t_s_leq_w_125944 && zzero_lte_i_125945;
                        bool y_125948 = zzero_leq_i_p_m_t_s_125943 && y_125947;
                        bool forwards_ok_125949 = i_lte_j_125946 && y_125948;
                        bool ok_or_empty_125950 = empty_slice_125940 || forwards_ok_125949;
                        bool index_certs_125951;
                        
                        if (!ok_or_empty_125950) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125937, ":", (long long) merge_sequential_arg2_125938, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:135:35-39\n   #10 ftRelational.fut:134:9-135:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125952 = sub64(defunc_0_f_res_125935, defunc_0_f_res_125928);
                        bool empty_slice_125953 = j_m_i_125952 == (int64_t) 0;
                        int64_t m_125954 = sub64(j_m_i_125952, (int64_t) 1);
                        int64_t i_p_m_t_s_125955 = add64(defunc_0_f_res_125928, m_125954);
                        bool zzero_leq_i_p_m_t_s_125956 = sle64((int64_t) 0, i_p_m_t_s_125955);
                        bool i_p_m_t_s_leq_w_125957 = slt64(i_p_m_t_s_125955, next_stride_125675);
                        bool zzero_lte_i_125958 = sle64((int64_t) 0, defunc_0_f_res_125928);
                        bool i_lte_j_125959 = sle64(defunc_0_f_res_125928, defunc_0_f_res_125935);
                        bool y_125960 = i_p_m_t_s_leq_w_125957 && zzero_lte_i_125958;
                        bool y_125961 = zzero_leq_i_p_m_t_s_125956 && y_125960;
                        bool forwards_ok_125962 = i_lte_j_125959 && y_125961;
                        bool ok_or_empty_125963 = empty_slice_125953 || forwards_ok_125962;
                        bool index_certs_125964;
                        
                        if (!ok_or_empty_125963) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125928, ":", (long long) defunc_0_f_res_125935, "] out of bounds for array of shape [", (long long) next_stride_125675, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:152:60-63\n   #9  ftRelational.fut:135:35-39\n   #10 ftRelational.fut:134:9-135:39\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125965 = slt64((int64_t) 0, j_m_i_125952);
                        int16_t dummy_125966;
                        int64_t dummy_125967;
                        
                        if (cond_125965) {
                            bool index_certs_128045;
                            
                            if (!cond_125965) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:135:35-39\n   #12 ftRelational.fut:134:9-135:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125747 + defunc_0_f_res_125928;
                            int16_t head_res_128047 = ((int16_t *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125966 = head_res_128047;
                            dummy_125967 = head_res_128048;
                        } else {
                            bool y_125972 = slt64((int64_t) 0, j_m_i_125939);
                            bool index_certs_125973;
                            
                            if (!y_125972) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:152:60-63\n   #11 ftRelational.fut:135:35-39\n   #12 ftRelational.fut:134:9-135:39\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125974 = start_125747 + merge_sequential_arg2_125937;
                            int16_t head_res_125975 = ((int16_t *) mem_param_133548.mem)[slice_125974];
                            int64_t head_res_125976 = ((int64_t *) mem_param_133551.mem)[slice_125974];
                            
                            dummy_125966 = head_res_125975;
                            dummy_125967 = head_res_125976;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125560; nest_i_133919++) {
                            ((int16_t *) mem_133584)[i_133326 * merge_block_sizze_125560 + nest_i_133919] = dummy_125966;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125560; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + nest_i_133920] = dummy_125967;
                        }
                        
                        int64_t data_125979;
                        int64_t i_125983 = (int64_t) 0;
                        
                        for (int64_t k_125982 = 0; k_125982 < merge_block_sizze_125560; k_125982++) {
                            int64_t j_125986 = sub64(k_125982, i_125983);
                            bool cond_125987 = j_125986 == j_m_i_125939;
                            bool cond_125988;
                            
                            if (cond_125987) {
                                cond_125988 = 1;
                            } else {
                                bool cond_125989 = slt64(i_125983, j_m_i_125952);
                                bool cond_f_res_125990;
                                
                                if (cond_125989) {
                                    bool x_128049 = sle64((int64_t) 0, j_125986);
                                    bool y_128050 = slt64(j_125986, j_m_i_125939);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:135:35-39\n   #11 ftRelational.fut:134:9-135:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125983);
                                    bool bounds_check_128057 = cond_125989 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:135:35-39\n   #11 ftRelational.fut:134:9-135:39\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125937 + j_125986;
                                    int64_t slice_128054 = start_125747 + slice_128053;
                                    int16_t leq_arg1_128055 = ((int16_t *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125928 + i_125983;
                                    int64_t slice_128060 = start_125747 + slice_128059;
                                    int16_t leq_arg0_128061 = ((int16_t *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = sle16(leq_arg0_128061, leq_arg1_128055);
                                    
                                    cond_f_res_125990 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125990 = 0;
                                }
                                cond_125988 = cond_f_res_125990;
                            }
                            
                            int64_t loopres_126005;
                            int16_t loopres_126006;
                            int64_t loopres_126007;
                            
                            if (cond_125988) {
                                bool x_128064 = sle64((int64_t) 0, i_125983);
                                bool y_128065 = slt64(i_125983, j_m_i_125952);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125983, "] out of bounds for array of shape [", (long long) j_m_i_125952, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:135:35-39\n   #11 ftRelational.fut:134:9-135:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125983);
                                int64_t slice_128068 = defunc_0_f_res_125928 + i_125983;
                                int64_t slice_128069 = start_125747 + slice_128068;
                                int16_t tmp_128070 = ((int16_t *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_126005 = tmp_128063;
                                loopres_126006 = tmp_128070;
                                loopres_126007 = tmp_128071;
                            } else {
                                bool x_126017 = sle64((int64_t) 0, j_125986);
                                bool y_126018 = slt64(j_125986, j_m_i_125939);
                                bool bounds_check_126019 = x_126017 && y_126018;
                                bool index_certs_126020;
                                
                                if (!bounds_check_126019) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125986, "] out of bounds for array of shape [", (long long) j_m_i_125939, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:152:60-63\n   #10 ftRelational.fut:135:35-39\n   #11 ftRelational.fut:134:9-135:39\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126021 = merge_sequential_arg2_125937 + j_125986;
                                int64_t slice_126022 = start_125747 + slice_126021;
                                int16_t tmp_126023 = ((int16_t *) mem_param_133548.mem)[slice_126022];
                                int64_t tmp_126024 = ((int64_t *) mem_param_133551.mem)[slice_126022];
                                
                                loopres_126005 = i_125983;
                                loopres_126006 = tmp_126023;
                                loopres_126007 = tmp_126024;
                            }
                            ((int16_t *) mem_133584)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126006;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125560 + k_125982] = loopres_126007;
                            
                            int64_t i_tmp_133921 = loopres_126005;
                            
                            i_125983 = i_tmp_133921;
                        }
                        data_125979 = i_125983;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_2b(ctx, 2, (uint16_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint16_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133586, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125560, (int64_t) 1}, (int64_t []) {num_blocks_125695, merge_block_sizze_125560});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_2b(ctx, 1, (uint16_t *) mem_133554, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint16_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125675, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125675});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126031 = next_stride_125675 * num_merges_125679;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_2b(ctx, 2, (uint16_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint16_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            if (memblock_alloc(ctx, &mem_133664, bytes_133556, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125675, (int64_t) 1}, (int64_t []) {num_merges_125679, next_stride_125675});
            
            bool loop_cond_126034 = slt64(next_stride_125675, flat_dim_125556);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126031;
            bool loop_while_tmp_133898 = loop_cond_126034;
            int64_t stride_tmp_133901 = next_stride_125675;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125670 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125671 = loop_while_tmp_133898;
            stride_125674 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125665 = loop_dz2084Uz2082U_125670;
        data_125666 = loop_while_125671;
        data_125669 = stride_125674;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126035 = n_90039 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126036 = sle64((int64_t) 0, zs_lhs_125540);
        bool i_p_m_t_s_leq_w_126037 = slt64(zs_lhs_125540, data_125665);
        bool y_126038 = zzero_leq_i_p_m_t_s_126036 && i_p_m_t_s_leq_w_126037;
        bool ok_or_empty_126039 = empty_slice_126035 || y_126038;
        bool index_certs_126040;
        
        if (!ok_or_empty_126039) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_90039, "] out of bounds for array of shape [", (long long) data_125665, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:152:60-63\n   #5  ftRelational.fut:135:35-39\n   #6  ftRelational.fut:134:9-135:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133468, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133677, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_90039; i_133340++) {
        int64_t eta_p_126048 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126049 = sle64((int64_t) 0, eta_p_126048);
        bool y_126050 = slt64(eta_p_126048, n_90039);
        bool bounds_check_126051 = x_126049 && y_126050;
        bool index_certs_126052;
        
        if (!bounds_check_126051) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126048, "] out of bounds for array of shape [", (long long) n_90039, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:152:60-63\n   #4  ftRelational.fut:135:35-39\n   #5  ftRelational.fut:134:9-135:39\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t lifted_lambda_res_126053 = ((int64_t *) ext_mem_133467.mem)[eta_p_126048];
        int16_t lifted_lambda_res_126054 = ((int16_t *) xs_mem_133466.mem)[eta_p_126048];
        
        ((int64_t *) mem_133676.mem)[i_133340] = lifted_lambda_res_126053;
        ((int16_t *) mem_133678.mem)[i_133340] = lifted_lambda_res_126054;
    }
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134162, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134163, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_double(struct futhark_context *ctx, struct memblock *mem_out_p_134174, struct memblock *mem_out_p_134175, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_83511, int64_t b_83512)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134176 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134177 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134178 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134179 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134180 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134181 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134182 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134183 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134184 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134185 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_83511;
    bool cond_125533 = sle64(n_83511, (int64_t) 1);
    int64_t zs_lhs_125534 = sub64(n_83511, (int64_t) 1);
    int64_t zp_rhs_125535 = sdiv_safe64(zs_lhs_125534, (int64_t) 20);
    int64_t min_num_blocks_125536 = add64((int64_t) 1, zp_rhs_125535);
    bool loop_cond_125537 = slt64((int64_t) 1, min_num_blocks_125536);
    bool smallest_pow_2_geq_than_res_125538;
    int64_t smallest_pow_2_geq_than_res_125539;
    bool loop_while_125540;
    int64_t x_125541;
    
    loop_while_125540 = loop_cond_125537;
    x_125541 = (int64_t) 1;
    while (loop_while_125540) {
        int64_t loopres_125542 = mul64((int64_t) 2, x_125541);
        bool loop_cond_125543 = slt64(loopres_125542, min_num_blocks_125536);
        bool loop_while_tmp_133879 = loop_cond_125543;
        int64_t x_tmp_133880 = loopres_125542;
        
        loop_while_125540 = loop_while_tmp_133879;
        x_125541 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125538 = loop_while_125540;
    smallest_pow_2_geq_than_res_125539 = x_125541;
    
    bool zzero_125544 = smallest_pow_2_geq_than_res_125539 == (int64_t) 0;
    bool nonzzero_125545 = !zzero_125544;
    bool protect_assert_disj_125546 = cond_125533 || nonzzero_125545;
    bool nonzzero_cert_125547;
    
    if (!protect_assert_disj_125546) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:117:36-40\n   #5  ftRelational.fut:114:9-117:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125548 = sdiv_safe64(zs_lhs_125534, smallest_pow_2_geq_than_res_125539);
    int64_t block_sizze_125549 = add64((int64_t) 1, zp_rhs_125548);
    bool y_125555 = slt64((int64_t) 0, n_83511);
    bool protect_assert_disj_133752 = cond_125533 || y_125555;
    bool index_certs_125556;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_83511, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:117:36-40\n   #5  ftRelational.fut:114:9-117:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125570 = slt64(smallest_pow_2_geq_than_res_125539, (int64_t) 0);
    bool valid_125571 = !bounds_invalid_upwards_125570;
    bool protect_assert_disj_133760 = cond_125533 || valid_125571;
    bool range_valid_c_125572;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125539, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:117:36-40\n   #6  ftRelational.fut:114:9-117:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125574 = slt64(block_sizze_125549, (int64_t) 0);
    bool valid_125575 = !bounds_invalid_upwards_125574;
    bool protect_assert_disj_133762 = cond_125533 || valid_125575;
    bool range_valid_c_125576;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125549, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125578 = sle64(block_sizze_125549, (int64_t) 1);
    int64_t tmp_125579 = sub64(block_sizze_125549, (int64_t) 2);
    bool bounds_invalid_upwards_125580 = slt64(tmp_125579, (int64_t) 0);
    bool valid_125582 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_125583 = cond_125578 || valid_125582;
    bool protect_assert_disj_133764 = cond_125533 || protect_assert_disj_125583;
    bool range_valid_c_125584;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125579, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133677 = n_83511 * b_83512;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_83511; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125550 = smallest_pow_2_geq_than_res_125539 * block_sizze_125549;
    bool x_133747 = !cond_125533;
    int64_t greatest_divisor_leq_than_arg1_125553 = mul64((int64_t) 2, block_sizze_125549);
    int64_t merge_block_sizze_125554;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125553) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125554 = x_133749;
    } else {
        merge_block_sizze_125554 = (int64_t) 0;
    }
    
    double reduce_arg1_125557;
    
    if (x_133747) {
        double x_133753 = ((double *) k_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125557 = x_133753;
    } else {
        reduce_arg1_125557 = 0.0;
    }
    
    double defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        double x_133755;
        int64_t x_133756;
        double redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125557;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_83511; i_133300++) {
            double x_125561 = ((double *) k_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125567 = redout_133298 <= x_125561;
            double defunc_0_op_res_125568;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125568 = x_125561;
            } else {
                defunc_0_op_res_125568 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125569;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125569 = i_133300;
            } else {
                defunc_0_op_res_125569 = redout_133299;
            }
            
            double redout_tmp_133883 = defunc_0_op_res_125568;
            int64_t redout_tmp_133884 = defunc_0_op_res_125569;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = 0.0;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125581 = add64((int64_t) 1, tmp_125579);
    int64_t binop_x_133470 = (int64_t) 8 * smallest_pow_2_geq_than_res_125539;
    int64_t bytes_133471 = block_sizze_125549 * binop_x_133470;
    int64_t bytes_133484 = (int64_t) 8 * block_sizze_125549;
    bool loop_cond_125656 = slt64(block_sizze_125549, flat_dim_125550);
    bool zzero_125657 = merge_block_sizze_125554 == (int64_t) 0;
    bool nonzzero_125658 = !zzero_125657;
    
    if (cond_125533) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134176 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134176, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134177 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134177, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134178 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134178, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134179 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134179, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125539; i_133312++) {
            int64_t zp_lhs_125588 = mul64(block_sizze_125549, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125549; i_133305++) {
                int64_t k_125592 = add64(zp_lhs_125588, i_133305);
                bool cond_125593 = slt64(k_125592, n_83511);
                double lifted_lambda_res_125594;
                int64_t lifted_lambda_res_125595;
                
                if (cond_125593) {
                    bool x_127931 = sle64((int64_t) 0, k_125592);
                    bool bounds_check_127932 = cond_125593 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125592, "] out of bounds for array of shape [", (long long) n_83511, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:117:36-40\n   #9  ftRelational.fut:114:9-117:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    double lifted_lambda_res_t_res_127934 = ((double *) k_mem_133466.mem)[k_125592];
                    
                    lifted_lambda_res_125594 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125595 = k_125592;
                } else {
                    lifted_lambda_res_125594 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125595 = defunc_0_reduce_res_128079;
                }
                ((double *) mem_133485)[i_133305] = lifted_lambda_res_125594;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125595;
            }
            if (!cond_125578) {
                for (int64_t i_125605 = 0; i_125605 < distance_125581; i_125605++) {
                    int64_t gt_arg1_125608 = add64((int64_t) 1, i_125605);
                    bool x_125609 = sle64((int64_t) 0, gt_arg1_125608);
                    bool y_125610 = slt64(gt_arg1_125608, block_sizze_125549);
                    bool bounds_check_125611 = x_125609 && y_125610;
                    bool index_certs_125612;
                    
                    if (!bounds_check_125611) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125608, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125614 = slt64(i_125605, block_sizze_125549);
                    bool index_certs_125615;
                    
                    if (!y_125614) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125605, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    double gt_arg1_125613 = ((double *) mem_133485)[gt_arg1_125608];
                    double gt_arg0_125616 = ((double *) mem_133485)[i_125605];
                    bool defunc_0_leq_res_125617 = gt_arg0_125616 <= gt_arg1_125613;
                    bool defunc_0_lifted_gt_res_125618 = !defunc_0_leq_res_125617;
                    bool s_125619;
                    int64_t s_125622;
                    bool loop_while_125623;
                    int64_t j_125626;
                    
                    loop_while_125623 = defunc_0_lifted_gt_res_125618;
                    j_125626 = i_125605;
                    while (loop_while_125623) {
                        bool x_125627 = sle64((int64_t) 0, j_125626);
                        bool y_125628 = slt64(j_125626, block_sizze_125549);
                        bool bounds_check_125629 = x_125627 && y_125628;
                        bool index_certs_125630;
                        
                        if (!bounds_check_125629) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125626, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125633 = add64((int64_t) 1, j_125626);
                        bool x_125634 = sle64((int64_t) 0, copy_arg0_125633);
                        bool y_125635 = slt64(copy_arg0_125633, block_sizze_125549);
                        bool bounds_check_125636 = x_125634 && y_125635;
                        bool index_certs_125637;
                        
                        if (!bounds_check_125636) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125633, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        double copy_arg0_125631 = ((double *) mem_133485)[j_125626];
                        int64_t copy_arg0_125632 = ((int64_t *) mem_133487)[j_125626];
                        double copy_arg0_125638 = ((double *) mem_133485)[copy_arg0_125633];
                        int64_t copy_arg0_125639 = ((int64_t *) mem_133487)[copy_arg0_125633];
                        
                        ((double *) mem_133485)[j_125626] = copy_arg0_125638;
                        ((int64_t *) mem_133487)[j_125626] = copy_arg0_125639;
                        ((double *) mem_133485)[copy_arg0_125633] = copy_arg0_125631;
                        ((int64_t *) mem_133487)[copy_arg0_125633] = copy_arg0_125632;
                        
                        int64_t tmp_125644 = sub64(j_125626, (int64_t) 1);
                        bool cond_125645 = sle64((int64_t) 0, tmp_125644);
                        bool loop_cond_125646;
                        
                        if (cond_125645) {
                            bool y_127936 = slt64(tmp_125644, block_sizze_125549);
                            bool bounds_check_127937 = cond_125645 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125644, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            double gt_arg1_127935 = ((double *) mem_133485)[j_125626];
                            double gt_arg0_127939 = ((double *) mem_133485)[tmp_125644];
                            bool defunc_0_leq_res_127940 = gt_arg0_127939 <= gt_arg1_127935;
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125646 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125646 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125646;
                        int64_t j_tmp_133894 = tmp_125644;
                        
                        loop_while_125623 = loop_while_tmp_133891;
                        j_125626 = j_tmp_133894;
                    }
                    s_125619 = loop_while_125623;
                    s_125622 = j_125626;
                }
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133472, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint64_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        if (memblock_alloc(ctx, &mem_133544, bytes_133471, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        
        int64_t data_125659;
        bool data_125660;
        int64_t data_125663;
        int64_t loop_dz2084Uz2082U_125664;
        bool loop_while_125665;
        int64_t stride_125668;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125664 = flat_dim_125550;
        loop_while_125665 = loop_cond_125656;
        stride_125668 = block_sizze_125549;
        while (loop_while_125665) {
            int64_t next_stride_125669 = mul64((int64_t) 2, stride_125668);
            bool zzero_125670 = next_stride_125669 == (int64_t) 0;
            bool nonzzero_125671 = !zzero_125670;
            bool nonzzero_cert_125672;
            
            if (!nonzzero_125671) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:117:36-40\n   #5  ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125673 = sdiv64(flat_dim_125550, next_stride_125669);
            bool bounds_invalid_upwards_125674 = slt64(num_merges_125673, (int64_t) 0);
            bool valid_125675 = !bounds_invalid_upwards_125674;
            bool range_valid_c_125676;
            
            if (!valid_125675) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125673, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:117:36-40\n   #6  ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125678 = sub64(next_stride_125669, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125679 = sle64((int64_t) 0, m_125678);
            bool cond_125681 = slt64(next_stride_125669, (int64_t) 10);
            bool protect_assert_disj_125682 = nonzzero_125658 || cond_125681;
            bool nonzzero_cert_125683;
            
            if (!protect_assert_disj_125682) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125684 = smod_safe64(next_stride_125669, merge_block_sizze_125554);
            bool num_blocks_125685 = zeze_lhs_125684 == (int64_t) 0;
            bool protect_assert_disj_125686 = cond_125681 || num_blocks_125685;
            bool assert_c_125687;
            
            if (!protect_assert_disj_125686) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125689 = sdiv_safe64(next_stride_125669, merge_block_sizze_125554);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690 = add64((int64_t) 1, num_blocks_125689);
            int64_t j_m_i_125691 = sub64(next_stride_125669, stride_125668);
            int64_t flat_dim_125692 = merge_block_sizze_125554 * num_blocks_125689;
            bool bounds_invalid_upwards_125693 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, (int64_t) 0);
            bool empty_slice_125694 = j_m_i_125691 == (int64_t) 0;
            int64_t m_125695 = sub64(j_m_i_125691, (int64_t) 1);
            bool zzero_lte_i_125696 = sle64((int64_t) 0, stride_125668);
            bool i_lte_j_125697 = sle64(stride_125668, next_stride_125669);
            bool empty_slice_125698 = stride_125668 == (int64_t) 0;
            int64_t m_125699 = sub64(stride_125668, (int64_t) 1);
            bool bounds_invalid_upwards_125700 = slt64(num_blocks_125689, (int64_t) 0);
            bool cond_125701 = slt64((int64_t) 0, stride_125668);
            bool valid_125702 = !bounds_invalid_upwards_125693;
            int64_t i_p_m_t_s_125703 = add64(stride_125668, m_125695);
            bool zzero_leq_i_p_m_t_s_125704 = sle64((int64_t) 0, m_125699);
            bool i_p_m_t_s_leq_w_125705 = slt64(m_125699, next_stride_125669);
            bool valid_125706 = !bounds_invalid_upwards_125700;
            bool i_p_m_t_s_leq_w_125707 = slt64(m_125678, flat_dim_125692);
            bool y_125708 = slt64((int64_t) 0, j_m_i_125691);
            bool protect_assert_disj_125709 = cond_125681 || valid_125702;
            bool range_valid_c_125710;
            
            if (!protect_assert_disj_125709) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:117:36-40\n   #10 ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125711 = sle64((int64_t) 0, i_p_m_t_s_125703);
            bool i_p_m_t_s_leq_w_125712 = slt64(i_p_m_t_s_125703, next_stride_125669);
            bool y_125713 = zzero_leq_i_p_m_t_s_125704 && i_p_m_t_s_leq_w_125705;
            bool protect_assert_disj_125714 = cond_125681 || valid_125706;
            bool range_valid_c_125715;
            
            if (!protect_assert_disj_125714) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125689, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:117:36-40\n   #9  ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125716 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125707;
            bool y_125717 = zzero_lte_i_125696 && i_p_m_t_s_leq_w_125712;
            bool forwards_ok_125718 = zzero_lte_i_125696 && y_125713;
            bool ok_or_empty_125719 = zzero_125670 || y_125716;
            bool protect_assert_disj_125720 = cond_125701 || y_125708;
            bool y_125721 = zzero_leq_i_p_m_t_s_125711 && y_125717;
            bool ok_or_empty_125722 = empty_slice_125698 || forwards_ok_125718;
            bool protect_assert_disj_125723 = cond_125681 || ok_or_empty_125719;
            bool index_certs_125724;
            
            if (!protect_assert_disj_125723) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) flat_dim_125692, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:117:36-40\n   #9  ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125725 = !cond_125681;
            bool protect_assert_disj_125726 = protect_assert_disj_125720 || loop_not_taken_125725;
            bool index_certs_125727;
            
            if (!protect_assert_disj_125726) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:117:36-40\n   #10 ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125728 = i_lte_j_125697 && y_125721;
            bool protect_assert_disj_125729 = cond_125681 || ok_or_empty_125722;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:117:36-40\n   #11 ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125731 = ok_or_empty_125722 || loop_not_taken_125725;
            bool index_certs_125732;
            
            if (!protect_assert_disj_125731) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125733 = empty_slice_125694 || forwards_ok_125728;
            bool protect_assert_disj_125734 = cond_125681 || ok_or_empty_125733;
            bool index_certs_125735;
            
            if (!protect_assert_disj_125734) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:117:36-40\n   #11 ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125736 = loop_not_taken_125725 || ok_or_empty_125733;
            bool index_certs_125737;
            
            if (!protect_assert_disj_125736) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 8 * num_merges_125673;
            int64_t bytes_133553 = next_stride_125669 * binop_x_133552;
            bool i_lte_j_125680 = sle64((int64_t) 0, next_stride_125669);
            
            if (mem_133554_cached_sizze_134180 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134180, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134181 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134181, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690;
            int64_t binop_x_133582 = (int64_t) 8 * num_blocks_125689;
            int64_t bytes_133583 = merge_block_sizze_125554 * binop_x_133582;
            int64_t bytes_133628 = (int64_t) 16 * stride_125668;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125673; i_133333++) {
                int64_t start_125741 = mul64(next_stride_125669, i_133333);
                int64_t j_m_i_125742 = sub64(loop_dz2084Uz2082U_125664, start_125741);
                bool empty_slice_125743 = j_m_i_125742 == (int64_t) 0;
                int64_t m_125744 = sub64(j_m_i_125742, (int64_t) 1);
                int64_t i_p_m_t_s_125745 = add64(start_125741, m_125744);
                bool zzero_leq_i_p_m_t_s_125746 = sle64((int64_t) 0, i_p_m_t_s_125745);
                bool i_p_m_t_s_leq_w_125747 = slt64(i_p_m_t_s_125745, loop_dz2084Uz2082U_125664);
                bool zzero_lte_i_125748 = sle64((int64_t) 0, start_125741);
                bool i_lte_j_125749 = sle64(start_125741, loop_dz2084Uz2082U_125664);
                bool y_125750 = i_p_m_t_s_leq_w_125747 && zzero_lte_i_125748;
                bool y_125751 = zzero_leq_i_p_m_t_s_125746 && y_125750;
                bool forwards_ok_125752 = i_lte_j_125749 && y_125751;
                bool ok_or_empty_125753 = empty_slice_125743 || forwards_ok_125752;
                bool index_certs_125754;
                
                if (!ok_or_empty_125753) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125741, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125664, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125755 = slt64(m_125678, j_m_i_125742);
                bool y_125756 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125755;
                bool forwards_ok_125757 = i_lte_j_125680 && y_125756;
                bool ok_or_empty_125758 = zzero_125670 || forwards_ok_125757;
                bool index_certs_125759;
                
                if (!ok_or_empty_125758) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) j_m_i_125742, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:117:36-40\n   #8  ftRelational.fut:114:9-117:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125681) {
                    double dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125701) {
                        double head_res_127969 = ((double *) mem_param_133548.mem)[start_125741];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125741];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125668 + start_125741;
                        double head_res_127972 = ((double *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125669; nest_i_133904++) {
                        ((double *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133628, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125669; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125669; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125691;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125668);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125691);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:117:36-40\n   #9  ftRelational.fut:114:9-117:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:117:36-40\n   #9  ftRelational.fut:114:9-117:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125668 + j_127983;
                                int64_t slice_127993 = start_125741 + slice_127992;
                                double leq_arg1_127994 = ((double *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125741 + i_127980;
                                double leq_arg0_127999 = ((double *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = leq_arg0_127999 <= leq_arg1_127994;
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        double loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125668);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:117:36-40\n   #9  ftRelational.fut:114:9-117:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125741 + i_127980;
                            double tmp_128010 = ((double *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125691);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:117:36-40\n   #9  ftRelational.fut:114:9-117:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125668 + j_127983;
                            int64_t slice_128017 = start_125741 + slice_128016;
                            double tmp_128018 = ((double *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((double *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134182 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134182, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134183 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134183, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690; i_133319++) {
                        int64_t split_count_arg3_125821 = mul64(merge_block_sizze_125554, i_133319);
                        int64_t defunc_0_split_count_res_125822;
                        int64_t defunc_0_split_count_res_125823;
                        int64_t defunc_0_split_count_res_125824;
                        int64_t defunc_0_split_count_res_125825;
                        int64_t defunc_0_split_count_res_125826;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125822, &defunc_0_split_count_res_125823, &defunc_0_split_count_res_125824, &defunc_0_split_count_res_125825, &defunc_0_split_count_res_125826, (int64_t) 0, stride_125668, (int64_t) 0, j_m_i_125691, split_count_arg3_125821) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125827 = slt64((int64_t) 0, defunc_0_split_count_res_125826);
                        bool defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        int64_t defunc_0_split_count_res_125833;
                        bool loop_while_125834;
                        int64_t ss_125835;
                        int64_t ss_125836;
                        int64_t tt_125837;
                        int64_t tt_125838;
                        int64_t count_125839;
                        
                        loop_while_125834 = loop_cond_125827;
                        ss_125835 = defunc_0_split_count_res_125822;
                        ss_125836 = defunc_0_split_count_res_125823;
                        tt_125837 = defunc_0_split_count_res_125824;
                        tt_125838 = defunc_0_split_count_res_125825;
                        count_125839 = defunc_0_split_count_res_125826;
                        while (loop_while_125834) {
                            int64_t zlze_lhs_125840 = sub64(ss_125836, ss_125835);
                            bool cond_125841 = sle64(zlze_lhs_125840, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125842;
                            int64_t defunc_0_lifted_step_res_125843;
                            int64_t defunc_0_lifted_step_res_125844;
                            int64_t defunc_0_lifted_step_res_125845;
                            
                            if (cond_125841) {
                                int64_t tmp_128022 = add64(tt_125837, count_125839);
                                
                                defunc_0_lifted_step_res_125842 = ss_125835;
                                defunc_0_lifted_step_res_125843 = tmp_128022;
                                defunc_0_lifted_step_res_125844 = tt_125838;
                                defunc_0_lifted_step_res_125845 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125847 = sub64(tt_125838, tt_125837);
                                bool cond_125848 = sle64(zlze_lhs_125847, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125849;
                                int64_t defunc_0_lifted_step_res_f_res_125850;
                                int64_t defunc_0_lifted_step_res_f_res_125851;
                                int64_t defunc_0_lifted_step_res_f_res_125852;
                                
                                if (cond_125848) {
                                    int64_t tmp_128023 = add64(ss_125835, count_125839);
                                    
                                    defunc_0_lifted_step_res_f_res_125849 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125850 = tt_125837;
                                    defunc_0_lifted_step_res_f_res_125851 = tt_125838;
                                    defunc_0_lifted_step_res_f_res_125852 = (int64_t) 0;
                                } else {
                                    bool cond_125854 = count_125839 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125855;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125856;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125857;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125858;
                                    
                                    if (cond_125854) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125835);
                                        bool y_128026 = slt64(ss_125835, stride_125668);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125835, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:117:36-40\n   #13 ftRelational.fut:114:9-117:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125837);
                                        bool y_128032 = slt64(tt_125837, j_m_i_125691);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125837, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:117:36-40\n   #13 ftRelational.fut:114:9-117:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125741 + ss_125835;
                                        double leq_arg1_128030 = ((double *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125668 + tt_125837;
                                        int64_t slice_128036 = start_125741 + slice_128035;
                                        double leq_arg0_128037 = ((double *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = leq_arg0_128037 <= leq_arg1_128030;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125837);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125835;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125835);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125837;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = tt_125838;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = (int64_t) 0;
                                    } else {
                                        int64_t m_125877 = sdiv64(count_125839, (int64_t) 2);
                                        int64_t n_125878 = sub64(count_125839, m_125877);
                                        bool cond_125879 = n_125878 == (int64_t) 0;
                                        int64_t zgze_lhs_125880 = add64(ss_125835, m_125877);
                                        bool cond_f_res_125881 = sle64(ss_125836, zgze_lhs_125880);
                                        bool x_125882 = !cond_125879;
                                        bool y_125883 = cond_f_res_125881 && x_125882;
                                        bool cond_125884 = cond_125879 || y_125883;
                                        bool leq_y_x_125885;
                                        
                                        if (cond_125884) {
                                            leq_y_x_125885 = 1;
                                        } else {
                                            bool x_125886 = sle64((int64_t) 0, zgze_lhs_125880);
                                            bool y_125887 = slt64(zgze_lhs_125880, stride_125668);
                                            bool bounds_check_125888 = x_125886 && y_125887;
                                            bool index_certs_125889;
                                            
                                            if (!bounds_check_125888) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125880, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:117:36-40\n   #13 ftRelational.fut:114:9-117:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125892 = add64(tt_125837, n_125878);
                                            int64_t leq_arg0_125893 = sub64(zm_lhs_125892, (int64_t) 1);
                                            bool x_125894 = sle64((int64_t) 0, leq_arg0_125893);
                                            bool y_125895 = slt64(leq_arg0_125893, j_m_i_125691);
                                            bool bounds_check_125896 = x_125894 && y_125895;
                                            bool index_certs_125897;
                                            
                                            if (!bounds_check_125896) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125893, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:117:36-40\n   #13 ftRelational.fut:114:9-117:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125890 = start_125741 + zgze_lhs_125880;
                                            double leq_arg1_125891 = ((double *) mem_param_133548.mem)[slice_125890];
                                            int64_t slice_125898 = stride_125668 + leq_arg0_125893;
                                            int64_t slice_125899 = start_125741 + slice_125898;
                                            double leq_arg0_125900 = ((double *) mem_param_133548.mem)[slice_125899];
                                            bool defunc_0_leq_res_125901 = leq_arg0_125900 <= leq_arg1_125891;
                                            
                                            leq_y_x_125885 = defunc_0_leq_res_125901;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                        
                                        if (leq_y_x_125885) {
                                            int64_t tmp_128043 = add64(tt_125837, n_125878);
                                            int64_t tmp_128044 = sub64(count_125839, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tt_125838;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = tmp_128044;
                                        } else {
                                            int64_t tmp_125907 = add64(tt_125837, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tt_125837;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tmp_125907;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = count_125839;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = ss_125835;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                    }
                                    defunc_0_lifted_step_res_f_res_125849 = defunc_0_lifted_step_res_f_res_f_res_125855;
                                    defunc_0_lifted_step_res_f_res_125850 = defunc_0_lifted_step_res_f_res_f_res_125856;
                                    defunc_0_lifted_step_res_f_res_125851 = defunc_0_lifted_step_res_f_res_f_res_125857;
                                    defunc_0_lifted_step_res_f_res_125852 = defunc_0_lifted_step_res_f_res_f_res_125858;
                                }
                                defunc_0_lifted_step_res_125842 = defunc_0_lifted_step_res_f_res_125849;
                                defunc_0_lifted_step_res_125843 = defunc_0_lifted_step_res_f_res_125850;
                                defunc_0_lifted_step_res_125844 = defunc_0_lifted_step_res_f_res_125851;
                                defunc_0_lifted_step_res_125845 = defunc_0_lifted_step_res_f_res_125852;
                            }
                            
                            int64_t loopres_125908;
                            int64_t loopres_125909;
                            int64_t loopres_125910;
                            int64_t loopres_125911;
                            int64_t loopres_125912;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125908, &loopres_125909, &loopres_125910, &loopres_125911, &loopres_125912, defunc_0_lifted_step_res_125842, ss_125836, defunc_0_lifted_step_res_125843, defunc_0_lifted_step_res_125844, defunc_0_lifted_step_res_125845) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125913 = slt64((int64_t) 0, loopres_125912);
                            bool loop_while_tmp_133911 = loop_cond_125913;
                            int64_t ss_tmp_133912 = loopres_125908;
                            int64_t ss_tmp_133913 = loopres_125909;
                            int64_t tt_tmp_133914 = loopres_125910;
                            int64_t tt_tmp_133915 = loopres_125911;
                            int64_t count_tmp_133916 = loopres_125912;
                            
                            loop_while_125834 = loop_while_tmp_133911;
                            ss_125835 = ss_tmp_133912;
                            ss_125836 = ss_tmp_133913;
                            tt_125837 = tt_tmp_133914;
                            tt_125838 = tt_tmp_133915;
                            count_125839 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125828 = loop_while_125834;
                        defunc_0_split_count_res_125829 = ss_125835;
                        defunc_0_split_count_res_125830 = ss_125836;
                        defunc_0_split_count_res_125831 = tt_125837;
                        defunc_0_split_count_res_125832 = tt_125838;
                        defunc_0_split_count_res_125833 = count_125839;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125829;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125831;
                    }
                    if (mem_133584_cached_sizze_134184 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134184, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134185 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134185, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125689; i_133326++) {
                        bool y_125919 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool index_certs_125921;
                        
                        if (!y_125919) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:117:36-40\n   #10 ftRelational.fut:114:9-117:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125922 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125923 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125924 = add64((int64_t) 1, i_133326);
                        bool x_125925 = sle64((int64_t) 0, tmp_125924);
                        bool y_125926 = slt64(tmp_125924, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool bounds_check_125927 = x_125925 && y_125926;
                        bool index_certs_125928;
                        
                        if (!bounds_check_125927) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125924, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:117:36-40\n   #10 ftRelational.fut:114:9-117:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133567)[tmp_125924];
                        int64_t defunc_0_f_res_125930 = ((int64_t *) mem_133569)[tmp_125924];
                        int64_t merge_sequential_arg2_125931 = add64(stride_125668, defunc_0_f_res_125923);
                        int64_t merge_sequential_arg2_125932 = add64(stride_125668, defunc_0_f_res_125930);
                        int64_t j_m_i_125933 = sub64(merge_sequential_arg2_125932, merge_sequential_arg2_125931);
                        bool empty_slice_125934 = j_m_i_125933 == (int64_t) 0;
                        int64_t m_125935 = sub64(j_m_i_125933, (int64_t) 1);
                        int64_t i_p_m_t_s_125936 = add64(merge_sequential_arg2_125931, m_125935);
                        bool zzero_leq_i_p_m_t_s_125937 = sle64((int64_t) 0, i_p_m_t_s_125936);
                        bool i_p_m_t_s_leq_w_125938 = slt64(i_p_m_t_s_125936, next_stride_125669);
                        bool zzero_lte_i_125939 = sle64((int64_t) 0, merge_sequential_arg2_125931);
                        bool i_lte_j_125940 = sle64(merge_sequential_arg2_125931, merge_sequential_arg2_125932);
                        bool y_125941 = i_p_m_t_s_leq_w_125938 && zzero_lte_i_125939;
                        bool y_125942 = zzero_leq_i_p_m_t_s_125937 && y_125941;
                        bool forwards_ok_125943 = i_lte_j_125940 && y_125942;
                        bool ok_or_empty_125944 = empty_slice_125934 || forwards_ok_125943;
                        bool index_certs_125945;
                        
                        if (!ok_or_empty_125944) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125931, ":", (long long) merge_sequential_arg2_125932, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:117:36-40\n   #10 ftRelational.fut:114:9-117:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125946 = sub64(defunc_0_f_res_125929, defunc_0_f_res_125922);
                        bool empty_slice_125947 = j_m_i_125946 == (int64_t) 0;
                        int64_t m_125948 = sub64(j_m_i_125946, (int64_t) 1);
                        int64_t i_p_m_t_s_125949 = add64(defunc_0_f_res_125922, m_125948);
                        bool zzero_leq_i_p_m_t_s_125950 = sle64((int64_t) 0, i_p_m_t_s_125949);
                        bool i_p_m_t_s_leq_w_125951 = slt64(i_p_m_t_s_125949, next_stride_125669);
                        bool zzero_lte_i_125952 = sle64((int64_t) 0, defunc_0_f_res_125922);
                        bool i_lte_j_125953 = sle64(defunc_0_f_res_125922, defunc_0_f_res_125929);
                        bool y_125954 = i_p_m_t_s_leq_w_125951 && zzero_lte_i_125952;
                        bool y_125955 = zzero_leq_i_p_m_t_s_125950 && y_125954;
                        bool forwards_ok_125956 = i_lte_j_125953 && y_125955;
                        bool ok_or_empty_125957 = empty_slice_125947 || forwards_ok_125956;
                        bool index_certs_125958;
                        
                        if (!ok_or_empty_125957) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125922, ":", (long long) defunc_0_f_res_125929, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:117:36-40\n   #10 ftRelational.fut:114:9-117:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125959 = slt64((int64_t) 0, j_m_i_125946);
                        double dummy_125960;
                        int64_t dummy_125961;
                        
                        if (cond_125959) {
                            bool index_certs_128045;
                            
                            if (!cond_125959) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:117:36-40\n   #12 ftRelational.fut:114:9-117:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125741 + defunc_0_f_res_125922;
                            double head_res_128047 = ((double *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125960 = head_res_128047;
                            dummy_125961 = head_res_128048;
                        } else {
                            bool y_125966 = slt64((int64_t) 0, j_m_i_125933);
                            bool index_certs_125967;
                            
                            if (!y_125966) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:117:36-40\n   #12 ftRelational.fut:114:9-117:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125968 = start_125741 + merge_sequential_arg2_125931;
                            double head_res_125969 = ((double *) mem_param_133548.mem)[slice_125968];
                            int64_t head_res_125970 = ((int64_t *) mem_param_133551.mem)[slice_125968];
                            
                            dummy_125960 = head_res_125969;
                            dummy_125961 = head_res_125970;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125554; nest_i_133919++) {
                            ((double *) mem_133584)[i_133326 * merge_block_sizze_125554 + nest_i_133919] = dummy_125960;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125554; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + nest_i_133920] = dummy_125961;
                        }
                        
                        int64_t data_125973;
                        int64_t i_125977 = (int64_t) 0;
                        
                        for (int64_t k_125976 = 0; k_125976 < merge_block_sizze_125554; k_125976++) {
                            int64_t j_125980 = sub64(k_125976, i_125977);
                            bool cond_125981 = j_125980 == j_m_i_125933;
                            bool cond_125982;
                            
                            if (cond_125981) {
                                cond_125982 = 1;
                            } else {
                                bool cond_125983 = slt64(i_125977, j_m_i_125946);
                                bool cond_f_res_125984;
                                
                                if (cond_125983) {
                                    bool x_128049 = sle64((int64_t) 0, j_125980);
                                    bool y_128050 = slt64(j_125980, j_m_i_125933);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:117:36-40\n   #11 ftRelational.fut:114:9-117:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125977);
                                    bool bounds_check_128057 = cond_125983 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:117:36-40\n   #11 ftRelational.fut:114:9-117:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125931 + j_125980;
                                    int64_t slice_128054 = start_125741 + slice_128053;
                                    double leq_arg1_128055 = ((double *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125922 + i_125977;
                                    int64_t slice_128060 = start_125741 + slice_128059;
                                    double leq_arg0_128061 = ((double *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = leq_arg0_128061 <= leq_arg1_128055;
                                    
                                    cond_f_res_125984 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125984 = 0;
                                }
                                cond_125982 = cond_f_res_125984;
                            }
                            
                            int64_t loopres_125999;
                            double loopres_126000;
                            int64_t loopres_126001;
                            
                            if (cond_125982) {
                                bool x_128064 = sle64((int64_t) 0, i_125977);
                                bool y_128065 = slt64(i_125977, j_m_i_125946);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:117:36-40\n   #11 ftRelational.fut:114:9-117:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125977);
                                int64_t slice_128068 = defunc_0_f_res_125922 + i_125977;
                                int64_t slice_128069 = start_125741 + slice_128068;
                                double tmp_128070 = ((double *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_125999 = tmp_128063;
                                loopres_126000 = tmp_128070;
                                loopres_126001 = tmp_128071;
                            } else {
                                bool x_126011 = sle64((int64_t) 0, j_125980);
                                bool y_126012 = slt64(j_125980, j_m_i_125933);
                                bool bounds_check_126013 = x_126011 && y_126012;
                                bool index_certs_126014;
                                
                                if (!bounds_check_126013) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:117:36-40\n   #11 ftRelational.fut:114:9-117:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126015 = merge_sequential_arg2_125931 + j_125980;
                                int64_t slice_126016 = start_125741 + slice_126015;
                                double tmp_126017 = ((double *) mem_param_133548.mem)[slice_126016];
                                int64_t tmp_126018 = ((int64_t *) mem_param_133551.mem)[slice_126016];
                                
                                loopres_125999 = i_125977;
                                loopres_126000 = tmp_126017;
                                loopres_126001 = tmp_126018;
                            }
                            ((double *) mem_133584)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126000;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126001;
                            
                            int64_t i_tmp_133921 = loopres_125999;
                            
                            i_125977 = i_tmp_133921;
                        }
                        data_125973 = i_125977;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint64_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133583, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133554, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126025 = next_stride_125669 * num_merges_125673;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint64_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            if (memblock_alloc(ctx, &mem_133664, bytes_133553, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            
            bool loop_cond_126028 = slt64(next_stride_125669, flat_dim_125550);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126025;
            bool loop_while_tmp_133898 = loop_cond_126028;
            int64_t stride_tmp_133901 = next_stride_125669;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125664 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125665 = loop_while_tmp_133898;
            stride_125668 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125659 = loop_dz2084Uz2082U_125664;
        data_125660 = loop_while_125665;
        data_125663 = stride_125668;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126029 = n_83511 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126030 = sle64((int64_t) 0, zs_lhs_125534);
        bool i_p_m_t_s_leq_w_126031 = slt64(zs_lhs_125534, data_125659);
        bool y_126032 = zzero_leq_i_p_m_t_s_126030 && i_p_m_t_s_leq_w_126031;
        bool ok_or_empty_126033 = empty_slice_126029 || y_126032;
        bool index_certs_126034;
        
        if (!ok_or_empty_126033) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_83511, "] out of bounds for array of shape [", (long long) data_125659, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:117:36-40\n   #6  ftRelational.fut:114:9-117:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133468, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133677, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_83511; i_133340++) {
        int64_t eta_p_126042 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126043 = sle64((int64_t) 0, eta_p_126042);
        bool y_126044 = slt64(eta_p_126042, n_83511);
        bool bounds_check_126045 = x_126043 && y_126044;
        bool index_certs_126046;
        
        if (!bounds_check_126045) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126042, "] out of bounds for array of shape [", (long long) n_83511, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:117:36-40\n   #5  ftRelational.fut:114:9-117:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        double lifted_lambda_res_126047 = ((double *) k_mem_133466.mem)[eta_p_126042];
        
        ((double *) mem_133676.mem)[i_133340] = lifted_lambda_res_126047;
        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133678.mem, i_133340 * b_83512, (int64_t []) {(int64_t) 1}, (uint8_t *) pL_mem_133467.mem, eta_p_126042 * b_83512, (int64_t []) {(int64_t) 1}, (int64_t []) {b_83512});
    }
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134174, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134175, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_float(struct futhark_context *ctx, struct memblock *mem_out_p_134186, struct memblock *mem_out_p_134187, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_81146, int64_t b_81147)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134188 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134189 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134190 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134191 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134192 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134193 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134194 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134195 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134196 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134197 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_81146;
    bool cond_125533 = sle64(n_81146, (int64_t) 1);
    int64_t zs_lhs_125534 = sub64(n_81146, (int64_t) 1);
    int64_t zp_rhs_125535 = sdiv_safe64(zs_lhs_125534, (int64_t) 20);
    int64_t min_num_blocks_125536 = add64((int64_t) 1, zp_rhs_125535);
    bool loop_cond_125537 = slt64((int64_t) 1, min_num_blocks_125536);
    bool smallest_pow_2_geq_than_res_125538;
    int64_t smallest_pow_2_geq_than_res_125539;
    bool loop_while_125540;
    int64_t x_125541;
    
    loop_while_125540 = loop_cond_125537;
    x_125541 = (int64_t) 1;
    while (loop_while_125540) {
        int64_t loopres_125542 = mul64((int64_t) 2, x_125541);
        bool loop_cond_125543 = slt64(loopres_125542, min_num_blocks_125536);
        bool loop_while_tmp_133879 = loop_cond_125543;
        int64_t x_tmp_133880 = loopres_125542;
        
        loop_while_125540 = loop_while_tmp_133879;
        x_125541 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125538 = loop_while_125540;
    smallest_pow_2_geq_than_res_125539 = x_125541;
    
    bool zzero_125544 = smallest_pow_2_geq_than_res_125539 == (int64_t) 0;
    bool nonzzero_125545 = !zzero_125544;
    bool protect_assert_disj_125546 = cond_125533 || nonzzero_125545;
    bool nonzzero_cert_125547;
    
    if (!protect_assert_disj_125546) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:113:36-40\n   #5  ftRelational.fut:110:9-113:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125548 = sdiv_safe64(zs_lhs_125534, smallest_pow_2_geq_than_res_125539);
    int64_t block_sizze_125549 = add64((int64_t) 1, zp_rhs_125548);
    bool y_125555 = slt64((int64_t) 0, n_81146);
    bool protect_assert_disj_133752 = cond_125533 || y_125555;
    bool index_certs_125556;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_81146, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:113:36-40\n   #5  ftRelational.fut:110:9-113:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125570 = slt64(smallest_pow_2_geq_than_res_125539, (int64_t) 0);
    bool valid_125571 = !bounds_invalid_upwards_125570;
    bool protect_assert_disj_133760 = cond_125533 || valid_125571;
    bool range_valid_c_125572;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125539, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:113:36-40\n   #6  ftRelational.fut:110:9-113:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125574 = slt64(block_sizze_125549, (int64_t) 0);
    bool valid_125575 = !bounds_invalid_upwards_125574;
    bool protect_assert_disj_133762 = cond_125533 || valid_125575;
    bool range_valid_c_125576;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125549, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125578 = sle64(block_sizze_125549, (int64_t) 1);
    int64_t tmp_125579 = sub64(block_sizze_125549, (int64_t) 2);
    bool bounds_invalid_upwards_125580 = slt64(tmp_125579, (int64_t) 0);
    bool valid_125582 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_125583 = cond_125578 || valid_125582;
    bool protect_assert_disj_133764 = cond_125533 || protect_assert_disj_125583;
    bool range_valid_c_125584;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125579, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133675 = (int64_t) 4 * n_81146;
    int64_t bytes_133677 = n_81146 * b_81147;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_81146; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125550 = smallest_pow_2_geq_than_res_125539 * block_sizze_125549;
    bool x_133747 = !cond_125533;
    int64_t greatest_divisor_leq_than_arg1_125553 = mul64((int64_t) 2, block_sizze_125549);
    int64_t merge_block_sizze_125554;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125553) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125554 = x_133749;
    } else {
        merge_block_sizze_125554 = (int64_t) 0;
    }
    
    float reduce_arg1_125557;
    
    if (x_133747) {
        float x_133753 = ((float *) k_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125557 = x_133753;
    } else {
        reduce_arg1_125557 = 0.0F;
    }
    
    float defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        float x_133755;
        int64_t x_133756;
        float redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125557;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_81146; i_133300++) {
            float x_125561 = ((float *) k_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125567 = redout_133298 <= x_125561;
            float defunc_0_op_res_125568;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125568 = x_125561;
            } else {
                defunc_0_op_res_125568 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125569;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125569 = i_133300;
            } else {
                defunc_0_op_res_125569 = redout_133299;
            }
            
            float redout_tmp_133883 = defunc_0_op_res_125568;
            int64_t redout_tmp_133884 = defunc_0_op_res_125569;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = 0.0F;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125581 = add64((int64_t) 1, tmp_125579);
    int64_t binop_x_133470 = (int64_t) 4 * smallest_pow_2_geq_than_res_125539;
    int64_t bytes_133471 = block_sizze_125549 * binop_x_133470;
    int64_t binop_x_133473 = (int64_t) 8 * smallest_pow_2_geq_than_res_125539;
    int64_t bytes_133474 = block_sizze_125549 * binop_x_133473;
    int64_t bytes_133484 = (int64_t) 4 * block_sizze_125549;
    int64_t bytes_133486 = (int64_t) 8 * block_sizze_125549;
    bool loop_cond_125656 = slt64(block_sizze_125549, flat_dim_125550);
    bool zzero_125657 = merge_block_sizze_125554 == (int64_t) 0;
    bool nonzzero_125658 = !zzero_125657;
    
    if (cond_125533) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134188 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134188, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134189 < bytes_133474) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134189, bytes_133474);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134190 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134190, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134191 < bytes_133486) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134191, bytes_133486);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125539; i_133312++) {
            int64_t zp_lhs_125588 = mul64(block_sizze_125549, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125549; i_133305++) {
                int64_t k_125592 = add64(zp_lhs_125588, i_133305);
                bool cond_125593 = slt64(k_125592, n_81146);
                float lifted_lambda_res_125594;
                int64_t lifted_lambda_res_125595;
                
                if (cond_125593) {
                    bool x_127931 = sle64((int64_t) 0, k_125592);
                    bool bounds_check_127932 = cond_125593 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125592, "] out of bounds for array of shape [", (long long) n_81146, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:113:36-40\n   #9  ftRelational.fut:110:9-113:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    float lifted_lambda_res_t_res_127934 = ((float *) k_mem_133466.mem)[k_125592];
                    
                    lifted_lambda_res_125594 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125595 = k_125592;
                } else {
                    lifted_lambda_res_125594 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125595 = defunc_0_reduce_res_128079;
                }
                ((float *) mem_133485)[i_133305] = lifted_lambda_res_125594;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125595;
            }
            if (!cond_125578) {
                for (int64_t i_125605 = 0; i_125605 < distance_125581; i_125605++) {
                    int64_t gt_arg1_125608 = add64((int64_t) 1, i_125605);
                    bool x_125609 = sle64((int64_t) 0, gt_arg1_125608);
                    bool y_125610 = slt64(gt_arg1_125608, block_sizze_125549);
                    bool bounds_check_125611 = x_125609 && y_125610;
                    bool index_certs_125612;
                    
                    if (!bounds_check_125611) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125608, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125614 = slt64(i_125605, block_sizze_125549);
                    bool index_certs_125615;
                    
                    if (!y_125614) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125605, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    float gt_arg1_125613 = ((float *) mem_133485)[gt_arg1_125608];
                    float gt_arg0_125616 = ((float *) mem_133485)[i_125605];
                    bool defunc_0_leq_res_125617 = gt_arg0_125616 <= gt_arg1_125613;
                    bool defunc_0_lifted_gt_res_125618 = !defunc_0_leq_res_125617;
                    bool s_125619;
                    int64_t s_125622;
                    bool loop_while_125623;
                    int64_t j_125626;
                    
                    loop_while_125623 = defunc_0_lifted_gt_res_125618;
                    j_125626 = i_125605;
                    while (loop_while_125623) {
                        bool x_125627 = sle64((int64_t) 0, j_125626);
                        bool y_125628 = slt64(j_125626, block_sizze_125549);
                        bool bounds_check_125629 = x_125627 && y_125628;
                        bool index_certs_125630;
                        
                        if (!bounds_check_125629) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125626, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125633 = add64((int64_t) 1, j_125626);
                        bool x_125634 = sle64((int64_t) 0, copy_arg0_125633);
                        bool y_125635 = slt64(copy_arg0_125633, block_sizze_125549);
                        bool bounds_check_125636 = x_125634 && y_125635;
                        bool index_certs_125637;
                        
                        if (!bounds_check_125636) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125633, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        float copy_arg0_125631 = ((float *) mem_133485)[j_125626];
                        int64_t copy_arg0_125632 = ((int64_t *) mem_133487)[j_125626];
                        float copy_arg0_125638 = ((float *) mem_133485)[copy_arg0_125633];
                        int64_t copy_arg0_125639 = ((int64_t *) mem_133487)[copy_arg0_125633];
                        
                        ((float *) mem_133485)[j_125626] = copy_arg0_125638;
                        ((int64_t *) mem_133487)[j_125626] = copy_arg0_125639;
                        ((float *) mem_133485)[copy_arg0_125633] = copy_arg0_125631;
                        ((int64_t *) mem_133487)[copy_arg0_125633] = copy_arg0_125632;
                        
                        int64_t tmp_125644 = sub64(j_125626, (int64_t) 1);
                        bool cond_125645 = sle64((int64_t) 0, tmp_125644);
                        bool loop_cond_125646;
                        
                        if (cond_125645) {
                            bool y_127936 = slt64(tmp_125644, block_sizze_125549);
                            bool bounds_check_127937 = cond_125645 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125644, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            float gt_arg1_127935 = ((float *) mem_133485)[j_125626];
                            float gt_arg0_127939 = ((float *) mem_133485)[tmp_125644];
                            bool defunc_0_leq_res_127940 = gt_arg0_127939 <= gt_arg1_127935;
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125646 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125646 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125646;
                        int64_t j_tmp_133894 = tmp_125644;
                        
                        loop_while_125623 = loop_while_tmp_133891;
                        j_125626 = j_tmp_133894;
                    }
                    s_125619 = loop_while_125623;
                    s_125622 = j_125626;
                }
            }
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133472, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_4b(ctx, 2, (uint32_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint32_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        if (memblock_alloc(ctx, &mem_133544, bytes_133474, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        
        int64_t data_125659;
        bool data_125660;
        int64_t data_125663;
        int64_t loop_dz2084Uz2082U_125664;
        bool loop_while_125665;
        int64_t stride_125668;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125664 = flat_dim_125550;
        loop_while_125665 = loop_cond_125656;
        stride_125668 = block_sizze_125549;
        while (loop_while_125665) {
            int64_t next_stride_125669 = mul64((int64_t) 2, stride_125668);
            bool zzero_125670 = next_stride_125669 == (int64_t) 0;
            bool nonzzero_125671 = !zzero_125670;
            bool nonzzero_cert_125672;
            
            if (!nonzzero_125671) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:113:36-40\n   #5  ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125673 = sdiv64(flat_dim_125550, next_stride_125669);
            bool bounds_invalid_upwards_125674 = slt64(num_merges_125673, (int64_t) 0);
            bool valid_125675 = !bounds_invalid_upwards_125674;
            bool range_valid_c_125676;
            
            if (!valid_125675) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125673, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:113:36-40\n   #6  ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125678 = sub64(next_stride_125669, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125679 = sle64((int64_t) 0, m_125678);
            bool cond_125681 = slt64(next_stride_125669, (int64_t) 10);
            bool protect_assert_disj_125682 = nonzzero_125658 || cond_125681;
            bool nonzzero_cert_125683;
            
            if (!protect_assert_disj_125682) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125684 = smod_safe64(next_stride_125669, merge_block_sizze_125554);
            bool num_blocks_125685 = zeze_lhs_125684 == (int64_t) 0;
            bool protect_assert_disj_125686 = cond_125681 || num_blocks_125685;
            bool assert_c_125687;
            
            if (!protect_assert_disj_125686) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125689 = sdiv_safe64(next_stride_125669, merge_block_sizze_125554);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690 = add64((int64_t) 1, num_blocks_125689);
            int64_t j_m_i_125691 = sub64(next_stride_125669, stride_125668);
            int64_t flat_dim_125692 = merge_block_sizze_125554 * num_blocks_125689;
            bool bounds_invalid_upwards_125693 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, (int64_t) 0);
            bool empty_slice_125694 = j_m_i_125691 == (int64_t) 0;
            int64_t m_125695 = sub64(j_m_i_125691, (int64_t) 1);
            bool zzero_lte_i_125696 = sle64((int64_t) 0, stride_125668);
            bool i_lte_j_125697 = sle64(stride_125668, next_stride_125669);
            bool empty_slice_125698 = stride_125668 == (int64_t) 0;
            int64_t m_125699 = sub64(stride_125668, (int64_t) 1);
            bool bounds_invalid_upwards_125700 = slt64(num_blocks_125689, (int64_t) 0);
            bool cond_125701 = slt64((int64_t) 0, stride_125668);
            bool valid_125702 = !bounds_invalid_upwards_125693;
            int64_t i_p_m_t_s_125703 = add64(stride_125668, m_125695);
            bool zzero_leq_i_p_m_t_s_125704 = sle64((int64_t) 0, m_125699);
            bool i_p_m_t_s_leq_w_125705 = slt64(m_125699, next_stride_125669);
            bool valid_125706 = !bounds_invalid_upwards_125700;
            bool i_p_m_t_s_leq_w_125707 = slt64(m_125678, flat_dim_125692);
            bool y_125708 = slt64((int64_t) 0, j_m_i_125691);
            bool protect_assert_disj_125709 = cond_125681 || valid_125702;
            bool range_valid_c_125710;
            
            if (!protect_assert_disj_125709) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:113:36-40\n   #10 ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125711 = sle64((int64_t) 0, i_p_m_t_s_125703);
            bool i_p_m_t_s_leq_w_125712 = slt64(i_p_m_t_s_125703, next_stride_125669);
            bool y_125713 = zzero_leq_i_p_m_t_s_125704 && i_p_m_t_s_leq_w_125705;
            bool protect_assert_disj_125714 = cond_125681 || valid_125706;
            bool range_valid_c_125715;
            
            if (!protect_assert_disj_125714) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125689, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:113:36-40\n   #9  ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125716 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125707;
            bool y_125717 = zzero_lte_i_125696 && i_p_m_t_s_leq_w_125712;
            bool forwards_ok_125718 = zzero_lte_i_125696 && y_125713;
            bool ok_or_empty_125719 = zzero_125670 || y_125716;
            bool protect_assert_disj_125720 = cond_125701 || y_125708;
            bool y_125721 = zzero_leq_i_p_m_t_s_125711 && y_125717;
            bool ok_or_empty_125722 = empty_slice_125698 || forwards_ok_125718;
            bool protect_assert_disj_125723 = cond_125681 || ok_or_empty_125719;
            bool index_certs_125724;
            
            if (!protect_assert_disj_125723) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) flat_dim_125692, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:113:36-40\n   #9  ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125725 = !cond_125681;
            bool protect_assert_disj_125726 = protect_assert_disj_125720 || loop_not_taken_125725;
            bool index_certs_125727;
            
            if (!protect_assert_disj_125726) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:113:36-40\n   #10 ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125728 = i_lte_j_125697 && y_125721;
            bool protect_assert_disj_125729 = cond_125681 || ok_or_empty_125722;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:113:36-40\n   #11 ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125731 = ok_or_empty_125722 || loop_not_taken_125725;
            bool index_certs_125732;
            
            if (!protect_assert_disj_125731) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125733 = empty_slice_125694 || forwards_ok_125728;
            bool protect_assert_disj_125734 = cond_125681 || ok_or_empty_125733;
            bool index_certs_125735;
            
            if (!protect_assert_disj_125734) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:113:36-40\n   #11 ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125736 = loop_not_taken_125725 || ok_or_empty_125733;
            bool index_certs_125737;
            
            if (!protect_assert_disj_125736) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 4 * num_merges_125673;
            int64_t bytes_133553 = next_stride_125669 * binop_x_133552;
            int64_t binop_x_133555 = (int64_t) 8 * num_merges_125673;
            int64_t bytes_133556 = next_stride_125669 * binop_x_133555;
            bool i_lte_j_125680 = sle64((int64_t) 0, next_stride_125669);
            
            if (mem_133554_cached_sizze_134192 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134192, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134193 < bytes_133556) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134193, bytes_133556);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690;
            int64_t binop_x_133582 = (int64_t) 4 * num_blocks_125689;
            int64_t bytes_133583 = merge_block_sizze_125554 * binop_x_133582;
            int64_t binop_x_133585 = (int64_t) 8 * num_blocks_125689;
            int64_t bytes_133586 = merge_block_sizze_125554 * binop_x_133585;
            int64_t bytes_133628 = (int64_t) 8 * stride_125668;
            int64_t bytes_133630 = (int64_t) 16 * stride_125668;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125673; i_133333++) {
                int64_t start_125741 = mul64(next_stride_125669, i_133333);
                int64_t j_m_i_125742 = sub64(loop_dz2084Uz2082U_125664, start_125741);
                bool empty_slice_125743 = j_m_i_125742 == (int64_t) 0;
                int64_t m_125744 = sub64(j_m_i_125742, (int64_t) 1);
                int64_t i_p_m_t_s_125745 = add64(start_125741, m_125744);
                bool zzero_leq_i_p_m_t_s_125746 = sle64((int64_t) 0, i_p_m_t_s_125745);
                bool i_p_m_t_s_leq_w_125747 = slt64(i_p_m_t_s_125745, loop_dz2084Uz2082U_125664);
                bool zzero_lte_i_125748 = sle64((int64_t) 0, start_125741);
                bool i_lte_j_125749 = sle64(start_125741, loop_dz2084Uz2082U_125664);
                bool y_125750 = i_p_m_t_s_leq_w_125747 && zzero_lte_i_125748;
                bool y_125751 = zzero_leq_i_p_m_t_s_125746 && y_125750;
                bool forwards_ok_125752 = i_lte_j_125749 && y_125751;
                bool ok_or_empty_125753 = empty_slice_125743 || forwards_ok_125752;
                bool index_certs_125754;
                
                if (!ok_or_empty_125753) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125741, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125664, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125755 = slt64(m_125678, j_m_i_125742);
                bool y_125756 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125755;
                bool forwards_ok_125757 = i_lte_j_125680 && y_125756;
                bool ok_or_empty_125758 = zzero_125670 || forwards_ok_125757;
                bool index_certs_125759;
                
                if (!ok_or_empty_125758) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) j_m_i_125742, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:113:36-40\n   #8  ftRelational.fut:110:9-113:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125681) {
                    float dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125701) {
                        float head_res_127969 = ((float *) mem_param_133548.mem)[start_125741];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125741];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125668 + start_125741;
                        float head_res_127972 = ((float *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125669; nest_i_133904++) {
                        ((float *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133630, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125669; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125669; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125691;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125668);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125691);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:113:36-40\n   #9  ftRelational.fut:110:9-113:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:113:36-40\n   #9  ftRelational.fut:110:9-113:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125668 + j_127983;
                                int64_t slice_127993 = start_125741 + slice_127992;
                                float leq_arg1_127994 = ((float *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125741 + i_127980;
                                float leq_arg0_127999 = ((float *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = leq_arg0_127999 <= leq_arg1_127994;
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        float loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125668);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:113:36-40\n   #9  ftRelational.fut:110:9-113:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125741 + i_127980;
                            float tmp_128010 = ((float *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125691);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:113:36-40\n   #9  ftRelational.fut:110:9-113:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125668 + j_127983;
                            int64_t slice_128017 = start_125741 + slice_128016;
                            float tmp_128018 = ((float *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((float *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134194 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134194, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134195 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134195, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690; i_133319++) {
                        int64_t split_count_arg3_125821 = mul64(merge_block_sizze_125554, i_133319);
                        int64_t defunc_0_split_count_res_125822;
                        int64_t defunc_0_split_count_res_125823;
                        int64_t defunc_0_split_count_res_125824;
                        int64_t defunc_0_split_count_res_125825;
                        int64_t defunc_0_split_count_res_125826;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125822, &defunc_0_split_count_res_125823, &defunc_0_split_count_res_125824, &defunc_0_split_count_res_125825, &defunc_0_split_count_res_125826, (int64_t) 0, stride_125668, (int64_t) 0, j_m_i_125691, split_count_arg3_125821) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125827 = slt64((int64_t) 0, defunc_0_split_count_res_125826);
                        bool defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        int64_t defunc_0_split_count_res_125833;
                        bool loop_while_125834;
                        int64_t ss_125835;
                        int64_t ss_125836;
                        int64_t tt_125837;
                        int64_t tt_125838;
                        int64_t count_125839;
                        
                        loop_while_125834 = loop_cond_125827;
                        ss_125835 = defunc_0_split_count_res_125822;
                        ss_125836 = defunc_0_split_count_res_125823;
                        tt_125837 = defunc_0_split_count_res_125824;
                        tt_125838 = defunc_0_split_count_res_125825;
                        count_125839 = defunc_0_split_count_res_125826;
                        while (loop_while_125834) {
                            int64_t zlze_lhs_125840 = sub64(ss_125836, ss_125835);
                            bool cond_125841 = sle64(zlze_lhs_125840, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125842;
                            int64_t defunc_0_lifted_step_res_125843;
                            int64_t defunc_0_lifted_step_res_125844;
                            int64_t defunc_0_lifted_step_res_125845;
                            
                            if (cond_125841) {
                                int64_t tmp_128022 = add64(tt_125837, count_125839);
                                
                                defunc_0_lifted_step_res_125842 = ss_125835;
                                defunc_0_lifted_step_res_125843 = tmp_128022;
                                defunc_0_lifted_step_res_125844 = tt_125838;
                                defunc_0_lifted_step_res_125845 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125847 = sub64(tt_125838, tt_125837);
                                bool cond_125848 = sle64(zlze_lhs_125847, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125849;
                                int64_t defunc_0_lifted_step_res_f_res_125850;
                                int64_t defunc_0_lifted_step_res_f_res_125851;
                                int64_t defunc_0_lifted_step_res_f_res_125852;
                                
                                if (cond_125848) {
                                    int64_t tmp_128023 = add64(ss_125835, count_125839);
                                    
                                    defunc_0_lifted_step_res_f_res_125849 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125850 = tt_125837;
                                    defunc_0_lifted_step_res_f_res_125851 = tt_125838;
                                    defunc_0_lifted_step_res_f_res_125852 = (int64_t) 0;
                                } else {
                                    bool cond_125854 = count_125839 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125855;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125856;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125857;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125858;
                                    
                                    if (cond_125854) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125835);
                                        bool y_128026 = slt64(ss_125835, stride_125668);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125835, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:113:36-40\n   #13 ftRelational.fut:110:9-113:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125837);
                                        bool y_128032 = slt64(tt_125837, j_m_i_125691);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125837, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:113:36-40\n   #13 ftRelational.fut:110:9-113:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125741 + ss_125835;
                                        float leq_arg1_128030 = ((float *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125668 + tt_125837;
                                        int64_t slice_128036 = start_125741 + slice_128035;
                                        float leq_arg0_128037 = ((float *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = leq_arg0_128037 <= leq_arg1_128030;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125837);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125835;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125835);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125837;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = tt_125838;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = (int64_t) 0;
                                    } else {
                                        int64_t m_125877 = sdiv64(count_125839, (int64_t) 2);
                                        int64_t n_125878 = sub64(count_125839, m_125877);
                                        bool cond_125879 = n_125878 == (int64_t) 0;
                                        int64_t zgze_lhs_125880 = add64(ss_125835, m_125877);
                                        bool cond_f_res_125881 = sle64(ss_125836, zgze_lhs_125880);
                                        bool x_125882 = !cond_125879;
                                        bool y_125883 = cond_f_res_125881 && x_125882;
                                        bool cond_125884 = cond_125879 || y_125883;
                                        bool leq_y_x_125885;
                                        
                                        if (cond_125884) {
                                            leq_y_x_125885 = 1;
                                        } else {
                                            bool x_125886 = sle64((int64_t) 0, zgze_lhs_125880);
                                            bool y_125887 = slt64(zgze_lhs_125880, stride_125668);
                                            bool bounds_check_125888 = x_125886 && y_125887;
                                            bool index_certs_125889;
                                            
                                            if (!bounds_check_125888) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125880, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:113:36-40\n   #13 ftRelational.fut:110:9-113:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125892 = add64(tt_125837, n_125878);
                                            int64_t leq_arg0_125893 = sub64(zm_lhs_125892, (int64_t) 1);
                                            bool x_125894 = sle64((int64_t) 0, leq_arg0_125893);
                                            bool y_125895 = slt64(leq_arg0_125893, j_m_i_125691);
                                            bool bounds_check_125896 = x_125894 && y_125895;
                                            bool index_certs_125897;
                                            
                                            if (!bounds_check_125896) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125893, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:113:36-40\n   #13 ftRelational.fut:110:9-113:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125890 = start_125741 + zgze_lhs_125880;
                                            float leq_arg1_125891 = ((float *) mem_param_133548.mem)[slice_125890];
                                            int64_t slice_125898 = stride_125668 + leq_arg0_125893;
                                            int64_t slice_125899 = start_125741 + slice_125898;
                                            float leq_arg0_125900 = ((float *) mem_param_133548.mem)[slice_125899];
                                            bool defunc_0_leq_res_125901 = leq_arg0_125900 <= leq_arg1_125891;
                                            
                                            leq_y_x_125885 = defunc_0_leq_res_125901;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                        
                                        if (leq_y_x_125885) {
                                            int64_t tmp_128043 = add64(tt_125837, n_125878);
                                            int64_t tmp_128044 = sub64(count_125839, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tt_125838;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = tmp_128044;
                                        } else {
                                            int64_t tmp_125907 = add64(tt_125837, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tt_125837;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tmp_125907;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = count_125839;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = ss_125835;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                    }
                                    defunc_0_lifted_step_res_f_res_125849 = defunc_0_lifted_step_res_f_res_f_res_125855;
                                    defunc_0_lifted_step_res_f_res_125850 = defunc_0_lifted_step_res_f_res_f_res_125856;
                                    defunc_0_lifted_step_res_f_res_125851 = defunc_0_lifted_step_res_f_res_f_res_125857;
                                    defunc_0_lifted_step_res_f_res_125852 = defunc_0_lifted_step_res_f_res_f_res_125858;
                                }
                                defunc_0_lifted_step_res_125842 = defunc_0_lifted_step_res_f_res_125849;
                                defunc_0_lifted_step_res_125843 = defunc_0_lifted_step_res_f_res_125850;
                                defunc_0_lifted_step_res_125844 = defunc_0_lifted_step_res_f_res_125851;
                                defunc_0_lifted_step_res_125845 = defunc_0_lifted_step_res_f_res_125852;
                            }
                            
                            int64_t loopres_125908;
                            int64_t loopres_125909;
                            int64_t loopres_125910;
                            int64_t loopres_125911;
                            int64_t loopres_125912;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125908, &loopres_125909, &loopres_125910, &loopres_125911, &loopres_125912, defunc_0_lifted_step_res_125842, ss_125836, defunc_0_lifted_step_res_125843, defunc_0_lifted_step_res_125844, defunc_0_lifted_step_res_125845) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125913 = slt64((int64_t) 0, loopres_125912);
                            bool loop_while_tmp_133911 = loop_cond_125913;
                            int64_t ss_tmp_133912 = loopres_125908;
                            int64_t ss_tmp_133913 = loopres_125909;
                            int64_t tt_tmp_133914 = loopres_125910;
                            int64_t tt_tmp_133915 = loopres_125911;
                            int64_t count_tmp_133916 = loopres_125912;
                            
                            loop_while_125834 = loop_while_tmp_133911;
                            ss_125835 = ss_tmp_133912;
                            ss_125836 = ss_tmp_133913;
                            tt_125837 = tt_tmp_133914;
                            tt_125838 = tt_tmp_133915;
                            count_125839 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125828 = loop_while_125834;
                        defunc_0_split_count_res_125829 = ss_125835;
                        defunc_0_split_count_res_125830 = ss_125836;
                        defunc_0_split_count_res_125831 = tt_125837;
                        defunc_0_split_count_res_125832 = tt_125838;
                        defunc_0_split_count_res_125833 = count_125839;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125829;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125831;
                    }
                    if (mem_133584_cached_sizze_134196 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134196, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134197 < bytes_133586) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134197, bytes_133586);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125689; i_133326++) {
                        bool y_125919 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool index_certs_125921;
                        
                        if (!y_125919) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:113:36-40\n   #10 ftRelational.fut:110:9-113:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125922 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125923 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125924 = add64((int64_t) 1, i_133326);
                        bool x_125925 = sle64((int64_t) 0, tmp_125924);
                        bool y_125926 = slt64(tmp_125924, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool bounds_check_125927 = x_125925 && y_125926;
                        bool index_certs_125928;
                        
                        if (!bounds_check_125927) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125924, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:113:36-40\n   #10 ftRelational.fut:110:9-113:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133567)[tmp_125924];
                        int64_t defunc_0_f_res_125930 = ((int64_t *) mem_133569)[tmp_125924];
                        int64_t merge_sequential_arg2_125931 = add64(stride_125668, defunc_0_f_res_125923);
                        int64_t merge_sequential_arg2_125932 = add64(stride_125668, defunc_0_f_res_125930);
                        int64_t j_m_i_125933 = sub64(merge_sequential_arg2_125932, merge_sequential_arg2_125931);
                        bool empty_slice_125934 = j_m_i_125933 == (int64_t) 0;
                        int64_t m_125935 = sub64(j_m_i_125933, (int64_t) 1);
                        int64_t i_p_m_t_s_125936 = add64(merge_sequential_arg2_125931, m_125935);
                        bool zzero_leq_i_p_m_t_s_125937 = sle64((int64_t) 0, i_p_m_t_s_125936);
                        bool i_p_m_t_s_leq_w_125938 = slt64(i_p_m_t_s_125936, next_stride_125669);
                        bool zzero_lte_i_125939 = sle64((int64_t) 0, merge_sequential_arg2_125931);
                        bool i_lte_j_125940 = sle64(merge_sequential_arg2_125931, merge_sequential_arg2_125932);
                        bool y_125941 = i_p_m_t_s_leq_w_125938 && zzero_lte_i_125939;
                        bool y_125942 = zzero_leq_i_p_m_t_s_125937 && y_125941;
                        bool forwards_ok_125943 = i_lte_j_125940 && y_125942;
                        bool ok_or_empty_125944 = empty_slice_125934 || forwards_ok_125943;
                        bool index_certs_125945;
                        
                        if (!ok_or_empty_125944) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125931, ":", (long long) merge_sequential_arg2_125932, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:113:36-40\n   #10 ftRelational.fut:110:9-113:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125946 = sub64(defunc_0_f_res_125929, defunc_0_f_res_125922);
                        bool empty_slice_125947 = j_m_i_125946 == (int64_t) 0;
                        int64_t m_125948 = sub64(j_m_i_125946, (int64_t) 1);
                        int64_t i_p_m_t_s_125949 = add64(defunc_0_f_res_125922, m_125948);
                        bool zzero_leq_i_p_m_t_s_125950 = sle64((int64_t) 0, i_p_m_t_s_125949);
                        bool i_p_m_t_s_leq_w_125951 = slt64(i_p_m_t_s_125949, next_stride_125669);
                        bool zzero_lte_i_125952 = sle64((int64_t) 0, defunc_0_f_res_125922);
                        bool i_lte_j_125953 = sle64(defunc_0_f_res_125922, defunc_0_f_res_125929);
                        bool y_125954 = i_p_m_t_s_leq_w_125951 && zzero_lte_i_125952;
                        bool y_125955 = zzero_leq_i_p_m_t_s_125950 && y_125954;
                        bool forwards_ok_125956 = i_lte_j_125953 && y_125955;
                        bool ok_or_empty_125957 = empty_slice_125947 || forwards_ok_125956;
                        bool index_certs_125958;
                        
                        if (!ok_or_empty_125957) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125922, ":", (long long) defunc_0_f_res_125929, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:113:36-40\n   #10 ftRelational.fut:110:9-113:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125959 = slt64((int64_t) 0, j_m_i_125946);
                        float dummy_125960;
                        int64_t dummy_125961;
                        
                        if (cond_125959) {
                            bool index_certs_128045;
                            
                            if (!cond_125959) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:113:36-40\n   #12 ftRelational.fut:110:9-113:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125741 + defunc_0_f_res_125922;
                            float head_res_128047 = ((float *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125960 = head_res_128047;
                            dummy_125961 = head_res_128048;
                        } else {
                            bool y_125966 = slt64((int64_t) 0, j_m_i_125933);
                            bool index_certs_125967;
                            
                            if (!y_125966) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:113:36-40\n   #12 ftRelational.fut:110:9-113:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125968 = start_125741 + merge_sequential_arg2_125931;
                            float head_res_125969 = ((float *) mem_param_133548.mem)[slice_125968];
                            int64_t head_res_125970 = ((int64_t *) mem_param_133551.mem)[slice_125968];
                            
                            dummy_125960 = head_res_125969;
                            dummy_125961 = head_res_125970;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125554; nest_i_133919++) {
                            ((float *) mem_133584)[i_133326 * merge_block_sizze_125554 + nest_i_133919] = dummy_125960;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125554; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + nest_i_133920] = dummy_125961;
                        }
                        
                        int64_t data_125973;
                        int64_t i_125977 = (int64_t) 0;
                        
                        for (int64_t k_125976 = 0; k_125976 < merge_block_sizze_125554; k_125976++) {
                            int64_t j_125980 = sub64(k_125976, i_125977);
                            bool cond_125981 = j_125980 == j_m_i_125933;
                            bool cond_125982;
                            
                            if (cond_125981) {
                                cond_125982 = 1;
                            } else {
                                bool cond_125983 = slt64(i_125977, j_m_i_125946);
                                bool cond_f_res_125984;
                                
                                if (cond_125983) {
                                    bool x_128049 = sle64((int64_t) 0, j_125980);
                                    bool y_128050 = slt64(j_125980, j_m_i_125933);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:113:36-40\n   #11 ftRelational.fut:110:9-113:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125977);
                                    bool bounds_check_128057 = cond_125983 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:113:36-40\n   #11 ftRelational.fut:110:9-113:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125931 + j_125980;
                                    int64_t slice_128054 = start_125741 + slice_128053;
                                    float leq_arg1_128055 = ((float *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125922 + i_125977;
                                    int64_t slice_128060 = start_125741 + slice_128059;
                                    float leq_arg0_128061 = ((float *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = leq_arg0_128061 <= leq_arg1_128055;
                                    
                                    cond_f_res_125984 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125984 = 0;
                                }
                                cond_125982 = cond_f_res_125984;
                            }
                            
                            int64_t loopres_125999;
                            float loopres_126000;
                            int64_t loopres_126001;
                            
                            if (cond_125982) {
                                bool x_128064 = sle64((int64_t) 0, i_125977);
                                bool y_128065 = slt64(i_125977, j_m_i_125946);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:113:36-40\n   #11 ftRelational.fut:110:9-113:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125977);
                                int64_t slice_128068 = defunc_0_f_res_125922 + i_125977;
                                int64_t slice_128069 = start_125741 + slice_128068;
                                float tmp_128070 = ((float *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_125999 = tmp_128063;
                                loopres_126000 = tmp_128070;
                                loopres_126001 = tmp_128071;
                            } else {
                                bool x_126011 = sle64((int64_t) 0, j_125980);
                                bool y_126012 = slt64(j_125980, j_m_i_125933);
                                bool bounds_check_126013 = x_126011 && y_126012;
                                bool index_certs_126014;
                                
                                if (!bounds_check_126013) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:113:36-40\n   #11 ftRelational.fut:110:9-113:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126015 = merge_sequential_arg2_125931 + j_125980;
                                int64_t slice_126016 = start_125741 + slice_126015;
                                float tmp_126017 = ((float *) mem_param_133548.mem)[slice_126016];
                                int64_t tmp_126018 = ((int64_t *) mem_param_133551.mem)[slice_126016];
                                
                                loopres_125999 = i_125977;
                                loopres_126000 = tmp_126017;
                                loopres_126001 = tmp_126018;
                            }
                            ((float *) mem_133584)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126000;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126001;
                            
                            int64_t i_tmp_133921 = loopres_125999;
                            
                            i_125977 = i_tmp_133921;
                        }
                        data_125973 = i_125977;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_4b(ctx, 2, (uint32_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint32_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133586, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_4b(ctx, 1, (uint32_t *) mem_133554, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126025 = next_stride_125669 * num_merges_125673;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_4b(ctx, 2, (uint32_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint32_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            if (memblock_alloc(ctx, &mem_133664, bytes_133556, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            
            bool loop_cond_126028 = slt64(next_stride_125669, flat_dim_125550);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126025;
            bool loop_while_tmp_133898 = loop_cond_126028;
            int64_t stride_tmp_133901 = next_stride_125669;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125664 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125665 = loop_while_tmp_133898;
            stride_125668 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125659 = loop_dz2084Uz2082U_125664;
        data_125660 = loop_while_125665;
        data_125663 = stride_125668;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126029 = n_81146 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126030 = sle64((int64_t) 0, zs_lhs_125534);
        bool i_p_m_t_s_leq_w_126031 = slt64(zs_lhs_125534, data_125659);
        bool y_126032 = zzero_leq_i_p_m_t_s_126030 && i_p_m_t_s_leq_w_126031;
        bool ok_or_empty_126033 = empty_slice_126029 || y_126032;
        bool index_certs_126034;
        
        if (!ok_or_empty_126033) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_81146, "] out of bounds for array of shape [", (long long) data_125659, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:113:36-40\n   #6  ftRelational.fut:110:9-113:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133675, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133677, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_81146; i_133340++) {
        int64_t eta_p_126042 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126043 = sle64((int64_t) 0, eta_p_126042);
        bool y_126044 = slt64(eta_p_126042, n_81146);
        bool bounds_check_126045 = x_126043 && y_126044;
        bool index_certs_126046;
        
        if (!bounds_check_126045) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126042, "] out of bounds for array of shape [", (long long) n_81146, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:113:36-40\n   #5  ftRelational.fut:110:9-113:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        float lifted_lambda_res_126047 = ((float *) k_mem_133466.mem)[eta_p_126042];
        
        ((float *) mem_133676.mem)[i_133340] = lifted_lambda_res_126047;
        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133678.mem, i_133340 * b_81147, (int64_t []) {(int64_t) 1}, (uint8_t *) pL_mem_133467.mem, eta_p_126042 * b_81147, (int64_t []) {(int64_t) 1}, (int64_t []) {b_81147});
    }
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134186, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134187, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_int(struct futhark_context *ctx, struct memblock *mem_out_p_134198, struct memblock *mem_out_p_134199, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_76426, int64_t b_76427)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134200 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134201 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134202 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134203 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134204 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134205 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134206 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134207 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134208 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134209 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_76426;
    bool cond_125533 = sle64(n_76426, (int64_t) 1);
    int64_t zs_lhs_125534 = sub64(n_76426, (int64_t) 1);
    int64_t zp_rhs_125535 = sdiv_safe64(zs_lhs_125534, (int64_t) 20);
    int64_t min_num_blocks_125536 = add64((int64_t) 1, zp_rhs_125535);
    bool loop_cond_125537 = slt64((int64_t) 1, min_num_blocks_125536);
    bool smallest_pow_2_geq_than_res_125538;
    int64_t smallest_pow_2_geq_than_res_125539;
    bool loop_while_125540;
    int64_t x_125541;
    
    loop_while_125540 = loop_cond_125537;
    x_125541 = (int64_t) 1;
    while (loop_while_125540) {
        int64_t loopres_125542 = mul64((int64_t) 2, x_125541);
        bool loop_cond_125543 = slt64(loopres_125542, min_num_blocks_125536);
        bool loop_while_tmp_133879 = loop_cond_125543;
        int64_t x_tmp_133880 = loopres_125542;
        
        loop_while_125540 = loop_while_tmp_133879;
        x_125541 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125538 = loop_while_125540;
    smallest_pow_2_geq_than_res_125539 = x_125541;
    
    bool zzero_125544 = smallest_pow_2_geq_than_res_125539 == (int64_t) 0;
    bool nonzzero_125545 = !zzero_125544;
    bool protect_assert_disj_125546 = cond_125533 || nonzzero_125545;
    bool nonzzero_cert_125547;
    
    if (!protect_assert_disj_125546) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:105:36-40\n   #5  ftRelational.fut:102:9-105:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125548 = sdiv_safe64(zs_lhs_125534, smallest_pow_2_geq_than_res_125539);
    int64_t block_sizze_125549 = add64((int64_t) 1, zp_rhs_125548);
    bool y_125555 = slt64((int64_t) 0, n_76426);
    bool protect_assert_disj_133752 = cond_125533 || y_125555;
    bool index_certs_125556;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_76426, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:105:36-40\n   #5  ftRelational.fut:102:9-105:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125570 = slt64(smallest_pow_2_geq_than_res_125539, (int64_t) 0);
    bool valid_125571 = !bounds_invalid_upwards_125570;
    bool protect_assert_disj_133760 = cond_125533 || valid_125571;
    bool range_valid_c_125572;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125539, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:105:36-40\n   #6  ftRelational.fut:102:9-105:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125574 = slt64(block_sizze_125549, (int64_t) 0);
    bool valid_125575 = !bounds_invalid_upwards_125574;
    bool protect_assert_disj_133762 = cond_125533 || valid_125575;
    bool range_valid_c_125576;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125549, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125578 = sle64(block_sizze_125549, (int64_t) 1);
    int64_t tmp_125579 = sub64(block_sizze_125549, (int64_t) 2);
    bool bounds_invalid_upwards_125580 = slt64(tmp_125579, (int64_t) 0);
    bool valid_125582 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_125583 = cond_125578 || valid_125582;
    bool protect_assert_disj_133764 = cond_125533 || protect_assert_disj_125583;
    bool range_valid_c_125584;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125579, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133675 = (int64_t) 4 * n_76426;
    int64_t bytes_133677 = n_76426 * b_76427;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_76426; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125550 = smallest_pow_2_geq_than_res_125539 * block_sizze_125549;
    bool x_133747 = !cond_125533;
    int64_t greatest_divisor_leq_than_arg1_125553 = mul64((int64_t) 2, block_sizze_125549);
    int64_t merge_block_sizze_125554;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125553) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125554 = x_133749;
    } else {
        merge_block_sizze_125554 = (int64_t) 0;
    }
    
    int32_t reduce_arg1_125557;
    
    if (x_133747) {
        int32_t x_133753 = ((int32_t *) k_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125557 = x_133753;
    } else {
        reduce_arg1_125557 = 0;
    }
    
    int32_t defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        int32_t x_133755;
        int64_t x_133756;
        int32_t redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125557;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_76426; i_133300++) {
            int32_t x_125561 = ((int32_t *) k_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125567 = sle32(redout_133298, x_125561);
            int32_t defunc_0_op_res_125568;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125568 = x_125561;
            } else {
                defunc_0_op_res_125568 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125569;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125569 = i_133300;
            } else {
                defunc_0_op_res_125569 = redout_133299;
            }
            
            int32_t redout_tmp_133883 = defunc_0_op_res_125568;
            int64_t redout_tmp_133884 = defunc_0_op_res_125569;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = 0;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125581 = add64((int64_t) 1, tmp_125579);
    int64_t binop_x_133470 = (int64_t) 4 * smallest_pow_2_geq_than_res_125539;
    int64_t bytes_133471 = block_sizze_125549 * binop_x_133470;
    int64_t binop_x_133473 = (int64_t) 8 * smallest_pow_2_geq_than_res_125539;
    int64_t bytes_133474 = block_sizze_125549 * binop_x_133473;
    int64_t bytes_133484 = (int64_t) 4 * block_sizze_125549;
    int64_t bytes_133486 = (int64_t) 8 * block_sizze_125549;
    bool loop_cond_125656 = slt64(block_sizze_125549, flat_dim_125550);
    bool zzero_125657 = merge_block_sizze_125554 == (int64_t) 0;
    bool nonzzero_125658 = !zzero_125657;
    
    if (cond_125533) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134200 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134200, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134201 < bytes_133474) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134201, bytes_133474);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134202 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134202, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134203 < bytes_133486) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134203, bytes_133486);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125539; i_133312++) {
            int64_t zp_lhs_125588 = mul64(block_sizze_125549, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125549; i_133305++) {
                int64_t k_125592 = add64(zp_lhs_125588, i_133305);
                bool cond_125593 = slt64(k_125592, n_76426);
                int32_t lifted_lambda_res_125594;
                int64_t lifted_lambda_res_125595;
                
                if (cond_125593) {
                    bool x_127931 = sle64((int64_t) 0, k_125592);
                    bool bounds_check_127932 = cond_125593 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125592, "] out of bounds for array of shape [", (long long) n_76426, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:105:36-40\n   #9  ftRelational.fut:102:9-105:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t lifted_lambda_res_t_res_127934 = ((int32_t *) k_mem_133466.mem)[k_125592];
                    
                    lifted_lambda_res_125594 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125595 = k_125592;
                } else {
                    lifted_lambda_res_125594 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125595 = defunc_0_reduce_res_128079;
                }
                ((int32_t *) mem_133485)[i_133305] = lifted_lambda_res_125594;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125595;
            }
            if (!cond_125578) {
                for (int64_t i_125605 = 0; i_125605 < distance_125581; i_125605++) {
                    int64_t gt_arg1_125608 = add64((int64_t) 1, i_125605);
                    bool x_125609 = sle64((int64_t) 0, gt_arg1_125608);
                    bool y_125610 = slt64(gt_arg1_125608, block_sizze_125549);
                    bool bounds_check_125611 = x_125609 && y_125610;
                    bool index_certs_125612;
                    
                    if (!bounds_check_125611) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125608, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125614 = slt64(i_125605, block_sizze_125549);
                    bool index_certs_125615;
                    
                    if (!y_125614) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125605, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t gt_arg1_125613 = ((int32_t *) mem_133485)[gt_arg1_125608];
                    int32_t gt_arg0_125616 = ((int32_t *) mem_133485)[i_125605];
                    bool defunc_0_leq_res_125617 = sle32(gt_arg0_125616, gt_arg1_125613);
                    bool defunc_0_lifted_gt_res_125618 = !defunc_0_leq_res_125617;
                    bool s_125619;
                    int64_t s_125622;
                    bool loop_while_125623;
                    int64_t j_125626;
                    
                    loop_while_125623 = defunc_0_lifted_gt_res_125618;
                    j_125626 = i_125605;
                    while (loop_while_125623) {
                        bool x_125627 = sle64((int64_t) 0, j_125626);
                        bool y_125628 = slt64(j_125626, block_sizze_125549);
                        bool bounds_check_125629 = x_125627 && y_125628;
                        bool index_certs_125630;
                        
                        if (!bounds_check_125629) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125626, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125633 = add64((int64_t) 1, j_125626);
                        bool x_125634 = sle64((int64_t) 0, copy_arg0_125633);
                        bool y_125635 = slt64(copy_arg0_125633, block_sizze_125549);
                        bool bounds_check_125636 = x_125634 && y_125635;
                        bool index_certs_125637;
                        
                        if (!bounds_check_125636) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125633, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t copy_arg0_125631 = ((int32_t *) mem_133485)[j_125626];
                        int64_t copy_arg0_125632 = ((int64_t *) mem_133487)[j_125626];
                        int32_t copy_arg0_125638 = ((int32_t *) mem_133485)[copy_arg0_125633];
                        int64_t copy_arg0_125639 = ((int64_t *) mem_133487)[copy_arg0_125633];
                        
                        ((int32_t *) mem_133485)[j_125626] = copy_arg0_125638;
                        ((int64_t *) mem_133487)[j_125626] = copy_arg0_125639;
                        ((int32_t *) mem_133485)[copy_arg0_125633] = copy_arg0_125631;
                        ((int64_t *) mem_133487)[copy_arg0_125633] = copy_arg0_125632;
                        
                        int64_t tmp_125644 = sub64(j_125626, (int64_t) 1);
                        bool cond_125645 = sle64((int64_t) 0, tmp_125644);
                        bool loop_cond_125646;
                        
                        if (cond_125645) {
                            bool y_127936 = slt64(tmp_125644, block_sizze_125549);
                            bool bounds_check_127937 = cond_125645 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125644, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t gt_arg1_127935 = ((int32_t *) mem_133485)[j_125626];
                            int32_t gt_arg0_127939 = ((int32_t *) mem_133485)[tmp_125644];
                            bool defunc_0_leq_res_127940 = sle32(gt_arg0_127939, gt_arg1_127935);
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125646 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125646 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125646;
                        int64_t j_tmp_133894 = tmp_125644;
                        
                        loop_while_125623 = loop_while_tmp_133891;
                        j_125626 = j_tmp_133894;
                    }
                    s_125619 = loop_while_125623;
                    s_125622 = j_125626;
                }
            }
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133472, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_4b(ctx, 2, (uint32_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint32_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        if (memblock_alloc(ctx, &mem_133544, bytes_133474, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        
        int64_t data_125659;
        bool data_125660;
        int64_t data_125663;
        int64_t loop_dz2084Uz2082U_125664;
        bool loop_while_125665;
        int64_t stride_125668;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125664 = flat_dim_125550;
        loop_while_125665 = loop_cond_125656;
        stride_125668 = block_sizze_125549;
        while (loop_while_125665) {
            int64_t next_stride_125669 = mul64((int64_t) 2, stride_125668);
            bool zzero_125670 = next_stride_125669 == (int64_t) 0;
            bool nonzzero_125671 = !zzero_125670;
            bool nonzzero_cert_125672;
            
            if (!nonzzero_125671) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:105:36-40\n   #5  ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125673 = sdiv64(flat_dim_125550, next_stride_125669);
            bool bounds_invalid_upwards_125674 = slt64(num_merges_125673, (int64_t) 0);
            bool valid_125675 = !bounds_invalid_upwards_125674;
            bool range_valid_c_125676;
            
            if (!valid_125675) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125673, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:105:36-40\n   #6  ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125678 = sub64(next_stride_125669, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125679 = sle64((int64_t) 0, m_125678);
            bool cond_125681 = slt64(next_stride_125669, (int64_t) 10);
            bool protect_assert_disj_125682 = nonzzero_125658 || cond_125681;
            bool nonzzero_cert_125683;
            
            if (!protect_assert_disj_125682) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125684 = smod_safe64(next_stride_125669, merge_block_sizze_125554);
            bool num_blocks_125685 = zeze_lhs_125684 == (int64_t) 0;
            bool protect_assert_disj_125686 = cond_125681 || num_blocks_125685;
            bool assert_c_125687;
            
            if (!protect_assert_disj_125686) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125689 = sdiv_safe64(next_stride_125669, merge_block_sizze_125554);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690 = add64((int64_t) 1, num_blocks_125689);
            int64_t j_m_i_125691 = sub64(next_stride_125669, stride_125668);
            int64_t flat_dim_125692 = merge_block_sizze_125554 * num_blocks_125689;
            bool bounds_invalid_upwards_125693 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, (int64_t) 0);
            bool empty_slice_125694 = j_m_i_125691 == (int64_t) 0;
            int64_t m_125695 = sub64(j_m_i_125691, (int64_t) 1);
            bool zzero_lte_i_125696 = sle64((int64_t) 0, stride_125668);
            bool i_lte_j_125697 = sle64(stride_125668, next_stride_125669);
            bool empty_slice_125698 = stride_125668 == (int64_t) 0;
            int64_t m_125699 = sub64(stride_125668, (int64_t) 1);
            bool bounds_invalid_upwards_125700 = slt64(num_blocks_125689, (int64_t) 0);
            bool cond_125701 = slt64((int64_t) 0, stride_125668);
            bool valid_125702 = !bounds_invalid_upwards_125693;
            int64_t i_p_m_t_s_125703 = add64(stride_125668, m_125695);
            bool zzero_leq_i_p_m_t_s_125704 = sle64((int64_t) 0, m_125699);
            bool i_p_m_t_s_leq_w_125705 = slt64(m_125699, next_stride_125669);
            bool valid_125706 = !bounds_invalid_upwards_125700;
            bool i_p_m_t_s_leq_w_125707 = slt64(m_125678, flat_dim_125692);
            bool y_125708 = slt64((int64_t) 0, j_m_i_125691);
            bool protect_assert_disj_125709 = cond_125681 || valid_125702;
            bool range_valid_c_125710;
            
            if (!protect_assert_disj_125709) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:105:36-40\n   #10 ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125711 = sle64((int64_t) 0, i_p_m_t_s_125703);
            bool i_p_m_t_s_leq_w_125712 = slt64(i_p_m_t_s_125703, next_stride_125669);
            bool y_125713 = zzero_leq_i_p_m_t_s_125704 && i_p_m_t_s_leq_w_125705;
            bool protect_assert_disj_125714 = cond_125681 || valid_125706;
            bool range_valid_c_125715;
            
            if (!protect_assert_disj_125714) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125689, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:105:36-40\n   #9  ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125716 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125707;
            bool y_125717 = zzero_lte_i_125696 && i_p_m_t_s_leq_w_125712;
            bool forwards_ok_125718 = zzero_lte_i_125696 && y_125713;
            bool ok_or_empty_125719 = zzero_125670 || y_125716;
            bool protect_assert_disj_125720 = cond_125701 || y_125708;
            bool y_125721 = zzero_leq_i_p_m_t_s_125711 && y_125717;
            bool ok_or_empty_125722 = empty_slice_125698 || forwards_ok_125718;
            bool protect_assert_disj_125723 = cond_125681 || ok_or_empty_125719;
            bool index_certs_125724;
            
            if (!protect_assert_disj_125723) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) flat_dim_125692, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:105:36-40\n   #9  ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125725 = !cond_125681;
            bool protect_assert_disj_125726 = protect_assert_disj_125720 || loop_not_taken_125725;
            bool index_certs_125727;
            
            if (!protect_assert_disj_125726) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:105:36-40\n   #10 ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125728 = i_lte_j_125697 && y_125721;
            bool protect_assert_disj_125729 = cond_125681 || ok_or_empty_125722;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:105:36-40\n   #11 ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125731 = ok_or_empty_125722 || loop_not_taken_125725;
            bool index_certs_125732;
            
            if (!protect_assert_disj_125731) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125733 = empty_slice_125694 || forwards_ok_125728;
            bool protect_assert_disj_125734 = cond_125681 || ok_or_empty_125733;
            bool index_certs_125735;
            
            if (!protect_assert_disj_125734) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:105:36-40\n   #11 ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125736 = loop_not_taken_125725 || ok_or_empty_125733;
            bool index_certs_125737;
            
            if (!protect_assert_disj_125736) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 4 * num_merges_125673;
            int64_t bytes_133553 = next_stride_125669 * binop_x_133552;
            int64_t binop_x_133555 = (int64_t) 8 * num_merges_125673;
            int64_t bytes_133556 = next_stride_125669 * binop_x_133555;
            bool i_lte_j_125680 = sle64((int64_t) 0, next_stride_125669);
            
            if (mem_133554_cached_sizze_134204 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134204, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134205 < bytes_133556) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134205, bytes_133556);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690;
            int64_t binop_x_133582 = (int64_t) 4 * num_blocks_125689;
            int64_t bytes_133583 = merge_block_sizze_125554 * binop_x_133582;
            int64_t binop_x_133585 = (int64_t) 8 * num_blocks_125689;
            int64_t bytes_133586 = merge_block_sizze_125554 * binop_x_133585;
            int64_t bytes_133628 = (int64_t) 8 * stride_125668;
            int64_t bytes_133630 = (int64_t) 16 * stride_125668;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125673; i_133333++) {
                int64_t start_125741 = mul64(next_stride_125669, i_133333);
                int64_t j_m_i_125742 = sub64(loop_dz2084Uz2082U_125664, start_125741);
                bool empty_slice_125743 = j_m_i_125742 == (int64_t) 0;
                int64_t m_125744 = sub64(j_m_i_125742, (int64_t) 1);
                int64_t i_p_m_t_s_125745 = add64(start_125741, m_125744);
                bool zzero_leq_i_p_m_t_s_125746 = sle64((int64_t) 0, i_p_m_t_s_125745);
                bool i_p_m_t_s_leq_w_125747 = slt64(i_p_m_t_s_125745, loop_dz2084Uz2082U_125664);
                bool zzero_lte_i_125748 = sle64((int64_t) 0, start_125741);
                bool i_lte_j_125749 = sle64(start_125741, loop_dz2084Uz2082U_125664);
                bool y_125750 = i_p_m_t_s_leq_w_125747 && zzero_lte_i_125748;
                bool y_125751 = zzero_leq_i_p_m_t_s_125746 && y_125750;
                bool forwards_ok_125752 = i_lte_j_125749 && y_125751;
                bool ok_or_empty_125753 = empty_slice_125743 || forwards_ok_125752;
                bool index_certs_125754;
                
                if (!ok_or_empty_125753) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125741, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125664, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125755 = slt64(m_125678, j_m_i_125742);
                bool y_125756 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125755;
                bool forwards_ok_125757 = i_lte_j_125680 && y_125756;
                bool ok_or_empty_125758 = zzero_125670 || forwards_ok_125757;
                bool index_certs_125759;
                
                if (!ok_or_empty_125758) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) j_m_i_125742, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:105:36-40\n   #8  ftRelational.fut:102:9-105:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125681) {
                    int32_t dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125701) {
                        int32_t head_res_127969 = ((int32_t *) mem_param_133548.mem)[start_125741];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125741];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125668 + start_125741;
                        int32_t head_res_127972 = ((int32_t *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125669; nest_i_133904++) {
                        ((int32_t *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133630, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125669; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125669; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125691;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125668);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125691);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:105:36-40\n   #9  ftRelational.fut:102:9-105:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:105:36-40\n   #9  ftRelational.fut:102:9-105:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125668 + j_127983;
                                int64_t slice_127993 = start_125741 + slice_127992;
                                int32_t leq_arg1_127994 = ((int32_t *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125741 + i_127980;
                                int32_t leq_arg0_127999 = ((int32_t *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = sle32(leq_arg0_127999, leq_arg1_127994);
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        int32_t loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125668);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:105:36-40\n   #9  ftRelational.fut:102:9-105:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125741 + i_127980;
                            int32_t tmp_128010 = ((int32_t *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125691);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:105:36-40\n   #9  ftRelational.fut:102:9-105:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125668 + j_127983;
                            int64_t slice_128017 = start_125741 + slice_128016;
                            int32_t tmp_128018 = ((int32_t *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((int32_t *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134206 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134206, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134207 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134207, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690; i_133319++) {
                        int64_t split_count_arg3_125821 = mul64(merge_block_sizze_125554, i_133319);
                        int64_t defunc_0_split_count_res_125822;
                        int64_t defunc_0_split_count_res_125823;
                        int64_t defunc_0_split_count_res_125824;
                        int64_t defunc_0_split_count_res_125825;
                        int64_t defunc_0_split_count_res_125826;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125822, &defunc_0_split_count_res_125823, &defunc_0_split_count_res_125824, &defunc_0_split_count_res_125825, &defunc_0_split_count_res_125826, (int64_t) 0, stride_125668, (int64_t) 0, j_m_i_125691, split_count_arg3_125821) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125827 = slt64((int64_t) 0, defunc_0_split_count_res_125826);
                        bool defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        int64_t defunc_0_split_count_res_125833;
                        bool loop_while_125834;
                        int64_t ss_125835;
                        int64_t ss_125836;
                        int64_t tt_125837;
                        int64_t tt_125838;
                        int64_t count_125839;
                        
                        loop_while_125834 = loop_cond_125827;
                        ss_125835 = defunc_0_split_count_res_125822;
                        ss_125836 = defunc_0_split_count_res_125823;
                        tt_125837 = defunc_0_split_count_res_125824;
                        tt_125838 = defunc_0_split_count_res_125825;
                        count_125839 = defunc_0_split_count_res_125826;
                        while (loop_while_125834) {
                            int64_t zlze_lhs_125840 = sub64(ss_125836, ss_125835);
                            bool cond_125841 = sle64(zlze_lhs_125840, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125842;
                            int64_t defunc_0_lifted_step_res_125843;
                            int64_t defunc_0_lifted_step_res_125844;
                            int64_t defunc_0_lifted_step_res_125845;
                            
                            if (cond_125841) {
                                int64_t tmp_128022 = add64(tt_125837, count_125839);
                                
                                defunc_0_lifted_step_res_125842 = ss_125835;
                                defunc_0_lifted_step_res_125843 = tmp_128022;
                                defunc_0_lifted_step_res_125844 = tt_125838;
                                defunc_0_lifted_step_res_125845 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125847 = sub64(tt_125838, tt_125837);
                                bool cond_125848 = sle64(zlze_lhs_125847, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125849;
                                int64_t defunc_0_lifted_step_res_f_res_125850;
                                int64_t defunc_0_lifted_step_res_f_res_125851;
                                int64_t defunc_0_lifted_step_res_f_res_125852;
                                
                                if (cond_125848) {
                                    int64_t tmp_128023 = add64(ss_125835, count_125839);
                                    
                                    defunc_0_lifted_step_res_f_res_125849 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125850 = tt_125837;
                                    defunc_0_lifted_step_res_f_res_125851 = tt_125838;
                                    defunc_0_lifted_step_res_f_res_125852 = (int64_t) 0;
                                } else {
                                    bool cond_125854 = count_125839 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125855;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125856;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125857;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125858;
                                    
                                    if (cond_125854) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125835);
                                        bool y_128026 = slt64(ss_125835, stride_125668);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125835, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:105:36-40\n   #13 ftRelational.fut:102:9-105:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125837);
                                        bool y_128032 = slt64(tt_125837, j_m_i_125691);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125837, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:105:36-40\n   #13 ftRelational.fut:102:9-105:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125741 + ss_125835;
                                        int32_t leq_arg1_128030 = ((int32_t *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125668 + tt_125837;
                                        int64_t slice_128036 = start_125741 + slice_128035;
                                        int32_t leq_arg0_128037 = ((int32_t *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = sle32(leq_arg0_128037, leq_arg1_128030);
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125837);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125835;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125835);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125837;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = tt_125838;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = (int64_t) 0;
                                    } else {
                                        int64_t m_125877 = sdiv64(count_125839, (int64_t) 2);
                                        int64_t n_125878 = sub64(count_125839, m_125877);
                                        bool cond_125879 = n_125878 == (int64_t) 0;
                                        int64_t zgze_lhs_125880 = add64(ss_125835, m_125877);
                                        bool cond_f_res_125881 = sle64(ss_125836, zgze_lhs_125880);
                                        bool x_125882 = !cond_125879;
                                        bool y_125883 = cond_f_res_125881 && x_125882;
                                        bool cond_125884 = cond_125879 || y_125883;
                                        bool leq_y_x_125885;
                                        
                                        if (cond_125884) {
                                            leq_y_x_125885 = 1;
                                        } else {
                                            bool x_125886 = sle64((int64_t) 0, zgze_lhs_125880);
                                            bool y_125887 = slt64(zgze_lhs_125880, stride_125668);
                                            bool bounds_check_125888 = x_125886 && y_125887;
                                            bool index_certs_125889;
                                            
                                            if (!bounds_check_125888) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125880, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:105:36-40\n   #13 ftRelational.fut:102:9-105:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125892 = add64(tt_125837, n_125878);
                                            int64_t leq_arg0_125893 = sub64(zm_lhs_125892, (int64_t) 1);
                                            bool x_125894 = sle64((int64_t) 0, leq_arg0_125893);
                                            bool y_125895 = slt64(leq_arg0_125893, j_m_i_125691);
                                            bool bounds_check_125896 = x_125894 && y_125895;
                                            bool index_certs_125897;
                                            
                                            if (!bounds_check_125896) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125893, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:105:36-40\n   #13 ftRelational.fut:102:9-105:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125890 = start_125741 + zgze_lhs_125880;
                                            int32_t leq_arg1_125891 = ((int32_t *) mem_param_133548.mem)[slice_125890];
                                            int64_t slice_125898 = stride_125668 + leq_arg0_125893;
                                            int64_t slice_125899 = start_125741 + slice_125898;
                                            int32_t leq_arg0_125900 = ((int32_t *) mem_param_133548.mem)[slice_125899];
                                            bool defunc_0_leq_res_125901 = sle32(leq_arg0_125900, leq_arg1_125891);
                                            
                                            leq_y_x_125885 = defunc_0_leq_res_125901;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                        
                                        if (leq_y_x_125885) {
                                            int64_t tmp_128043 = add64(tt_125837, n_125878);
                                            int64_t tmp_128044 = sub64(count_125839, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tt_125838;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = tmp_128044;
                                        } else {
                                            int64_t tmp_125907 = add64(tt_125837, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tt_125837;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tmp_125907;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = count_125839;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = ss_125835;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                    }
                                    defunc_0_lifted_step_res_f_res_125849 = defunc_0_lifted_step_res_f_res_f_res_125855;
                                    defunc_0_lifted_step_res_f_res_125850 = defunc_0_lifted_step_res_f_res_f_res_125856;
                                    defunc_0_lifted_step_res_f_res_125851 = defunc_0_lifted_step_res_f_res_f_res_125857;
                                    defunc_0_lifted_step_res_f_res_125852 = defunc_0_lifted_step_res_f_res_f_res_125858;
                                }
                                defunc_0_lifted_step_res_125842 = defunc_0_lifted_step_res_f_res_125849;
                                defunc_0_lifted_step_res_125843 = defunc_0_lifted_step_res_f_res_125850;
                                defunc_0_lifted_step_res_125844 = defunc_0_lifted_step_res_f_res_125851;
                                defunc_0_lifted_step_res_125845 = defunc_0_lifted_step_res_f_res_125852;
                            }
                            
                            int64_t loopres_125908;
                            int64_t loopres_125909;
                            int64_t loopres_125910;
                            int64_t loopres_125911;
                            int64_t loopres_125912;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125908, &loopres_125909, &loopres_125910, &loopres_125911, &loopres_125912, defunc_0_lifted_step_res_125842, ss_125836, defunc_0_lifted_step_res_125843, defunc_0_lifted_step_res_125844, defunc_0_lifted_step_res_125845) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125913 = slt64((int64_t) 0, loopres_125912);
                            bool loop_while_tmp_133911 = loop_cond_125913;
                            int64_t ss_tmp_133912 = loopres_125908;
                            int64_t ss_tmp_133913 = loopres_125909;
                            int64_t tt_tmp_133914 = loopres_125910;
                            int64_t tt_tmp_133915 = loopres_125911;
                            int64_t count_tmp_133916 = loopres_125912;
                            
                            loop_while_125834 = loop_while_tmp_133911;
                            ss_125835 = ss_tmp_133912;
                            ss_125836 = ss_tmp_133913;
                            tt_125837 = tt_tmp_133914;
                            tt_125838 = tt_tmp_133915;
                            count_125839 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125828 = loop_while_125834;
                        defunc_0_split_count_res_125829 = ss_125835;
                        defunc_0_split_count_res_125830 = ss_125836;
                        defunc_0_split_count_res_125831 = tt_125837;
                        defunc_0_split_count_res_125832 = tt_125838;
                        defunc_0_split_count_res_125833 = count_125839;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125829;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125831;
                    }
                    if (mem_133584_cached_sizze_134208 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134208, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134209 < bytes_133586) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134209, bytes_133586);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125689; i_133326++) {
                        bool y_125919 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool index_certs_125921;
                        
                        if (!y_125919) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:105:36-40\n   #10 ftRelational.fut:102:9-105:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125922 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125923 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125924 = add64((int64_t) 1, i_133326);
                        bool x_125925 = sle64((int64_t) 0, tmp_125924);
                        bool y_125926 = slt64(tmp_125924, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool bounds_check_125927 = x_125925 && y_125926;
                        bool index_certs_125928;
                        
                        if (!bounds_check_125927) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125924, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:105:36-40\n   #10 ftRelational.fut:102:9-105:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133567)[tmp_125924];
                        int64_t defunc_0_f_res_125930 = ((int64_t *) mem_133569)[tmp_125924];
                        int64_t merge_sequential_arg2_125931 = add64(stride_125668, defunc_0_f_res_125923);
                        int64_t merge_sequential_arg2_125932 = add64(stride_125668, defunc_0_f_res_125930);
                        int64_t j_m_i_125933 = sub64(merge_sequential_arg2_125932, merge_sequential_arg2_125931);
                        bool empty_slice_125934 = j_m_i_125933 == (int64_t) 0;
                        int64_t m_125935 = sub64(j_m_i_125933, (int64_t) 1);
                        int64_t i_p_m_t_s_125936 = add64(merge_sequential_arg2_125931, m_125935);
                        bool zzero_leq_i_p_m_t_s_125937 = sle64((int64_t) 0, i_p_m_t_s_125936);
                        bool i_p_m_t_s_leq_w_125938 = slt64(i_p_m_t_s_125936, next_stride_125669);
                        bool zzero_lte_i_125939 = sle64((int64_t) 0, merge_sequential_arg2_125931);
                        bool i_lte_j_125940 = sle64(merge_sequential_arg2_125931, merge_sequential_arg2_125932);
                        bool y_125941 = i_p_m_t_s_leq_w_125938 && zzero_lte_i_125939;
                        bool y_125942 = zzero_leq_i_p_m_t_s_125937 && y_125941;
                        bool forwards_ok_125943 = i_lte_j_125940 && y_125942;
                        bool ok_or_empty_125944 = empty_slice_125934 || forwards_ok_125943;
                        bool index_certs_125945;
                        
                        if (!ok_or_empty_125944) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125931, ":", (long long) merge_sequential_arg2_125932, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:105:36-40\n   #10 ftRelational.fut:102:9-105:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125946 = sub64(defunc_0_f_res_125929, defunc_0_f_res_125922);
                        bool empty_slice_125947 = j_m_i_125946 == (int64_t) 0;
                        int64_t m_125948 = sub64(j_m_i_125946, (int64_t) 1);
                        int64_t i_p_m_t_s_125949 = add64(defunc_0_f_res_125922, m_125948);
                        bool zzero_leq_i_p_m_t_s_125950 = sle64((int64_t) 0, i_p_m_t_s_125949);
                        bool i_p_m_t_s_leq_w_125951 = slt64(i_p_m_t_s_125949, next_stride_125669);
                        bool zzero_lte_i_125952 = sle64((int64_t) 0, defunc_0_f_res_125922);
                        bool i_lte_j_125953 = sle64(defunc_0_f_res_125922, defunc_0_f_res_125929);
                        bool y_125954 = i_p_m_t_s_leq_w_125951 && zzero_lte_i_125952;
                        bool y_125955 = zzero_leq_i_p_m_t_s_125950 && y_125954;
                        bool forwards_ok_125956 = i_lte_j_125953 && y_125955;
                        bool ok_or_empty_125957 = empty_slice_125947 || forwards_ok_125956;
                        bool index_certs_125958;
                        
                        if (!ok_or_empty_125957) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125922, ":", (long long) defunc_0_f_res_125929, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:105:36-40\n   #10 ftRelational.fut:102:9-105:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125959 = slt64((int64_t) 0, j_m_i_125946);
                        int32_t dummy_125960;
                        int64_t dummy_125961;
                        
                        if (cond_125959) {
                            bool index_certs_128045;
                            
                            if (!cond_125959) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:105:36-40\n   #12 ftRelational.fut:102:9-105:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125741 + defunc_0_f_res_125922;
                            int32_t head_res_128047 = ((int32_t *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125960 = head_res_128047;
                            dummy_125961 = head_res_128048;
                        } else {
                            bool y_125966 = slt64((int64_t) 0, j_m_i_125933);
                            bool index_certs_125967;
                            
                            if (!y_125966) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:105:36-40\n   #12 ftRelational.fut:102:9-105:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125968 = start_125741 + merge_sequential_arg2_125931;
                            int32_t head_res_125969 = ((int32_t *) mem_param_133548.mem)[slice_125968];
                            int64_t head_res_125970 = ((int64_t *) mem_param_133551.mem)[slice_125968];
                            
                            dummy_125960 = head_res_125969;
                            dummy_125961 = head_res_125970;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125554; nest_i_133919++) {
                            ((int32_t *) mem_133584)[i_133326 * merge_block_sizze_125554 + nest_i_133919] = dummy_125960;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125554; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + nest_i_133920] = dummy_125961;
                        }
                        
                        int64_t data_125973;
                        int64_t i_125977 = (int64_t) 0;
                        
                        for (int64_t k_125976 = 0; k_125976 < merge_block_sizze_125554; k_125976++) {
                            int64_t j_125980 = sub64(k_125976, i_125977);
                            bool cond_125981 = j_125980 == j_m_i_125933;
                            bool cond_125982;
                            
                            if (cond_125981) {
                                cond_125982 = 1;
                            } else {
                                bool cond_125983 = slt64(i_125977, j_m_i_125946);
                                bool cond_f_res_125984;
                                
                                if (cond_125983) {
                                    bool x_128049 = sle64((int64_t) 0, j_125980);
                                    bool y_128050 = slt64(j_125980, j_m_i_125933);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:105:36-40\n   #11 ftRelational.fut:102:9-105:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125977);
                                    bool bounds_check_128057 = cond_125983 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:105:36-40\n   #11 ftRelational.fut:102:9-105:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125931 + j_125980;
                                    int64_t slice_128054 = start_125741 + slice_128053;
                                    int32_t leq_arg1_128055 = ((int32_t *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125922 + i_125977;
                                    int64_t slice_128060 = start_125741 + slice_128059;
                                    int32_t leq_arg0_128061 = ((int32_t *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = sle32(leq_arg0_128061, leq_arg1_128055);
                                    
                                    cond_f_res_125984 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125984 = 0;
                                }
                                cond_125982 = cond_f_res_125984;
                            }
                            
                            int64_t loopres_125999;
                            int32_t loopres_126000;
                            int64_t loopres_126001;
                            
                            if (cond_125982) {
                                bool x_128064 = sle64((int64_t) 0, i_125977);
                                bool y_128065 = slt64(i_125977, j_m_i_125946);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:105:36-40\n   #11 ftRelational.fut:102:9-105:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125977);
                                int64_t slice_128068 = defunc_0_f_res_125922 + i_125977;
                                int64_t slice_128069 = start_125741 + slice_128068;
                                int32_t tmp_128070 = ((int32_t *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_125999 = tmp_128063;
                                loopres_126000 = tmp_128070;
                                loopres_126001 = tmp_128071;
                            } else {
                                bool x_126011 = sle64((int64_t) 0, j_125980);
                                bool y_126012 = slt64(j_125980, j_m_i_125933);
                                bool bounds_check_126013 = x_126011 && y_126012;
                                bool index_certs_126014;
                                
                                if (!bounds_check_126013) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:105:36-40\n   #11 ftRelational.fut:102:9-105:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126015 = merge_sequential_arg2_125931 + j_125980;
                                int64_t slice_126016 = start_125741 + slice_126015;
                                int32_t tmp_126017 = ((int32_t *) mem_param_133548.mem)[slice_126016];
                                int64_t tmp_126018 = ((int64_t *) mem_param_133551.mem)[slice_126016];
                                
                                loopres_125999 = i_125977;
                                loopres_126000 = tmp_126017;
                                loopres_126001 = tmp_126018;
                            }
                            ((int32_t *) mem_133584)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126000;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126001;
                            
                            int64_t i_tmp_133921 = loopres_125999;
                            
                            i_125977 = i_tmp_133921;
                        }
                        data_125973 = i_125977;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_4b(ctx, 2, (uint32_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint32_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133586, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_4b(ctx, 1, (uint32_t *) mem_133554, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126025 = next_stride_125669 * num_merges_125673;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_4b(ctx, 2, (uint32_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint32_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            if (memblock_alloc(ctx, &mem_133664, bytes_133556, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            
            bool loop_cond_126028 = slt64(next_stride_125669, flat_dim_125550);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126025;
            bool loop_while_tmp_133898 = loop_cond_126028;
            int64_t stride_tmp_133901 = next_stride_125669;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125664 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125665 = loop_while_tmp_133898;
            stride_125668 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125659 = loop_dz2084Uz2082U_125664;
        data_125660 = loop_while_125665;
        data_125663 = stride_125668;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126029 = n_76426 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126030 = sle64((int64_t) 0, zs_lhs_125534);
        bool i_p_m_t_s_leq_w_126031 = slt64(zs_lhs_125534, data_125659);
        bool y_126032 = zzero_leq_i_p_m_t_s_126030 && i_p_m_t_s_leq_w_126031;
        bool ok_or_empty_126033 = empty_slice_126029 || y_126032;
        bool index_certs_126034;
        
        if (!ok_or_empty_126033) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_76426, "] out of bounds for array of shape [", (long long) data_125659, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:105:36-40\n   #6  ftRelational.fut:102:9-105:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133675, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133677, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_76426; i_133340++) {
        int64_t eta_p_126042 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126043 = sle64((int64_t) 0, eta_p_126042);
        bool y_126044 = slt64(eta_p_126042, n_76426);
        bool bounds_check_126045 = x_126043 && y_126044;
        bool index_certs_126046;
        
        if (!bounds_check_126045) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126042, "] out of bounds for array of shape [", (long long) n_76426, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:105:36-40\n   #5  ftRelational.fut:102:9-105:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int32_t lifted_lambda_res_126047 = ((int32_t *) k_mem_133466.mem)[eta_p_126042];
        
        ((int32_t *) mem_133676.mem)[i_133340] = lifted_lambda_res_126047;
        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133678.mem, i_133340 * b_76427, (int64_t []) {(int64_t) 1}, (uint8_t *) pL_mem_133467.mem, eta_p_126042 * b_76427, (int64_t []) {(int64_t) 1}, (int64_t []) {b_76427});
    }
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134198, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134199, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_long(struct futhark_context *ctx, struct memblock *mem_out_p_134210, struct memblock *mem_out_p_134211, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_78781, int64_t b_78782)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134212 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134213 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134214 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134215 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134216 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134217 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134218 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134219 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134220 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134221 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_78781;
    bool cond_125533 = sle64(n_78781, (int64_t) 1);
    int64_t zs_lhs_125534 = sub64(n_78781, (int64_t) 1);
    int64_t zp_rhs_125535 = sdiv_safe64(zs_lhs_125534, (int64_t) 20);
    int64_t min_num_blocks_125536 = add64((int64_t) 1, zp_rhs_125535);
    bool loop_cond_125537 = slt64((int64_t) 1, min_num_blocks_125536);
    bool smallest_pow_2_geq_than_res_125538;
    int64_t smallest_pow_2_geq_than_res_125539;
    bool loop_while_125540;
    int64_t x_125541;
    
    loop_while_125540 = loop_cond_125537;
    x_125541 = (int64_t) 1;
    while (loop_while_125540) {
        int64_t loopres_125542 = mul64((int64_t) 2, x_125541);
        bool loop_cond_125543 = slt64(loopres_125542, min_num_blocks_125536);
        bool loop_while_tmp_133879 = loop_cond_125543;
        int64_t x_tmp_133880 = loopres_125542;
        
        loop_while_125540 = loop_while_tmp_133879;
        x_125541 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125538 = loop_while_125540;
    smallest_pow_2_geq_than_res_125539 = x_125541;
    
    bool zzero_125544 = smallest_pow_2_geq_than_res_125539 == (int64_t) 0;
    bool nonzzero_125545 = !zzero_125544;
    bool protect_assert_disj_125546 = cond_125533 || nonzzero_125545;
    bool nonzzero_cert_125547;
    
    if (!protect_assert_disj_125546) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:109:36-40\n   #5  ftRelational.fut:106:9-109:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125548 = sdiv_safe64(zs_lhs_125534, smallest_pow_2_geq_than_res_125539);
    int64_t block_sizze_125549 = add64((int64_t) 1, zp_rhs_125548);
    bool y_125555 = slt64((int64_t) 0, n_78781);
    bool protect_assert_disj_133752 = cond_125533 || y_125555;
    bool index_certs_125556;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_78781, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:109:36-40\n   #5  ftRelational.fut:106:9-109:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125570 = slt64(smallest_pow_2_geq_than_res_125539, (int64_t) 0);
    bool valid_125571 = !bounds_invalid_upwards_125570;
    bool protect_assert_disj_133760 = cond_125533 || valid_125571;
    bool range_valid_c_125572;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125539, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:109:36-40\n   #6  ftRelational.fut:106:9-109:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125574 = slt64(block_sizze_125549, (int64_t) 0);
    bool valid_125575 = !bounds_invalid_upwards_125574;
    bool protect_assert_disj_133762 = cond_125533 || valid_125575;
    bool range_valid_c_125576;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125549, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125578 = sle64(block_sizze_125549, (int64_t) 1);
    int64_t tmp_125579 = sub64(block_sizze_125549, (int64_t) 2);
    bool bounds_invalid_upwards_125580 = slt64(tmp_125579, (int64_t) 0);
    bool valid_125582 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_125583 = cond_125578 || valid_125582;
    bool protect_assert_disj_133764 = cond_125533 || protect_assert_disj_125583;
    bool range_valid_c_125584;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125579, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133677 = n_78781 * b_78782;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_78781; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125550 = smallest_pow_2_geq_than_res_125539 * block_sizze_125549;
    bool x_133747 = !cond_125533;
    int64_t greatest_divisor_leq_than_arg1_125553 = mul64((int64_t) 2, block_sizze_125549);
    int64_t merge_block_sizze_125554;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125553) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125554 = x_133749;
    } else {
        merge_block_sizze_125554 = (int64_t) 0;
    }
    
    int64_t reduce_arg1_125557;
    
    if (x_133747) {
        int64_t x_133753 = ((int64_t *) k_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125557 = x_133753;
    } else {
        reduce_arg1_125557 = (int64_t) 0;
    }
    
    int64_t defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        int64_t x_133755;
        int64_t x_133756;
        int64_t redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125557;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_78781; i_133300++) {
            int64_t x_125561 = ((int64_t *) k_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125567 = sle64(redout_133298, x_125561);
            int64_t defunc_0_op_res_125568;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125568 = x_125561;
            } else {
                defunc_0_op_res_125568 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125569;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125569 = i_133300;
            } else {
                defunc_0_op_res_125569 = redout_133299;
            }
            
            int64_t redout_tmp_133883 = defunc_0_op_res_125568;
            int64_t redout_tmp_133884 = defunc_0_op_res_125569;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = (int64_t) 0;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125581 = add64((int64_t) 1, tmp_125579);
    int64_t binop_x_133470 = (int64_t) 8 * smallest_pow_2_geq_than_res_125539;
    int64_t bytes_133471 = block_sizze_125549 * binop_x_133470;
    int64_t bytes_133484 = (int64_t) 8 * block_sizze_125549;
    bool loop_cond_125656 = slt64(block_sizze_125549, flat_dim_125550);
    bool zzero_125657 = merge_block_sizze_125554 == (int64_t) 0;
    bool nonzzero_125658 = !zzero_125657;
    
    if (cond_125533) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134212 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134212, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134213 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134213, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134214 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134214, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134215 < bytes_133484) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134215, bytes_133484);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125539; i_133312++) {
            int64_t zp_lhs_125588 = mul64(block_sizze_125549, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125549; i_133305++) {
                int64_t k_125592 = add64(zp_lhs_125588, i_133305);
                bool cond_125593 = slt64(k_125592, n_78781);
                int64_t lifted_lambda_res_125594;
                int64_t lifted_lambda_res_125595;
                
                if (cond_125593) {
                    bool x_127931 = sle64((int64_t) 0, k_125592);
                    bool bounds_check_127932 = cond_125593 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125592, "] out of bounds for array of shape [", (long long) n_78781, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:109:36-40\n   #9  ftRelational.fut:106:9-109:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t lifted_lambda_res_t_res_127934 = ((int64_t *) k_mem_133466.mem)[k_125592];
                    
                    lifted_lambda_res_125594 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125595 = k_125592;
                } else {
                    lifted_lambda_res_125594 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125595 = defunc_0_reduce_res_128079;
                }
                ((int64_t *) mem_133485)[i_133305] = lifted_lambda_res_125594;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125595;
            }
            if (!cond_125578) {
                for (int64_t i_125605 = 0; i_125605 < distance_125581; i_125605++) {
                    int64_t gt_arg1_125608 = add64((int64_t) 1, i_125605);
                    bool x_125609 = sle64((int64_t) 0, gt_arg1_125608);
                    bool y_125610 = slt64(gt_arg1_125608, block_sizze_125549);
                    bool bounds_check_125611 = x_125609 && y_125610;
                    bool index_certs_125612;
                    
                    if (!bounds_check_125611) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125608, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125614 = slt64(i_125605, block_sizze_125549);
                    bool index_certs_125615;
                    
                    if (!y_125614) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125605, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t gt_arg1_125613 = ((int64_t *) mem_133485)[gt_arg1_125608];
                    int64_t gt_arg0_125616 = ((int64_t *) mem_133485)[i_125605];
                    bool defunc_0_leq_res_125617 = sle64(gt_arg0_125616, gt_arg1_125613);
                    bool defunc_0_lifted_gt_res_125618 = !defunc_0_leq_res_125617;
                    bool s_125619;
                    int64_t s_125622;
                    bool loop_while_125623;
                    int64_t j_125626;
                    
                    loop_while_125623 = defunc_0_lifted_gt_res_125618;
                    j_125626 = i_125605;
                    while (loop_while_125623) {
                        bool x_125627 = sle64((int64_t) 0, j_125626);
                        bool y_125628 = slt64(j_125626, block_sizze_125549);
                        bool bounds_check_125629 = x_125627 && y_125628;
                        bool index_certs_125630;
                        
                        if (!bounds_check_125629) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125626, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125633 = add64((int64_t) 1, j_125626);
                        bool x_125634 = sle64((int64_t) 0, copy_arg0_125633);
                        bool y_125635 = slt64(copy_arg0_125633, block_sizze_125549);
                        bool bounds_check_125636 = x_125634 && y_125635;
                        bool index_certs_125637;
                        
                        if (!bounds_check_125636) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125633, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125631 = ((int64_t *) mem_133485)[j_125626];
                        int64_t copy_arg0_125632 = ((int64_t *) mem_133487)[j_125626];
                        int64_t copy_arg0_125638 = ((int64_t *) mem_133485)[copy_arg0_125633];
                        int64_t copy_arg0_125639 = ((int64_t *) mem_133487)[copy_arg0_125633];
                        
                        ((int64_t *) mem_133485)[j_125626] = copy_arg0_125638;
                        ((int64_t *) mem_133487)[j_125626] = copy_arg0_125639;
                        ((int64_t *) mem_133485)[copy_arg0_125633] = copy_arg0_125631;
                        ((int64_t *) mem_133487)[copy_arg0_125633] = copy_arg0_125632;
                        
                        int64_t tmp_125644 = sub64(j_125626, (int64_t) 1);
                        bool cond_125645 = sle64((int64_t) 0, tmp_125644);
                        bool loop_cond_125646;
                        
                        if (cond_125645) {
                            bool y_127936 = slt64(tmp_125644, block_sizze_125549);
                            bool bounds_check_127937 = cond_125645 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125644, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t gt_arg1_127935 = ((int64_t *) mem_133485)[j_125626];
                            int64_t gt_arg0_127939 = ((int64_t *) mem_133485)[tmp_125644];
                            bool defunc_0_leq_res_127940 = sle64(gt_arg0_127939, gt_arg1_127935);
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125646 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125646 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125646;
                        int64_t j_tmp_133894 = tmp_125644;
                        
                        loop_while_125623 = loop_while_tmp_133891;
                        j_125626 = j_tmp_133894;
                    }
                    s_125619 = loop_while_125623;
                    s_125622 = j_125626;
                }
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133472, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint64_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        if (memblock_alloc(ctx, &mem_133544, bytes_133471, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        
        int64_t data_125659;
        bool data_125660;
        int64_t data_125663;
        int64_t loop_dz2084Uz2082U_125664;
        bool loop_while_125665;
        int64_t stride_125668;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125664 = flat_dim_125550;
        loop_while_125665 = loop_cond_125656;
        stride_125668 = block_sizze_125549;
        while (loop_while_125665) {
            int64_t next_stride_125669 = mul64((int64_t) 2, stride_125668);
            bool zzero_125670 = next_stride_125669 == (int64_t) 0;
            bool nonzzero_125671 = !zzero_125670;
            bool nonzzero_cert_125672;
            
            if (!nonzzero_125671) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:109:36-40\n   #5  ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125673 = sdiv64(flat_dim_125550, next_stride_125669);
            bool bounds_invalid_upwards_125674 = slt64(num_merges_125673, (int64_t) 0);
            bool valid_125675 = !bounds_invalid_upwards_125674;
            bool range_valid_c_125676;
            
            if (!valid_125675) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125673, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:109:36-40\n   #6  ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125678 = sub64(next_stride_125669, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125679 = sle64((int64_t) 0, m_125678);
            bool cond_125681 = slt64(next_stride_125669, (int64_t) 10);
            bool protect_assert_disj_125682 = nonzzero_125658 || cond_125681;
            bool nonzzero_cert_125683;
            
            if (!protect_assert_disj_125682) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125684 = smod_safe64(next_stride_125669, merge_block_sizze_125554);
            bool num_blocks_125685 = zeze_lhs_125684 == (int64_t) 0;
            bool protect_assert_disj_125686 = cond_125681 || num_blocks_125685;
            bool assert_c_125687;
            
            if (!protect_assert_disj_125686) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125689 = sdiv_safe64(next_stride_125669, merge_block_sizze_125554);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690 = add64((int64_t) 1, num_blocks_125689);
            int64_t j_m_i_125691 = sub64(next_stride_125669, stride_125668);
            int64_t flat_dim_125692 = merge_block_sizze_125554 * num_blocks_125689;
            bool bounds_invalid_upwards_125693 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, (int64_t) 0);
            bool empty_slice_125694 = j_m_i_125691 == (int64_t) 0;
            int64_t m_125695 = sub64(j_m_i_125691, (int64_t) 1);
            bool zzero_lte_i_125696 = sle64((int64_t) 0, stride_125668);
            bool i_lte_j_125697 = sle64(stride_125668, next_stride_125669);
            bool empty_slice_125698 = stride_125668 == (int64_t) 0;
            int64_t m_125699 = sub64(stride_125668, (int64_t) 1);
            bool bounds_invalid_upwards_125700 = slt64(num_blocks_125689, (int64_t) 0);
            bool cond_125701 = slt64((int64_t) 0, stride_125668);
            bool valid_125702 = !bounds_invalid_upwards_125693;
            int64_t i_p_m_t_s_125703 = add64(stride_125668, m_125695);
            bool zzero_leq_i_p_m_t_s_125704 = sle64((int64_t) 0, m_125699);
            bool i_p_m_t_s_leq_w_125705 = slt64(m_125699, next_stride_125669);
            bool valid_125706 = !bounds_invalid_upwards_125700;
            bool i_p_m_t_s_leq_w_125707 = slt64(m_125678, flat_dim_125692);
            bool y_125708 = slt64((int64_t) 0, j_m_i_125691);
            bool protect_assert_disj_125709 = cond_125681 || valid_125702;
            bool range_valid_c_125710;
            
            if (!protect_assert_disj_125709) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:109:36-40\n   #10 ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125711 = sle64((int64_t) 0, i_p_m_t_s_125703);
            bool i_p_m_t_s_leq_w_125712 = slt64(i_p_m_t_s_125703, next_stride_125669);
            bool y_125713 = zzero_leq_i_p_m_t_s_125704 && i_p_m_t_s_leq_w_125705;
            bool protect_assert_disj_125714 = cond_125681 || valid_125706;
            bool range_valid_c_125715;
            
            if (!protect_assert_disj_125714) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125689, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:109:36-40\n   #9  ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125716 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125707;
            bool y_125717 = zzero_lte_i_125696 && i_p_m_t_s_leq_w_125712;
            bool forwards_ok_125718 = zzero_lte_i_125696 && y_125713;
            bool ok_or_empty_125719 = zzero_125670 || y_125716;
            bool protect_assert_disj_125720 = cond_125701 || y_125708;
            bool y_125721 = zzero_leq_i_p_m_t_s_125711 && y_125717;
            bool ok_or_empty_125722 = empty_slice_125698 || forwards_ok_125718;
            bool protect_assert_disj_125723 = cond_125681 || ok_or_empty_125719;
            bool index_certs_125724;
            
            if (!protect_assert_disj_125723) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) flat_dim_125692, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:109:36-40\n   #9  ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125725 = !cond_125681;
            bool protect_assert_disj_125726 = protect_assert_disj_125720 || loop_not_taken_125725;
            bool index_certs_125727;
            
            if (!protect_assert_disj_125726) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:109:36-40\n   #10 ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125728 = i_lte_j_125697 && y_125721;
            bool protect_assert_disj_125729 = cond_125681 || ok_or_empty_125722;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:109:36-40\n   #11 ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125731 = ok_or_empty_125722 || loop_not_taken_125725;
            bool index_certs_125732;
            
            if (!protect_assert_disj_125731) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125733 = empty_slice_125694 || forwards_ok_125728;
            bool protect_assert_disj_125734 = cond_125681 || ok_or_empty_125733;
            bool index_certs_125735;
            
            if (!protect_assert_disj_125734) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:109:36-40\n   #11 ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125736 = loop_not_taken_125725 || ok_or_empty_125733;
            bool index_certs_125737;
            
            if (!protect_assert_disj_125736) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 8 * num_merges_125673;
            int64_t bytes_133553 = next_stride_125669 * binop_x_133552;
            bool i_lte_j_125680 = sle64((int64_t) 0, next_stride_125669);
            
            if (mem_133554_cached_sizze_134216 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134216, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134217 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134217, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690;
            int64_t binop_x_133582 = (int64_t) 8 * num_blocks_125689;
            int64_t bytes_133583 = merge_block_sizze_125554 * binop_x_133582;
            int64_t bytes_133628 = (int64_t) 16 * stride_125668;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125673; i_133333++) {
                int64_t start_125741 = mul64(next_stride_125669, i_133333);
                int64_t j_m_i_125742 = sub64(loop_dz2084Uz2082U_125664, start_125741);
                bool empty_slice_125743 = j_m_i_125742 == (int64_t) 0;
                int64_t m_125744 = sub64(j_m_i_125742, (int64_t) 1);
                int64_t i_p_m_t_s_125745 = add64(start_125741, m_125744);
                bool zzero_leq_i_p_m_t_s_125746 = sle64((int64_t) 0, i_p_m_t_s_125745);
                bool i_p_m_t_s_leq_w_125747 = slt64(i_p_m_t_s_125745, loop_dz2084Uz2082U_125664);
                bool zzero_lte_i_125748 = sle64((int64_t) 0, start_125741);
                bool i_lte_j_125749 = sle64(start_125741, loop_dz2084Uz2082U_125664);
                bool y_125750 = i_p_m_t_s_leq_w_125747 && zzero_lte_i_125748;
                bool y_125751 = zzero_leq_i_p_m_t_s_125746 && y_125750;
                bool forwards_ok_125752 = i_lte_j_125749 && y_125751;
                bool ok_or_empty_125753 = empty_slice_125743 || forwards_ok_125752;
                bool index_certs_125754;
                
                if (!ok_or_empty_125753) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125741, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125664, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125755 = slt64(m_125678, j_m_i_125742);
                bool y_125756 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125755;
                bool forwards_ok_125757 = i_lte_j_125680 && y_125756;
                bool ok_or_empty_125758 = zzero_125670 || forwards_ok_125757;
                bool index_certs_125759;
                
                if (!ok_or_empty_125758) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) j_m_i_125742, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:109:36-40\n   #8  ftRelational.fut:106:9-109:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125681) {
                    int64_t dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125701) {
                        int64_t head_res_127969 = ((int64_t *) mem_param_133548.mem)[start_125741];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125741];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125668 + start_125741;
                        int64_t head_res_127972 = ((int64_t *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125669; nest_i_133904++) {
                        ((int64_t *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133628, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125669; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125669; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125691;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125668);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125691);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:109:36-40\n   #9  ftRelational.fut:106:9-109:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:109:36-40\n   #9  ftRelational.fut:106:9-109:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125668 + j_127983;
                                int64_t slice_127993 = start_125741 + slice_127992;
                                int64_t leq_arg1_127994 = ((int64_t *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125741 + i_127980;
                                int64_t leq_arg0_127999 = ((int64_t *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = sle64(leq_arg0_127999, leq_arg1_127994);
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        int64_t loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125668);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:109:36-40\n   #9  ftRelational.fut:106:9-109:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125741 + i_127980;
                            int64_t tmp_128010 = ((int64_t *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125691);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:109:36-40\n   #9  ftRelational.fut:106:9-109:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125668 + j_127983;
                            int64_t slice_128017 = start_125741 + slice_128016;
                            int64_t tmp_128018 = ((int64_t *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((int64_t *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134218 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134218, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134219 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134219, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690; i_133319++) {
                        int64_t split_count_arg3_125821 = mul64(merge_block_sizze_125554, i_133319);
                        int64_t defunc_0_split_count_res_125822;
                        int64_t defunc_0_split_count_res_125823;
                        int64_t defunc_0_split_count_res_125824;
                        int64_t defunc_0_split_count_res_125825;
                        int64_t defunc_0_split_count_res_125826;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125822, &defunc_0_split_count_res_125823, &defunc_0_split_count_res_125824, &defunc_0_split_count_res_125825, &defunc_0_split_count_res_125826, (int64_t) 0, stride_125668, (int64_t) 0, j_m_i_125691, split_count_arg3_125821) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125827 = slt64((int64_t) 0, defunc_0_split_count_res_125826);
                        bool defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        int64_t defunc_0_split_count_res_125833;
                        bool loop_while_125834;
                        int64_t ss_125835;
                        int64_t ss_125836;
                        int64_t tt_125837;
                        int64_t tt_125838;
                        int64_t count_125839;
                        
                        loop_while_125834 = loop_cond_125827;
                        ss_125835 = defunc_0_split_count_res_125822;
                        ss_125836 = defunc_0_split_count_res_125823;
                        tt_125837 = defunc_0_split_count_res_125824;
                        tt_125838 = defunc_0_split_count_res_125825;
                        count_125839 = defunc_0_split_count_res_125826;
                        while (loop_while_125834) {
                            int64_t zlze_lhs_125840 = sub64(ss_125836, ss_125835);
                            bool cond_125841 = sle64(zlze_lhs_125840, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125842;
                            int64_t defunc_0_lifted_step_res_125843;
                            int64_t defunc_0_lifted_step_res_125844;
                            int64_t defunc_0_lifted_step_res_125845;
                            
                            if (cond_125841) {
                                int64_t tmp_128022 = add64(tt_125837, count_125839);
                                
                                defunc_0_lifted_step_res_125842 = ss_125835;
                                defunc_0_lifted_step_res_125843 = tmp_128022;
                                defunc_0_lifted_step_res_125844 = tt_125838;
                                defunc_0_lifted_step_res_125845 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125847 = sub64(tt_125838, tt_125837);
                                bool cond_125848 = sle64(zlze_lhs_125847, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125849;
                                int64_t defunc_0_lifted_step_res_f_res_125850;
                                int64_t defunc_0_lifted_step_res_f_res_125851;
                                int64_t defunc_0_lifted_step_res_f_res_125852;
                                
                                if (cond_125848) {
                                    int64_t tmp_128023 = add64(ss_125835, count_125839);
                                    
                                    defunc_0_lifted_step_res_f_res_125849 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125850 = tt_125837;
                                    defunc_0_lifted_step_res_f_res_125851 = tt_125838;
                                    defunc_0_lifted_step_res_f_res_125852 = (int64_t) 0;
                                } else {
                                    bool cond_125854 = count_125839 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125855;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125856;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125857;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125858;
                                    
                                    if (cond_125854) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125835);
                                        bool y_128026 = slt64(ss_125835, stride_125668);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125835, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:109:36-40\n   #13 ftRelational.fut:106:9-109:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125837);
                                        bool y_128032 = slt64(tt_125837, j_m_i_125691);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125837, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:109:36-40\n   #13 ftRelational.fut:106:9-109:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125741 + ss_125835;
                                        int64_t leq_arg1_128030 = ((int64_t *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125668 + tt_125837;
                                        int64_t slice_128036 = start_125741 + slice_128035;
                                        int64_t leq_arg0_128037 = ((int64_t *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = sle64(leq_arg0_128037, leq_arg1_128030);
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125837);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125835;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125835);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125837;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = tt_125838;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = (int64_t) 0;
                                    } else {
                                        int64_t m_125877 = sdiv64(count_125839, (int64_t) 2);
                                        int64_t n_125878 = sub64(count_125839, m_125877);
                                        bool cond_125879 = n_125878 == (int64_t) 0;
                                        int64_t zgze_lhs_125880 = add64(ss_125835, m_125877);
                                        bool cond_f_res_125881 = sle64(ss_125836, zgze_lhs_125880);
                                        bool x_125882 = !cond_125879;
                                        bool y_125883 = cond_f_res_125881 && x_125882;
                                        bool cond_125884 = cond_125879 || y_125883;
                                        bool leq_y_x_125885;
                                        
                                        if (cond_125884) {
                                            leq_y_x_125885 = 1;
                                        } else {
                                            bool x_125886 = sle64((int64_t) 0, zgze_lhs_125880);
                                            bool y_125887 = slt64(zgze_lhs_125880, stride_125668);
                                            bool bounds_check_125888 = x_125886 && y_125887;
                                            bool index_certs_125889;
                                            
                                            if (!bounds_check_125888) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125880, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:109:36-40\n   #13 ftRelational.fut:106:9-109:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125892 = add64(tt_125837, n_125878);
                                            int64_t leq_arg0_125893 = sub64(zm_lhs_125892, (int64_t) 1);
                                            bool x_125894 = sle64((int64_t) 0, leq_arg0_125893);
                                            bool y_125895 = slt64(leq_arg0_125893, j_m_i_125691);
                                            bool bounds_check_125896 = x_125894 && y_125895;
                                            bool index_certs_125897;
                                            
                                            if (!bounds_check_125896) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125893, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:109:36-40\n   #13 ftRelational.fut:106:9-109:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125890 = start_125741 + zgze_lhs_125880;
                                            int64_t leq_arg1_125891 = ((int64_t *) mem_param_133548.mem)[slice_125890];
                                            int64_t slice_125898 = stride_125668 + leq_arg0_125893;
                                            int64_t slice_125899 = start_125741 + slice_125898;
                                            int64_t leq_arg0_125900 = ((int64_t *) mem_param_133548.mem)[slice_125899];
                                            bool defunc_0_leq_res_125901 = sle64(leq_arg0_125900, leq_arg1_125891);
                                            
                                            leq_y_x_125885 = defunc_0_leq_res_125901;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                        
                                        if (leq_y_x_125885) {
                                            int64_t tmp_128043 = add64(tt_125837, n_125878);
                                            int64_t tmp_128044 = sub64(count_125839, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tt_125838;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = tmp_128044;
                                        } else {
                                            int64_t tmp_125907 = add64(tt_125837, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tt_125837;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tmp_125907;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = count_125839;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = ss_125835;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                    }
                                    defunc_0_lifted_step_res_f_res_125849 = defunc_0_lifted_step_res_f_res_f_res_125855;
                                    defunc_0_lifted_step_res_f_res_125850 = defunc_0_lifted_step_res_f_res_f_res_125856;
                                    defunc_0_lifted_step_res_f_res_125851 = defunc_0_lifted_step_res_f_res_f_res_125857;
                                    defunc_0_lifted_step_res_f_res_125852 = defunc_0_lifted_step_res_f_res_f_res_125858;
                                }
                                defunc_0_lifted_step_res_125842 = defunc_0_lifted_step_res_f_res_125849;
                                defunc_0_lifted_step_res_125843 = defunc_0_lifted_step_res_f_res_125850;
                                defunc_0_lifted_step_res_125844 = defunc_0_lifted_step_res_f_res_125851;
                                defunc_0_lifted_step_res_125845 = defunc_0_lifted_step_res_f_res_125852;
                            }
                            
                            int64_t loopres_125908;
                            int64_t loopres_125909;
                            int64_t loopres_125910;
                            int64_t loopres_125911;
                            int64_t loopres_125912;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125908, &loopres_125909, &loopres_125910, &loopres_125911, &loopres_125912, defunc_0_lifted_step_res_125842, ss_125836, defunc_0_lifted_step_res_125843, defunc_0_lifted_step_res_125844, defunc_0_lifted_step_res_125845) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125913 = slt64((int64_t) 0, loopres_125912);
                            bool loop_while_tmp_133911 = loop_cond_125913;
                            int64_t ss_tmp_133912 = loopres_125908;
                            int64_t ss_tmp_133913 = loopres_125909;
                            int64_t tt_tmp_133914 = loopres_125910;
                            int64_t tt_tmp_133915 = loopres_125911;
                            int64_t count_tmp_133916 = loopres_125912;
                            
                            loop_while_125834 = loop_while_tmp_133911;
                            ss_125835 = ss_tmp_133912;
                            ss_125836 = ss_tmp_133913;
                            tt_125837 = tt_tmp_133914;
                            tt_125838 = tt_tmp_133915;
                            count_125839 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125828 = loop_while_125834;
                        defunc_0_split_count_res_125829 = ss_125835;
                        defunc_0_split_count_res_125830 = ss_125836;
                        defunc_0_split_count_res_125831 = tt_125837;
                        defunc_0_split_count_res_125832 = tt_125838;
                        defunc_0_split_count_res_125833 = count_125839;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125829;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125831;
                    }
                    if (mem_133584_cached_sizze_134220 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134220, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134221 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134221, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125689; i_133326++) {
                        bool y_125919 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool index_certs_125921;
                        
                        if (!y_125919) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:109:36-40\n   #10 ftRelational.fut:106:9-109:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125922 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125923 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125924 = add64((int64_t) 1, i_133326);
                        bool x_125925 = sle64((int64_t) 0, tmp_125924);
                        bool y_125926 = slt64(tmp_125924, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool bounds_check_125927 = x_125925 && y_125926;
                        bool index_certs_125928;
                        
                        if (!bounds_check_125927) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125924, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:109:36-40\n   #10 ftRelational.fut:106:9-109:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133567)[tmp_125924];
                        int64_t defunc_0_f_res_125930 = ((int64_t *) mem_133569)[tmp_125924];
                        int64_t merge_sequential_arg2_125931 = add64(stride_125668, defunc_0_f_res_125923);
                        int64_t merge_sequential_arg2_125932 = add64(stride_125668, defunc_0_f_res_125930);
                        int64_t j_m_i_125933 = sub64(merge_sequential_arg2_125932, merge_sequential_arg2_125931);
                        bool empty_slice_125934 = j_m_i_125933 == (int64_t) 0;
                        int64_t m_125935 = sub64(j_m_i_125933, (int64_t) 1);
                        int64_t i_p_m_t_s_125936 = add64(merge_sequential_arg2_125931, m_125935);
                        bool zzero_leq_i_p_m_t_s_125937 = sle64((int64_t) 0, i_p_m_t_s_125936);
                        bool i_p_m_t_s_leq_w_125938 = slt64(i_p_m_t_s_125936, next_stride_125669);
                        bool zzero_lte_i_125939 = sle64((int64_t) 0, merge_sequential_arg2_125931);
                        bool i_lte_j_125940 = sle64(merge_sequential_arg2_125931, merge_sequential_arg2_125932);
                        bool y_125941 = i_p_m_t_s_leq_w_125938 && zzero_lte_i_125939;
                        bool y_125942 = zzero_leq_i_p_m_t_s_125937 && y_125941;
                        bool forwards_ok_125943 = i_lte_j_125940 && y_125942;
                        bool ok_or_empty_125944 = empty_slice_125934 || forwards_ok_125943;
                        bool index_certs_125945;
                        
                        if (!ok_or_empty_125944) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125931, ":", (long long) merge_sequential_arg2_125932, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:109:36-40\n   #10 ftRelational.fut:106:9-109:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125946 = sub64(defunc_0_f_res_125929, defunc_0_f_res_125922);
                        bool empty_slice_125947 = j_m_i_125946 == (int64_t) 0;
                        int64_t m_125948 = sub64(j_m_i_125946, (int64_t) 1);
                        int64_t i_p_m_t_s_125949 = add64(defunc_0_f_res_125922, m_125948);
                        bool zzero_leq_i_p_m_t_s_125950 = sle64((int64_t) 0, i_p_m_t_s_125949);
                        bool i_p_m_t_s_leq_w_125951 = slt64(i_p_m_t_s_125949, next_stride_125669);
                        bool zzero_lte_i_125952 = sle64((int64_t) 0, defunc_0_f_res_125922);
                        bool i_lte_j_125953 = sle64(defunc_0_f_res_125922, defunc_0_f_res_125929);
                        bool y_125954 = i_p_m_t_s_leq_w_125951 && zzero_lte_i_125952;
                        bool y_125955 = zzero_leq_i_p_m_t_s_125950 && y_125954;
                        bool forwards_ok_125956 = i_lte_j_125953 && y_125955;
                        bool ok_or_empty_125957 = empty_slice_125947 || forwards_ok_125956;
                        bool index_certs_125958;
                        
                        if (!ok_or_empty_125957) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125922, ":", (long long) defunc_0_f_res_125929, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:109:36-40\n   #10 ftRelational.fut:106:9-109:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125959 = slt64((int64_t) 0, j_m_i_125946);
                        int64_t dummy_125960;
                        int64_t dummy_125961;
                        
                        if (cond_125959) {
                            bool index_certs_128045;
                            
                            if (!cond_125959) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:109:36-40\n   #12 ftRelational.fut:106:9-109:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125741 + defunc_0_f_res_125922;
                            int64_t head_res_128047 = ((int64_t *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125960 = head_res_128047;
                            dummy_125961 = head_res_128048;
                        } else {
                            bool y_125966 = slt64((int64_t) 0, j_m_i_125933);
                            bool index_certs_125967;
                            
                            if (!y_125966) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:109:36-40\n   #12 ftRelational.fut:106:9-109:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125968 = start_125741 + merge_sequential_arg2_125931;
                            int64_t head_res_125969 = ((int64_t *) mem_param_133548.mem)[slice_125968];
                            int64_t head_res_125970 = ((int64_t *) mem_param_133551.mem)[slice_125968];
                            
                            dummy_125960 = head_res_125969;
                            dummy_125961 = head_res_125970;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125554; nest_i_133919++) {
                            ((int64_t *) mem_133584)[i_133326 * merge_block_sizze_125554 + nest_i_133919] = dummy_125960;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125554; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + nest_i_133920] = dummy_125961;
                        }
                        
                        int64_t data_125973;
                        int64_t i_125977 = (int64_t) 0;
                        
                        for (int64_t k_125976 = 0; k_125976 < merge_block_sizze_125554; k_125976++) {
                            int64_t j_125980 = sub64(k_125976, i_125977);
                            bool cond_125981 = j_125980 == j_m_i_125933;
                            bool cond_125982;
                            
                            if (cond_125981) {
                                cond_125982 = 1;
                            } else {
                                bool cond_125983 = slt64(i_125977, j_m_i_125946);
                                bool cond_f_res_125984;
                                
                                if (cond_125983) {
                                    bool x_128049 = sle64((int64_t) 0, j_125980);
                                    bool y_128050 = slt64(j_125980, j_m_i_125933);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:109:36-40\n   #11 ftRelational.fut:106:9-109:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125977);
                                    bool bounds_check_128057 = cond_125983 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:109:36-40\n   #11 ftRelational.fut:106:9-109:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125931 + j_125980;
                                    int64_t slice_128054 = start_125741 + slice_128053;
                                    int64_t leq_arg1_128055 = ((int64_t *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125922 + i_125977;
                                    int64_t slice_128060 = start_125741 + slice_128059;
                                    int64_t leq_arg0_128061 = ((int64_t *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = sle64(leq_arg0_128061, leq_arg1_128055);
                                    
                                    cond_f_res_125984 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125984 = 0;
                                }
                                cond_125982 = cond_f_res_125984;
                            }
                            
                            int64_t loopres_125999;
                            int64_t loopres_126000;
                            int64_t loopres_126001;
                            
                            if (cond_125982) {
                                bool x_128064 = sle64((int64_t) 0, i_125977);
                                bool y_128065 = slt64(i_125977, j_m_i_125946);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:109:36-40\n   #11 ftRelational.fut:106:9-109:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125977);
                                int64_t slice_128068 = defunc_0_f_res_125922 + i_125977;
                                int64_t slice_128069 = start_125741 + slice_128068;
                                int64_t tmp_128070 = ((int64_t *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_125999 = tmp_128063;
                                loopres_126000 = tmp_128070;
                                loopres_126001 = tmp_128071;
                            } else {
                                bool x_126011 = sle64((int64_t) 0, j_125980);
                                bool y_126012 = slt64(j_125980, j_m_i_125933);
                                bool bounds_check_126013 = x_126011 && y_126012;
                                bool index_certs_126014;
                                
                                if (!bounds_check_126013) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:109:36-40\n   #11 ftRelational.fut:106:9-109:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126015 = merge_sequential_arg2_125931 + j_125980;
                                int64_t slice_126016 = start_125741 + slice_126015;
                                int64_t tmp_126017 = ((int64_t *) mem_param_133548.mem)[slice_126016];
                                int64_t tmp_126018 = ((int64_t *) mem_param_133551.mem)[slice_126016];
                                
                                loopres_125999 = i_125977;
                                loopres_126000 = tmp_126017;
                                loopres_126001 = tmp_126018;
                            }
                            ((int64_t *) mem_133584)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126000;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126001;
                            
                            int64_t i_tmp_133921 = loopres_125999;
                            
                            i_125977 = i_tmp_133921;
                        }
                        data_125973 = i_125977;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint64_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133583, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133554, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126025 = next_stride_125669 * num_merges_125673;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint64_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            if (memblock_alloc(ctx, &mem_133664, bytes_133553, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            
            bool loop_cond_126028 = slt64(next_stride_125669, flat_dim_125550);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126025;
            bool loop_while_tmp_133898 = loop_cond_126028;
            int64_t stride_tmp_133901 = next_stride_125669;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125664 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125665 = loop_while_tmp_133898;
            stride_125668 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125659 = loop_dz2084Uz2082U_125664;
        data_125660 = loop_while_125665;
        data_125663 = stride_125668;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126029 = n_78781 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126030 = sle64((int64_t) 0, zs_lhs_125534);
        bool i_p_m_t_s_leq_w_126031 = slt64(zs_lhs_125534, data_125659);
        bool y_126032 = zzero_leq_i_p_m_t_s_126030 && i_p_m_t_s_leq_w_126031;
        bool ok_or_empty_126033 = empty_slice_126029 || y_126032;
        bool index_certs_126034;
        
        if (!ok_or_empty_126033) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_78781, "] out of bounds for array of shape [", (long long) data_125659, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:109:36-40\n   #6  ftRelational.fut:106:9-109:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133468, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133677, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_78781; i_133340++) {
        int64_t eta_p_126042 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126043 = sle64((int64_t) 0, eta_p_126042);
        bool y_126044 = slt64(eta_p_126042, n_78781);
        bool bounds_check_126045 = x_126043 && y_126044;
        bool index_certs_126046;
        
        if (!bounds_check_126045) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126042, "] out of bounds for array of shape [", (long long) n_78781, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:109:36-40\n   #5  ftRelational.fut:106:9-109:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t lifted_lambda_res_126047 = ((int64_t *) k_mem_133466.mem)[eta_p_126042];
        
        ((int64_t *) mem_133676.mem)[i_133340] = lifted_lambda_res_126047;
        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133678.mem, i_133340 * b_78782, (int64_t []) {(int64_t) 1}, (uint8_t *) pL_mem_133467.mem, eta_p_126042 * b_78782, (int64_t []) {(int64_t) 1}, (int64_t []) {b_78782});
    }
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134210, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134211, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_mergeSortRelation_short(struct futhark_context *ctx, struct memblock *mem_out_p_134222, struct memblock *mem_out_p_134223, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_74061, int64_t b_74062)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133472_cached_sizze_134224 = 0;
    unsigned char *mem_133472 = NULL;
    int64_t mem_133475_cached_sizze_134225 = 0;
    unsigned char *mem_133475 = NULL;
    int64_t mem_133485_cached_sizze_134226 = 0;
    unsigned char *mem_133485 = NULL;
    int64_t mem_133487_cached_sizze_134227 = 0;
    unsigned char *mem_133487 = NULL;
    int64_t mem_133554_cached_sizze_134228 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133557_cached_sizze_134229 = 0;
    unsigned char *mem_133557 = NULL;
    int64_t mem_133567_cached_sizze_134230 = 0;
    unsigned char *mem_133567 = NULL;
    int64_t mem_133569_cached_sizze_134231 = 0;
    unsigned char *mem_133569 = NULL;
    int64_t mem_133584_cached_sizze_134232 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133587_cached_sizze_134233 = 0;
    unsigned char *mem_133587 = NULL;
    struct memblock mem_133678;
    
    mem_133678.references = NULL;
    
    struct memblock mem_133676;
    
    mem_133676.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_133664;
    
    mem_133664.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133626;
    
    mem_133626.references = NULL;
    
    struct memblock mem_133622;
    
    mem_133622.references = NULL;
    
    struct memblock mem_133631;
    
    mem_133631.references = NULL;
    
    struct memblock mem_133629;
    
    mem_133629.references = NULL;
    
    struct memblock ext_mem_133646;
    
    ext_mem_133646.references = NULL;
    
    struct memblock ext_mem_133649;
    
    ext_mem_133649.references = NULL;
    
    struct memblock mem_param_133551;
    
    mem_param_133551.references = NULL;
    
    struct memblock mem_param_133548;
    
    mem_param_133548.references = NULL;
    
    struct memblock ext_mem_133670;
    
    ext_mem_133670.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock mem_133544;
    
    mem_133544.references = NULL;
    
    struct memblock mem_133540;
    
    mem_133540.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_74061;
    bool cond_125533 = sle64(n_74061, (int64_t) 1);
    int64_t zs_lhs_125534 = sub64(n_74061, (int64_t) 1);
    int64_t zp_rhs_125535 = sdiv_safe64(zs_lhs_125534, (int64_t) 20);
    int64_t min_num_blocks_125536 = add64((int64_t) 1, zp_rhs_125535);
    bool loop_cond_125537 = slt64((int64_t) 1, min_num_blocks_125536);
    bool smallest_pow_2_geq_than_res_125538;
    int64_t smallest_pow_2_geq_than_res_125539;
    bool loop_while_125540;
    int64_t x_125541;
    
    loop_while_125540 = loop_cond_125537;
    x_125541 = (int64_t) 1;
    while (loop_while_125540) {
        int64_t loopres_125542 = mul64((int64_t) 2, x_125541);
        bool loop_cond_125543 = slt64(loopres_125542, min_num_blocks_125536);
        bool loop_while_tmp_133879 = loop_cond_125543;
        int64_t x_tmp_133880 = loopres_125542;
        
        loop_while_125540 = loop_while_tmp_133879;
        x_125541 = x_tmp_133880;
    }
    smallest_pow_2_geq_than_res_125538 = loop_while_125540;
    smallest_pow_2_geq_than_res_125539 = x_125541;
    
    bool zzero_125544 = smallest_pow_2_geq_than_res_125539 == (int64_t) 0;
    bool nonzzero_125545 = !zzero_125544;
    bool protect_assert_disj_125546 = cond_125533 || nonzzero_125545;
    bool nonzzero_cert_125547;
    
    if (!protect_assert_disj_125546) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:101:36-40\n   #5  ftRelational.fut:98:9-101:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zp_rhs_125548 = sdiv_safe64(zs_lhs_125534, smallest_pow_2_geq_than_res_125539);
    int64_t block_sizze_125549 = add64((int64_t) 1, zp_rhs_125548);
    bool y_125555 = slt64((int64_t) 0, n_74061);
    bool protect_assert_disj_133752 = cond_125533 || y_125555;
    bool index_certs_125556;
    
    if (!protect_assert_disj_133752) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) n_74061, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:101:36-40\n   #5  ftRelational.fut:98:9-101:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125570 = slt64(smallest_pow_2_geq_than_res_125539, (int64_t) 0);
    bool valid_125571 = !bounds_invalid_upwards_125570;
    bool protect_assert_disj_133760 = cond_125533 || valid_125571;
    bool range_valid_c_125572;
    
    if (!protect_assert_disj_133760) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_125539, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:101:36-40\n   #6  ftRelational.fut:98:9-101:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool bounds_invalid_upwards_125574 = slt64(block_sizze_125549, (int64_t) 0);
    bool valid_125575 = !bounds_invalid_upwards_125574;
    bool protect_assert_disj_133762 = cond_125533 || valid_125575;
    bool range_valid_c_125576;
    
    if (!protect_assert_disj_133762) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_125549, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_125578 = sle64(block_sizze_125549, (int64_t) 1);
    int64_t tmp_125579 = sub64(block_sizze_125549, (int64_t) 2);
    bool bounds_invalid_upwards_125580 = slt64(tmp_125579, (int64_t) 0);
    bool valid_125582 = !bounds_invalid_upwards_125580;
    bool protect_assert_disj_125583 = cond_125578 || valid_125582;
    bool protect_assert_disj_133764 = cond_125533 || protect_assert_disj_125583;
    bool range_valid_c_125584;
    
    if (!protect_assert_disj_133764) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_125579, " is invalid.", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:166:19-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133675 = (int64_t) 2 * n_74061;
    int64_t bytes_133677 = n_74061 * b_74062;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133881 = 0; i_133881 < n_74061; i_133881++) {
        int64_t x_133882 = (int64_t) 0 + i_133881 * (int64_t) 1;
        
        ((int64_t *) mem_133469.mem)[i_133881] = x_133882;
    }
    
    int64_t flat_dim_125550 = smallest_pow_2_geq_than_res_125539 * block_sizze_125549;
    bool x_133747 = !cond_125533;
    int64_t greatest_divisor_leq_than_arg1_125553 = mul64((int64_t) 2, block_sizze_125549);
    int64_t merge_block_sizze_125554;
    
    if (x_133747) {
        int64_t x_133749;
        
        if (futrts_greatest_divisor_leq_than_5357(ctx, &x_133749, (int64_t) 8, greatest_divisor_leq_than_arg1_125553) != 0) {
            err = 1;
            goto cleanup;
        }
        merge_block_sizze_125554 = x_133749;
    } else {
        merge_block_sizze_125554 = (int64_t) 0;
    }
    
    int16_t reduce_arg1_125557;
    
    if (x_133747) {
        int16_t x_133753 = ((int16_t *) k_mem_133466.mem)[(int64_t) 0];
        
        reduce_arg1_125557 = x_133753;
    } else {
        reduce_arg1_125557 = (int16_t) 0;
    }
    
    int16_t defunc_0_reduce_res_128078;
    int64_t defunc_0_reduce_res_128079;
    
    if (x_133747) {
        int16_t x_133755;
        int64_t x_133756;
        int16_t redout_133298;
        int64_t redout_133299;
        
        redout_133298 = reduce_arg1_125557;
        redout_133299 = (int64_t) 0;
        for (int64_t i_133300 = 0; i_133300 < n_74061; i_133300++) {
            int16_t x_125561 = ((int16_t *) k_mem_133466.mem)[i_133300];
            bool defunc_0_leq_res_125567 = sle16(redout_133298, x_125561);
            int16_t defunc_0_op_res_125568;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125568 = x_125561;
            } else {
                defunc_0_op_res_125568 = redout_133298;
            }
            
            int64_t defunc_0_op_res_125569;
            
            if (defunc_0_leq_res_125567) {
                defunc_0_op_res_125569 = i_133300;
            } else {
                defunc_0_op_res_125569 = redout_133299;
            }
            
            int16_t redout_tmp_133883 = defunc_0_op_res_125568;
            int64_t redout_tmp_133884 = defunc_0_op_res_125569;
            
            redout_133298 = redout_tmp_133883;
            redout_133299 = redout_tmp_133884;
        }
        x_133755 = redout_133298;
        x_133756 = redout_133299;
        defunc_0_reduce_res_128078 = x_133755;
        defunc_0_reduce_res_128079 = x_133756;
    } else {
        defunc_0_reduce_res_128078 = (int16_t) 0;
        defunc_0_reduce_res_128079 = (int64_t) 0;
    }
    
    int64_t distance_125581 = add64((int64_t) 1, tmp_125579);
    int64_t binop_x_133470 = (int64_t) 2 * smallest_pow_2_geq_than_res_125539;
    int64_t bytes_133471 = block_sizze_125549 * binop_x_133470;
    int64_t binop_x_133473 = (int64_t) 8 * smallest_pow_2_geq_than_res_125539;
    int64_t bytes_133474 = block_sizze_125549 * binop_x_133473;
    int64_t bytes_133486 = (int64_t) 8 * block_sizze_125549;
    bool loop_cond_125656 = slt64(block_sizze_125549, flat_dim_125550);
    bool zzero_125657 = merge_block_sizze_125554 == (int64_t) 0;
    bool nonzzero_125658 = !zzero_125657;
    
    if (cond_125533) {
        if (memblock_set(ctx, &ext_mem_133674, &mem_133469, "mem_133469") != 0)
            return 1;
    } else {
        if (mem_133472_cached_sizze_134224 < bytes_133471) {
            err = lexical_realloc(ctx, &mem_133472, &mem_133472_cached_sizze_134224, bytes_133471);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133475_cached_sizze_134225 < bytes_133474) {
            err = lexical_realloc(ctx, &mem_133475, &mem_133475_cached_sizze_134225, bytes_133474);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133485_cached_sizze_134226 < greatest_divisor_leq_than_arg1_125553) {
            err = lexical_realloc(ctx, &mem_133485, &mem_133485_cached_sizze_134226, greatest_divisor_leq_than_arg1_125553);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (mem_133487_cached_sizze_134227 < bytes_133486) {
            err = lexical_realloc(ctx, &mem_133487, &mem_133487_cached_sizze_134227, bytes_133486);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_133312 = 0; i_133312 < smallest_pow_2_geq_than_res_125539; i_133312++) {
            int64_t zp_lhs_125588 = mul64(block_sizze_125549, i_133312);
            
            for (int64_t i_133305 = 0; i_133305 < block_sizze_125549; i_133305++) {
                int64_t k_125592 = add64(zp_lhs_125588, i_133305);
                bool cond_125593 = slt64(k_125592, n_74061);
                int16_t lifted_lambda_res_125594;
                int64_t lifted_lambda_res_125595;
                
                if (cond_125593) {
                    bool x_127931 = sle64((int64_t) 0, k_125592);
                    bool bounds_check_127932 = cond_125593 && x_127931;
                    bool index_certs_127933;
                    
                    if (!bounds_check_127932) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_125592, "] out of bounds for array of shape [", (long long) n_74061, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:101:36-40\n   #9  ftRelational.fut:98:9-101:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int16_t lifted_lambda_res_t_res_127934 = ((int16_t *) k_mem_133466.mem)[k_125592];
                    
                    lifted_lambda_res_125594 = lifted_lambda_res_t_res_127934;
                    lifted_lambda_res_125595 = k_125592;
                } else {
                    lifted_lambda_res_125594 = defunc_0_reduce_res_128078;
                    lifted_lambda_res_125595 = defunc_0_reduce_res_128079;
                }
                ((int16_t *) mem_133485)[i_133305] = lifted_lambda_res_125594;
                ((int64_t *) mem_133487)[i_133305] = lifted_lambda_res_125595;
            }
            if (!cond_125578) {
                for (int64_t i_125605 = 0; i_125605 < distance_125581; i_125605++) {
                    int64_t gt_arg1_125608 = add64((int64_t) 1, i_125605);
                    bool x_125609 = sle64((int64_t) 0, gt_arg1_125608);
                    bool y_125610 = slt64(gt_arg1_125608, block_sizze_125549);
                    bool bounds_check_125611 = x_125609 && y_125610;
                    bool index_certs_125612;
                    
                    if (!bounds_check_125611) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_125608, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool y_125614 = slt64(i_125605, block_sizze_125549);
                    bool index_certs_125615;
                    
                    if (!y_125614) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125605, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int16_t gt_arg1_125613 = ((int16_t *) mem_133485)[gt_arg1_125608];
                    int16_t gt_arg0_125616 = ((int16_t *) mem_133485)[i_125605];
                    bool defunc_0_leq_res_125617 = sle16(gt_arg0_125616, gt_arg1_125613);
                    bool defunc_0_lifted_gt_res_125618 = !defunc_0_leq_res_125617;
                    bool s_125619;
                    int64_t s_125622;
                    bool loop_while_125623;
                    int64_t j_125626;
                    
                    loop_while_125623 = defunc_0_lifted_gt_res_125618;
                    j_125626 = i_125605;
                    while (loop_while_125623) {
                        bool x_125627 = sle64((int64_t) 0, j_125626);
                        bool y_125628 = slt64(j_125626, block_sizze_125549);
                        bool bounds_check_125629 = x_125627 && y_125628;
                        bool index_certs_125630;
                        
                        if (!bounds_check_125629) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125626, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t copy_arg0_125633 = add64((int64_t) 1, j_125626);
                        bool x_125634 = sle64((int64_t) 0, copy_arg0_125633);
                        bool y_125635 = slt64(copy_arg0_125633, block_sizze_125549);
                        bool bounds_check_125636 = x_125634 && y_125635;
                        bool index_certs_125637;
                        
                        if (!bounds_check_125636) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_125633, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int16_t copy_arg0_125631 = ((int16_t *) mem_133485)[j_125626];
                        int64_t copy_arg0_125632 = ((int64_t *) mem_133487)[j_125626];
                        int16_t copy_arg0_125638 = ((int16_t *) mem_133485)[copy_arg0_125633];
                        int64_t copy_arg0_125639 = ((int64_t *) mem_133487)[copy_arg0_125633];
                        
                        ((int16_t *) mem_133485)[j_125626] = copy_arg0_125638;
                        ((int64_t *) mem_133487)[j_125626] = copy_arg0_125639;
                        ((int16_t *) mem_133485)[copy_arg0_125633] = copy_arg0_125631;
                        ((int64_t *) mem_133487)[copy_arg0_125633] = copy_arg0_125632;
                        
                        int64_t tmp_125644 = sub64(j_125626, (int64_t) 1);
                        bool cond_125645 = sle64((int64_t) 0, tmp_125644);
                        bool loop_cond_125646;
                        
                        if (cond_125645) {
                            bool y_127936 = slt64(tmp_125644, block_sizze_125549);
                            bool bounds_check_127937 = cond_125645 && y_127936;
                            bool index_certs_127938;
                            
                            if (!bounds_check_127937) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125644, "] out of bounds for array of shape [", (long long) block_sizze_125549, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:248:32-37\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int16_t gt_arg1_127935 = ((int16_t *) mem_133485)[j_125626];
                            int16_t gt_arg0_127939 = ((int16_t *) mem_133485)[tmp_125644];
                            bool defunc_0_leq_res_127940 = sle16(gt_arg0_127939, gt_arg1_127935);
                            bool defunc_0_lifted_gt_res_127941 = !defunc_0_leq_res_127940;
                            
                            loop_cond_125646 = defunc_0_lifted_gt_res_127941;
                        } else {
                            loop_cond_125646 = 0;
                        }
                        
                        bool loop_while_tmp_133891 = loop_cond_125646;
                        int64_t j_tmp_133894 = tmp_125644;
                        
                        loop_while_125623 = loop_while_tmp_133891;
                        j_125626 = j_tmp_133894;
                    }
                    s_125619 = loop_while_125623;
                    s_125622 = j_125626;
                }
            }
            lmad_copy_2b(ctx, 1, (uint16_t *) mem_133472, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint16_t *) mem_133485, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133475, i_133312 * block_sizze_125549, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133487, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_125549});
        }
        if (memblock_alloc(ctx, &mem_133540, bytes_133471, "mem_133540")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_2b(ctx, 2, (uint16_t *) mem_133540.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint16_t *) mem_133472, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        if (memblock_alloc(ctx, &mem_133544, bytes_133474, "mem_133544")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_133544.mem, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (uint64_t *) mem_133475, (int64_t) 0, (int64_t []) {block_sizze_125549, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_125539, block_sizze_125549});
        
        int64_t data_125659;
        bool data_125660;
        int64_t data_125663;
        int64_t loop_dz2084Uz2082U_125664;
        bool loop_while_125665;
        int64_t stride_125668;
        
        if (memblock_set(ctx, &mem_param_133548, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133551, &mem_133544, "mem_133544") != 0)
            return 1;
        loop_dz2084Uz2082U_125664 = flat_dim_125550;
        loop_while_125665 = loop_cond_125656;
        stride_125668 = block_sizze_125549;
        while (loop_while_125665) {
            int64_t next_stride_125669 = mul64((int64_t) 2, stride_125668);
            bool zzero_125670 = next_stride_125669 == (int64_t) 0;
            bool nonzzero_125671 = !zzero_125670;
            bool nonzzero_cert_125672;
            
            if (!nonzzero_125671) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #2  /prelude/functional.fut:9:44-45\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:101:36-40\n   #5  ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_merges_125673 = sdiv64(flat_dim_125550, next_stride_125669);
            bool bounds_invalid_upwards_125674 = slt64(num_merges_125673, (int64_t) 0);
            bool valid_125675 = !bounds_invalid_upwards_125674;
            bool range_valid_c_125676;
            
            if (!valid_125675) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_125673, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:101:36-40\n   #6  ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_125678 = sub64(next_stride_125669, (int64_t) 1);
            bool zzero_leq_i_p_m_t_s_125679 = sle64((int64_t) 0, m_125678);
            bool cond_125681 = slt64(next_stride_125669, (int64_t) 10);
            bool protect_assert_disj_125682 = nonzzero_125658 || cond_125681;
            bool nonzzero_cert_125683;
            
            if (!protect_assert_disj_125682) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t zeze_lhs_125684 = smod_safe64(next_stride_125669, merge_block_sizze_125554);
            bool num_blocks_125685 = zeze_lhs_125684 == (int64_t) 0;
            bool protect_assert_disj_125686 = cond_125681 || num_blocks_125685;
            bool assert_c_125687;
            
            if (!protect_assert_disj_125686) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t num_blocks_125689 = sdiv_safe64(next_stride_125669, merge_block_sizze_125554);
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690 = add64((int64_t) 1, num_blocks_125689);
            int64_t j_m_i_125691 = sub64(next_stride_125669, stride_125668);
            int64_t flat_dim_125692 = merge_block_sizze_125554 * num_blocks_125689;
            bool bounds_invalid_upwards_125693 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, (int64_t) 0);
            bool empty_slice_125694 = j_m_i_125691 == (int64_t) 0;
            int64_t m_125695 = sub64(j_m_i_125691, (int64_t) 1);
            bool zzero_lte_i_125696 = sle64((int64_t) 0, stride_125668);
            bool i_lte_j_125697 = sle64(stride_125668, next_stride_125669);
            bool empty_slice_125698 = stride_125668 == (int64_t) 0;
            int64_t m_125699 = sub64(stride_125668, (int64_t) 1);
            bool bounds_invalid_upwards_125700 = slt64(num_blocks_125689, (int64_t) 0);
            bool cond_125701 = slt64((int64_t) 0, stride_125668);
            bool valid_125702 = !bounds_invalid_upwards_125693;
            int64_t i_p_m_t_s_125703 = add64(stride_125668, m_125695);
            bool zzero_leq_i_p_m_t_s_125704 = sle64((int64_t) 0, m_125699);
            bool i_p_m_t_s_leq_w_125705 = slt64(m_125699, next_stride_125669);
            bool valid_125706 = !bounds_invalid_upwards_125700;
            bool i_p_m_t_s_leq_w_125707 = slt64(m_125678, flat_dim_125692);
            bool y_125708 = slt64((int64_t) 0, j_m_i_125691);
            bool protect_assert_disj_125709 = cond_125681 || valid_125702;
            bool range_valid_c_125710;
            
            if (!protect_assert_disj_125709) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:101:36-40\n   #10 ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool zzero_leq_i_p_m_t_s_125711 = sle64((int64_t) 0, i_p_m_t_s_125703);
            bool i_p_m_t_s_leq_w_125712 = slt64(i_p_m_t_s_125703, next_stride_125669);
            bool y_125713 = zzero_leq_i_p_m_t_s_125704 && i_p_m_t_s_leq_w_125705;
            bool protect_assert_disj_125714 = cond_125681 || valid_125706;
            bool range_valid_c_125715;
            
            if (!protect_assert_disj_125714) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_125689, " is invalid.", "-> #0  /prelude/array.fut:94:3-11\n   #1  /prelude/array.fut:241:11-17\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:101:36-40\n   #9  ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool y_125716 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125707;
            bool y_125717 = zzero_lte_i_125696 && i_p_m_t_s_leq_w_125712;
            bool forwards_ok_125718 = zzero_lte_i_125696 && y_125713;
            bool ok_or_empty_125719 = zzero_125670 || y_125716;
            bool protect_assert_disj_125720 = cond_125701 || y_125708;
            bool y_125721 = zzero_leq_i_p_m_t_s_125711 && y_125717;
            bool ok_or_empty_125722 = empty_slice_125698 || forwards_ok_125718;
            bool protect_assert_disj_125723 = cond_125681 || ok_or_empty_125719;
            bool index_certs_125724;
            
            if (!protect_assert_disj_125723) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) flat_dim_125692, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:101:36-40\n   #9  ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool loop_not_taken_125725 = !cond_125681;
            bool protect_assert_disj_125726 = protect_assert_disj_125720 || loop_not_taken_125725;
            bool index_certs_125727;
            
            if (!protect_assert_disj_125726) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:101:36-40\n   #10 ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool forwards_ok_125728 = i_lte_j_125697 && y_125721;
            bool protect_assert_disj_125729 = cond_125681 || ok_or_empty_125722;
            bool index_certs_125730;
            
            if (!protect_assert_disj_125729) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:101:36-40\n   #11 ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125731 = ok_or_empty_125722 || loop_not_taken_125725;
            bool index_certs_125732;
            
            if (!protect_assert_disj_125731) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_125668, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool ok_or_empty_125733 = empty_slice_125694 || forwards_ok_125728;
            bool protect_assert_disj_125734 = cond_125681 || ok_or_empty_125733;
            bool index_certs_125735;
            
            if (!protect_assert_disj_125734) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:101:36-40\n   #11 ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            bool protect_assert_disj_125736 = loop_not_taken_125725 || ok_or_empty_125733;
            bool index_certs_125737;
            
            if (!protect_assert_disj_125736) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_125668, ":] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t binop_x_133552 = (int64_t) 2 * num_merges_125673;
            int64_t bytes_133553 = next_stride_125669 * binop_x_133552;
            int64_t binop_x_133555 = (int64_t) 8 * num_merges_125673;
            int64_t bytes_133556 = next_stride_125669 * binop_x_133555;
            bool i_lte_j_125680 = sle64((int64_t) 0, next_stride_125669);
            
            if (mem_133554_cached_sizze_134228 < bytes_133553) {
                err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134228, bytes_133553);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133557_cached_sizze_134229 < bytes_133556) {
                err = lexical_realloc(ctx, &mem_133557, &mem_133557_cached_sizze_134229, bytes_133556);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t bytes_133566 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690;
            int64_t binop_x_133582 = (int64_t) 2 * num_blocks_125689;
            int64_t bytes_133583 = merge_block_sizze_125554 * binop_x_133582;
            int64_t binop_x_133585 = (int64_t) 8 * num_blocks_125689;
            int64_t bytes_133586 = merge_block_sizze_125554 * binop_x_133585;
            int64_t bytes_133628 = (int64_t) 4 * stride_125668;
            int64_t bytes_133630 = (int64_t) 16 * stride_125668;
            
            for (int64_t i_133333 = 0; i_133333 < num_merges_125673; i_133333++) {
                int64_t start_125741 = mul64(next_stride_125669, i_133333);
                int64_t j_m_i_125742 = sub64(loop_dz2084Uz2082U_125664, start_125741);
                bool empty_slice_125743 = j_m_i_125742 == (int64_t) 0;
                int64_t m_125744 = sub64(j_m_i_125742, (int64_t) 1);
                int64_t i_p_m_t_s_125745 = add64(start_125741, m_125744);
                bool zzero_leq_i_p_m_t_s_125746 = sle64((int64_t) 0, i_p_m_t_s_125745);
                bool i_p_m_t_s_leq_w_125747 = slt64(i_p_m_t_s_125745, loop_dz2084Uz2082U_125664);
                bool zzero_lte_i_125748 = sle64((int64_t) 0, start_125741);
                bool i_lte_j_125749 = sle64(start_125741, loop_dz2084Uz2082U_125664);
                bool y_125750 = i_p_m_t_s_leq_w_125747 && zzero_lte_i_125748;
                bool y_125751 = zzero_leq_i_p_m_t_s_125746 && y_125750;
                bool forwards_ok_125752 = i_lte_j_125749 && y_125751;
                bool ok_or_empty_125753 = empty_slice_125743 || forwards_ok_125752;
                bool index_certs_125754;
                
                if (!ok_or_empty_125753) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_125741, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_125664, "].", "-> #0  /prelude/array.fut:52:49-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                bool i_p_m_t_s_leq_w_125755 = slt64(m_125678, j_m_i_125742);
                bool y_125756 = zzero_leq_i_p_m_t_s_125679 && i_p_m_t_s_leq_w_125755;
                bool forwards_ok_125757 = i_lte_j_125680 && y_125756;
                bool ok_or_empty_125758 = zzero_125670 || forwards_ok_125757;
                bool index_certs_125759;
                
                if (!ok_or_empty_125758) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_125669, "] out of bounds for array of shape [", (long long) j_m_i_125742, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #5  /prelude/functional.fut:9:44-45\n   #6  ftSMJ.fut:105:58-61\n   #7  ftRelational.fut:101:36-40\n   #8  ftRelational.fut:98:9-101:40\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_125681) {
                    int16_t dummy_127967;
                    int64_t dummy_127968;
                    
                    if (cond_125701) {
                        int16_t head_res_127969 = ((int16_t *) mem_param_133548.mem)[start_125741];
                        int64_t head_res_127970 = ((int64_t *) mem_param_133551.mem)[start_125741];
                        
                        dummy_127967 = head_res_127969;
                        dummy_127968 = head_res_127970;
                    } else {
                        int64_t slice_127971 = stride_125668 + start_125741;
                        int16_t head_res_127972 = ((int16_t *) mem_param_133548.mem)[slice_127971];
                        int64_t head_res_127973 = ((int64_t *) mem_param_133551.mem)[slice_127971];
                        
                        dummy_127967 = head_res_127972;
                        dummy_127968 = head_res_127973;
                    }
                    if (memblock_alloc(ctx, &mem_133629, bytes_133628, "mem_133629")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133904 = 0; nest_i_133904 < next_stride_125669; nest_i_133904++) {
                        ((int16_t *) mem_133629.mem)[nest_i_133904] = dummy_127967;
                    }
                    if (memblock_alloc(ctx, &mem_133631, bytes_133630, "mem_133631")) {
                        err = 1;
                        goto cleanup;
                    }
                    for (int64_t nest_i_133905 = 0; nest_i_133905 < next_stride_125669; nest_i_133905++) {
                        ((int64_t *) mem_133631.mem)[nest_i_133905] = dummy_127968;
                    }
                    
                    int64_t data_127976;
                    int64_t i_127980 = (int64_t) 0;
                    
                    for (int64_t k_127979 = 0; k_127979 < next_stride_125669; k_127979++) {
                        int64_t j_127983 = sub64(k_127979, i_127980);
                        bool cond_127984 = j_127983 == j_m_i_125691;
                        bool cond_127985;
                        
                        if (cond_127984) {
                            cond_127985 = 1;
                        } else {
                            bool cond_127986 = slt64(i_127980, stride_125668);
                            bool cond_f_res_127987;
                            
                            if (cond_127986) {
                                bool x_127988 = sle64((int64_t) 0, j_127983);
                                bool y_127989 = slt64(j_127983, j_m_i_125691);
                                bool bounds_check_127990 = x_127988 && y_127989;
                                bool index_certs_127991;
                                
                                if (!bounds_check_127990) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:101:36-40\n   #9  ftRelational.fut:98:9-101:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                bool x_127995 = sle64((int64_t) 0, i_127980);
                                bool bounds_check_127996 = cond_127986 && x_127995;
                                bool index_certs_127997;
                                
                                if (!bounds_check_127996) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:101:36-40\n   #9  ftRelational.fut:98:9-101:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_127992 = stride_125668 + j_127983;
                                int64_t slice_127993 = start_125741 + slice_127992;
                                int16_t leq_arg1_127994 = ((int16_t *) mem_param_133548.mem)[slice_127993];
                                int64_t slice_127998 = start_125741 + i_127980;
                                int16_t leq_arg0_127999 = ((int16_t *) mem_param_133548.mem)[slice_127998];
                                bool defunc_0_leq_res_128000 = sle16(leq_arg0_127999, leq_arg1_127994);
                                
                                cond_f_res_127987 = defunc_0_leq_res_128000;
                            } else {
                                cond_f_res_127987 = 0;
                            }
                            cond_127985 = cond_f_res_127987;
                        }
                        
                        int64_t loopres_128001;
                        int16_t loopres_128002;
                        int64_t loopres_128003;
                        
                        if (cond_127985) {
                            bool x_128005 = sle64((int64_t) 0, i_127980);
                            bool y_128006 = slt64(i_127980, stride_125668);
                            bool bounds_check_128007 = x_128005 && y_128006;
                            bool index_certs_128008;
                            
                            if (!bounds_check_128007) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_127980, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:101:36-40\n   #9  ftRelational.fut:98:9-101:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t tmp_128004 = add64((int64_t) 1, i_127980);
                            int64_t slice_128009 = start_125741 + i_127980;
                            int16_t tmp_128010 = ((int16_t *) mem_param_133548.mem)[slice_128009];
                            int64_t tmp_128011 = ((int64_t *) mem_param_133551.mem)[slice_128009];
                            
                            loopres_128001 = tmp_128004;
                            loopres_128002 = tmp_128010;
                            loopres_128003 = tmp_128011;
                        } else {
                            bool x_128012 = sle64((int64_t) 0, j_127983);
                            bool y_128013 = slt64(j_127983, j_m_i_125691);
                            bool bounds_check_128014 = x_128012 && y_128013;
                            bool index_certs_128015;
                            
                            if (!bounds_check_128014) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_127983, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:145:42-43\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #6  /prelude/functional.fut:9:44-45\n   #7  ftSMJ.fut:105:58-61\n   #8  ftRelational.fut:101:36-40\n   #9  ftRelational.fut:98:9-101:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128016 = stride_125668 + j_127983;
                            int64_t slice_128017 = start_125741 + slice_128016;
                            int16_t tmp_128018 = ((int16_t *) mem_param_133548.mem)[slice_128017];
                            int64_t tmp_128019 = ((int64_t *) mem_param_133551.mem)[slice_128017];
                            
                            loopres_128001 = i_127980;
                            loopres_128002 = tmp_128018;
                            loopres_128003 = tmp_128019;
                        }
                        ((int16_t *) mem_133629.mem)[k_127979] = loopres_128002;
                        ((int64_t *) mem_133631.mem)[k_127979] = loopres_128003;
                        
                        int64_t i_tmp_133906 = loopres_128001;
                        
                        i_127980 = i_tmp_133906;
                    }
                    data_127976 = i_127980;
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133629, "mem_133629") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133631, "mem_133631") != 0)
                        return 1;
                } else {
                    if (mem_133567_cached_sizze_134230 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133567, &mem_133567_cached_sizze_134230, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133569_cached_sizze_134231 < bytes_133566) {
                        err = lexical_realloc(ctx, &mem_133569, &mem_133569_cached_sizze_134231, bytes_133566);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133319 = 0; i_133319 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690; i_133319++) {
                        int64_t split_count_arg3_125821 = mul64(merge_block_sizze_125554, i_133319);
                        int64_t defunc_0_split_count_res_125822;
                        int64_t defunc_0_split_count_res_125823;
                        int64_t defunc_0_split_count_res_125824;
                        int64_t defunc_0_split_count_res_125825;
                        int64_t defunc_0_split_count_res_125826;
                        
                        if (futrts_lifted_normalizze_10748(ctx, &defunc_0_split_count_res_125822, &defunc_0_split_count_res_125823, &defunc_0_split_count_res_125824, &defunc_0_split_count_res_125825, &defunc_0_split_count_res_125826, (int64_t) 0, stride_125668, (int64_t) 0, j_m_i_125691, split_count_arg3_125821) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        bool loop_cond_125827 = slt64((int64_t) 0, defunc_0_split_count_res_125826);
                        bool defunc_0_split_count_res_125828;
                        int64_t defunc_0_split_count_res_125829;
                        int64_t defunc_0_split_count_res_125830;
                        int64_t defunc_0_split_count_res_125831;
                        int64_t defunc_0_split_count_res_125832;
                        int64_t defunc_0_split_count_res_125833;
                        bool loop_while_125834;
                        int64_t ss_125835;
                        int64_t ss_125836;
                        int64_t tt_125837;
                        int64_t tt_125838;
                        int64_t count_125839;
                        
                        loop_while_125834 = loop_cond_125827;
                        ss_125835 = defunc_0_split_count_res_125822;
                        ss_125836 = defunc_0_split_count_res_125823;
                        tt_125837 = defunc_0_split_count_res_125824;
                        tt_125838 = defunc_0_split_count_res_125825;
                        count_125839 = defunc_0_split_count_res_125826;
                        while (loop_while_125834) {
                            int64_t zlze_lhs_125840 = sub64(ss_125836, ss_125835);
                            bool cond_125841 = sle64(zlze_lhs_125840, (int64_t) 0);
                            int64_t defunc_0_lifted_step_res_125842;
                            int64_t defunc_0_lifted_step_res_125843;
                            int64_t defunc_0_lifted_step_res_125844;
                            int64_t defunc_0_lifted_step_res_125845;
                            
                            if (cond_125841) {
                                int64_t tmp_128022 = add64(tt_125837, count_125839);
                                
                                defunc_0_lifted_step_res_125842 = ss_125835;
                                defunc_0_lifted_step_res_125843 = tmp_128022;
                                defunc_0_lifted_step_res_125844 = tt_125838;
                                defunc_0_lifted_step_res_125845 = (int64_t) 0;
                            } else {
                                int64_t zlze_lhs_125847 = sub64(tt_125838, tt_125837);
                                bool cond_125848 = sle64(zlze_lhs_125847, (int64_t) 0);
                                int64_t defunc_0_lifted_step_res_f_res_125849;
                                int64_t defunc_0_lifted_step_res_f_res_125850;
                                int64_t defunc_0_lifted_step_res_f_res_125851;
                                int64_t defunc_0_lifted_step_res_f_res_125852;
                                
                                if (cond_125848) {
                                    int64_t tmp_128023 = add64(ss_125835, count_125839);
                                    
                                    defunc_0_lifted_step_res_f_res_125849 = tmp_128023;
                                    defunc_0_lifted_step_res_f_res_125850 = tt_125837;
                                    defunc_0_lifted_step_res_f_res_125851 = tt_125838;
                                    defunc_0_lifted_step_res_f_res_125852 = (int64_t) 0;
                                } else {
                                    bool cond_125854 = count_125839 == (int64_t) 1;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125855;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125856;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125857;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_125858;
                                    
                                    if (cond_125854) {
                                        bool x_128025 = sle64((int64_t) 0, ss_125835);
                                        bool y_128026 = slt64(ss_125835, stride_125668);
                                        bool bounds_check_128027 = x_128025 && y_128026;
                                        bool index_certs_128028;
                                        
                                        if (!bounds_check_128027) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_125835, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:101:36-40\n   #13 ftRelational.fut:98:9-101:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        bool x_128031 = sle64((int64_t) 0, tt_125837);
                                        bool y_128032 = slt64(tt_125837, j_m_i_125691);
                                        bool bounds_check_128033 = x_128031 && y_128032;
                                        bool index_certs_128034;
                                        
                                        if (!bounds_check_128033) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_125837, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:101:36-40\n   #13 ftRelational.fut:98:9-101:40\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        
                                        int64_t slice_128029 = start_125741 + ss_125835;
                                        int16_t leq_arg1_128030 = ((int16_t *) mem_param_133548.mem)[slice_128029];
                                        int64_t slice_128035 = stride_125668 + tt_125837;
                                        int64_t slice_128036 = start_125741 + slice_128035;
                                        int16_t leq_arg0_128037 = ((int16_t *) mem_param_133548.mem)[slice_128036];
                                        bool defunc_0_leq_res_128038 = sle16(leq_arg0_128037, leq_arg1_128030);
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        
                                        if (defunc_0_leq_res_128038) {
                                            int64_t tmp_128041 = add64((int64_t) 1, tt_125837);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = ss_125835;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tmp_128041;
                                        } else {
                                            int64_t tmp_128042 = add64((int64_t) 1, ss_125835);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128039 = tmp_128042;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_128040 = tt_125837;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = defunc_0_lifted_step_res_f_res_f_res_t_res_128039;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_t_res_128040;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = tt_125838;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = (int64_t) 0;
                                    } else {
                                        int64_t m_125877 = sdiv64(count_125839, (int64_t) 2);
                                        int64_t n_125878 = sub64(count_125839, m_125877);
                                        bool cond_125879 = n_125878 == (int64_t) 0;
                                        int64_t zgze_lhs_125880 = add64(ss_125835, m_125877);
                                        bool cond_f_res_125881 = sle64(ss_125836, zgze_lhs_125880);
                                        bool x_125882 = !cond_125879;
                                        bool y_125883 = cond_f_res_125881 && x_125882;
                                        bool cond_125884 = cond_125879 || y_125883;
                                        bool leq_y_x_125885;
                                        
                                        if (cond_125884) {
                                            leq_y_x_125885 = 1;
                                        } else {
                                            bool x_125886 = sle64((int64_t) 0, zgze_lhs_125880);
                                            bool y_125887 = slt64(zgze_lhs_125880, stride_125668);
                                            bool bounds_check_125888 = x_125886 && y_125887;
                                            bool index_certs_125889;
                                            
                                            if (!bounds_check_125888) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_125880, "] out of bounds for array of shape [", (long long) stride_125668, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:101:36-40\n   #13 ftRelational.fut:98:9-101:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t zm_lhs_125892 = add64(tt_125837, n_125878);
                                            int64_t leq_arg0_125893 = sub64(zm_lhs_125892, (int64_t) 1);
                                            bool x_125894 = sle64((int64_t) 0, leq_arg0_125893);
                                            bool y_125895 = slt64(leq_arg0_125893, j_m_i_125691);
                                            bool bounds_check_125896 = x_125894 && y_125895;
                                            bool index_certs_125897;
                                            
                                            if (!bounds_check_125896) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_125893, "] out of bounds for array of shape [", (long long) j_m_i_125691, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:149:30-84\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #7  /prelude/soacs.fut:59:9-11\n   #8  /prelude/array.fut:241:11-17\n   #9  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #10 /prelude/functional.fut:9:44-45\n   #11 ftSMJ.fut:105:58-61\n   #12 ftRelational.fut:101:36-40\n   #13 ftRelational.fut:98:9-101:40\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            
                                            int64_t slice_125890 = start_125741 + zgze_lhs_125880;
                                            int16_t leq_arg1_125891 = ((int16_t *) mem_param_133548.mem)[slice_125890];
                                            int64_t slice_125898 = stride_125668 + leq_arg0_125893;
                                            int64_t slice_125899 = start_125741 + slice_125898;
                                            int16_t leq_arg0_125900 = ((int16_t *) mem_param_133548.mem)[slice_125899];
                                            bool defunc_0_leq_res_125901 = sle16(leq_arg0_125900, leq_arg1_125891);
                                            
                                            leq_y_x_125885 = defunc_0_leq_res_125901;
                                        }
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                        
                                        if (leq_y_x_125885) {
                                            int64_t tmp_128043 = add64(tt_125837, n_125878);
                                            int64_t tmp_128044 = sub64(count_125839, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tmp_128043;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tt_125838;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = tmp_128044;
                                        } else {
                                            int64_t tmp_125907 = add64(tt_125837, n_125878);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125902 = tt_125837;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125903 = tmp_125907;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_125904 = count_125839;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_125855 = ss_125835;
                                        defunc_0_lifted_step_res_f_res_f_res_125856 = defunc_0_lifted_step_res_f_res_f_res_f_res_125902;
                                        defunc_0_lifted_step_res_f_res_f_res_125857 = defunc_0_lifted_step_res_f_res_f_res_f_res_125903;
                                        defunc_0_lifted_step_res_f_res_f_res_125858 = defunc_0_lifted_step_res_f_res_f_res_f_res_125904;
                                    }
                                    defunc_0_lifted_step_res_f_res_125849 = defunc_0_lifted_step_res_f_res_f_res_125855;
                                    defunc_0_lifted_step_res_f_res_125850 = defunc_0_lifted_step_res_f_res_f_res_125856;
                                    defunc_0_lifted_step_res_f_res_125851 = defunc_0_lifted_step_res_f_res_f_res_125857;
                                    defunc_0_lifted_step_res_f_res_125852 = defunc_0_lifted_step_res_f_res_f_res_125858;
                                }
                                defunc_0_lifted_step_res_125842 = defunc_0_lifted_step_res_f_res_125849;
                                defunc_0_lifted_step_res_125843 = defunc_0_lifted_step_res_f_res_125850;
                                defunc_0_lifted_step_res_125844 = defunc_0_lifted_step_res_f_res_125851;
                                defunc_0_lifted_step_res_125845 = defunc_0_lifted_step_res_f_res_125852;
                            }
                            
                            int64_t loopres_125908;
                            int64_t loopres_125909;
                            int64_t loopres_125910;
                            int64_t loopres_125911;
                            int64_t loopres_125912;
                            
                            if (futrts_lifted_normalizze_10748(ctx, &loopres_125908, &loopres_125909, &loopres_125910, &loopres_125911, &loopres_125912, defunc_0_lifted_step_res_125842, ss_125836, defunc_0_lifted_step_res_125843, defunc_0_lifted_step_res_125844, defunc_0_lifted_step_res_125845) != 0) {
                                err = 1;
                                goto cleanup;
                            }
                            
                            bool loop_cond_125913 = slt64((int64_t) 0, loopres_125912);
                            bool loop_while_tmp_133911 = loop_cond_125913;
                            int64_t ss_tmp_133912 = loopres_125908;
                            int64_t ss_tmp_133913 = loopres_125909;
                            int64_t tt_tmp_133914 = loopres_125910;
                            int64_t tt_tmp_133915 = loopres_125911;
                            int64_t count_tmp_133916 = loopres_125912;
                            
                            loop_while_125834 = loop_while_tmp_133911;
                            ss_125835 = ss_tmp_133912;
                            ss_125836 = ss_tmp_133913;
                            tt_125837 = tt_tmp_133914;
                            tt_125838 = tt_tmp_133915;
                            count_125839 = count_tmp_133916;
                        }
                        defunc_0_split_count_res_125828 = loop_while_125834;
                        defunc_0_split_count_res_125829 = ss_125835;
                        defunc_0_split_count_res_125830 = ss_125836;
                        defunc_0_split_count_res_125831 = tt_125837;
                        defunc_0_split_count_res_125832 = tt_125838;
                        defunc_0_split_count_res_125833 = count_125839;
                        ((int64_t *) mem_133567)[i_133319] = defunc_0_split_count_res_125829;
                        ((int64_t *) mem_133569)[i_133319] = defunc_0_split_count_res_125831;
                    }
                    if (mem_133584_cached_sizze_134232 < bytes_133583) {
                        err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134232, bytes_133583);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    if (mem_133587_cached_sizze_134233 < bytes_133586) {
                        err = lexical_realloc(ctx, &mem_133587, &mem_133587_cached_sizze_134233, bytes_133586);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    for (int64_t i_133326 = 0; i_133326 < num_blocks_125689; i_133326++) {
                        bool y_125919 = slt64(i_133326, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool index_certs_125921;
                        
                        if (!y_125919) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133326, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:101:36-40\n   #10 ftRelational.fut:98:9-101:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125922 = ((int64_t *) mem_133567)[i_133326];
                        int64_t defunc_0_f_res_125923 = ((int64_t *) mem_133569)[i_133326];
                        int64_t tmp_125924 = add64((int64_t) 1, i_133326);
                        bool x_125925 = sle64((int64_t) 0, tmp_125924);
                        bool y_125926 = slt64(tmp_125924, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690);
                        bool bounds_check_125927 = x_125925 && y_125926;
                        bool index_certs_125928;
                        
                        if (!bounds_check_125927) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_125924, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_125690, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:101:36-40\n   #10 ftRelational.fut:98:9-101:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t defunc_0_f_res_125929 = ((int64_t *) mem_133567)[tmp_125924];
                        int64_t defunc_0_f_res_125930 = ((int64_t *) mem_133569)[tmp_125924];
                        int64_t merge_sequential_arg2_125931 = add64(stride_125668, defunc_0_f_res_125923);
                        int64_t merge_sequential_arg2_125932 = add64(stride_125668, defunc_0_f_res_125930);
                        int64_t j_m_i_125933 = sub64(merge_sequential_arg2_125932, merge_sequential_arg2_125931);
                        bool empty_slice_125934 = j_m_i_125933 == (int64_t) 0;
                        int64_t m_125935 = sub64(j_m_i_125933, (int64_t) 1);
                        int64_t i_p_m_t_s_125936 = add64(merge_sequential_arg2_125931, m_125935);
                        bool zzero_leq_i_p_m_t_s_125937 = sle64((int64_t) 0, i_p_m_t_s_125936);
                        bool i_p_m_t_s_leq_w_125938 = slt64(i_p_m_t_s_125936, next_stride_125669);
                        bool zzero_lte_i_125939 = sle64((int64_t) 0, merge_sequential_arg2_125931);
                        bool i_lte_j_125940 = sle64(merge_sequential_arg2_125931, merge_sequential_arg2_125932);
                        bool y_125941 = i_p_m_t_s_leq_w_125938 && zzero_lte_i_125939;
                        bool y_125942 = zzero_leq_i_p_m_t_s_125937 && y_125941;
                        bool forwards_ok_125943 = i_lte_j_125940 && y_125942;
                        bool ok_or_empty_125944 = empty_slice_125934 || forwards_ok_125943;
                        bool index_certs_125945;
                        
                        if (!ok_or_empty_125944) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_125931, ":", (long long) merge_sequential_arg2_125932, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:101:36-40\n   #10 ftRelational.fut:98:9-101:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int64_t j_m_i_125946 = sub64(defunc_0_f_res_125929, defunc_0_f_res_125922);
                        bool empty_slice_125947 = j_m_i_125946 == (int64_t) 0;
                        int64_t m_125948 = sub64(j_m_i_125946, (int64_t) 1);
                        int64_t i_p_m_t_s_125949 = add64(defunc_0_f_res_125922, m_125948);
                        bool zzero_leq_i_p_m_t_s_125950 = sle64((int64_t) 0, i_p_m_t_s_125949);
                        bool i_p_m_t_s_leq_w_125951 = slt64(i_p_m_t_s_125949, next_stride_125669);
                        bool zzero_lte_i_125952 = sle64((int64_t) 0, defunc_0_f_res_125922);
                        bool i_lte_j_125953 = sle64(defunc_0_f_res_125922, defunc_0_f_res_125929);
                        bool y_125954 = i_p_m_t_s_leq_w_125951 && zzero_lte_i_125952;
                        bool y_125955 = zzero_leq_i_p_m_t_s_125950 && y_125954;
                        bool forwards_ok_125956 = i_lte_j_125953 && y_125955;
                        bool ok_or_empty_125957 = empty_slice_125947 || forwards_ok_125956;
                        bool index_certs_125958;
                        
                        if (!ok_or_empty_125957) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_125922, ":", (long long) defunc_0_f_res_125929, "] out of bounds for array of shape [", (long long) next_stride_125669, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  /prelude/soacs.fut:59:9-11\n   #2  /prelude/array.fut:241:11-17\n   #3  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #4  /prelude/soacs.fut:59:9-11\n   #5  /prelude/array.fut:241:11-17\n   #6  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #7  /prelude/functional.fut:9:44-45\n   #8  ftSMJ.fut:105:58-61\n   #9  ftRelational.fut:101:36-40\n   #10 ftRelational.fut:98:9-101:40\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        bool cond_125959 = slt64((int64_t) 0, j_m_i_125946);
                        int16_t dummy_125960;
                        int64_t dummy_125961;
                        
                        if (cond_125959) {
                            bool index_certs_128045;
                            
                            if (!cond_125959) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:101:36-40\n   #12 ftRelational.fut:98:9-101:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_128046 = start_125741 + defunc_0_f_res_125922;
                            int16_t head_res_128047 = ((int16_t *) mem_param_133548.mem)[slice_128046];
                            int64_t head_res_128048 = ((int64_t *) mem_param_133551.mem)[slice_128046];
                            
                            dummy_125960 = head_res_128047;
                            dummy_125961 = head_res_128048;
                        } else {
                            bool y_125966 = slt64((int64_t) 0, j_m_i_125933);
                            bool index_certs_125967;
                            
                            if (!y_125966) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  /prelude/array.fut:22:29-33\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #3  /prelude/soacs.fut:59:9-11\n   #4  /prelude/array.fut:241:11-17\n   #5  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #6  /prelude/soacs.fut:59:9-11\n   #7  /prelude/array.fut:241:11-17\n   #8  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #9  /prelude/functional.fut:9:44-45\n   #10 ftSMJ.fut:105:58-61\n   #11 ftRelational.fut:101:36-40\n   #12 ftRelational.fut:98:9-101:40\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int64_t slice_125968 = start_125741 + merge_sequential_arg2_125931;
                            int16_t head_res_125969 = ((int16_t *) mem_param_133548.mem)[slice_125968];
                            int64_t head_res_125970 = ((int64_t *) mem_param_133551.mem)[slice_125968];
                            
                            dummy_125960 = head_res_125969;
                            dummy_125961 = head_res_125970;
                        }
                        for (int64_t nest_i_133919 = 0; nest_i_133919 < merge_block_sizze_125554; nest_i_133919++) {
                            ((int16_t *) mem_133584)[i_133326 * merge_block_sizze_125554 + nest_i_133919] = dummy_125960;
                        }
                        for (int64_t nest_i_133920 = 0; nest_i_133920 < merge_block_sizze_125554; nest_i_133920++) {
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + nest_i_133920] = dummy_125961;
                        }
                        
                        int64_t data_125973;
                        int64_t i_125977 = (int64_t) 0;
                        
                        for (int64_t k_125976 = 0; k_125976 < merge_block_sizze_125554; k_125976++) {
                            int64_t j_125980 = sub64(k_125976, i_125977);
                            bool cond_125981 = j_125980 == j_m_i_125933;
                            bool cond_125982;
                            
                            if (cond_125981) {
                                cond_125982 = 1;
                            } else {
                                bool cond_125983 = slt64(i_125977, j_m_i_125946);
                                bool cond_f_res_125984;
                                
                                if (cond_125983) {
                                    bool x_128049 = sle64((int64_t) 0, j_125980);
                                    bool y_128050 = slt64(j_125980, j_m_i_125933);
                                    bool bounds_check_128051 = x_128049 && y_128050;
                                    bool index_certs_128052;
                                    
                                    if (!bounds_check_128051) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:101:36-40\n   #11 ftRelational.fut:98:9-101:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    bool x_128056 = sle64((int64_t) 0, i_125977);
                                    bool bounds_check_128057 = cond_125983 && x_128056;
                                    bool index_certs_128058;
                                    
                                    if (!bounds_check_128057) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:101:36-40\n   #11 ftRelational.fut:98:9-101:40\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    
                                    int64_t slice_128053 = merge_sequential_arg2_125931 + j_125980;
                                    int64_t slice_128054 = start_125741 + slice_128053;
                                    int16_t leq_arg1_128055 = ((int16_t *) mem_param_133548.mem)[slice_128054];
                                    int64_t slice_128059 = defunc_0_f_res_125922 + i_125977;
                                    int64_t slice_128060 = start_125741 + slice_128059;
                                    int16_t leq_arg0_128061 = ((int16_t *) mem_param_133548.mem)[slice_128060];
                                    bool defunc_0_leq_res_128062 = sle16(leq_arg0_128061, leq_arg1_128055);
                                    
                                    cond_f_res_125984 = defunc_0_leq_res_128062;
                                } else {
                                    cond_f_res_125984 = 0;
                                }
                                cond_125982 = cond_f_res_125984;
                            }
                            
                            int64_t loopres_125999;
                            int16_t loopres_126000;
                            int64_t loopres_126001;
                            
                            if (cond_125982) {
                                bool x_128064 = sle64((int64_t) 0, i_125977);
                                bool y_128065 = slt64(i_125977, j_m_i_125946);
                                bool bounds_check_128066 = x_128064 && y_128065;
                                bool index_certs_128067;
                                
                                if (!bounds_check_128066) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_125977, "] out of bounds for array of shape [", (long long) j_m_i_125946, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:101:36-40\n   #11 ftRelational.fut:98:9-101:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t tmp_128063 = add64((int64_t) 1, i_125977);
                                int64_t slice_128068 = defunc_0_f_res_125922 + i_125977;
                                int64_t slice_128069 = start_125741 + slice_128068;
                                int16_t tmp_128070 = ((int16_t *) mem_param_133548.mem)[slice_128069];
                                int64_t tmp_128071 = ((int64_t *) mem_param_133551.mem)[slice_128069];
                                
                                loopres_125999 = tmp_128063;
                                loopres_126000 = tmp_128070;
                                loopres_126001 = tmp_128071;
                            } else {
                                bool x_126011 = sle64((int64_t) 0, j_125980);
                                bool y_126012 = slt64(j_125980, j_m_i_125933);
                                bool bounds_check_126013 = x_126011 && y_126012;
                                bool index_certs_126014;
                                
                                if (!bounds_check_126013) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_125980, "] out of bounds for array of shape [", (long long) j_m_i_125933, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:153:59-69\n   #2  /prelude/soacs.fut:59:9-11\n   #3  /prelude/array.fut:241:11-17\n   #4  lib/github.com/diku-dk/sorts/merge_sort.fut:260:43-59\n   #5  /prelude/soacs.fut:59:9-11\n   #6  /prelude/array.fut:241:11-17\n   #7  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #8  /prelude/functional.fut:9:44-45\n   #9  ftSMJ.fut:105:58-61\n   #10 ftRelational.fut:101:36-40\n   #11 ftRelational.fut:98:9-101:40\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                
                                int64_t slice_126015 = merge_sequential_arg2_125931 + j_125980;
                                int64_t slice_126016 = start_125741 + slice_126015;
                                int16_t tmp_126017 = ((int16_t *) mem_param_133548.mem)[slice_126016];
                                int64_t tmp_126018 = ((int64_t *) mem_param_133551.mem)[slice_126016];
                                
                                loopres_125999 = i_125977;
                                loopres_126000 = tmp_126017;
                                loopres_126001 = tmp_126018;
                            }
                            ((int16_t *) mem_133584)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126000;
                            ((int64_t *) mem_133587)[i_133326 * merge_block_sizze_125554 + k_125976] = loopres_126001;
                            
                            int64_t i_tmp_133921 = loopres_125999;
                            
                            i_125977 = i_tmp_133921;
                        }
                        data_125973 = i_125977;
                    }
                    if (memblock_alloc(ctx, &mem_133622, bytes_133583, "mem_133622")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_2b(ctx, 2, (uint16_t *) mem_133622.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint16_t *) mem_133584, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_alloc(ctx, &mem_133626, bytes_133586, "mem_133626")) {
                        err = 1;
                        goto cleanup;
                    }
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_133626.mem, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (uint64_t *) mem_133587, (int64_t) 0, (int64_t []) {merge_block_sizze_125554, (int64_t) 1}, (int64_t []) {num_blocks_125689, merge_block_sizze_125554});
                    if (memblock_set(ctx, &ext_mem_133649, &mem_133622, "mem_133622") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_133646, &mem_133626, "mem_133626") != 0)
                        return 1;
                }
                lmad_copy_2b(ctx, 1, (uint16_t *) mem_133554, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint16_t *) ext_mem_133649.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133557, i_133333 * next_stride_125669, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133646.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_125669});
                if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
                    return 1;
            }
            
            int64_t flat_dim_126025 = next_stride_125669 * num_merges_125673;
            
            if (memblock_alloc(ctx, &mem_133660, bytes_133553, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_2b(ctx, 2, (uint16_t *) mem_133660.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint16_t *) mem_133554, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            if (memblock_alloc(ctx, &mem_133664, bytes_133556, "mem_133664")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_133664.mem, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (uint64_t *) mem_133557, (int64_t) 0, (int64_t []) {next_stride_125669, (int64_t) 1}, (int64_t []) {num_merges_125673, next_stride_125669});
            
            bool loop_cond_126028 = slt64(next_stride_125669, flat_dim_125550);
            
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133664, "mem_133664") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_133897 = flat_dim_126025;
            bool loop_while_tmp_133898 = loop_cond_126028;
            int64_t stride_tmp_133901 = next_stride_125669;
            
            if (memblock_set(ctx, &mem_param_133548, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133551, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            loop_dz2084Uz2082U_125664 = loop_dz2084Uz2082U_tmp_133897;
            loop_while_125665 = loop_while_tmp_133898;
            stride_125668 = stride_tmp_133901;
        }
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133670, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        data_125659 = loop_dz2084Uz2082U_125664;
        data_125660 = loop_while_125665;
        data_125663 = stride_125668;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        
        bool empty_slice_126029 = n_74061 == (int64_t) 0;
        bool zzero_leq_i_p_m_t_s_126030 = sle64((int64_t) 0, zs_lhs_125534);
        bool i_p_m_t_s_leq_w_126031 = slt64(zs_lhs_125534, data_125659);
        bool y_126032 = zzero_leq_i_p_m_t_s_126030 && i_p_m_t_s_leq_w_126031;
        bool ok_or_empty_126033 = empty_slice_126029 || y_126032;
        bool index_certs_126034;
        
        if (!ok_or_empty_126033) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) n_74061, "] out of bounds for array of shape [", (long long) data_125659, "].", "-> #0  /prelude/array.fut:46:45-51\n   #1  lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:272:74-75\n   #3  /prelude/functional.fut:9:44-45\n   #4  ftSMJ.fut:105:58-61\n   #5  ftRelational.fut:101:36-40\n   #6  ftRelational.fut:98:9-101:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_133674, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133676, bytes_133675, "mem_133676")) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133678, bytes_133677, "mem_133678")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133340 = 0; i_133340 < n_74061; i_133340++) {
        int64_t eta_p_126042 = ((int64_t *) ext_mem_133674.mem)[i_133340];
        bool x_126043 = sle64((int64_t) 0, eta_p_126042);
        bool y_126044 = slt64(eta_p_126042, n_74061);
        bool bounds_check_126045 = x_126043 && y_126044;
        bool index_certs_126046;
        
        if (!bounds_check_126045) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_126042, "] out of bounds for array of shape [", (long long) n_74061, "].", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:277:24-28\n   #1  /prelude/functional.fut:9:44-45\n   #2  lib/github.com/diku-dk/sorts/merge_sort.fut:277:8-29\n   #3  ftSMJ.fut:105:58-61\n   #4  ftRelational.fut:101:36-40\n   #5  ftRelational.fut:98:9-101:40\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int16_t lifted_lambda_res_126047 = ((int16_t *) k_mem_133466.mem)[eta_p_126042];
        
        ((int16_t *) mem_133676.mem)[i_133340] = lifted_lambda_res_126047;
        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133678.mem, i_133340 * b_74062, (int64_t []) {(int64_t) 1}, (uint8_t *) pL_mem_133467.mem, eta_p_126042 * b_74062, (int64_t []) {(int64_t) 1}, (int64_t []) {b_74062});
    }
    if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133676, "mem_133676") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133678, "mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134222, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134223, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133472);
        free(mem_133475);
        free(mem_133485);
        free(mem_133487);
        free(mem_133554);
        free(mem_133557);
        free(mem_133567);
        free(mem_133569);
        free(mem_133584);
        free(mem_133587);
        if (memblock_unref(ctx, &mem_133678, "mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133676, "mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133664, "mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133626, "mem_133626") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133622, "mem_133622") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133631, "mem_133631") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133629, "mem_133629") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133646, "ext_mem_133646") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133649, "ext_mem_133649") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133551, "mem_param_133551") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133548, "mem_param_133548") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133670, "ext_mem_133670") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133544, "mem_133544") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133540, "mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_min_idx(struct futhark_context *ctx, int64_t *out_prim_out_134234, struct memblock eta_p_mem_133466, int64_t nz2080U_61860)
{
    (void) ctx;
    
    int err = 0;
    int64_t prim_out_133877;
    int64_t defunc_0_reduce_res_127931;
    int64_t redout_133298 = (int64_t) 9223372036854775807;
    
    for (int64_t i_133299 = 0; i_133299 < nz2080U_61860; i_133299++) {
        int64_t x_118493 = ((int64_t *) eta_p_mem_133466.mem)[i_133299];
        int64_t min_res_118496 = smin64(x_118493, redout_133298);
        int64_t redout_tmp_133878 = min_res_118496;
        
        redout_133298 = redout_tmp_133878;
    }
    defunc_0_reduce_res_127931 = redout_133298;
    prim_out_133877 = defunc_0_reduce_res_127931;
    *out_prim_out_134234 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_double(struct futhark_context *ctx, struct memblock *mem_out_p_134235, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_63570, int64_t incr_63571, int64_t block_sizze_63572)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_63570;
    bool zzero_118772 = block_sizze_63572 == (int64_t) 0;
    bool nonzzero_118773 = !zzero_118772;
    bool nonzzero_cert_118774;
    
    if (!nonzzero_118773) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:37:1-39:48\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < n_63570; i_133300++) {
        int64_t eta_p_118768 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118769 = sub64(eta_p_118768, incr_63571);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118769;
    }
    
    int64_t zm_lhs_118770 = add64(n_63570, block_sizze_63572);
    int64_t zs_lhs_118771 = sub64(zm_lhs_118770, (int64_t) 1);
    int64_t m_118775 = sdiv64(zs_lhs_118771, block_sizze_63572);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133468, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_63570; nest_i_133879++) {
        ((double *) mem_133477.mem)[nest_i_133879] = 0.0;
    }
    
    bool loop_cond_118777 = slt64((int64_t) 0, m_118775);
    bool partitioned_gather_res_118778;
    int64_t partitioned_gather_res_118781;
    bool loop_while_118782;
    int64_t p_118785;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118782 = loop_cond_118777;
    p_118785 = (int64_t) 0;
    while (loop_while_118782) {
        int64_t lower_bound_118786 = mul64(block_sizze_63572, p_118785);
        int64_t min_arg1_118787 = add64(block_sizze_63572, lower_bound_118786);
        int64_t min_res_118788 = smin64(n_63570, min_arg1_118787);
        int64_t j_m_i_118789 = sub64(min_res_118788, lower_bound_118786);
        bool empty_slice_118790 = j_m_i_118789 == (int64_t) 0;
        int64_t m_118791 = sub64(j_m_i_118789, (int64_t) 1);
        int64_t i_p_m_t_s_118792 = add64(lower_bound_118786, m_118791);
        bool zzero_leq_i_p_m_t_s_118793 = sle64((int64_t) 0, i_p_m_t_s_118792);
        bool i_p_m_t_s_leq_w_118794 = slt64(i_p_m_t_s_118792, n_63570);
        bool zzero_lte_i_118795 = sle64((int64_t) 0, lower_bound_118786);
        bool i_lte_j_118796 = sle64(lower_bound_118786, min_res_118788);
        bool y_118797 = i_p_m_t_s_leq_w_118794 && zzero_lte_i_118795;
        bool y_118798 = zzero_leq_i_p_m_t_s_118793 && y_118797;
        bool forwards_ok_118799 = i_lte_j_118796 && y_118798;
        bool ok_or_empty_118800 = empty_slice_118790 || forwards_ok_118799;
        bool index_certs_118801;
        
        if (!ok_or_empty_118800) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118786, ":", (long long) min_res_118788, "] out of bounds for array of shape [", (long long) n_63570, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:37:1-39:48\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_63570});
        if (memblock_alloc(ctx, &mem_133487, bytes_133468, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < n_63570; i_133304++) {
            int64_t eta_p_118804 = ((int64_t *) mem_param_133480.mem)[i_133304];
            double eta_p_118805 = ((double *) mem_param_133483.mem)[i_133304];
            bool cond_118806 = sle64(lower_bound_118786, eta_p_118804);
            bool cond_t_res_118807 = slt64(eta_p_118804, min_res_118788);
            bool x_118808 = cond_118806 && cond_t_res_118807;
            double lifted_lambda_res_118809;
            
            if (x_118808) {
                int64_t tmp_127931 = sub64(eta_p_118804, lower_bound_118786);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118789);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118789, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftSMJ.fut:158:3-49\n   #4  ftRelational.fut:37:1-39:48\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                double tmp_127936 = ((double *) ys_mem_133467.mem)[eta_p_118804];
                
                lifted_lambda_res_118809 = tmp_127936;
            } else {
                lifted_lambda_res_118809 = eta_p_118805;
            }
            ((double *) mem_133487.mem)[i_133304] = lifted_lambda_res_118809;
        }
        
        int64_t tmp_118816 = add64((int64_t) 1, p_118785);
        bool loop_cond_118817 = slt64(tmp_118816, m_118775);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118817;
        int64_t p_tmp_133885 = tmp_118816;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118782 = loop_while_tmp_133882;
        p_118785 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118778 = loop_while_118782;
    partitioned_gather_res_118781 = p_118785;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133468, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_63570});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134235, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_float(struct futhark_context *ctx, struct memblock *mem_out_p_134236, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_63236, int64_t incr_63237, int64_t block_sizze_63238)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_63236;
    bool zzero_118772 = block_sizze_63238 == (int64_t) 0;
    bool nonzzero_118773 = !zzero_118772;
    bool nonzzero_cert_118774;
    
    if (!nonzzero_118773) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:34:1-36:48\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133476 = (int64_t) 4 * n_63236;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < n_63236; i_133300++) {
        int64_t eta_p_118768 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118769 = sub64(eta_p_118768, incr_63237);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118769;
    }
    
    int64_t zm_lhs_118770 = add64(n_63236, block_sizze_63238);
    int64_t zs_lhs_118771 = sub64(zm_lhs_118770, (int64_t) 1);
    int64_t m_118775 = sdiv64(zs_lhs_118771, block_sizze_63238);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133476, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_63236; nest_i_133879++) {
        ((float *) mem_133477.mem)[nest_i_133879] = 0.0F;
    }
    
    bool loop_cond_118777 = slt64((int64_t) 0, m_118775);
    bool partitioned_gather_res_118778;
    int64_t partitioned_gather_res_118781;
    bool loop_while_118782;
    int64_t p_118785;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118782 = loop_cond_118777;
    p_118785 = (int64_t) 0;
    while (loop_while_118782) {
        int64_t lower_bound_118786 = mul64(block_sizze_63238, p_118785);
        int64_t min_arg1_118787 = add64(block_sizze_63238, lower_bound_118786);
        int64_t min_res_118788 = smin64(n_63236, min_arg1_118787);
        int64_t j_m_i_118789 = sub64(min_res_118788, lower_bound_118786);
        bool empty_slice_118790 = j_m_i_118789 == (int64_t) 0;
        int64_t m_118791 = sub64(j_m_i_118789, (int64_t) 1);
        int64_t i_p_m_t_s_118792 = add64(lower_bound_118786, m_118791);
        bool zzero_leq_i_p_m_t_s_118793 = sle64((int64_t) 0, i_p_m_t_s_118792);
        bool i_p_m_t_s_leq_w_118794 = slt64(i_p_m_t_s_118792, n_63236);
        bool zzero_lte_i_118795 = sle64((int64_t) 0, lower_bound_118786);
        bool i_lte_j_118796 = sle64(lower_bound_118786, min_res_118788);
        bool y_118797 = i_p_m_t_s_leq_w_118794 && zzero_lte_i_118795;
        bool y_118798 = zzero_leq_i_p_m_t_s_118793 && y_118797;
        bool forwards_ok_118799 = i_lte_j_118796 && y_118798;
        bool ok_or_empty_118800 = empty_slice_118790 || forwards_ok_118799;
        bool index_certs_118801;
        
        if (!ok_or_empty_118800) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118786, ":", (long long) min_res_118788, "] out of bounds for array of shape [", (long long) n_63236, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:34:1-36:48\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_63236});
        if (memblock_alloc(ctx, &mem_133487, bytes_133476, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < n_63236; i_133304++) {
            int64_t eta_p_118804 = ((int64_t *) mem_param_133480.mem)[i_133304];
            float eta_p_118805 = ((float *) mem_param_133483.mem)[i_133304];
            bool cond_118806 = sle64(lower_bound_118786, eta_p_118804);
            bool cond_t_res_118807 = slt64(eta_p_118804, min_res_118788);
            bool x_118808 = cond_118806 && cond_t_res_118807;
            float lifted_lambda_res_118809;
            
            if (x_118808) {
                int64_t tmp_127931 = sub64(eta_p_118804, lower_bound_118786);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118789);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118789, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftSMJ.fut:158:3-49\n   #4  ftRelational.fut:34:1-36:48\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                float tmp_127936 = ((float *) ys_mem_133467.mem)[eta_p_118804];
                
                lifted_lambda_res_118809 = tmp_127936;
            } else {
                lifted_lambda_res_118809 = eta_p_118805;
            }
            ((float *) mem_133487.mem)[i_133304] = lifted_lambda_res_118809;
        }
        
        int64_t tmp_118816 = add64((int64_t) 1, p_118785);
        bool loop_cond_118817 = slt64(tmp_118816, m_118775);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118817;
        int64_t p_tmp_133885 = tmp_118816;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118782 = loop_while_tmp_133882;
        p_118785 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118778 = loop_while_118782;
    partitioned_gather_res_118781 = p_118785;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133476, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_63236});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134236, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_int(struct futhark_context *ctx, struct memblock *mem_out_p_134237, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_62568, int64_t incr_62569, int64_t block_sizze_62570)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_62568;
    bool zzero_118772 = block_sizze_62570 == (int64_t) 0;
    bool nonzzero_118773 = !zzero_118772;
    bool nonzzero_cert_118774;
    
    if (!nonzzero_118773) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:28:1-30:48\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133476 = (int64_t) 4 * n_62568;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < n_62568; i_133300++) {
        int64_t eta_p_118768 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118769 = sub64(eta_p_118768, incr_62569);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118769;
    }
    
    int64_t zm_lhs_118770 = add64(n_62568, block_sizze_62570);
    int64_t zs_lhs_118771 = sub64(zm_lhs_118770, (int64_t) 1);
    int64_t m_118775 = sdiv64(zs_lhs_118771, block_sizze_62570);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133476, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_62568; nest_i_133879++) {
        ((int32_t *) mem_133477.mem)[nest_i_133879] = 0;
    }
    
    bool loop_cond_118777 = slt64((int64_t) 0, m_118775);
    bool partitioned_gather_res_118778;
    int64_t partitioned_gather_res_118781;
    bool loop_while_118782;
    int64_t p_118785;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118782 = loop_cond_118777;
    p_118785 = (int64_t) 0;
    while (loop_while_118782) {
        int64_t lower_bound_118786 = mul64(block_sizze_62570, p_118785);
        int64_t min_arg1_118787 = add64(block_sizze_62570, lower_bound_118786);
        int64_t min_res_118788 = smin64(n_62568, min_arg1_118787);
        int64_t j_m_i_118789 = sub64(min_res_118788, lower_bound_118786);
        bool empty_slice_118790 = j_m_i_118789 == (int64_t) 0;
        int64_t m_118791 = sub64(j_m_i_118789, (int64_t) 1);
        int64_t i_p_m_t_s_118792 = add64(lower_bound_118786, m_118791);
        bool zzero_leq_i_p_m_t_s_118793 = sle64((int64_t) 0, i_p_m_t_s_118792);
        bool i_p_m_t_s_leq_w_118794 = slt64(i_p_m_t_s_118792, n_62568);
        bool zzero_lte_i_118795 = sle64((int64_t) 0, lower_bound_118786);
        bool i_lte_j_118796 = sle64(lower_bound_118786, min_res_118788);
        bool y_118797 = i_p_m_t_s_leq_w_118794 && zzero_lte_i_118795;
        bool y_118798 = zzero_leq_i_p_m_t_s_118793 && y_118797;
        bool forwards_ok_118799 = i_lte_j_118796 && y_118798;
        bool ok_or_empty_118800 = empty_slice_118790 || forwards_ok_118799;
        bool index_certs_118801;
        
        if (!ok_or_empty_118800) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118786, ":", (long long) min_res_118788, "] out of bounds for array of shape [", (long long) n_62568, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:28:1-30:48\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_62568});
        if (memblock_alloc(ctx, &mem_133487, bytes_133476, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < n_62568; i_133304++) {
            int64_t eta_p_118804 = ((int64_t *) mem_param_133480.mem)[i_133304];
            int32_t eta_p_118805 = ((int32_t *) mem_param_133483.mem)[i_133304];
            bool cond_118806 = sle64(lower_bound_118786, eta_p_118804);
            bool cond_t_res_118807 = slt64(eta_p_118804, min_res_118788);
            bool x_118808 = cond_118806 && cond_t_res_118807;
            int32_t lifted_lambda_res_118809;
            
            if (x_118808) {
                int64_t tmp_127931 = sub64(eta_p_118804, lower_bound_118786);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118789);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118789, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftSMJ.fut:158:3-49\n   #4  ftRelational.fut:28:1-30:48\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t tmp_127936 = ((int32_t *) ys_mem_133467.mem)[eta_p_118804];
                
                lifted_lambda_res_118809 = tmp_127936;
            } else {
                lifted_lambda_res_118809 = eta_p_118805;
            }
            ((int32_t *) mem_133487.mem)[i_133304] = lifted_lambda_res_118809;
        }
        
        int64_t tmp_118816 = add64((int64_t) 1, p_118785);
        bool loop_cond_118817 = slt64(tmp_118816, m_118775);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118817;
        int64_t p_tmp_133885 = tmp_118816;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118782 = loop_while_tmp_133882;
        p_118785 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118778 = loop_while_118782;
    partitioned_gather_res_118781 = p_118785;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133476, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_62568});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134237, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_long(struct futhark_context *ctx, struct memblock *mem_out_p_134238, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_62902, int64_t incr_62903, int64_t block_sizze_62904)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_62902;
    bool zzero_118772 = block_sizze_62904 == (int64_t) 0;
    bool nonzzero_118773 = !zzero_118772;
    bool nonzzero_cert_118774;
    
    if (!nonzzero_118773) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:31:1-33:48\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < n_62902; i_133300++) {
        int64_t eta_p_118768 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118769 = sub64(eta_p_118768, incr_62903);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118769;
    }
    
    int64_t zm_lhs_118770 = add64(n_62902, block_sizze_62904);
    int64_t zs_lhs_118771 = sub64(zm_lhs_118770, (int64_t) 1);
    int64_t m_118775 = sdiv64(zs_lhs_118771, block_sizze_62904);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133468, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_62902; nest_i_133879++) {
        ((int64_t *) mem_133477.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    bool loop_cond_118777 = slt64((int64_t) 0, m_118775);
    bool partitioned_gather_res_118778;
    int64_t partitioned_gather_res_118781;
    bool loop_while_118782;
    int64_t p_118785;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118782 = loop_cond_118777;
    p_118785 = (int64_t) 0;
    while (loop_while_118782) {
        int64_t lower_bound_118786 = mul64(block_sizze_62904, p_118785);
        int64_t min_arg1_118787 = add64(block_sizze_62904, lower_bound_118786);
        int64_t min_res_118788 = smin64(n_62902, min_arg1_118787);
        int64_t j_m_i_118789 = sub64(min_res_118788, lower_bound_118786);
        bool empty_slice_118790 = j_m_i_118789 == (int64_t) 0;
        int64_t m_118791 = sub64(j_m_i_118789, (int64_t) 1);
        int64_t i_p_m_t_s_118792 = add64(lower_bound_118786, m_118791);
        bool zzero_leq_i_p_m_t_s_118793 = sle64((int64_t) 0, i_p_m_t_s_118792);
        bool i_p_m_t_s_leq_w_118794 = slt64(i_p_m_t_s_118792, n_62902);
        bool zzero_lte_i_118795 = sle64((int64_t) 0, lower_bound_118786);
        bool i_lte_j_118796 = sle64(lower_bound_118786, min_res_118788);
        bool y_118797 = i_p_m_t_s_leq_w_118794 && zzero_lte_i_118795;
        bool y_118798 = zzero_leq_i_p_m_t_s_118793 && y_118797;
        bool forwards_ok_118799 = i_lte_j_118796 && y_118798;
        bool ok_or_empty_118800 = empty_slice_118790 || forwards_ok_118799;
        bool index_certs_118801;
        
        if (!ok_or_empty_118800) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118786, ":", (long long) min_res_118788, "] out of bounds for array of shape [", (long long) n_62902, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:31:1-33:48\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_62902});
        if (memblock_alloc(ctx, &mem_133487, bytes_133468, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < n_62902; i_133304++) {
            int64_t eta_p_118804 = ((int64_t *) mem_param_133480.mem)[i_133304];
            int64_t eta_p_118805 = ((int64_t *) mem_param_133483.mem)[i_133304];
            bool cond_118806 = sle64(lower_bound_118786, eta_p_118804);
            bool cond_t_res_118807 = slt64(eta_p_118804, min_res_118788);
            bool x_118808 = cond_118806 && cond_t_res_118807;
            int64_t lifted_lambda_res_118809;
            
            if (x_118808) {
                int64_t tmp_127931 = sub64(eta_p_118804, lower_bound_118786);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118789);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118789, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftSMJ.fut:158:3-49\n   #4  ftRelational.fut:31:1-33:48\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t tmp_127936 = ((int64_t *) ys_mem_133467.mem)[eta_p_118804];
                
                lifted_lambda_res_118809 = tmp_127936;
            } else {
                lifted_lambda_res_118809 = eta_p_118805;
            }
            ((int64_t *) mem_133487.mem)[i_133304] = lifted_lambda_res_118809;
        }
        
        int64_t tmp_118816 = add64((int64_t) 1, p_118785);
        bool loop_cond_118817 = slt64(tmp_118816, m_118775);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118817;
        int64_t p_tmp_133885 = tmp_118816;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118782 = loop_while_tmp_133882;
        p_118785 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118778 = loop_while_118782;
    partitioned_gather_res_118781 = p_118785;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133468, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_62902});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134238, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_orderByIndices_short(struct futhark_context *ctx, struct memblock *mem_out_p_134239, struct memblock is_mem_133466, struct memblock ys_mem_133467, int64_t n_62234, int64_t incr_62235, int64_t block_sizze_62236)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_133485;
    
    mem_133485.references = NULL;
    
    struct memblock mem_param_133483;
    
    mem_param_133483.references = NULL;
    
    struct memblock mem_param_133480;
    
    mem_param_133480.references = NULL;
    
    struct memblock ext_mem_133498;
    
    ext_mem_133498.references = NULL;
    
    struct memblock ext_mem_133499;
    
    ext_mem_133499.references = NULL;
    
    struct memblock mem_133477;
    
    mem_133477.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t bytes_133468 = (int64_t) 8 * n_62234;
    bool zzero_118772 = block_sizze_62236 == (int64_t) 0;
    bool nonzzero_118773 = !zzero_118772;
    bool nonzzero_cert_118774;
    
    if (!nonzzero_118773) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:24:22-28\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:25:1-27:48\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133476 = (int64_t) 2 * n_62234;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133300 = 0; i_133300 < n_62234; i_133300++) {
        int64_t eta_p_118768 = ((int64_t *) is_mem_133466.mem)[i_133300];
        int64_t lifted_lambda_res_118769 = sub64(eta_p_118768, incr_62235);
        
        ((int64_t *) mem_133469.mem)[i_133300] = lifted_lambda_res_118769;
    }
    
    int64_t zm_lhs_118770 = add64(n_62234, block_sizze_62236);
    int64_t zs_lhs_118771 = sub64(zm_lhs_118770, (int64_t) 1);
    int64_t m_118775 = sdiv64(zs_lhs_118771, block_sizze_62236);
    
    if (memblock_alloc(ctx, &mem_133477, bytes_133476, "mem_133477")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_62234; nest_i_133879++) {
        ((int16_t *) mem_133477.mem)[nest_i_133879] = (int16_t) 0;
    }
    
    bool loop_cond_118777 = slt64((int64_t) 0, m_118775);
    bool partitioned_gather_res_118778;
    int64_t partitioned_gather_res_118781;
    bool loop_while_118782;
    int64_t p_118785;
    
    if (memblock_set(ctx, &mem_param_133480, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133483, &mem_133477, "mem_133477") != 0)
        return 1;
    loop_while_118782 = loop_cond_118777;
    p_118785 = (int64_t) 0;
    while (loop_while_118782) {
        int64_t lower_bound_118786 = mul64(block_sizze_62236, p_118785);
        int64_t min_arg1_118787 = add64(block_sizze_62236, lower_bound_118786);
        int64_t min_res_118788 = smin64(n_62234, min_arg1_118787);
        int64_t j_m_i_118789 = sub64(min_res_118788, lower_bound_118786);
        bool empty_slice_118790 = j_m_i_118789 == (int64_t) 0;
        int64_t m_118791 = sub64(j_m_i_118789, (int64_t) 1);
        int64_t i_p_m_t_s_118792 = add64(lower_bound_118786, m_118791);
        bool zzero_leq_i_p_m_t_s_118793 = sle64((int64_t) 0, i_p_m_t_s_118792);
        bool i_p_m_t_s_leq_w_118794 = slt64(i_p_m_t_s_118792, n_62234);
        bool zzero_lte_i_118795 = sle64((int64_t) 0, lower_bound_118786);
        bool i_lte_j_118796 = sle64(lower_bound_118786, min_res_118788);
        bool y_118797 = i_p_m_t_s_leq_w_118794 && zzero_lte_i_118795;
        bool y_118798 = zzero_leq_i_p_m_t_s_118793 && y_118797;
        bool forwards_ok_118799 = i_lte_j_118796 && y_118798;
        bool ok_or_empty_118800 = empty_slice_118790 || forwards_ok_118799;
        bool index_certs_118801;
        
        if (!ok_or_empty_118800) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_118786, ":", (long long) min_res_118788, "] out of bounds for array of shape [", (long long) n_62234, "].", "-> #0  ftbasics.fut:31:18-45\n   #1  ftSMJ.fut:158:3-49\n   #2  ftRelational.fut:25:1-27:48\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_133485, bytes_133468, "mem_133485")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133485.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133480.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_62234});
        if (memblock_alloc(ctx, &mem_133487, bytes_133476, "mem_133487")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_133304 = 0; i_133304 < n_62234; i_133304++) {
            int64_t eta_p_118804 = ((int64_t *) mem_param_133480.mem)[i_133304];
            int16_t eta_p_118805 = ((int16_t *) mem_param_133483.mem)[i_133304];
            bool cond_118806 = sle64(lower_bound_118786, eta_p_118804);
            bool cond_t_res_118807 = slt64(eta_p_118804, min_res_118788);
            bool x_118808 = cond_118806 && cond_t_res_118807;
            int16_t lifted_lambda_res_118809;
            
            if (x_118808) {
                int64_t tmp_127931 = sub64(eta_p_118804, lower_bound_118786);
                bool x_127932 = sle64((int64_t) 0, tmp_127931);
                bool y_127933 = slt64(tmp_127931, j_m_i_118789);
                bool bounds_check_127934 = x_127932 && y_127933;
                bool index_certs_127935;
                
                if (!bounds_check_127934) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_127931, "] out of bounds for array of shape [", (long long) j_m_i_118789, "].", "-> #0  ftbasics.fut:34:16-37\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftbasics.fut:32:30-36:6\n   #3  ftSMJ.fut:158:3-49\n   #4  ftRelational.fut:25:1-27:48\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int16_t tmp_127936 = ((int16_t *) ys_mem_133467.mem)[eta_p_118804];
                
                lifted_lambda_res_118809 = tmp_127936;
            } else {
                lifted_lambda_res_118809 = eta_p_118805;
            }
            ((int16_t *) mem_133487.mem)[i_133304] = lifted_lambda_res_118809;
        }
        
        int64_t tmp_118816 = add64((int64_t) 1, p_118785);
        bool loop_cond_118817 = slt64(tmp_118816, m_118775);
        
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133487, "mem_133487") != 0)
            return 1;
        
        bool loop_while_tmp_133882 = loop_cond_118817;
        int64_t p_tmp_133885 = tmp_118816;
        
        if (memblock_set(ctx, &mem_param_133480, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133483, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        loop_while_118782 = loop_while_tmp_133882;
        p_118785 = p_tmp_133885;
    }
    if (memblock_set(ctx, &ext_mem_133499, &mem_param_133480, "mem_param_133480") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133498, &mem_param_133483, "mem_param_133483") != 0)
        return 1;
    partitioned_gather_res_118778 = loop_while_118782;
    partitioned_gather_res_118781 = p_118785;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133501, bytes_133476, "mem_133501")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_2b(ctx, 1, (uint16_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint16_t *) ext_mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_62234});
    if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133501, "mem_133501") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134239, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133485, "mem_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133483, "mem_param_133483") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133480, "mem_param_133480") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133498, "ext_mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133499, "ext_mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133477, "mem_133477") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_partition_and_deepen_GFTR(struct futhark_context *ctx, struct memblock *mem_out_p_134240, struct memblock *mem_out_p_134241, struct memblock xs_mem_133466, struct memblock pL_mem_133467, int64_t n_111999, int64_t b_112000, int64_t pL_b_112001, int16_t block_sizze_112002, int64_t gather_psizze_112003, int32_t radix_sizze_112004, int64_t sizze_thresh_112007, int32_t max_depth_112008)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133513_cached_sizze_134242 = 0;
    unsigned char *mem_133513 = NULL;
    int64_t mem_133547_cached_sizze_134243 = 0;
    unsigned char *mem_133547 = NULL;
    int64_t mem_133549_cached_sizze_134244 = 0;
    unsigned char *mem_133549 = NULL;
    int64_t mem_133558_cached_sizze_134245 = 0;
    unsigned char *mem_133558 = NULL;
    int64_t mem_133559_cached_sizze_134246 = 0;
    unsigned char *mem_133559 = NULL;
    int64_t mem_133590_cached_sizze_134247 = 0;
    unsigned char *mem_133590 = NULL;
    int64_t mem_133592_cached_sizze_134248 = 0;
    unsigned char *mem_133592 = NULL;
    int64_t mem_133594_cached_sizze_134249 = 0;
    unsigned char *mem_133594 = NULL;
    int64_t mem_133596_cached_sizze_134250 = 0;
    unsigned char *mem_133596 = NULL;
    int64_t mem_133622_cached_sizze_134251 = 0;
    unsigned char *mem_133622 = NULL;
    int64_t mem_133624_cached_sizze_134252 = 0;
    unsigned char *mem_133624 = NULL;
    struct memblock mem_param_tmp_133884;
    
    mem_param_tmp_133884.references = NULL;
    
    struct memblock mem_param_tmp_133883;
    
    mem_param_tmp_133883.references = NULL;
    
    struct memblock mem_param_tmp_133882;
    
    mem_param_tmp_133882.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_param_tmp_133894;
    
    mem_param_tmp_133894.references = NULL;
    
    struct memblock mem_param_tmp_133893;
    
    mem_param_tmp_133893.references = NULL;
    
    struct memblock mem_param_tmp_133892;
    
    mem_param_tmp_133892.references = NULL;
    
    struct memblock mem_133660;
    
    mem_133660.references = NULL;
    
    struct memblock mem_133658;
    
    mem_133658.references = NULL;
    
    struct memblock mem_133640;
    
    mem_133640.references = NULL;
    
    struct memblock mem_133638;
    
    mem_133638.references = NULL;
    
    struct memblock ext_mem_133587;
    
    ext_mem_133587.references = NULL;
    
    struct memblock ext_mem_133588;
    
    ext_mem_133588.references = NULL;
    
    struct memblock mem_133585;
    
    mem_133585.references = NULL;
    
    struct memblock mem_param_tmp_133903;
    
    mem_param_tmp_133903.references = NULL;
    
    struct memblock mem_param_tmp_133902;
    
    mem_param_tmp_133902.references = NULL;
    
    struct memblock mem_133537;
    
    mem_133537.references = NULL;
    
    struct memblock mem_133535;
    
    mem_133535.references = NULL;
    
    struct memblock mem_param_tmp_133910;
    
    mem_param_tmp_133910.references = NULL;
    
    struct memblock mem_133524;
    
    mem_133524.references = NULL;
    
    struct memblock mem_param_133522;
    
    mem_param_133522.references = NULL;
    
    struct memblock ext_mem_133533;
    
    ext_mem_133533.references = NULL;
    
    struct memblock mem_param_133508;
    
    mem_param_133508.references = NULL;
    
    struct memblock mem_param_133504;
    
    mem_param_133504.references = NULL;
    
    struct memblock ext_mem_133582;
    
    ext_mem_133582.references = NULL;
    
    struct memblock ext_mem_133583;
    
    ext_mem_133583.references = NULL;
    
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_param_133498;
    
    mem_param_133498.references = NULL;
    
    struct memblock mem_param_133494;
    
    mem_param_133494.references = NULL;
    
    struct memblock mem_param_133490;
    
    mem_param_133490.references = NULL;
    
    struct memblock mem_param_133487;
    
    mem_param_133487.references = NULL;
    
    struct memblock ext_mem_133671;
    
    ext_mem_133671.references = NULL;
    
    struct memblock ext_mem_133672;
    
    ext_mem_133672.references = NULL;
    
    struct memblock ext_mem_133673;
    
    ext_mem_133673.references = NULL;
    
    struct memblock ext_mem_133674;
    
    ext_mem_133674.references = NULL;
    
    struct memblock mem_param_133484;
    
    mem_param_133484.references = NULL;
    
    struct memblock mem_param_133481;
    
    mem_param_133481.references = NULL;
    
    struct memblock mem_param_133478;
    
    mem_param_133478.references = NULL;
    
    struct memblock mem_param_133474;
    
    mem_param_133474.references = NULL;
    
    struct memblock ext_mem_133685;
    
    ext_mem_133685.references = NULL;
    
    struct memblock ext_mem_133686;
    
    ext_mem_133686.references = NULL;
    
    struct memblock ext_mem_133687;
    
    ext_mem_133687.references = NULL;
    
    struct memblock ext_mem_133688;
    
    ext_mem_133688.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_133468;
    
    mem_133468.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    if (memblock_alloc(ctx, &mem_133468, (int64_t) 8, "mem_133468")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < (int64_t) 1; nest_i_133879++) {
        ((int64_t *) mem_133468.mem)[nest_i_133879] = (int64_t) 0;
    }
    if (memblock_alloc(ctx, &mem_133469, (int64_t) 8, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133880 = 0; nest_i_133880 < (int64_t) 1; nest_i_133880++) {
        ((int64_t *) mem_133469.mem)[nest_i_133880] = n_111999;
    }
    
    bool loop_cond_t_res_120708 = slt32(0, max_depth_112008);
    
    if (memblock_alloc(ctx, &mem_133470, (int64_t) 0, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    
    int32_t i64_res_120759 = sext_i64_i32(b_112000);
    int32_t zm_lhs_120760 = mul32(8, i64_res_120759);
    int32_t min_arg1_120761 = sub32(zm_lhs_120760, 1);
    bool zzero_120780 = gather_psizze_112003 == (int64_t) 0;
    bool nonzzero_120781 = !zzero_120780;
    int64_t bytes_133637 = n_111999 * b_112000;
    int64_t bytes_133639 = n_111999 * pL_b_112001;
    
    if (mem_133558_cached_sizze_134245 < b_112000) {
        err = lexical_realloc(ctx, &mem_133558, &mem_133558_cached_sizze_134245, b_112000);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133559_cached_sizze_134246 < pL_b_112001) {
        err = lexical_realloc(ctx, &mem_133559, &mem_133559_cached_sizze_134246, pL_b_112001);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t partition_and_deepen_res_120710;
    bool partition_and_deepen_res_120711;
    int32_t partition_and_deepen_res_120712;
    int64_t loop_dz2087U_120717;
    bool loop_while_120718;
    int32_t p_120719;
    
    if (memblock_set(ctx, &mem_param_133474, &pL_mem_133467, "pL_mem_133467") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133478, &xs_mem_133466, "xs_mem_133466") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133481, &mem_133468, "mem_133468") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133484, &mem_133469, "mem_133469") != 0)
        return 1;
    loop_dz2087U_120717 = (int64_t) 1;
    loop_while_120718 = loop_cond_t_res_120708;
    p_120719 = 0;
    while (loop_while_120718) {
        bool loop_nonempty_126067 = slt64((int64_t) 0, loop_dz2087U_120717);
        int32_t newDepth_120755 = add32(1, p_120719);
        int32_t new_i_120756 = mul32(radix_sizze_112004, p_120719);
        int32_t zm_lhs_120757 = mul32(radix_sizze_112004, newDepth_120755);
        int32_t new_j_120758 = sub32(zm_lhs_120757, 1);
        int32_t min_res_120762 = smin32(new_j_120758, min_arg1_120761);
        int32_t tmp_120763 = add32(2, new_i_120756);
        int64_t i_120764 = sext_i32_i64(new_i_120756);
        int64_t j__120765 = sext_i32_i64(min_res_120762);
        int64_t tmp_120766 = sext_i32_i64(tmp_120763);
        bool step_zzero_120767 = new_i_120756 == tmp_120763;
        bool bounds_invalid_upwards_120768 = slt32(min_res_120762, new_i_120756);
        int32_t distance_upwards_exclusive_120769 = sub32(min_res_120762, new_i_120756);
        int64_t distance_exclusive_120770 = sext_i32_i64(distance_upwards_exclusive_120769);
        int64_t distance_120771 = add64((int64_t) 1, distance_exclusive_120770);
        bool range_invalid_120772 = step_zzero_120767 || bounds_invalid_upwards_120768;
        bool valid_120773 = !range_invalid_120772;
        bool loop_not_taken_126068 = !loop_nonempty_126067;
        bool protect_assert_disj_126069 = valid_120773 || loop_not_taken_126068;
        bool range_valid_c_120774;
        
        if (!protect_assert_disj_126069) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) i_120764, "..", (long long) tmp_120766, "...", (long long) j__120765, " is invalid.", "-> #0  ftHashJoin.fut:219:15-37\n   #1  ftHashJoin.fut:261:20-267:6\n   #2  ftRelational.fut:215:5-88\n   #3  ftRelational.fut:205:1-216:30\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t num_elems_120775 = sdiv_up64(distance_120771, (int64_t) 2);
        bool loop_nonempty_120776 = slt64((int64_t) 0, num_elems_120775);
        bool loop_not_taken_120782 = !loop_nonempty_120776;
        bool protect_assert_disj_120783 = nonzzero_120781 || loop_not_taken_120782;
        bool protect_assert_disj_126071 = protect_assert_disj_120783 || loop_not_taken_126068;
        bool nonzzero_cert_120784;
        
        if (!protect_assert_disj_126071) {
            set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftHashJoin.fut:206:87-90\n   #2  ftHashJoin.fut:220:6-71\n   #3  ftHashJoin.fut:261:20-267:6\n   #4  ftRelational.fut:215:5-88\n   #5  ftRelational.fut:205:1-216:30\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t loopres_120724;
        int64_t loop_dz2081Uz2089U_120730;
        
        if (memblock_set(ctx, &mem_param_133487, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133490, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133494, &mem_param_133474, "mem_param_133474") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133498, &mem_param_133478, "mem_param_133478") != 0)
            return 1;
        loop_dz2081Uz2089U_120730 = (int64_t) 0;
        for (int64_t i_120729 = 0; i_120729 < loop_dz2087U_120717; i_120729++) {
            int64_t bounds_120735 = ((int64_t *) mem_param_133481.mem)[i_120729];
            int64_t bounds_120736 = ((int64_t *) mem_param_133484.mem)[i_120729];
            int64_t dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737 = sub64(bounds_120736, bounds_120735);
            bool empty_slice_120738 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737 == (int64_t) 0;
            int64_t m_120739 = sub64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737, (int64_t) 1);
            int64_t i_p_m_t_s_120740 = add64(bounds_120735, m_120739);
            bool zzero_leq_i_p_m_t_s_120741 = sle64((int64_t) 0, i_p_m_t_s_120740);
            bool i_p_m_t_s_leq_w_120742 = slt64(i_p_m_t_s_120740, n_111999);
            bool zzero_lte_i_120743 = sle64((int64_t) 0, bounds_120735);
            bool i_lte_j_120744 = sle64(bounds_120735, bounds_120736);
            bool y_120745 = i_p_m_t_s_leq_w_120742 && zzero_lte_i_120743;
            bool y_120746 = zzero_leq_i_p_m_t_s_120741 && y_120745;
            bool forwards_ok_120747 = i_lte_j_120744 && y_120746;
            bool ok_or_empty_120748 = empty_slice_120738 || forwards_ok_120747;
            bool index_certs_120749;
            
            if (!ok_or_empty_120748) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) bounds_120735, ":", (long long) bounds_120736, "] out of bounds for array of shape [", (long long) n_111999, "].", "-> #0  ftHashJoin.fut:294:21-47\n   #1  ftRelational.fut:215:5-88\n   #2  ftRelational.fut:205:1-216:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133499 = (int64_t) 8 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737;
            
            if (memblock_alloc(ctx, &mem_133500, bytes_133499, "mem_133500")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t nest_i_133901 = 0; nest_i_133901 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737; nest_i_133901++) {
                ((int64_t *) mem_133500.mem)[nest_i_133901] = (int64_t) 0;
            }
            
            int64_t zm_lhs_120778 = add64(gather_psizze_112003, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737);
            int64_t zs_lhs_120779 = sub64(zm_lhs_120778, (int64_t) 1);
            int64_t m_120785 = sdiv_safe64(zs_lhs_120779, gather_psizze_112003);
            bool loop_cond_120786 = slt64((int64_t) 0, m_120785);
            int64_t binop_y_133509 = b_112000 * bounds_120735;
            int64_t binop_y_133511 = pL_b_112001 * bounds_120735;
            int64_t bytes_133534 = b_112000 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737;
            int64_t bytes_133536 = pL_b_112001 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737;
            
            if (mem_133513_cached_sizze_134242 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737) {
                err = lexical_realloc(ctx, &mem_133513, &mem_133513_cached_sizze_134242, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t ext_133581;
            int64_t ext_133578;
            int64_t ctx_param_ext_133501;
            int64_t ctx_param_ext_133505;
            
            if (memblock_set(ctx, &mem_param_133504, &mem_param_133498, "mem_param_133498") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133508, &mem_param_133494, "mem_param_133494") != 0)
                return 1;
            ctx_param_ext_133501 = binop_y_133509;
            ctx_param_ext_133505 = binop_y_133511;
            for (int64_t i_120789 = 0; i_120789 < num_elems_120775; i_120789++) {
                int32_t binop_x_120792 = sext_i64_i32(i_120789);
                int32_t binop_x_120793 = mul32(2, binop_x_120792);
                int32_t index_primexp_120794 = add32(new_i_120756, binop_x_120793);
                int32_t zm_lhs_120795 = add32(2, index_primexp_120794);
                int32_t min_arg1_120796 = sub32(zm_lhs_120795, 1);
                int32_t min_res_120797 = smin32(min_res_120762, min_arg1_120796);
                int32_t zp_lhs_120798 = sub32(min_res_120797, index_primexp_120794);
                int32_t ij_bits_120799 = add32(1, zp_lhs_120798);
                int32_t up_to_120800 = shl32(1, ij_bits_120799);
                int64_t tmp_120801 = sext_i32_i64(zp_lhs_120798);
                bool bounds_invalid_upwards_120802 = slt32(zp_lhs_120798, 0);
                bool valid_120804 = !bounds_invalid_upwards_120802;
                bool range_valid_c_120805;
                
                if (!valid_120804) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_120801, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:206:87-90\n   #3  ftHashJoin.fut:220:6-71\n   #4  ftHashJoin.fut:261:20-267:6\n   #5  ftRelational.fut:215:5-88\n   #6  ftRelational.fut:205:1-216:30\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t up_to_120815 = sext_i32_i64(up_to_120800);
                bool bounds_invalid_upwards_120816 = slt32(up_to_120800, 0);
                bool valid_120817 = !bounds_invalid_upwards_120816;
                bool range_valid_c_120818;
                
                if (!valid_120817) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_120815, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftHashJoin.fut:206:87-90\n   #2  ftHashJoin.fut:220:6-71\n   #3  ftHashJoin.fut:261:20-267:6\n   #4  ftRelational.fut:215:5-88\n   #5  ftRelational.fut:205:1-216:30\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t distance_120803 = add64((int64_t) 1, tmp_120801);
                
                for (int64_t i_133300 = 0; i_133300 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737; i_133300++) {
                    int8_t defunc_0_f_res_120808;
                    int8_t y_120810 = (int8_t) 0;
                    
                    for (int64_t i_120809 = 0; i_120809 < distance_120803; i_120809++) {
                        int32_t binop_x_120811 = sext_i64_i32(i_120809);
                        int32_t get_bit_arg0_120812 = add32(index_primexp_120794, binop_x_120811);
                        int32_t zm_rhs_126555 = sdiv32(get_bit_arg0_120812, 8);
                        int32_t zm_lhs_126556 = sub32(i64_res_120759, zm_rhs_126555);
                        int32_t whichByte_126557 = sub32(zm_lhs_126556, 1);
                        int64_t whichByte_126559 = sext_i32_i64(whichByte_126557);
                        bool x_126560 = sle64((int64_t) 0, whichByte_126559);
                        bool y_126561 = slt64(whichByte_126559, b_112000);
                        bool bounds_check_126562 = x_126560 && y_126561;
                        bool index_certs_126563;
                        
                        if (!bounds_check_126562) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) whichByte_126559, "] out of bounds for array of shape [", (long long) b_112000, "].", "-> #0  ftHashJoin.fut:17:6-18\n   #1  ftRelational.fut:215:5-88\n   #2  ftRelational.fut:205:1-216:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t whichBit_126558 = smod32(get_bit_arg0_120812, 8);
                        int8_t zbzg_lhs_126564 = ((int8_t *) mem_param_133504.mem)[ctx_param_ext_133501 + (i_133300 * b_112000 + whichByte_126559)];
                        int8_t unsign_arg0_126565 = zext_i32_i8(whichBit_126558);
                        int8_t unsign_arg0_126566 = ashr8(zbzg_lhs_126564, unsign_arg0_126565);
                        int8_t unsign_arg0_126567 = (int8_t) 1 & unsign_arg0_126566;
                        int32_t to_i32_res_126568 = zext_i8_i32(unsign_arg0_126567);
                        int8_t loopres_120814;
                        
                        if (futrts_set_bit_2464(ctx, &loopres_120814, binop_x_120811, y_120810, to_i32_res_126568) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        int8_t y_tmp_133909 = loopres_120814;
                        
                        y_120810 = y_tmp_133909;
                    }
                    defunc_0_f_res_120808 = y_120810;
                    ((int8_t *) mem_133513)[i_133300] = defunc_0_f_res_120808;
                }
                
                int64_t defunc_0_radix_sort_multistep_res_120819;
                int64_t offs_120822;
                
                if (memblock_set(ctx, &mem_param_133522, &mem_133500, "mem_133500") != 0)
                    return 1;
                offs_120822 = (int64_t) 0;
                for (int64_t i_120821 = 0; i_120821 < up_to_120815; i_120821++) {
                    int32_t binop_x_120824 = sext_i64_i32(i_120821);
                    int8_t index_primexp_120825 = zext_i32_i8(binop_x_120824);
                    
                    if (memblock_alloc(ctx, &mem_133524, bytes_133499, "mem_133524")) {
                        err = 1;
                        goto cleanup;
                    }
                    
                    int64_t inpacc_128344;
                    int64_t defunc_0_reduce_res_128345;
                    int64_t inpacc_128165;
                    int64_t inpacc_128166;
                    
                    inpacc_128165 = (int64_t) 0;
                    inpacc_128166 = (int64_t) 0;
                    for (int64_t i_133318 = 0; i_133318 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737; i_133318++) {
                        int8_t eta_p_133435 = ((int8_t *) mem_133513)[i_133318];
                        bool lifted_lambda_res_133436 = eta_p_133435 == index_primexp_120825;
                        int64_t bool_res_133437 = btoi_bool_i64(lifted_lambda_res_133436);
                        int64_t eta_p_133450 = ((int64_t *) mem_param_133522.mem)[i_133318];
                        int64_t defunc_0_op_res_133451 = add64(inpacc_128165, bool_res_133437);
                        int64_t zm_lhs_133452 = add64(offs_120822, defunc_0_op_res_133451);
                        int64_t lifted_lambda_res_133453 = sub64(zm_lhs_133452, (int64_t) 1);
                        int64_t defunc_0_f_res_133454 = mul64(bool_res_133437, lifted_lambda_res_133453);
                        int64_t defunc_0_f_res_133455 = add64(eta_p_133450, defunc_0_f_res_133454);
                        int64_t defunc_0_op_res_128214 = add64(inpacc_128166, bool_res_133437);
                        
                        ((int64_t *) mem_133524.mem)[i_133318] = defunc_0_f_res_133455;
                        
                        int64_t inpacc_tmp_133913 = defunc_0_op_res_133451;
                        int64_t inpacc_tmp_133914 = defunc_0_op_res_128214;
                        
                        inpacc_128165 = inpacc_tmp_133913;
                        inpacc_128166 = inpacc_tmp_133914;
                    }
                    inpacc_128344 = inpacc_128165;
                    defunc_0_reduce_res_128345 = inpacc_128166;
                    
                    int64_t tmp_120850 = add64(offs_120822, defunc_0_reduce_res_128345);
                    
                    if (memblock_set(ctx, &mem_param_tmp_133910, &mem_133524, "mem_133524") != 0)
                        return 1;
                    
                    int64_t offs_tmp_133911 = tmp_120850;
                    
                    if (memblock_set(ctx, &mem_param_133522, &mem_param_tmp_133910, "mem_param_tmp_133910") != 0)
                        return 1;
                    offs_120822 = offs_tmp_133911;
                }
                if (memblock_set(ctx, &ext_mem_133533, &mem_param_133522, "mem_param_133522") != 0)
                    return 1;
                defunc_0_radix_sort_multistep_res_120819 = offs_120822;
                if (memblock_alloc(ctx, &mem_133535, bytes_133534, "mem_133535")) {
                    err = 1;
                    goto cleanup;
                }
                lmad_copy_1b(ctx, 2, (uint8_t *) mem_133535.mem, (int64_t) 0, (int64_t []) {b_112000, (int64_t) 1}, (uint8_t *) mem_param_133504.mem, ctx_param_ext_133501, (int64_t []) {b_112000, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737, b_112000});
                if (memblock_alloc(ctx, &mem_133537, bytes_133536, "mem_133537")) {
                    err = 1;
                    goto cleanup;
                }
                lmad_copy_1b(ctx, 2, (uint8_t *) mem_133537.mem, (int64_t) 0, (int64_t []) {pL_b_112001, (int64_t) 1}, (uint8_t *) mem_param_133508.mem, ctx_param_ext_133505, (int64_t []) {pL_b_112001, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737, pL_b_112001});
                
                bool partitioned_scatter_res_120857;
                int64_t partitioned_scatter_res_120860;
                bool loop_while_120861;
                int64_t p_120864;
                
                loop_while_120861 = loop_cond_120786;
                p_120864 = (int64_t) 0;
                while (loop_while_120861) {
                    int64_t lower_bound_120865 = mul64(gather_psizze_112003, p_120864);
                    int64_t min_arg1_120866 = add64(gather_psizze_112003, lower_bound_120865);
                    int64_t min_res_120867 = smin64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737, min_arg1_120866);
                    int64_t j_m_i_120868 = sub64(min_res_120867, lower_bound_120865);
                    bool empty_slice_120869 = j_m_i_120868 == (int64_t) 0;
                    int64_t m_120870 = sub64(j_m_i_120868, (int64_t) 1);
                    int64_t i_p_m_t_s_120871 = add64(lower_bound_120865, m_120870);
                    bool zzero_leq_i_p_m_t_s_120872 = sle64((int64_t) 0, i_p_m_t_s_120871);
                    bool i_p_m_t_s_leq_w_120873 = slt64(i_p_m_t_s_120871, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737);
                    bool zzero_lte_i_120874 = sle64((int64_t) 0, lower_bound_120865);
                    bool i_lte_j_120875 = sle64(lower_bound_120865, min_res_120867);
                    bool y_120876 = i_p_m_t_s_leq_w_120873 && zzero_lte_i_120874;
                    bool y_120877 = zzero_leq_i_p_m_t_s_120872 && y_120876;
                    bool forwards_ok_120878 = i_lte_j_120875 && y_120877;
                    bool ok_or_empty_120879 = empty_slice_120869 || forwards_ok_120878;
                    bool index_certs_120880;
                    
                    if (!ok_or_empty_120879) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_120865, ":", (long long) min_res_120867, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftHashJoin.fut:206:87-90\n   #2  ftHashJoin.fut:220:6-71\n   #3  ftHashJoin.fut:261:20-267:6\n   #4  ftRelational.fut:215:5-88\n   #5  ftRelational.fut:205:1-216:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t bytes_133546 = b_112000 * j_m_i_120868;
                    int64_t bytes_133548 = pL_b_112001 * j_m_i_120868;
                    
                    if (mem_133547_cached_sizze_134243 < bytes_133546) {
                        err = lexical_realloc(ctx, &mem_133547, &mem_133547_cached_sizze_134243, bytes_133546);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133547, (int64_t) 0, (int64_t []) {b_112000, (int64_t) 1}, (uint8_t *) mem_133535.mem, (int64_t) 0 + b_112000 * lower_bound_120865, (int64_t []) {b_112000, (int64_t) 1}, (int64_t []) {j_m_i_120868, b_112000});
                    if (mem_133549_cached_sizze_134244 < bytes_133548) {
                        err = lexical_realloc(ctx, &mem_133549, &mem_133549_cached_sizze_134244, bytes_133548);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133549, (int64_t) 0, (int64_t []) {pL_b_112001, (int64_t) 1}, (uint8_t *) mem_133537.mem, (int64_t) 0 + pL_b_112001 * lower_bound_120865, (int64_t []) {pL_b_112001, (int64_t) 1}, (int64_t []) {j_m_i_120868, pL_b_112001});
                    for (int64_t write_iter_133320 = 0; write_iter_133320 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737; write_iter_133320++) {
                        int64_t write_iv_133323 = ((int64_t *) ext_mem_133533.mem)[write_iter_133320];
                        
                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133558, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_133504.mem, ctx_param_ext_133501 + write_iter_133320 * b_112000, (int64_t []) {(int64_t) 1}, (int64_t []) {b_112000});
                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133559, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_133508.mem, ctx_param_ext_133505 + write_iter_133320 * pL_b_112001, (int64_t []) {(int64_t) 1}, (int64_t []) {pL_b_112001});
                        
                        bool cond_128257 = sle64(lower_bound_120865, write_iv_133323);
                        bool cond_t_res_128258 = slt64(write_iv_133323, min_res_120867);
                        bool x_128259 = cond_128257 && cond_t_res_128258;
                        int64_t lifted_lambda_res_128260;
                        
                        if (x_128259) {
                            int64_t lifted_lambda_res_t_res_128347 = sub64(write_iv_133323, lower_bound_120865);
                            
                            lifted_lambda_res_128260 = lifted_lambda_res_t_res_128347;
                        } else {
                            lifted_lambda_res_128260 = (int64_t) -1;
                        }
                        if ((sle64((int64_t) 0, lifted_lambda_res_128260) && slt64(lifted_lambda_res_128260, j_m_i_120868)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(b_112000 - (int64_t) 1, b_112000))) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_133547, lifted_lambda_res_128260 * b_112000, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133558, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_112000});
                        }
                        if ((sle64((int64_t) 0, lifted_lambda_res_128260) && slt64(lifted_lambda_res_128260, j_m_i_120868)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(pL_b_112001 - (int64_t) 1, pL_b_112001))) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_133549, lifted_lambda_res_128260 * pL_b_112001, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133559, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {pL_b_112001});
                        }
                    }
                    
                    int64_t tmp_120892 = add64((int64_t) 1, p_120864);
                    
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133535.mem, b_112000 * lower_bound_120865, (int64_t []) {b_112000, (int64_t) 1}, (uint8_t *) mem_133547, (int64_t) 0, (int64_t []) {b_112000, (int64_t) 1}, (int64_t []) {j_m_i_120868, b_112000});
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133537.mem, pL_b_112001 * lower_bound_120865, (int64_t []) {pL_b_112001, (int64_t) 1}, (uint8_t *) mem_133549, (int64_t) 0, (int64_t []) {pL_b_112001, (int64_t) 1}, (int64_t []) {j_m_i_120868, pL_b_112001});
                    
                    bool loop_cond_120900 = slt64(tmp_120892, m_120785);
                    bool loop_while_tmp_133916 = loop_cond_120900;
                    int64_t p_tmp_133919 = tmp_120892;
                    
                    loop_while_120861 = loop_while_tmp_133916;
                    p_120864 = p_tmp_133919;
                }
                partitioned_scatter_res_120857 = loop_while_120861;
                partitioned_scatter_res_120860 = p_120864;
                if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_tmp_133902, &mem_133535, "mem_133535") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_tmp_133903, &mem_133537, "mem_133537") != 0)
                    return 1;
                
                int64_t ctx_param_ext_tmp_133904 = (int64_t) 0;
                int64_t ctx_param_ext_tmp_133905 = (int64_t) 0;
                
                if (memblock_set(ctx, &mem_param_133504, &mem_param_tmp_133902, "mem_param_tmp_133902") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_133508, &mem_param_tmp_133903, "mem_param_tmp_133903") != 0)
                    return 1;
                ctx_param_ext_133501 = ctx_param_ext_tmp_133904;
                ctx_param_ext_133505 = ctx_param_ext_tmp_133905;
            }
            if (memblock_set(ctx, &ext_mem_133583, &mem_param_133504, "mem_param_133504") != 0)
                return 1;
            if (memblock_set(ctx, &ext_mem_133582, &mem_param_133508, "mem_param_133508") != 0)
                return 1;
            ext_133581 = ctx_param_ext_133501;
            ext_133578 = ctx_param_ext_133505;
            if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_133585, bytes_133534, "mem_133585")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133585.mem, (int64_t) 0, (int64_t []) {b_112000, (int64_t) 1}, (uint8_t *) ext_mem_133583.mem, ext_133581, (int64_t []) {b_112000, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737, b_112000});
            
            int64_t deepen_step_res_120901;
            int64_t deepen_step_res_120902;
            int32_t deepen_step_res_120905;
            
            if (futrts_getPartitionBounds_12125(ctx, &ext_mem_133588, &ext_mem_133587, &deepen_step_res_120901, &deepen_step_res_120902, &deepen_step_res_120905, mem_133585, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737, b_112000, newDepth_120755, new_i_120756, new_j_120758) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref(ctx, &mem_133585, "mem_133585") != 0)
                return 1;
            
            int64_t zl_rhs_126081 = sub64(deepen_step_res_120901, (int64_t) 1);
            int64_t bytes_133589 = (int64_t) 8 * deepen_step_res_120901;
            
            if (mem_133590_cached_sizze_134247 < bytes_133589) {
                err = lexical_realloc(ctx, &mem_133590, &mem_133590_cached_sizze_134247, bytes_133589);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133592_cached_sizze_134248 < bytes_133589) {
                err = lexical_realloc(ctx, &mem_133592, &mem_133592_cached_sizze_134248, bytes_133589);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133594_cached_sizze_134249 < bytes_133589) {
                err = lexical_realloc(ctx, &mem_133594, &mem_133594_cached_sizze_134249, bytes_133589);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133596_cached_sizze_134250 < bytes_133589) {
                err = lexical_realloc(ctx, &mem_133596, &mem_133596_cached_sizze_134250, bytes_133589);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t discard_133342;
            int64_t scanacc_133332 = (int64_t) 0;
            
            for (int64_t i_133337 = 0; i_133337 < deepen_step_res_120901; i_133337++) {
                int64_t tmp_127954 = ((int64_t *) ext_mem_133588.mem)[i_133337];
                bool cond_127955 = slt64(i_133337, zl_rhs_126081);
                int64_t tmp_127956;
                
                if (cond_127955) {
                    int64_t tmp_128351 = add64((int64_t) 1, i_133337);
                    bool x_128352 = sle64((int64_t) 0, tmp_128351);
                    bool y_128353 = slt64(tmp_128351, deepen_step_res_120901);
                    bool bounds_check_128354 = x_128352 && y_128353;
                    bool index_certs_128355;
                    
                    if (!bounds_check_128354) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128351, "] out of bounds for array of shape [", (long long) deepen_step_res_120901, "].", "-> #0  ftHashJoin.fut:271:67-81\n   #1  ftRelational.fut:215:5-88\n   #2  ftRelational.fut:205:1-216:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t tmp_t_res_128356 = ((int64_t *) ext_mem_133588.mem)[tmp_128351];
                    
                    tmp_127956 = tmp_t_res_128356;
                } else {
                    tmp_127956 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737;
                }
                
                int64_t zg_lhs_127965 = sub64(tmp_127956, tmp_127954);
                bool lifted_lambda_res_127966 = slt64(sizze_thresh_112007, zg_lhs_127965);
                int64_t defunc_0_f_res_127967 = btoi_bool_i64(lifted_lambda_res_127966);
                int64_t defunc_0_op_res_120922 = add64(defunc_0_f_res_127967, scanacc_133332);
                
                ((int64_t *) mem_133590)[i_133337] = defunc_0_op_res_120922;
                ((int64_t *) mem_133592)[i_133337] = defunc_0_f_res_127967;
                ((int64_t *) mem_133594)[i_133337] = tmp_127954;
                ((int64_t *) mem_133596)[i_133337] = tmp_127956;
                
                int64_t scanacc_tmp_133922 = defunc_0_op_res_120922;
                
                scanacc_133332 = scanacc_tmp_133922;
            }
            discard_133342 = scanacc_133332;
            if (memblock_unref(ctx, &ext_mem_133588, "ext_mem_133588") != 0)
                return 1;
            
            bool cond_120923 = deepen_step_res_120901 == (int64_t) 0;
            bool x_120924 = !cond_120923;
            bool x_120926 = sle64((int64_t) 0, zl_rhs_126081);
            bool y_120927 = slt64(zl_rhs_126081, deepen_step_res_120901);
            bool bounds_check_120928 = x_120926 && y_120927;
            bool protect_assert_disj_120929 = cond_120923 || bounds_check_120928;
            bool index_certs_120930;
            
            if (!protect_assert_disj_120929) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zl_rhs_126081, "] out of bounds for array of shape [", (long long) deepen_step_res_120901, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:272:8-49\n   #3  ftRelational.fut:215:5-88\n   #4  ftRelational.fut:205:1-216:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_f_res_120931;
            
            if (x_120924) {
                int64_t x_128357 = ((int64_t *) mem_133590)[zl_rhs_126081];
                
                m_f_res_120931 = x_128357;
            } else {
                m_f_res_120931 = (int64_t) 0;
            }
            
            int64_t m_120933;
            
            if (cond_120923) {
                m_120933 = (int64_t) 0;
            } else {
                m_120933 = m_f_res_120931;
            }
            
            int64_t m_120943 = sub64(m_120933, (int64_t) 1);
            bool i_p_m_t_s_leq_w_120945 = slt64(m_120943, deepen_step_res_120901);
            bool zzero_leq_i_p_m_t_s_120944 = sle64((int64_t) 0, m_120943);
            bool y_120947 = zzero_leq_i_p_m_t_s_120944 && i_p_m_t_s_leq_w_120945;
            bool i_lte_j_120946 = sle64((int64_t) 0, m_120933);
            bool forwards_ok_120948 = i_lte_j_120946 && y_120947;
            bool eq_x_zz_120940 = (int64_t) 0 == m_f_res_120931;
            bool p_and_eq_x_y_120941 = x_120924 && eq_x_zz_120940;
            bool empty_slice_120942 = cond_120923 || p_and_eq_x_y_120941;
            bool ok_or_empty_120949 = empty_slice_120942 || forwards_ok_120948;
            bool index_certs_120950;
            
            if (!ok_or_empty_120949) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_120933, "] out of bounds for array of shape [", (long long) deepen_step_res_120901, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:272:8-49\n   #3  ftRelational.fut:215:5-88\n   #4  ftRelational.fut:205:1-216:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133621 = (int64_t) 8 * m_120933;
            int64_t conc_tmp_120972 = loop_dz2081Uz2089U_120730 + m_120933;
            int64_t bytes_133657 = (int64_t) 8 * conc_tmp_120972;
            
            if (mem_133622_cached_sizze_134251 < bytes_133621) {
                err = lexical_realloc(ctx, &mem_133622, &mem_133622_cached_sizze_134251, bytes_133621);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133622, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133596, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120933});
            if (mem_133624_cached_sizze_134252 < bytes_133621) {
                err = lexical_realloc(ctx, &mem_133624, &mem_133624_cached_sizze_134252, bytes_133621);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133624, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133594, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120933});
            for (int64_t write_iter_133343 = 0; write_iter_133343 < deepen_step_res_120901; write_iter_133343++) {
                int64_t write_iv_133346 = ((int64_t *) mem_133592)[write_iter_133343];
                int64_t write_iv_133347 = ((int64_t *) mem_133590)[write_iter_133343];
                int64_t write_iv_133348 = ((int64_t *) mem_133594)[write_iter_133343];
                int64_t write_iv_133349 = ((int64_t *) mem_133596)[write_iter_133343];
                bool cond_127936 = write_iv_133346 == (int64_t) 1;
                int64_t lifted_lambda_res_127937;
                
                if (cond_127936) {
                    int64_t lifted_lambda_res_t_res_128358 = sub64(write_iv_133347, (int64_t) 1);
                    
                    lifted_lambda_res_127937 = lifted_lambda_res_t_res_128358;
                } else {
                    lifted_lambda_res_127937 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_127937) && slt64(lifted_lambda_res_127937, m_120933)) {
                    ((int64_t *) mem_133624)[lifted_lambda_res_127937] = write_iv_133348;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_127937) && slt64(lifted_lambda_res_127937, m_120933)) {
                    ((int64_t *) mem_133622)[lifted_lambda_res_127937] = write_iv_133349;
                }
            }
            if (memblock_alloc(ctx, &mem_133638, bytes_133637, "mem_133638")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133638.mem, (int64_t) 0, (int64_t []) {b_112000, (int64_t) 1}, (uint8_t *) mem_param_133498.mem, (int64_t) 0, (int64_t []) {b_112000, (int64_t) 1}, (int64_t []) {n_111999, b_112000});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133638.mem, b_112000 * bounds_120735, (int64_t []) {b_112000, (int64_t) 1}, (uint8_t *) ext_mem_133583.mem, ext_133581, (int64_t []) {b_112000, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737, b_112000});
            if (memblock_unref(ctx, &ext_mem_133583, "ext_mem_133583") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_133640, bytes_133639, "mem_133640")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133640.mem, (int64_t) 0, (int64_t []) {pL_b_112001, (int64_t) 1}, (uint8_t *) mem_param_133494.mem, (int64_t) 0, (int64_t []) {pL_b_112001, (int64_t) 1}, (int64_t []) {n_111999, pL_b_112001});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133640.mem, pL_b_112001 * bounds_120735, (int64_t []) {pL_b_112001, (int64_t) 1}, (uint8_t *) ext_mem_133582.mem, ext_133578, (int64_t []) {pL_b_112001, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120737, pL_b_112001});
            if (memblock_unref(ctx, &ext_mem_133582, "ext_mem_133582") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_133658, bytes_133657, "mem_133658")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_133660, bytes_133657, "mem_133660")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t i_133356 = 0; i_133356 < m_120933; i_133356++) {
                int64_t eta_p_120968 = ((int64_t *) mem_133624)[i_133356];
                int64_t eta_p_120969 = ((int64_t *) mem_133622)[i_133356];
                int64_t tmp_120970 = add64(bounds_120735, eta_p_120968);
                int64_t tmp_120971 = add64(bounds_120735, eta_p_120969);
                
                ((int64_t *) mem_133658.mem)[loop_dz2081Uz2089U_120730 + i_133356] = tmp_120970;
                ((int64_t *) mem_133660.mem)[loop_dz2081Uz2089U_120730 + i_133356] = tmp_120971;
            }
            
            int64_t tmp_offs_133931 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133658.mem, tmp_offs_133931, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133487.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2089U_120730});
            tmp_offs_133931 += loop_dz2081Uz2089U_120730;
            if (!(tmp_offs_133931 == loop_dz2081Uz2089U_120730)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133658.mem, tmp_offs_133931, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133658.mem, loop_dz2081Uz2089U_120730, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120933});
            }
            tmp_offs_133931 += m_120933;
            
            int64_t tmp_offs_133932 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133660.mem, tmp_offs_133932, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133490.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2089U_120730});
            tmp_offs_133932 += loop_dz2081Uz2089U_120730;
            if (!(tmp_offs_133932 == loop_dz2081Uz2089U_120730)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133660.mem, tmp_offs_133932, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133660.mem, loop_dz2081Uz2089U_120730, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120933});
            }
            tmp_offs_133932 += m_120933;
            if (memblock_set(ctx, &mem_param_tmp_133892, &mem_133658, "mem_133658") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133893, &mem_133660, "mem_133660") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133894, &mem_133640, "mem_133640") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133638, "mem_133638") != 0)
                return 1;
            
            int64_t loop_dz2081Uz2089U_tmp_133896 = conc_tmp_120972;
            
            if (memblock_set(ctx, &mem_param_133487, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133490, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133494, &mem_param_tmp_133894, "mem_param_tmp_133894") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133498, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            loop_dz2081Uz2089U_120730 = loop_dz2081Uz2089U_tmp_133896;
        }
        if (memblock_set(ctx, &ext_mem_133674, &mem_param_133487, "mem_param_133487") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133673, &mem_param_133490, "mem_param_133490") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133672, &mem_param_133494, "mem_param_133494") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133671, &mem_param_133498, "mem_param_133498") != 0)
            return 1;
        loopres_120724 = loop_dz2081Uz2089U_120730;
        
        bool cond_120976 = slt64((int64_t) 0, loopres_120724);
        bool loop_cond_t_res_120977 = slt32(newDepth_120755, max_depth_112008);
        bool x_120978 = cond_120976 && loop_cond_t_res_120977;
        
        if (memblock_set(ctx, &mem_param_tmp_133881, &ext_mem_133672, "ext_mem_133672") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133882, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133883, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133884, &ext_mem_133673, "ext_mem_133673") != 0)
            return 1;
        
        int64_t loop_dz2087U_tmp_133885 = loopres_120724;
        bool loop_while_tmp_133886 = x_120978;
        int32_t p_tmp_133887 = newDepth_120755;
        
        if (memblock_set(ctx, &mem_param_133474, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133478, &mem_param_tmp_133882, "mem_param_tmp_133882") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133481, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133484, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        loop_dz2087U_120717 = loop_dz2087U_tmp_133885;
        loop_while_120718 = loop_while_tmp_133886;
        p_120719 = p_tmp_133887;
    }
    if (memblock_set(ctx, &ext_mem_133688, &mem_param_133474, "mem_param_133474") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133687, &mem_param_133478, "mem_param_133478") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133686, &mem_param_133481, "mem_param_133481") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133685, &mem_param_133484, "mem_param_133484") != 0)
        return 1;
    partition_and_deepen_res_120710 = loop_dz2087U_120717;
    partition_and_deepen_res_120711 = loop_while_120718;
    partition_and_deepen_res_120712 = p_120719;
    if (memblock_unref(ctx, &mem_133468, "mem_133468") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &ext_mem_133687, "ext_mem_133687") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &ext_mem_133688, "ext_mem_133688") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134240, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134241, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133513);
        free(mem_133547);
        free(mem_133549);
        free(mem_133558);
        free(mem_133559);
        free(mem_133590);
        free(mem_133592);
        free(mem_133594);
        free(mem_133596);
        free(mem_133622);
        free(mem_133624);
        if (memblock_unref(ctx, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133882, "mem_param_tmp_133882") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133894, "mem_param_tmp_133894") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133893, "mem_param_tmp_133893") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133892, "mem_param_tmp_133892") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133660, "mem_133660") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133658, "mem_133658") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133640, "mem_133640") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133638, "mem_133638") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133587, "ext_mem_133587") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133588, "ext_mem_133588") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133585, "mem_133585") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133903, "mem_param_tmp_133903") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133902, "mem_param_tmp_133902") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133537, "mem_133537") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133535, "mem_133535") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133910, "mem_param_tmp_133910") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133524, "mem_133524") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133522, "mem_param_133522") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133508, "mem_param_133508") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133504, "mem_param_133504") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133582, "ext_mem_133582") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133583, "ext_mem_133583") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133498, "mem_param_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133494, "mem_param_133494") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133490, "mem_param_133490") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133487, "mem_param_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133671, "ext_mem_133671") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133672, "ext_mem_133672") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133673, "ext_mem_133673") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133674, "ext_mem_133674") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133484, "mem_param_133484") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133481, "mem_param_133481") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133478, "mem_param_133478") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133474, "mem_param_133474") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133685, "ext_mem_133685") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133686, "ext_mem_133686") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133687, "ext_mem_133687") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133688, "ext_mem_133688") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133468, "mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_partition_and_deepen_GFUR(struct futhark_context *ctx, struct memblock *mem_out_p_134253, struct memblock *mem_out_p_134254, struct memblock xs_mem_133466, int64_t n_113366, int64_t b_113367, int16_t block_sizze_113368, int64_t gather_psizze_113369, int32_t radix_sizze_113370, int64_t offset_113372, int64_t sizze_thresh_113373, int32_t max_depth_113374)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133511_cached_sizze_134255 = 0;
    unsigned char *mem_133511 = NULL;
    int64_t mem_133544_cached_sizze_134256 = 0;
    unsigned char *mem_133544 = NULL;
    int64_t mem_133546_cached_sizze_134257 = 0;
    unsigned char *mem_133546 = NULL;
    int64_t mem_133554_cached_sizze_134258 = 0;
    unsigned char *mem_133554 = NULL;
    int64_t mem_133582_cached_sizze_134259 = 0;
    unsigned char *mem_133582 = NULL;
    int64_t mem_133584_cached_sizze_134260 = 0;
    unsigned char *mem_133584 = NULL;
    int64_t mem_133586_cached_sizze_134261 = 0;
    unsigned char *mem_133586 = NULL;
    int64_t mem_133588_cached_sizze_134262 = 0;
    unsigned char *mem_133588 = NULL;
    int64_t mem_133614_cached_sizze_134263 = 0;
    unsigned char *mem_133614 = NULL;
    int64_t mem_133616_cached_sizze_134264 = 0;
    unsigned char *mem_133616 = NULL;
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_param_tmp_133885;
    
    mem_param_tmp_133885.references = NULL;
    
    struct memblock mem_param_tmp_133884;
    
    mem_param_tmp_133884.references = NULL;
    
    struct memblock mem_param_tmp_133883;
    
    mem_param_tmp_133883.references = NULL;
    
    struct memblock mem_param_tmp_133897;
    
    mem_param_tmp_133897.references = NULL;
    
    struct memblock mem_param_tmp_133896;
    
    mem_param_tmp_133896.references = NULL;
    
    struct memblock mem_param_tmp_133895;
    
    mem_param_tmp_133895.references = NULL;
    
    struct memblock mem_param_tmp_133894;
    
    mem_param_tmp_133894.references = NULL;
    
    struct memblock mem_133652;
    
    mem_133652.references = NULL;
    
    struct memblock mem_133650;
    
    mem_133650.references = NULL;
    
    struct memblock mem_133632;
    
    mem_133632.references = NULL;
    
    struct memblock mem_133630;
    
    mem_133630.references = NULL;
    
    struct memblock ext_mem_133579;
    
    ext_mem_133579.references = NULL;
    
    struct memblock ext_mem_133580;
    
    ext_mem_133580.references = NULL;
    
    struct memblock mem_133577;
    
    mem_133577.references = NULL;
    
    struct memblock mem_param_tmp_133905;
    
    mem_param_tmp_133905.references = NULL;
    
    struct memblock mem_param_tmp_133904;
    
    mem_param_tmp_133904.references = NULL;
    
    struct memblock mem_133535;
    
    mem_133535.references = NULL;
    
    struct memblock mem_133533;
    
    mem_133533.references = NULL;
    
    struct memblock mem_param_tmp_133912;
    
    mem_param_tmp_133912.references = NULL;
    
    struct memblock mem_133522;
    
    mem_133522.references = NULL;
    
    struct memblock mem_param_133520;
    
    mem_param_133520.references = NULL;
    
    struct memblock ext_mem_133531;
    
    ext_mem_133531.references = NULL;
    
    struct memblock mem_param_133506;
    
    mem_param_133506.references = NULL;
    
    struct memblock mem_param_133503;
    
    mem_param_133503.references = NULL;
    
    struct memblock ext_mem_133574;
    
    ext_mem_133574.references = NULL;
    
    struct memblock ext_mem_133575;
    
    ext_mem_133575.references = NULL;
    
    struct memblock mem_133499;
    
    mem_133499.references = NULL;
    
    struct memblock mem_param_133497;
    
    mem_param_133497.references = NULL;
    
    struct memblock mem_param_133493;
    
    mem_param_133493.references = NULL;
    
    struct memblock mem_param_133490;
    
    mem_param_133490.references = NULL;
    
    struct memblock mem_param_133487;
    
    mem_param_133487.references = NULL;
    
    struct memblock ext_mem_133662;
    
    ext_mem_133662.references = NULL;
    
    struct memblock ext_mem_133663;
    
    ext_mem_133663.references = NULL;
    
    struct memblock ext_mem_133664;
    
    ext_mem_133664.references = NULL;
    
    struct memblock ext_mem_133665;
    
    ext_mem_133665.references = NULL;
    
    struct memblock mem_param_133484;
    
    mem_param_133484.references = NULL;
    
    struct memblock mem_param_133481;
    
    mem_param_133481.references = NULL;
    
    struct memblock mem_param_133478;
    
    mem_param_133478.references = NULL;
    
    struct memblock mem_param_133474;
    
    mem_param_133474.references = NULL;
    
    struct memblock ext_mem_133675;
    
    ext_mem_133675.references = NULL;
    
    struct memblock ext_mem_133676;
    
    ext_mem_133676.references = NULL;
    
    struct memblock ext_mem_133677;
    
    ext_mem_133677.references = NULL;
    
    struct memblock ext_mem_133678;
    
    ext_mem_133678.references = NULL;
    
    struct memblock mem_133471;
    
    mem_133471.references = NULL;
    
    struct memblock mem_133470;
    
    mem_133470.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_133468;
    
    mem_133468.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t is_120705 = add64(n_113366, offset_113372);
    bool bounds_invalid_upwards_120706 = slt64(is_120705, offset_113372);
    bool valid_120707 = !bounds_invalid_upwards_120706;
    bool range_valid_c_120708;
    
    if (!valid_120707) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) offset_113372, "..<", (long long) is_120705, " is invalid.", "-> #0  ftRelational.fut:227:13-32\n   #1  ftRelational.fut:218:1-230:31\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133467 = (int64_t) 8 * n_113366;
    
    if (memblock_alloc(ctx, &mem_133468, bytes_133467, "mem_133468")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133879 = 0; i_133879 < n_113366; i_133879++) {
        int64_t x_133880 = offset_113372 + i_133879 * (int64_t) 1;
        
        ((int64_t *) mem_133468.mem)[i_133879] = x_133880;
    }
    if (memblock_alloc(ctx, &mem_133469, (int64_t) 8, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133881 = 0; nest_i_133881 < (int64_t) 1; nest_i_133881++) {
        ((int64_t *) mem_133469.mem)[nest_i_133881] = (int64_t) 0;
    }
    if (memblock_alloc(ctx, &mem_133470, (int64_t) 8, "mem_133470")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133882 = 0; nest_i_133882 < (int64_t) 1; nest_i_133882++) {
        ((int64_t *) mem_133470.mem)[nest_i_133882] = n_113366;
    }
    
    bool loop_cond_t_res_120712 = slt32(0, max_depth_113374);
    
    if (memblock_alloc(ctx, &mem_133471, (int64_t) 0, "mem_133471")) {
        err = 1;
        goto cleanup;
    }
    
    int32_t i64_res_120763 = sext_i64_i32(b_113367);
    int32_t zm_lhs_120764 = mul32(8, i64_res_120763);
    int32_t min_arg1_120765 = sub32(zm_lhs_120764, 1);
    bool zzero_120784 = gather_psizze_113369 == (int64_t) 0;
    bool nonzzero_120785 = !zzero_120784;
    int64_t bytes_133629 = n_113366 * b_113367;
    
    if (mem_133554_cached_sizze_134258 < b_113367) {
        err = lexical_realloc(ctx, &mem_133554, &mem_133554_cached_sizze_134258, b_113367);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t partition_and_deepen_res_120714;
    bool partition_and_deepen_res_120715;
    int32_t partition_and_deepen_res_120716;
    int64_t loop_dz2087U_120721;
    bool loop_while_120722;
    int32_t p_120723;
    
    if (memblock_set(ctx, &mem_param_133474, &mem_133468, "mem_133468") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133478, &xs_mem_133466, "xs_mem_133466") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133481, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133484, &mem_133470, "mem_133470") != 0)
        return 1;
    loop_dz2087U_120721 = (int64_t) 1;
    loop_while_120722 = loop_cond_t_res_120712;
    p_120723 = 0;
    while (loop_while_120722) {
        bool loop_nonempty_126067 = slt64((int64_t) 0, loop_dz2087U_120721);
        int32_t newDepth_120759 = add32(1, p_120723);
        int32_t new_i_120760 = mul32(radix_sizze_113370, p_120723);
        int32_t zm_lhs_120761 = mul32(radix_sizze_113370, newDepth_120759);
        int32_t new_j_120762 = sub32(zm_lhs_120761, 1);
        int32_t min_res_120766 = smin32(new_j_120762, min_arg1_120765);
        int32_t tmp_120767 = add32(2, new_i_120760);
        int64_t i_120768 = sext_i32_i64(new_i_120760);
        int64_t j__120769 = sext_i32_i64(min_res_120766);
        int64_t tmp_120770 = sext_i32_i64(tmp_120767);
        bool step_zzero_120771 = new_i_120760 == tmp_120767;
        bool bounds_invalid_upwards_120772 = slt32(min_res_120766, new_i_120760);
        int32_t distance_upwards_exclusive_120773 = sub32(min_res_120766, new_i_120760);
        int64_t distance_exclusive_120774 = sext_i32_i64(distance_upwards_exclusive_120773);
        int64_t distance_120775 = add64((int64_t) 1, distance_exclusive_120774);
        bool range_invalid_120776 = step_zzero_120771 || bounds_invalid_upwards_120772;
        bool valid_120777 = !range_invalid_120776;
        bool loop_not_taken_126068 = !loop_nonempty_126067;
        bool protect_assert_disj_126069 = valid_120777 || loop_not_taken_126068;
        bool range_valid_c_120778;
        
        if (!protect_assert_disj_126069) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) i_120768, "..", (long long) tmp_120770, "...", (long long) j__120769, " is invalid.", "-> #0  ftHashJoin.fut:219:15-37\n   #1  ftHashJoin.fut:261:20-267:6\n   #2  ftRelational.fut:229:5-88\n   #3  ftRelational.fut:218:1-230:31\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t num_elems_120779 = sdiv_up64(distance_120775, (int64_t) 2);
        bool loop_nonempty_120780 = slt64((int64_t) 0, num_elems_120779);
        bool loop_not_taken_120786 = !loop_nonempty_120780;
        bool protect_assert_disj_120787 = nonzzero_120785 || loop_not_taken_120786;
        bool protect_assert_disj_126071 = protect_assert_disj_120787 || loop_not_taken_126068;
        bool nonzzero_cert_120788;
        
        if (!protect_assert_disj_126071) {
            set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftHashJoin.fut:206:87-90\n   #2  ftHashJoin.fut:220:6-71\n   #3  ftHashJoin.fut:261:20-267:6\n   #4  ftRelational.fut:229:5-88\n   #5  ftRelational.fut:218:1-230:31\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t loopres_120728;
        int64_t loop_dz2081Uz2089U_120734;
        
        if (memblock_set(ctx, &mem_param_133487, &mem_133471, "mem_133471") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133490, &mem_133471, "mem_133471") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133493, &mem_param_133474, "mem_param_133474") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133497, &mem_param_133478, "mem_param_133478") != 0)
            return 1;
        loop_dz2081Uz2089U_120734 = (int64_t) 0;
        for (int64_t i_120733 = 0; i_120733 < loop_dz2087U_120721; i_120733++) {
            int64_t bounds_120739 = ((int64_t *) mem_param_133481.mem)[i_120733];
            int64_t bounds_120740 = ((int64_t *) mem_param_133484.mem)[i_120733];
            int64_t dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741 = sub64(bounds_120740, bounds_120739);
            bool empty_slice_120742 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741 == (int64_t) 0;
            int64_t m_120743 = sub64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741, (int64_t) 1);
            int64_t i_p_m_t_s_120744 = add64(bounds_120739, m_120743);
            bool zzero_leq_i_p_m_t_s_120745 = sle64((int64_t) 0, i_p_m_t_s_120744);
            bool i_p_m_t_s_leq_w_120746 = slt64(i_p_m_t_s_120744, n_113366);
            bool zzero_lte_i_120747 = sle64((int64_t) 0, bounds_120739);
            bool i_lte_j_120748 = sle64(bounds_120739, bounds_120740);
            bool y_120749 = i_p_m_t_s_leq_w_120746 && zzero_lte_i_120747;
            bool y_120750 = zzero_leq_i_p_m_t_s_120745 && y_120749;
            bool forwards_ok_120751 = i_lte_j_120748 && y_120750;
            bool ok_or_empty_120752 = empty_slice_120742 || forwards_ok_120751;
            bool index_certs_120753;
            
            if (!ok_or_empty_120752) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) bounds_120739, ":", (long long) bounds_120740, "] out of bounds for array of shape [", (long long) n_113366, "].", "-> #0  ftHashJoin.fut:294:21-47\n   #1  ftRelational.fut:229:5-88\n   #2  ftRelational.fut:218:1-230:31\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133498 = (int64_t) 8 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741;
            
            if (memblock_alloc(ctx, &mem_133499, bytes_133498, "mem_133499")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t nest_i_133903 = 0; nest_i_133903 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741; nest_i_133903++) {
                ((int64_t *) mem_133499.mem)[nest_i_133903] = (int64_t) 0;
            }
            
            int64_t zm_lhs_120782 = add64(gather_psizze_113369, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741);
            int64_t zs_lhs_120783 = sub64(zm_lhs_120782, (int64_t) 1);
            int64_t m_120789 = sdiv_safe64(zs_lhs_120783, gather_psizze_113369);
            bool loop_cond_120790 = slt64((int64_t) 0, m_120789);
            int64_t binop_y_133507 = b_113367 * bounds_120739;
            int64_t bytes_133532 = b_113367 * dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741;
            
            if (mem_133511_cached_sizze_134255 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741) {
                err = lexical_realloc(ctx, &mem_133511, &mem_133511_cached_sizze_134255, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t ext_133573;
            int64_t ext_133570;
            int64_t ctx_param_ext_133500;
            int64_t ctx_param_ext_133504;
            
            if (memblock_set(ctx, &mem_param_133503, &mem_param_133497, "mem_param_133497") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133506, &mem_param_133493, "mem_param_133493") != 0)
                return 1;
            ctx_param_ext_133500 = binop_y_133507;
            ctx_param_ext_133504 = bounds_120739;
            for (int64_t i_120793 = 0; i_120793 < num_elems_120779; i_120793++) {
                int32_t binop_x_120796 = sext_i64_i32(i_120793);
                int32_t binop_x_120797 = mul32(2, binop_x_120796);
                int32_t index_primexp_120798 = add32(new_i_120760, binop_x_120797);
                int32_t zm_lhs_120799 = add32(2, index_primexp_120798);
                int32_t min_arg1_120800 = sub32(zm_lhs_120799, 1);
                int32_t min_res_120801 = smin32(min_res_120766, min_arg1_120800);
                int32_t zp_lhs_120802 = sub32(min_res_120801, index_primexp_120798);
                int32_t ij_bits_120803 = add32(1, zp_lhs_120802);
                int32_t up_to_120804 = shl32(1, ij_bits_120803);
                int64_t tmp_120805 = sext_i32_i64(zp_lhs_120802);
                bool bounds_invalid_upwards_120806 = slt32(zp_lhs_120802, 0);
                bool valid_120808 = !bounds_invalid_upwards_120806;
                bool range_valid_c_120809;
                
                if (!valid_120808) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_120805, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:206:87-90\n   #3  ftHashJoin.fut:220:6-71\n   #4  ftHashJoin.fut:261:20-267:6\n   #5  ftRelational.fut:229:5-88\n   #6  ftRelational.fut:218:1-230:31\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t up_to_120819 = sext_i32_i64(up_to_120804);
                bool bounds_invalid_upwards_120820 = slt32(up_to_120804, 0);
                bool valid_120821 = !bounds_invalid_upwards_120820;
                bool range_valid_c_120822;
                
                if (!valid_120821) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_120819, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftHashJoin.fut:206:87-90\n   #2  ftHashJoin.fut:220:6-71\n   #3  ftHashJoin.fut:261:20-267:6\n   #4  ftRelational.fut:229:5-88\n   #5  ftRelational.fut:218:1-230:31\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int64_t distance_120807 = add64((int64_t) 1, tmp_120805);
                
                for (int64_t i_133300 = 0; i_133300 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741; i_133300++) {
                    int8_t defunc_0_f_res_120812;
                    int8_t y_120814 = (int8_t) 0;
                    
                    for (int64_t i_120813 = 0; i_120813 < distance_120807; i_120813++) {
                        int32_t binop_x_120815 = sext_i64_i32(i_120813);
                        int32_t get_bit_arg0_120816 = add32(index_primexp_120798, binop_x_120815);
                        int32_t zm_rhs_126555 = sdiv32(get_bit_arg0_120816, 8);
                        int32_t zm_lhs_126556 = sub32(i64_res_120763, zm_rhs_126555);
                        int32_t whichByte_126557 = sub32(zm_lhs_126556, 1);
                        int64_t whichByte_126559 = sext_i32_i64(whichByte_126557);
                        bool x_126560 = sle64((int64_t) 0, whichByte_126559);
                        bool y_126561 = slt64(whichByte_126559, b_113367);
                        bool bounds_check_126562 = x_126560 && y_126561;
                        bool index_certs_126563;
                        
                        if (!bounds_check_126562) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) whichByte_126559, "] out of bounds for array of shape [", (long long) b_113367, "].", "-> #0  ftHashJoin.fut:17:6-18\n   #1  ftRelational.fut:229:5-88\n   #2  ftRelational.fut:218:1-230:31\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t whichBit_126558 = smod32(get_bit_arg0_120816, 8);
                        int8_t zbzg_lhs_126564 = ((int8_t *) mem_param_133503.mem)[ctx_param_ext_133500 + (i_133300 * b_113367 + whichByte_126559)];
                        int8_t unsign_arg0_126565 = zext_i32_i8(whichBit_126558);
                        int8_t unsign_arg0_126566 = ashr8(zbzg_lhs_126564, unsign_arg0_126565);
                        int8_t unsign_arg0_126567 = (int8_t) 1 & unsign_arg0_126566;
                        int32_t to_i32_res_126568 = zext_i8_i32(unsign_arg0_126567);
                        int8_t loopres_120818;
                        
                        if (futrts_set_bit_2464(ctx, &loopres_120818, binop_x_120815, y_120814, to_i32_res_126568) != 0) {
                            err = 1;
                            goto cleanup;
                        }
                        
                        int8_t y_tmp_133911 = loopres_120818;
                        
                        y_120814 = y_tmp_133911;
                    }
                    defunc_0_f_res_120812 = y_120814;
                    ((int8_t *) mem_133511)[i_133300] = defunc_0_f_res_120812;
                }
                
                int64_t defunc_0_radix_sort_multistep_res_120823;
                int64_t offs_120826;
                
                if (memblock_set(ctx, &mem_param_133520, &mem_133499, "mem_133499") != 0)
                    return 1;
                offs_120826 = (int64_t) 0;
                for (int64_t i_120825 = 0; i_120825 < up_to_120819; i_120825++) {
                    int32_t binop_x_120828 = sext_i64_i32(i_120825);
                    int8_t index_primexp_120829 = zext_i32_i8(binop_x_120828);
                    
                    if (memblock_alloc(ctx, &mem_133522, bytes_133498, "mem_133522")) {
                        err = 1;
                        goto cleanup;
                    }
                    
                    int64_t inpacc_128344;
                    int64_t defunc_0_reduce_res_128345;
                    int64_t inpacc_128165;
                    int64_t inpacc_128166;
                    
                    inpacc_128165 = (int64_t) 0;
                    inpacc_128166 = (int64_t) 0;
                    for (int64_t i_133318 = 0; i_133318 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741; i_133318++) {
                        int8_t eta_p_133435 = ((int8_t *) mem_133511)[i_133318];
                        bool lifted_lambda_res_133436 = eta_p_133435 == index_primexp_120829;
                        int64_t bool_res_133437 = btoi_bool_i64(lifted_lambda_res_133436);
                        int64_t eta_p_133450 = ((int64_t *) mem_param_133520.mem)[i_133318];
                        int64_t defunc_0_op_res_133451 = add64(inpacc_128165, bool_res_133437);
                        int64_t zm_lhs_133452 = add64(offs_120826, defunc_0_op_res_133451);
                        int64_t lifted_lambda_res_133453 = sub64(zm_lhs_133452, (int64_t) 1);
                        int64_t defunc_0_f_res_133454 = mul64(bool_res_133437, lifted_lambda_res_133453);
                        int64_t defunc_0_f_res_133455 = add64(eta_p_133450, defunc_0_f_res_133454);
                        int64_t defunc_0_op_res_128214 = add64(inpacc_128166, bool_res_133437);
                        
                        ((int64_t *) mem_133522.mem)[i_133318] = defunc_0_f_res_133455;
                        
                        int64_t inpacc_tmp_133915 = defunc_0_op_res_133451;
                        int64_t inpacc_tmp_133916 = defunc_0_op_res_128214;
                        
                        inpacc_128165 = inpacc_tmp_133915;
                        inpacc_128166 = inpacc_tmp_133916;
                    }
                    inpacc_128344 = inpacc_128165;
                    defunc_0_reduce_res_128345 = inpacc_128166;
                    
                    int64_t tmp_120854 = add64(offs_120826, defunc_0_reduce_res_128345);
                    
                    if (memblock_set(ctx, &mem_param_tmp_133912, &mem_133522, "mem_133522") != 0)
                        return 1;
                    
                    int64_t offs_tmp_133913 = tmp_120854;
                    
                    if (memblock_set(ctx, &mem_param_133520, &mem_param_tmp_133912, "mem_param_tmp_133912") != 0)
                        return 1;
                    offs_120826 = offs_tmp_133913;
                }
                if (memblock_set(ctx, &ext_mem_133531, &mem_param_133520, "mem_param_133520") != 0)
                    return 1;
                defunc_0_radix_sort_multistep_res_120823 = offs_120826;
                if (memblock_alloc(ctx, &mem_133533, bytes_133532, "mem_133533")) {
                    err = 1;
                    goto cleanup;
                }
                lmad_copy_1b(ctx, 2, (uint8_t *) mem_133533.mem, (int64_t) 0, (int64_t []) {b_113367, (int64_t) 1}, (uint8_t *) mem_param_133503.mem, ctx_param_ext_133500, (int64_t []) {b_113367, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741, b_113367});
                if (memblock_alloc(ctx, &mem_133535, bytes_133498, "mem_133535")) {
                    err = 1;
                    goto cleanup;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133535.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133506.mem, ctx_param_ext_133504, (int64_t []) {(int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741});
                
                bool partitioned_scatter_res_120861;
                int64_t partitioned_scatter_res_120864;
                bool loop_while_120865;
                int64_t p_120868;
                
                loop_while_120865 = loop_cond_120790;
                p_120868 = (int64_t) 0;
                while (loop_while_120865) {
                    int64_t lower_bound_120869 = mul64(gather_psizze_113369, p_120868);
                    int64_t min_arg1_120870 = add64(gather_psizze_113369, lower_bound_120869);
                    int64_t min_res_120871 = smin64(dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741, min_arg1_120870);
                    int64_t j_m_i_120872 = sub64(min_res_120871, lower_bound_120869);
                    bool empty_slice_120873 = j_m_i_120872 == (int64_t) 0;
                    int64_t m_120874 = sub64(j_m_i_120872, (int64_t) 1);
                    int64_t i_p_m_t_s_120875 = add64(lower_bound_120869, m_120874);
                    bool zzero_leq_i_p_m_t_s_120876 = sle64((int64_t) 0, i_p_m_t_s_120875);
                    bool i_p_m_t_s_leq_w_120877 = slt64(i_p_m_t_s_120875, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741);
                    bool zzero_lte_i_120878 = sle64((int64_t) 0, lower_bound_120869);
                    bool i_lte_j_120879 = sle64(lower_bound_120869, min_res_120871);
                    bool y_120880 = i_p_m_t_s_leq_w_120877 && zzero_lte_i_120878;
                    bool y_120881 = zzero_leq_i_p_m_t_s_120876 && y_120880;
                    bool forwards_ok_120882 = i_lte_j_120879 && y_120881;
                    bool ok_or_empty_120883 = empty_slice_120873 || forwards_ok_120882;
                    bool index_certs_120884;
                    
                    if (!ok_or_empty_120883) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_120869, ":", (long long) min_res_120871, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftHashJoin.fut:206:87-90\n   #2  ftHashJoin.fut:220:6-71\n   #3  ftHashJoin.fut:261:20-267:6\n   #4  ftRelational.fut:229:5-88\n   #5  ftRelational.fut:218:1-230:31\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t bytes_133543 = b_113367 * j_m_i_120872;
                    int64_t bytes_133545 = (int64_t) 8 * j_m_i_120872;
                    
                    if (mem_133544_cached_sizze_134256 < bytes_133543) {
                        err = lexical_realloc(ctx, &mem_133544, &mem_133544_cached_sizze_134256, bytes_133543);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133544, (int64_t) 0, (int64_t []) {b_113367, (int64_t) 1}, (uint8_t *) mem_133533.mem, (int64_t) 0 + b_113367 * lower_bound_120869, (int64_t []) {b_113367, (int64_t) 1}, (int64_t []) {j_m_i_120872, b_113367});
                    if (mem_133546_cached_sizze_134257 < bytes_133545) {
                        err = lexical_realloc(ctx, &mem_133546, &mem_133546_cached_sizze_134257, bytes_133545);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133546, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133535.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120869, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120872});
                    for (int64_t write_iter_133320 = 0; write_iter_133320 < dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741; write_iter_133320++) {
                        int64_t write_iv_133323 = ((int64_t *) ext_mem_133531.mem)[write_iter_133320];
                        int64_t write_iv_133325 = ((int64_t *) mem_param_133506.mem)[ctx_param_ext_133504 + write_iter_133320];
                        
                        lmad_copy_1b(ctx, 1, (uint8_t *) mem_133554, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_133503.mem, ctx_param_ext_133500 + write_iter_133320 * b_113367, (int64_t []) {(int64_t) 1}, (int64_t []) {b_113367});
                        
                        bool cond_128257 = sle64(lower_bound_120869, write_iv_133323);
                        bool cond_t_res_128258 = slt64(write_iv_133323, min_res_120871);
                        bool x_128259 = cond_128257 && cond_t_res_128258;
                        int64_t lifted_lambda_res_128260;
                        
                        if (x_128259) {
                            int64_t lifted_lambda_res_t_res_128347 = sub64(write_iv_133323, lower_bound_120869);
                            
                            lifted_lambda_res_128260 = lifted_lambda_res_t_res_128347;
                        } else {
                            lifted_lambda_res_128260 = (int64_t) -1;
                        }
                        if ((sle64((int64_t) 0, lifted_lambda_res_128260) && slt64(lifted_lambda_res_128260, j_m_i_120872)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(b_113367 - (int64_t) 1, b_113367))) {
                            lmad_copy_1b(ctx, 1, (uint8_t *) mem_133544, lifted_lambda_res_128260 * b_113367, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133554, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_113367});
                        }
                        if (sle64((int64_t) 0, lifted_lambda_res_128260) && slt64(lifted_lambda_res_128260, j_m_i_120872)) {
                            ((int64_t *) mem_133546)[lifted_lambda_res_128260] = write_iv_133325;
                        }
                    }
                    
                    int64_t tmp_120896 = add64((int64_t) 1, p_120868);
                    
                    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133533.mem, b_113367 * lower_bound_120869, (int64_t []) {b_113367, (int64_t) 1}, (uint8_t *) mem_133544, (int64_t) 0, (int64_t []) {b_113367, (int64_t) 1}, (int64_t []) {j_m_i_120872, b_113367});
                    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133535.mem, lower_bound_120869, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133546, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120872});
                    
                    bool loop_cond_120904 = slt64(tmp_120896, m_120789);
                    bool loop_while_tmp_133918 = loop_cond_120904;
                    int64_t p_tmp_133921 = tmp_120896;
                    
                    loop_while_120865 = loop_while_tmp_133918;
                    p_120868 = p_tmp_133921;
                }
                partitioned_scatter_res_120861 = loop_while_120865;
                partitioned_scatter_res_120864 = p_120868;
                if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_tmp_133904, &mem_133533, "mem_133533") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_tmp_133905, &mem_133535, "mem_133535") != 0)
                    return 1;
                
                int64_t ctx_param_ext_tmp_133906 = (int64_t) 0;
                int64_t ctx_param_ext_tmp_133907 = (int64_t) 0;
                
                if (memblock_set(ctx, &mem_param_133503, &mem_param_tmp_133904, "mem_param_tmp_133904") != 0)
                    return 1;
                if (memblock_set(ctx, &mem_param_133506, &mem_param_tmp_133905, "mem_param_tmp_133905") != 0)
                    return 1;
                ctx_param_ext_133500 = ctx_param_ext_tmp_133906;
                ctx_param_ext_133504 = ctx_param_ext_tmp_133907;
            }
            if (memblock_set(ctx, &ext_mem_133575, &mem_param_133503, "mem_param_133503") != 0)
                return 1;
            if (memblock_set(ctx, &ext_mem_133574, &mem_param_133506, "mem_param_133506") != 0)
                return 1;
            ext_133573 = ctx_param_ext_133500;
            ext_133570 = ctx_param_ext_133504;
            if (memblock_unref(ctx, &mem_133499, "mem_133499") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_133577, bytes_133532, "mem_133577")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133577.mem, (int64_t) 0, (int64_t []) {b_113367, (int64_t) 1}, (uint8_t *) ext_mem_133575.mem, ext_133573, (int64_t []) {b_113367, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741, b_113367});
            
            int64_t deepen_step_res_120905;
            int64_t deepen_step_res_120906;
            int32_t deepen_step_res_120909;
            
            if (futrts_getPartitionBounds_12125(ctx, &ext_mem_133580, &ext_mem_133579, &deepen_step_res_120905, &deepen_step_res_120906, &deepen_step_res_120909, mem_133577, dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741, b_113367, newDepth_120759, new_i_120760, new_j_120762) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref(ctx, &mem_133577, "mem_133577") != 0)
                return 1;
            
            int64_t zl_rhs_126081 = sub64(deepen_step_res_120905, (int64_t) 1);
            int64_t bytes_133581 = (int64_t) 8 * deepen_step_res_120905;
            
            if (mem_133582_cached_sizze_134259 < bytes_133581) {
                err = lexical_realloc(ctx, &mem_133582, &mem_133582_cached_sizze_134259, bytes_133581);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133584_cached_sizze_134260 < bytes_133581) {
                err = lexical_realloc(ctx, &mem_133584, &mem_133584_cached_sizze_134260, bytes_133581);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133586_cached_sizze_134261 < bytes_133581) {
                err = lexical_realloc(ctx, &mem_133586, &mem_133586_cached_sizze_134261, bytes_133581);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (mem_133588_cached_sizze_134262 < bytes_133581) {
                err = lexical_realloc(ctx, &mem_133588, &mem_133588_cached_sizze_134262, bytes_133581);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int64_t discard_133342;
            int64_t scanacc_133332 = (int64_t) 0;
            
            for (int64_t i_133337 = 0; i_133337 < deepen_step_res_120905; i_133337++) {
                int64_t tmp_127954 = ((int64_t *) ext_mem_133580.mem)[i_133337];
                bool cond_127955 = slt64(i_133337, zl_rhs_126081);
                int64_t tmp_127956;
                
                if (cond_127955) {
                    int64_t tmp_128351 = add64((int64_t) 1, i_133337);
                    bool x_128352 = sle64((int64_t) 0, tmp_128351);
                    bool y_128353 = slt64(tmp_128351, deepen_step_res_120905);
                    bool bounds_check_128354 = x_128352 && y_128353;
                    bool index_certs_128355;
                    
                    if (!bounds_check_128354) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_128351, "] out of bounds for array of shape [", (long long) deepen_step_res_120905, "].", "-> #0  ftHashJoin.fut:271:67-81\n   #1  ftRelational.fut:229:5-88\n   #2  ftRelational.fut:218:1-230:31\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int64_t tmp_t_res_128356 = ((int64_t *) ext_mem_133580.mem)[tmp_128351];
                    
                    tmp_127956 = tmp_t_res_128356;
                } else {
                    tmp_127956 = dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741;
                }
                
                int64_t zg_lhs_127965 = sub64(tmp_127956, tmp_127954);
                bool lifted_lambda_res_127966 = slt64(sizze_thresh_113373, zg_lhs_127965);
                int64_t defunc_0_f_res_127967 = btoi_bool_i64(lifted_lambda_res_127966);
                int64_t defunc_0_op_res_120926 = add64(defunc_0_f_res_127967, scanacc_133332);
                
                ((int64_t *) mem_133582)[i_133337] = defunc_0_op_res_120926;
                ((int64_t *) mem_133584)[i_133337] = defunc_0_f_res_127967;
                ((int64_t *) mem_133586)[i_133337] = tmp_127954;
                ((int64_t *) mem_133588)[i_133337] = tmp_127956;
                
                int64_t scanacc_tmp_133924 = defunc_0_op_res_120926;
                
                scanacc_133332 = scanacc_tmp_133924;
            }
            discard_133342 = scanacc_133332;
            if (memblock_unref(ctx, &ext_mem_133580, "ext_mem_133580") != 0)
                return 1;
            
            bool cond_120927 = deepen_step_res_120905 == (int64_t) 0;
            bool x_120928 = !cond_120927;
            bool x_120930 = sle64((int64_t) 0, zl_rhs_126081);
            bool y_120931 = slt64(zl_rhs_126081, deepen_step_res_120905);
            bool bounds_check_120932 = x_120930 && y_120931;
            bool protect_assert_disj_120933 = cond_120927 || bounds_check_120932;
            bool index_certs_120934;
            
            if (!protect_assert_disj_120933) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zl_rhs_126081, "] out of bounds for array of shape [", (long long) deepen_step_res_120905, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:272:8-49\n   #3  ftRelational.fut:229:5-88\n   #4  ftRelational.fut:218:1-230:31\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t m_f_res_120935;
            
            if (x_120928) {
                int64_t x_128357 = ((int64_t *) mem_133582)[zl_rhs_126081];
                
                m_f_res_120935 = x_128357;
            } else {
                m_f_res_120935 = (int64_t) 0;
            }
            
            int64_t m_120937;
            
            if (cond_120927) {
                m_120937 = (int64_t) 0;
            } else {
                m_120937 = m_f_res_120935;
            }
            
            int64_t m_120947 = sub64(m_120937, (int64_t) 1);
            bool i_p_m_t_s_leq_w_120949 = slt64(m_120947, deepen_step_res_120905);
            bool zzero_leq_i_p_m_t_s_120948 = sle64((int64_t) 0, m_120947);
            bool y_120951 = zzero_leq_i_p_m_t_s_120948 && i_p_m_t_s_leq_w_120949;
            bool i_lte_j_120950 = sle64((int64_t) 0, m_120937);
            bool forwards_ok_120952 = i_lte_j_120950 && y_120951;
            bool eq_x_zz_120944 = (int64_t) 0 == m_f_res_120935;
            bool p_and_eq_x_y_120945 = x_120928 && eq_x_zz_120944;
            bool empty_slice_120946 = cond_120927 || p_and_eq_x_y_120945;
            bool ok_or_empty_120953 = empty_slice_120946 || forwards_ok_120952;
            bool index_certs_120954;
            
            if (!ok_or_empty_120953) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_120937, "] out of bounds for array of shape [", (long long) deepen_step_res_120905, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:272:8-49\n   #3  ftRelational.fut:229:5-88\n   #4  ftRelational.fut:218:1-230:31\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133613 = (int64_t) 8 * m_120937;
            int64_t conc_tmp_120976 = loop_dz2081Uz2089U_120734 + m_120937;
            int64_t bytes_133649 = (int64_t) 8 * conc_tmp_120976;
            
            if (mem_133614_cached_sizze_134263 < bytes_133613) {
                err = lexical_realloc(ctx, &mem_133614, &mem_133614_cached_sizze_134263, bytes_133613);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133614, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133588, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120937});
            if (mem_133616_cached_sizze_134264 < bytes_133613) {
                err = lexical_realloc(ctx, &mem_133616, &mem_133616_cached_sizze_134264, bytes_133613);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133616, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133586, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120937});
            for (int64_t write_iter_133343 = 0; write_iter_133343 < deepen_step_res_120905; write_iter_133343++) {
                int64_t write_iv_133346 = ((int64_t *) mem_133584)[write_iter_133343];
                int64_t write_iv_133347 = ((int64_t *) mem_133582)[write_iter_133343];
                int64_t write_iv_133348 = ((int64_t *) mem_133586)[write_iter_133343];
                int64_t write_iv_133349 = ((int64_t *) mem_133588)[write_iter_133343];
                bool cond_127936 = write_iv_133346 == (int64_t) 1;
                int64_t lifted_lambda_res_127937;
                
                if (cond_127936) {
                    int64_t lifted_lambda_res_t_res_128358 = sub64(write_iv_133347, (int64_t) 1);
                    
                    lifted_lambda_res_127937 = lifted_lambda_res_t_res_128358;
                } else {
                    lifted_lambda_res_127937 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_127937) && slt64(lifted_lambda_res_127937, m_120937)) {
                    ((int64_t *) mem_133616)[lifted_lambda_res_127937] = write_iv_133348;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_127937) && slt64(lifted_lambda_res_127937, m_120937)) {
                    ((int64_t *) mem_133614)[lifted_lambda_res_127937] = write_iv_133349;
                }
            }
            if (memblock_alloc(ctx, &mem_133630, bytes_133629, "mem_133630")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133630.mem, (int64_t) 0, (int64_t []) {b_113367, (int64_t) 1}, (uint8_t *) mem_param_133497.mem, (int64_t) 0, (int64_t []) {b_113367, (int64_t) 1}, (int64_t []) {n_113366, b_113367});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133630.mem, b_113367 * bounds_120739, (int64_t []) {b_113367, (int64_t) 1}, (uint8_t *) ext_mem_133575.mem, ext_133573, (int64_t []) {b_113367, (int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741, b_113367});
            if (memblock_unref(ctx, &ext_mem_133575, "ext_mem_133575") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_133632, bytes_133467, "mem_133632")) {
                err = 1;
                goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133632.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133493.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_113366});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133632.mem, bounds_120739, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133574.mem, ext_133570, (int64_t []) {(int64_t) 1}, (int64_t []) {dzlz7bUZLzmZRz20Uboundszi1z20Uboundszi0z7dUzg_120741});
            if (memblock_unref(ctx, &ext_mem_133574, "ext_mem_133574") != 0)
                return 1;
            if (memblock_alloc(ctx, &mem_133650, bytes_133649, "mem_133650")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_133652, bytes_133649, "mem_133652")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t i_133356 = 0; i_133356 < m_120937; i_133356++) {
                int64_t eta_p_120972 = ((int64_t *) mem_133616)[i_133356];
                int64_t eta_p_120973 = ((int64_t *) mem_133614)[i_133356];
                int64_t tmp_120974 = add64(bounds_120739, eta_p_120972);
                int64_t tmp_120975 = add64(bounds_120739, eta_p_120973);
                
                ((int64_t *) mem_133650.mem)[loop_dz2081Uz2089U_120734 + i_133356] = tmp_120974;
                ((int64_t *) mem_133652.mem)[loop_dz2081Uz2089U_120734 + i_133356] = tmp_120975;
            }
            
            int64_t tmp_offs_133933 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133650.mem, tmp_offs_133933, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133487.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2089U_120734});
            tmp_offs_133933 += loop_dz2081Uz2089U_120734;
            if (!(tmp_offs_133933 == loop_dz2081Uz2089U_120734)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133650.mem, tmp_offs_133933, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133650.mem, loop_dz2081Uz2089U_120734, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120937});
            }
            tmp_offs_133933 += m_120937;
            
            int64_t tmp_offs_133934 = (int64_t) 0;
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133652.mem, tmp_offs_133934, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133490.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {loop_dz2081Uz2089U_120734});
            tmp_offs_133934 += loop_dz2081Uz2089U_120734;
            if (!(tmp_offs_133934 == loop_dz2081Uz2089U_120734)) {
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_133652.mem, tmp_offs_133934, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133652.mem, loop_dz2081Uz2089U_120734, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120937});
            }
            tmp_offs_133934 += m_120937;
            if (memblock_set(ctx, &mem_param_tmp_133894, &mem_133650, "mem_133650") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133895, &mem_133652, "mem_133652") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133896, &mem_133632, "mem_133632") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_133897, &mem_133630, "mem_133630") != 0)
                return 1;
            
            int64_t loop_dz2081Uz2089U_tmp_133898 = conc_tmp_120976;
            
            if (memblock_set(ctx, &mem_param_133487, &mem_param_tmp_133894, "mem_param_tmp_133894") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133490, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133493, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_133497, &mem_param_tmp_133897, "mem_param_tmp_133897") != 0)
                return 1;
            loop_dz2081Uz2089U_120734 = loop_dz2081Uz2089U_tmp_133898;
        }
        if (memblock_set(ctx, &ext_mem_133665, &mem_param_133487, "mem_param_133487") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133664, &mem_param_133490, "mem_param_133490") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133663, &mem_param_133493, "mem_param_133493") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_133662, &mem_param_133497, "mem_param_133497") != 0)
            return 1;
        loopres_120728 = loop_dz2081Uz2089U_120734;
        
        bool cond_120980 = slt64((int64_t) 0, loopres_120728);
        bool loop_cond_t_res_120981 = slt32(newDepth_120759, max_depth_113374);
        bool x_120982 = cond_120980 && loop_cond_t_res_120981;
        
        if (memblock_set(ctx, &mem_param_tmp_133883, &ext_mem_133663, "ext_mem_133663") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133884, &ext_mem_133662, "ext_mem_133662") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133885, &ext_mem_133665, "ext_mem_133665") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133886, &ext_mem_133664, "ext_mem_133664") != 0)
            return 1;
        
        int64_t loop_dz2087U_tmp_133887 = loopres_120728;
        bool loop_while_tmp_133888 = x_120982;
        int32_t p_tmp_133889 = newDepth_120759;
        
        if (memblock_set(ctx, &mem_param_133474, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133478, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133481, &mem_param_tmp_133885, "mem_param_tmp_133885") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133484, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        loop_dz2087U_120721 = loop_dz2087U_tmp_133887;
        loop_while_120722 = loop_while_tmp_133888;
        p_120723 = p_tmp_133889;
    }
    if (memblock_set(ctx, &ext_mem_133678, &mem_param_133474, "mem_param_133474") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133677, &mem_param_133478, "mem_param_133478") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133676, &mem_param_133481, "mem_param_133481") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133675, &mem_param_133484, "mem_param_133484") != 0)
        return 1;
    partition_and_deepen_res_120714 = loop_dz2087U_120721;
    partition_and_deepen_res_120715 = loop_while_120722;
    partition_and_deepen_res_120716 = p_120723;
    if (memblock_unref(ctx, &mem_133468, "mem_133468") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133471, "mem_133471") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &ext_mem_133678, "ext_mem_133678") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &ext_mem_133677, "ext_mem_133677") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134253, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134254, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133511);
        free(mem_133544);
        free(mem_133546);
        free(mem_133554);
        free(mem_133582);
        free(mem_133584);
        free(mem_133586);
        free(mem_133588);
        free(mem_133614);
        free(mem_133616);
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133885, "mem_param_tmp_133885") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133884, "mem_param_tmp_133884") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133883, "mem_param_tmp_133883") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133897, "mem_param_tmp_133897") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133896, "mem_param_tmp_133896") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133895, "mem_param_tmp_133895") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133894, "mem_param_tmp_133894") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133652, "mem_133652") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133650, "mem_133650") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133632, "mem_133632") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133630, "mem_133630") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133579, "ext_mem_133579") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133580, "ext_mem_133580") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133577, "mem_133577") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133905, "mem_param_tmp_133905") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133904, "mem_param_tmp_133904") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133535, "mem_133535") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133533, "mem_133533") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133912, "mem_param_tmp_133912") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133522, "mem_133522") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133520, "mem_param_133520") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133531, "ext_mem_133531") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133506, "mem_param_133506") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133503, "mem_param_133503") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133574, "ext_mem_133574") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133575, "ext_mem_133575") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133497, "mem_param_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133493, "mem_param_133493") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133490, "mem_param_133490") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133487, "mem_param_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133662, "ext_mem_133662") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133663, "ext_mem_133663") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133664, "ext_mem_133664") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133665, "ext_mem_133665") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133484, "mem_param_133484") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133481, "mem_param_133481") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133478, "mem_param_133478") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133474, "mem_param_133474") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133675, "ext_mem_133675") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133676, "ext_mem_133676") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133677, "ext_mem_133677") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133678, "ext_mem_133678") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133471, "mem_133471") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133470, "mem_133470") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133468, "mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_double(struct futhark_context *ctx, struct memblock *mem_out_p_134265, struct memblock *mem_out_p_134266, struct memblock xs_mem_133466, int64_t n_87893, int64_t incr_87894, int16_t block_sizze_87895)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133476_cached_sizze_134267 = 0;
    unsigned char *mem_133476 = NULL;
    int64_t mem_133508_cached_sizze_134268 = 0;
    unsigned char *mem_133508 = NULL;
    int64_t mem_133510_cached_sizze_134269 = 0;
    unsigned char *mem_133510 = NULL;
    struct memblock mem_133538;
    
    mem_133538.references = NULL;
    
    struct memblock mem_133536;
    
    mem_133536.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_133498;
    
    mem_133498.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133496;
    
    ext_mem_133496.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133533;
    
    ext_mem_133533.references = NULL;
    
    struct memblock ext_mem_133534;
    
    ext_mem_133534.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_122895 = sext_i16_i64(block_sizze_87895);
    int64_t bytes_133468 = (int64_t) 8 * n_87893;
    bool zzero_122915 = i16_res_122895 == (int64_t) 0;
    bool nonzzero_122916 = !zzero_122915;
    bool nonzzero_cert_122919;
    
    if (!nonzzero_122916) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:143:98-101\n   #4  ftRelational.fut:132:75-86\n   #5  ftRelational.fut:131:9-132:87\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (futrts_indicesWithIncrement_11729(ctx, &ext_mem_133467, xs_mem_133466, n_87893, incr_87894) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_87893; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_122913 = add64(n_87893, i16_res_122895);
    int64_t zs_lhs_122914 = sub64(zm_lhs_122913, (int64_t) 1);
    int64_t m_122920 = sdiv_safe64(zs_lhs_122914, i16_res_122895);
    bool loop_cond_122921 = slt64((int64_t) 0, m_122920);
    
    if (mem_133476_cached_sizze_134267 < n_87893) {
        err = lexical_realloc(ctx, &mem_133476, &mem_133476_cached_sizze_134267, n_87893);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133475, &xs_mem_133466, "xs_mem_133466") != 0)
        return 1;
    for (int64_t i_122924 = 0; i_122924 < (int64_t) 32; i_122924++) {
        int32_t binop_x_122927 = sext_i64_i32(i_122924);
        int32_t binop_x_122928 = mul32(2, binop_x_122927);
        int32_t zm_lhs_122929 = add32(2, binop_x_122928);
        int32_t min_arg1_122930 = sub32(zm_lhs_122929, 1);
        int32_t min_res_122931 = smin32(64, min_arg1_122930);
        int32_t zp_lhs_122932 = sub32(min_res_122931, binop_x_122928);
        int32_t ij_bits_122933 = add32(1, zp_lhs_122932);
        int32_t up_to_122934 = shl32(1, ij_bits_122933);
        int64_t tmp_122935 = sext_i32_i64(zp_lhs_122932);
        bool bounds_invalid_upwards_122936 = slt32(zp_lhs_122932, 0);
        bool valid_122938 = !bounds_invalid_upwards_122936;
        bool range_valid_c_122939;
        
        if (!valid_122938) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_122935, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:53:58-60\n   #4  ftSMJ.fut:143:98-101\n   #5  ftRelational.fut:132:75-86\n   #6  ftRelational.fut:131:9-132:87\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_122963 = sext_i32_i64(up_to_122934);
        bool bounds_invalid_upwards_122964 = slt32(up_to_122934, 0);
        bool valid_122965 = !bounds_invalid_upwards_122964;
        bool range_valid_c_122966;
        
        if (!valid_122965) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_122963, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:143:98-101\n   #4  ftRelational.fut:132:75-86\n   #5  ftRelational.fut:131:9-132:87\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_122937 = add64((int64_t) 1, tmp_122935);
        
        for (int64_t i_133300 = 0; i_133300 < n_87893; i_133300++) {
            double eta_p_122941 = ((double *) mem_param_133475.mem)[i_133300];
            int64_t i64_arg0_122942 = futrts_to_bits64(eta_p_122941);
            int64_t unsign_arg0_122943 = ashr64(i64_arg0_122942, (int64_t) 63);
            int64_t unsign_arg0_122944 = (int64_t) 1 & unsign_arg0_122943;
            int32_t to_i32_res_122945 = zext_i64_i32(unsign_arg0_122944);
            bool cond_122946 = to_i32_res_122945 == 1;
            bool x_122947 = !cond_122946;
            int8_t defunc_0_f_res_122948;
            int8_t y_122950 = (int8_t) 0;
            
            for (int64_t i_122949 = 0; i_122949 < distance_122937; i_122949++) {
                int32_t binop_x_122951 = sext_i64_i32(i_122949);
                int32_t get_bit_arg0_122952 = add32(binop_x_122928, binop_x_122951);
                int64_t unsign_arg0_122953 = zext_i32_i64(get_bit_arg0_122952);
                int64_t unsign_arg0_122954 = ashr64(i64_arg0_122942, unsign_arg0_122953);
                int64_t unsign_arg0_122955 = (int64_t) 1 & unsign_arg0_122954;
                int32_t to_i32_res_122956 = zext_i64_i32(unsign_arg0_122955);
                bool cond_f_res_122957 = get_bit_arg0_122952 == 63;
                bool y_122958 = x_122947 && cond_f_res_122957;
                bool cond_122959 = cond_122946 || y_122958;
                int32_t defunc_0_get_bit_res_122960;
                
                if (cond_122959) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ to_i32_res_122956;
                    
                    defunc_0_get_bit_res_122960 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_122960 = to_i32_res_122956;
                }
                
                int8_t loopres_122962;
                
                if (futrts_set_bit_2464(ctx, &loopres_122962, binop_x_122951, y_122950, defunc_0_get_bit_res_122960) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_122962;
                
                y_122950 = y_tmp_133885;
            }
            defunc_0_f_res_122948 = y_122950;
            ((int8_t *) mem_133476)[i_133300] = defunc_0_f_res_122948;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_122967;
        int64_t offs_122970;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_122970 = (int64_t) 0;
        for (int64_t i_122969 = 0; i_122969 < up_to_122963; i_122969++) {
            int32_t binop_x_122972 = sext_i64_i32(i_122969);
            int8_t index_primexp_122973 = zext_i32_i8(binop_x_122972);
            
            if (memblock_alloc(ctx, &mem_133487, bytes_133468, "mem_133487")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_87893; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133476)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_122973;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133485.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_122970, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133487.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_122998 = add64(offs_122970, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133487, "mem_133487") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_122998;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_122970 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133496, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_122967 = offs_122970;
        if (memblock_alloc(ctx, &mem_133498, bytes_133468, "mem_133498")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_87893});
        if (memblock_alloc(ctx, &mem_133500, bytes_133468, "mem_133500")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_87893});
        
        bool partitioned_scatter_res_123005;
        int64_t partitioned_scatter_res_123008;
        bool loop_while_123009;
        int64_t p_123012;
        
        loop_while_123009 = loop_cond_122921;
        p_123012 = (int64_t) 0;
        while (loop_while_123009) {
            int64_t lower_bound_123013 = mul64(i16_res_122895, p_123012);
            int64_t min_arg1_123014 = add64(i16_res_122895, lower_bound_123013);
            int64_t min_res_123015 = smin64(n_87893, min_arg1_123014);
            int64_t j_m_i_123016 = sub64(min_res_123015, lower_bound_123013);
            bool empty_slice_123017 = j_m_i_123016 == (int64_t) 0;
            int64_t m_123018 = sub64(j_m_i_123016, (int64_t) 1);
            int64_t i_p_m_t_s_123019 = add64(lower_bound_123013, m_123018);
            bool zzero_leq_i_p_m_t_s_123020 = sle64((int64_t) 0, i_p_m_t_s_123019);
            bool i_p_m_t_s_leq_w_123021 = slt64(i_p_m_t_s_123019, n_87893);
            bool zzero_lte_i_123022 = sle64((int64_t) 0, lower_bound_123013);
            bool i_lte_j_123023 = sle64(lower_bound_123013, min_res_123015);
            bool y_123024 = i_p_m_t_s_leq_w_123021 && zzero_lte_i_123022;
            bool y_123025 = zzero_leq_i_p_m_t_s_123020 && y_123024;
            bool forwards_ok_123026 = i_lte_j_123023 && y_123025;
            bool ok_or_empty_123027 = empty_slice_123017 || forwards_ok_123026;
            bool index_certs_123028;
            
            if (!ok_or_empty_123027) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_123013, ":", (long long) min_res_123015, "] out of bounds for array of shape [", (long long) n_87893, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:143:98-101\n   #4  ftRelational.fut:132:75-86\n   #5  ftRelational.fut:131:9-132:87\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133507 = (int64_t) 8 * j_m_i_123016;
            
            if (mem_133508_cached_sizze_134268 < bytes_133507) {
                err = lexical_realloc(ctx, &mem_133508, &mem_133508_cached_sizze_134268, bytes_133507);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133498.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_123013, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123016});
            if (mem_133510_cached_sizze_134269 < bytes_133507) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134269, bytes_133507);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133500.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_123013, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123016});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_87893; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133496.mem)[write_iter_133320];
                int64_t write_iv_133324 = ((int64_t *) mem_param_133472.mem)[write_iter_133320];
                double write_iv_133325 = ((double *) mem_param_133475.mem)[write_iter_133320];
                bool cond_128220 = sle64(lower_bound_123013, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_123015);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_123013);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_123016)) {
                    ((int64_t *) mem_133508)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_123016)) {
                    ((double *) mem_133510)[lifted_lambda_res_128223] = write_iv_133325;
                }
            }
            
            int64_t tmp_123040 = add64((int64_t) 1, p_123012);
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, lower_bound_123013, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123016});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133500.mem, lower_bound_123013, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123016});
            
            bool loop_cond_123048 = slt64(tmp_123040, m_122920);
            bool loop_while_tmp_133892 = loop_cond_123048;
            int64_t p_tmp_133895 = tmp_123040;
            
            loop_while_123009 = loop_while_tmp_133892;
            p_123012 = p_tmp_133895;
        }
        partitioned_scatter_res_123005 = loop_while_123009;
        partitioned_scatter_res_123008 = p_123012;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133534, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133533, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133536, bytes_133468, "mem_133536")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133536.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133534.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_87893});
    if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133538, bytes_133468, "mem_133538")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133538.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133533.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_87893});
    if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133536, "mem_133536") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133538, "mem_133538") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134265, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134266, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133476);
        free(mem_133508);
        free(mem_133510);
        if (memblock_unref(ctx, &mem_133538, "mem_133538") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133536, "mem_133536") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_float(struct futhark_context *ctx, struct memblock *mem_out_p_134270, struct memblock *mem_out_p_134271, struct memblock xs_mem_133466, int64_t n_87004, int64_t incr_87005, int16_t block_sizze_87006)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133476_cached_sizze_134272 = 0;
    unsigned char *mem_133476 = NULL;
    int64_t mem_133508_cached_sizze_134273 = 0;
    unsigned char *mem_133508 = NULL;
    int64_t mem_133510_cached_sizze_134274 = 0;
    unsigned char *mem_133510 = NULL;
    struct memblock mem_133538;
    
    mem_133538.references = NULL;
    
    struct memblock mem_133536;
    
    mem_133536.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_133498;
    
    mem_133498.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133496;
    
    ext_mem_133496.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133533;
    
    ext_mem_133533.references = NULL;
    
    struct memblock ext_mem_133534;
    
    ext_mem_133534.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_122895 = sext_i16_i64(block_sizze_87006);
    int64_t bytes_133468 = (int64_t) 8 * n_87004;
    bool zzero_122914 = i16_res_122895 == (int64_t) 0;
    bool nonzzero_122915 = !zzero_122914;
    bool nonzzero_cert_122918;
    
    if (!nonzzero_122915) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:143:98-101\n   #4  ftRelational.fut:130:75-86\n   #5  ftRelational.fut:129:9-130:87\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133537 = (int64_t) 4 * n_87004;
    
    if (futrts_indicesWithIncrement_11708(ctx, &ext_mem_133467, xs_mem_133466, n_87004, incr_87005) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_87004; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_122912 = add64(n_87004, i16_res_122895);
    int64_t zs_lhs_122913 = sub64(zm_lhs_122912, (int64_t) 1);
    int64_t m_122919 = sdiv_safe64(zs_lhs_122913, i16_res_122895);
    bool loop_cond_122920 = slt64((int64_t) 0, m_122919);
    
    if (mem_133476_cached_sizze_134272 < n_87004) {
        err = lexical_realloc(ctx, &mem_133476, &mem_133476_cached_sizze_134272, n_87004);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133475, &xs_mem_133466, "xs_mem_133466") != 0)
        return 1;
    for (int64_t i_122923 = 0; i_122923 < (int64_t) 16; i_122923++) {
        int32_t binop_x_122926 = sext_i64_i32(i_122923);
        int32_t binop_x_122927 = mul32(2, binop_x_122926);
        int32_t zm_lhs_122928 = add32(2, binop_x_122927);
        int32_t min_arg1_122929 = sub32(zm_lhs_122928, 1);
        int32_t min_res_122930 = smin32(32, min_arg1_122929);
        int32_t zp_lhs_122931 = sub32(min_res_122930, binop_x_122927);
        int32_t ij_bits_122932 = add32(1, zp_lhs_122931);
        int32_t up_to_122933 = shl32(1, ij_bits_122932);
        int64_t tmp_122934 = sext_i32_i64(zp_lhs_122931);
        bool bounds_invalid_upwards_122935 = slt32(zp_lhs_122931, 0);
        bool valid_122937 = !bounds_invalid_upwards_122935;
        bool range_valid_c_122938;
        
        if (!valid_122937) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_122934, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:53:58-60\n   #4  ftSMJ.fut:143:98-101\n   #5  ftRelational.fut:130:75-86\n   #6  ftRelational.fut:129:9-130:87\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_122959 = sext_i32_i64(up_to_122933);
        bool bounds_invalid_upwards_122960 = slt32(up_to_122933, 0);
        bool valid_122961 = !bounds_invalid_upwards_122960;
        bool range_valid_c_122962;
        
        if (!valid_122961) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_122959, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:143:98-101\n   #4  ftRelational.fut:130:75-86\n   #5  ftRelational.fut:129:9-130:87\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_122936 = add64((int64_t) 1, tmp_122934);
        
        for (int64_t i_133300 = 0; i_133300 < n_87004; i_133300++) {
            float eta_p_122940 = ((float *) mem_param_133475.mem)[i_133300];
            int32_t i32_arg0_122941 = futrts_to_bits32(eta_p_122940);
            int32_t unsign_arg0_122942 = ashr32(i32_arg0_122941, 31);
            int32_t unsign_arg0_122943 = 1 & unsign_arg0_122942;
            bool cond_122944 = unsign_arg0_122943 == 1;
            bool x_122945 = !cond_122944;
            int8_t defunc_0_f_res_122946;
            int8_t y_122948 = (int8_t) 0;
            
            for (int64_t i_122947 = 0; i_122947 < distance_122936; i_122947++) {
                int32_t binop_x_122949 = sext_i64_i32(i_122947);
                int32_t get_bit_arg0_122950 = add32(binop_x_122927, binop_x_122949);
                int32_t unsign_arg0_122951 = ashr32(i32_arg0_122941, get_bit_arg0_122950);
                int32_t unsign_arg0_122952 = 1 & unsign_arg0_122951;
                bool cond_f_res_122953 = get_bit_arg0_122950 == 31;
                bool y_122954 = x_122945 && cond_f_res_122953;
                bool cond_122955 = cond_122944 || y_122954;
                int32_t defunc_0_get_bit_res_122956;
                
                if (cond_122955) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ unsign_arg0_122952;
                    
                    defunc_0_get_bit_res_122956 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_122956 = unsign_arg0_122952;
                }
                
                int8_t loopres_122958;
                
                if (futrts_set_bit_2464(ctx, &loopres_122958, binop_x_122949, y_122948, defunc_0_get_bit_res_122956) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_122958;
                
                y_122948 = y_tmp_133885;
            }
            defunc_0_f_res_122946 = y_122948;
            ((int8_t *) mem_133476)[i_133300] = defunc_0_f_res_122946;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_122963;
        int64_t offs_122966;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_122966 = (int64_t) 0;
        for (int64_t i_122965 = 0; i_122965 < up_to_122959; i_122965++) {
            int32_t binop_x_122968 = sext_i64_i32(i_122965);
            int8_t index_primexp_122969 = zext_i32_i8(binop_x_122968);
            
            if (memblock_alloc(ctx, &mem_133487, bytes_133468, "mem_133487")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_87004; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133476)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_122969;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133485.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_122966, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133487.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_122994 = add64(offs_122966, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133487, "mem_133487") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_122994;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_122966 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133496, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_122963 = offs_122966;
        if (memblock_alloc(ctx, &mem_133498, bytes_133468, "mem_133498")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_87004});
        if (memblock_alloc(ctx, &mem_133500, bytes_133537, "mem_133500")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_4b(ctx, 1, (uint32_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_87004});
        
        bool partitioned_scatter_res_123001;
        int64_t partitioned_scatter_res_123004;
        bool loop_while_123005;
        int64_t p_123008;
        
        loop_while_123005 = loop_cond_122920;
        p_123008 = (int64_t) 0;
        while (loop_while_123005) {
            int64_t lower_bound_123009 = mul64(i16_res_122895, p_123008);
            int64_t min_arg1_123010 = add64(i16_res_122895, lower_bound_123009);
            int64_t min_res_123011 = smin64(n_87004, min_arg1_123010);
            int64_t j_m_i_123012 = sub64(min_res_123011, lower_bound_123009);
            bool empty_slice_123013 = j_m_i_123012 == (int64_t) 0;
            int64_t m_123014 = sub64(j_m_i_123012, (int64_t) 1);
            int64_t i_p_m_t_s_123015 = add64(lower_bound_123009, m_123014);
            bool zzero_leq_i_p_m_t_s_123016 = sle64((int64_t) 0, i_p_m_t_s_123015);
            bool i_p_m_t_s_leq_w_123017 = slt64(i_p_m_t_s_123015, n_87004);
            bool zzero_lte_i_123018 = sle64((int64_t) 0, lower_bound_123009);
            bool i_lte_j_123019 = sle64(lower_bound_123009, min_res_123011);
            bool y_123020 = i_p_m_t_s_leq_w_123017 && zzero_lte_i_123018;
            bool y_123021 = zzero_leq_i_p_m_t_s_123016 && y_123020;
            bool forwards_ok_123022 = i_lte_j_123019 && y_123021;
            bool ok_or_empty_123023 = empty_slice_123013 || forwards_ok_123022;
            bool index_certs_123024;
            
            if (!ok_or_empty_123023) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_123009, ":", (long long) min_res_123011, "] out of bounds for array of shape [", (long long) n_87004, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:143:98-101\n   #4  ftRelational.fut:130:75-86\n   #5  ftRelational.fut:129:9-130:87\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133507 = (int64_t) 8 * j_m_i_123012;
            int64_t bytes_133509 = (int64_t) 4 * j_m_i_123012;
            
            if (mem_133508_cached_sizze_134273 < bytes_133507) {
                err = lexical_realloc(ctx, &mem_133508, &mem_133508_cached_sizze_134273, bytes_133507);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133498.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_123009, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123012});
            if (mem_133510_cached_sizze_134274 < bytes_133509) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134274, bytes_133509);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133500.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_123009, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123012});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_87004; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133496.mem)[write_iter_133320];
                int64_t write_iv_133324 = ((int64_t *) mem_param_133472.mem)[write_iter_133320];
                float write_iv_133325 = ((float *) mem_param_133475.mem)[write_iter_133320];
                bool cond_128220 = sle64(lower_bound_123009, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_123011);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_123009);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_123012)) {
                    ((int64_t *) mem_133508)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_123012)) {
                    ((float *) mem_133510)[lifted_lambda_res_128223] = write_iv_133325;
                }
            }
            
            int64_t tmp_123036 = add64((int64_t) 1, p_123008);
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, lower_bound_123009, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123012});
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133500.mem, lower_bound_123009, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123012});
            
            bool loop_cond_123044 = slt64(tmp_123036, m_122919);
            bool loop_while_tmp_133892 = loop_cond_123044;
            int64_t p_tmp_133895 = tmp_123036;
            
            loop_while_123005 = loop_while_tmp_133892;
            p_123008 = p_tmp_133895;
        }
        partitioned_scatter_res_123001 = loop_while_123005;
        partitioned_scatter_res_123004 = p_123008;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133534, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133533, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133536, bytes_133468, "mem_133536")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133536.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133534.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_87004});
    if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133538, bytes_133537, "mem_133538")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133538.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133533.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_87004});
    if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133536, "mem_133536") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133538, "mem_133538") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134270, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134271, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133476);
        free(mem_133508);
        free(mem_133510);
        if (memblock_unref(ctx, &mem_133538, "mem_133538") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133536, "mem_133536") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_int(struct futhark_context *ctx, struct memblock *mem_out_p_134275, struct memblock *mem_out_p_134276, struct memblock xs_mem_133466, int64_t n_85247, int64_t incr_85248, int16_t block_sizze_85249)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133476_cached_sizze_134277 = 0;
    unsigned char *mem_133476 = NULL;
    int64_t mem_133508_cached_sizze_134278 = 0;
    unsigned char *mem_133508 = NULL;
    int64_t mem_133510_cached_sizze_134279 = 0;
    unsigned char *mem_133510 = NULL;
    struct memblock mem_133538;
    
    mem_133538.references = NULL;
    
    struct memblock mem_133536;
    
    mem_133536.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_133498;
    
    mem_133498.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133496;
    
    ext_mem_133496.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133533;
    
    ext_mem_133533.references = NULL;
    
    struct memblock ext_mem_133534;
    
    ext_mem_133534.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_120709 = sext_i16_i64(block_sizze_85249);
    int64_t bytes_133468 = (int64_t) 8 * n_85247;
    bool zzero_120728 = i16_res_120709 == (int64_t) 0;
    bool nonzzero_120729 = !zzero_120728;
    bool nonzzero_cert_120732;
    
    if (!nonzzero_120729) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:132:96-99\n   #4  ftRelational.fut:126:78-89\n   #5  ftRelational.fut:125:9-126:90\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133537 = (int64_t) 4 * n_85247;
    
    if (futrts_indicesWithIncrement_11664(ctx, &ext_mem_133467, xs_mem_133466, n_85247, incr_85248) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_85247; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_120726 = add64(n_85247, i16_res_120709);
    int64_t zs_lhs_120727 = sub64(zm_lhs_120726, (int64_t) 1);
    int64_t m_120733 = sdiv_safe64(zs_lhs_120727, i16_res_120709);
    bool loop_cond_120734 = slt64((int64_t) 0, m_120733);
    
    if (mem_133476_cached_sizze_134277 < n_85247) {
        err = lexical_realloc(ctx, &mem_133476, &mem_133476_cached_sizze_134277, n_85247);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133475, &xs_mem_133466, "xs_mem_133466") != 0)
        return 1;
    for (int64_t i_120737 = 0; i_120737 < (int64_t) 16; i_120737++) {
        int32_t binop_x_120740 = sext_i64_i32(i_120737);
        int32_t binop_x_120741 = mul32(2, binop_x_120740);
        int32_t zm_lhs_120742 = add32(2, binop_x_120741);
        int32_t min_arg1_120743 = sub32(zm_lhs_120742, 1);
        int32_t min_res_120744 = smin32(32, min_arg1_120743);
        int32_t zp_lhs_120745 = sub32(min_res_120744, binop_x_120741);
        int32_t ij_bits_120746 = add32(1, zp_lhs_120745);
        int32_t up_to_120747 = shl32(1, ij_bits_120746);
        int64_t tmp_120748 = sext_i32_i64(zp_lhs_120745);
        bool bounds_invalid_upwards_120749 = slt32(zp_lhs_120745, 0);
        bool valid_120751 = !bounds_invalid_upwards_120749;
        bool range_valid_c_120752;
        
        if (!valid_120751) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_120748, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:32:58-60\n   #4  ftSMJ.fut:132:96-99\n   #5  ftRelational.fut:126:78-89\n   #6  ftRelational.fut:125:9-126:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_120765 = sext_i32_i64(up_to_120747);
        bool bounds_invalid_upwards_120766 = slt32(up_to_120747, 0);
        bool valid_120767 = !bounds_invalid_upwards_120766;
        bool range_valid_c_120768;
        
        if (!valid_120767) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_120765, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:132:96-99\n   #4  ftRelational.fut:126:78-89\n   #5  ftRelational.fut:125:9-126:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_120750 = add64((int64_t) 1, tmp_120748);
        
        for (int64_t i_133300 = 0; i_133300 < n_85247; i_133300++) {
            int32_t eta_p_120754 = ((int32_t *) mem_param_133475.mem)[i_133300];
            int8_t defunc_0_f_res_120755;
            int8_t y_120757 = (int8_t) 0;
            
            for (int64_t i_120756 = 0; i_120756 < distance_120750; i_120756++) {
                int32_t binop_x_120758 = sext_i64_i32(i_120756);
                int32_t get_bit_arg0_120759 = add32(binop_x_120741, binop_x_120758);
                int32_t zgzg_res_126074 = ashr32(eta_p_120754, get_bit_arg0_120759);
                int32_t za_res_126075 = 1 & zgzg_res_126074;
                bool cond_120761 = get_bit_arg0_120759 == 31;
                int32_t defunc_0_get_bit_res_120762;
                
                if (cond_120761) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ za_res_126075;
                    
                    defunc_0_get_bit_res_120762 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_120762 = za_res_126075;
                }
                
                int8_t loopres_120764;
                
                if (futrts_set_bit_2464(ctx, &loopres_120764, binop_x_120758, y_120757, defunc_0_get_bit_res_120762) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_120764;
                
                y_120757 = y_tmp_133885;
            }
            defunc_0_f_res_120755 = y_120757;
            ((int8_t *) mem_133476)[i_133300] = defunc_0_f_res_120755;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_120769;
        int64_t offs_120772;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_120772 = (int64_t) 0;
        for (int64_t i_120771 = 0; i_120771 < up_to_120765; i_120771++) {
            int32_t binop_x_120774 = sext_i64_i32(i_120771);
            int8_t index_primexp_120775 = zext_i32_i8(binop_x_120774);
            
            if (memblock_alloc(ctx, &mem_133487, bytes_133468, "mem_133487")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_85247; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133476)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_120775;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133485.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_120772, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133487.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_120800 = add64(offs_120772, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133487, "mem_133487") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_120800;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_120772 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133496, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_120769 = offs_120772;
        if (memblock_alloc(ctx, &mem_133498, bytes_133468, "mem_133498")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_85247});
        if (memblock_alloc(ctx, &mem_133500, bytes_133537, "mem_133500")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_4b(ctx, 1, (uint32_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_85247});
        
        bool partitioned_scatter_res_120807;
        int64_t partitioned_scatter_res_120810;
        bool loop_while_120811;
        int64_t p_120814;
        
        loop_while_120811 = loop_cond_120734;
        p_120814 = (int64_t) 0;
        while (loop_while_120811) {
            int64_t lower_bound_120815 = mul64(i16_res_120709, p_120814);
            int64_t min_arg1_120816 = add64(i16_res_120709, lower_bound_120815);
            int64_t min_res_120817 = smin64(n_85247, min_arg1_120816);
            int64_t j_m_i_120818 = sub64(min_res_120817, lower_bound_120815);
            bool empty_slice_120819 = j_m_i_120818 == (int64_t) 0;
            int64_t m_120820 = sub64(j_m_i_120818, (int64_t) 1);
            int64_t i_p_m_t_s_120821 = add64(lower_bound_120815, m_120820);
            bool zzero_leq_i_p_m_t_s_120822 = sle64((int64_t) 0, i_p_m_t_s_120821);
            bool i_p_m_t_s_leq_w_120823 = slt64(i_p_m_t_s_120821, n_85247);
            bool zzero_lte_i_120824 = sle64((int64_t) 0, lower_bound_120815);
            bool i_lte_j_120825 = sle64(lower_bound_120815, min_res_120817);
            bool y_120826 = i_p_m_t_s_leq_w_120823 && zzero_lte_i_120824;
            bool y_120827 = zzero_leq_i_p_m_t_s_120822 && y_120826;
            bool forwards_ok_120828 = i_lte_j_120825 && y_120827;
            bool ok_or_empty_120829 = empty_slice_120819 || forwards_ok_120828;
            bool index_certs_120830;
            
            if (!ok_or_empty_120829) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_120815, ":", (long long) min_res_120817, "] out of bounds for array of shape [", (long long) n_85247, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:132:96-99\n   #4  ftRelational.fut:126:78-89\n   #5  ftRelational.fut:125:9-126:90\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133507 = (int64_t) 8 * j_m_i_120818;
            int64_t bytes_133509 = (int64_t) 4 * j_m_i_120818;
            
            if (mem_133508_cached_sizze_134278 < bytes_133507) {
                err = lexical_realloc(ctx, &mem_133508, &mem_133508_cached_sizze_134278, bytes_133507);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133498.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120815, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            if (mem_133510_cached_sizze_134279 < bytes_133509) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134279, bytes_133509);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133500.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120815, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_85247; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133496.mem)[write_iter_133320];
                int64_t write_iv_133324 = ((int64_t *) mem_param_133472.mem)[write_iter_133320];
                int32_t write_iv_133325 = ((int32_t *) mem_param_133475.mem)[write_iter_133320];
                bool cond_128220 = sle64(lower_bound_120815, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_120817);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_120815);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120818)) {
                    ((int64_t *) mem_133508)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120818)) {
                    ((int32_t *) mem_133510)[lifted_lambda_res_128223] = write_iv_133325;
                }
            }
            
            int64_t tmp_120842 = add64((int64_t) 1, p_120814);
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, lower_bound_120815, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133500.mem, lower_bound_120815, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            
            bool loop_cond_120850 = slt64(tmp_120842, m_120733);
            bool loop_while_tmp_133892 = loop_cond_120850;
            int64_t p_tmp_133895 = tmp_120842;
            
            loop_while_120811 = loop_while_tmp_133892;
            p_120814 = p_tmp_133895;
        }
        partitioned_scatter_res_120807 = loop_while_120811;
        partitioned_scatter_res_120810 = p_120814;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133534, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133533, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133536, bytes_133468, "mem_133536")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133536.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133534.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_85247});
    if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133538, bytes_133537, "mem_133538")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133538.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133533.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_85247});
    if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133536, "mem_133536") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133538, "mem_133538") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134275, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134276, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133476);
        free(mem_133508);
        free(mem_133510);
        if (memblock_unref(ctx, &mem_133538, "mem_133538") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133536, "mem_133536") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_long(struct futhark_context *ctx, struct memblock *mem_out_p_134280, struct memblock *mem_out_p_134281, struct memblock xs_mem_133466, int64_t n_86115, int64_t incr_86116, int16_t block_sizze_86117)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133476_cached_sizze_134282 = 0;
    unsigned char *mem_133476 = NULL;
    int64_t mem_133508_cached_sizze_134283 = 0;
    unsigned char *mem_133508 = NULL;
    int64_t mem_133510_cached_sizze_134284 = 0;
    unsigned char *mem_133510 = NULL;
    struct memblock mem_133538;
    
    mem_133538.references = NULL;
    
    struct memblock mem_133536;
    
    mem_133536.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_133498;
    
    mem_133498.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133496;
    
    ext_mem_133496.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133533;
    
    ext_mem_133533.references = NULL;
    
    struct memblock ext_mem_133534;
    
    ext_mem_133534.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_120709 = sext_i16_i64(block_sizze_86117);
    int64_t bytes_133468 = (int64_t) 8 * n_86115;
    bool zzero_120728 = i16_res_120709 == (int64_t) 0;
    bool nonzzero_120729 = !zzero_120728;
    bool nonzzero_cert_120732;
    
    if (!nonzzero_120729) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:132:96-99\n   #4  ftRelational.fut:128:78-89\n   #5  ftRelational.fut:127:9-128:90\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    if (futrts_indicesWithIncrement_11686(ctx, &ext_mem_133467, xs_mem_133466, n_86115, incr_86116) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_86115; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_120726 = add64(n_86115, i16_res_120709);
    int64_t zs_lhs_120727 = sub64(zm_lhs_120726, (int64_t) 1);
    int64_t m_120733 = sdiv_safe64(zs_lhs_120727, i16_res_120709);
    bool loop_cond_120734 = slt64((int64_t) 0, m_120733);
    
    if (mem_133476_cached_sizze_134282 < n_86115) {
        err = lexical_realloc(ctx, &mem_133476, &mem_133476_cached_sizze_134282, n_86115);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133475, &xs_mem_133466, "xs_mem_133466") != 0)
        return 1;
    for (int64_t i_120737 = 0; i_120737 < (int64_t) 32; i_120737++) {
        int32_t binop_x_120740 = sext_i64_i32(i_120737);
        int32_t binop_x_120741 = mul32(2, binop_x_120740);
        int32_t zm_lhs_120742 = add32(2, binop_x_120741);
        int32_t min_arg1_120743 = sub32(zm_lhs_120742, 1);
        int32_t min_res_120744 = smin32(64, min_arg1_120743);
        int32_t zp_lhs_120745 = sub32(min_res_120744, binop_x_120741);
        int32_t ij_bits_120746 = add32(1, zp_lhs_120745);
        int32_t up_to_120747 = shl32(1, ij_bits_120746);
        int64_t tmp_120748 = sext_i32_i64(zp_lhs_120745);
        bool bounds_invalid_upwards_120749 = slt32(zp_lhs_120745, 0);
        bool valid_120751 = !bounds_invalid_upwards_120749;
        bool range_valid_c_120752;
        
        if (!valid_120751) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_120748, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:32:58-60\n   #4  ftSMJ.fut:132:96-99\n   #5  ftRelational.fut:128:78-89\n   #6  ftRelational.fut:127:9-128:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_120765 = sext_i32_i64(up_to_120747);
        bool bounds_invalid_upwards_120766 = slt32(up_to_120747, 0);
        bool valid_120767 = !bounds_invalid_upwards_120766;
        bool range_valid_c_120768;
        
        if (!valid_120767) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_120765, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:132:96-99\n   #4  ftRelational.fut:128:78-89\n   #5  ftRelational.fut:127:9-128:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_120750 = add64((int64_t) 1, tmp_120748);
        
        for (int64_t i_133300 = 0; i_133300 < n_86115; i_133300++) {
            int64_t eta_p_120754 = ((int64_t *) mem_param_133475.mem)[i_133300];
            int8_t defunc_0_f_res_120755;
            int8_t y_120757 = (int8_t) 0;
            
            for (int64_t i_120756 = 0; i_120756 < distance_120750; i_120756++) {
                int32_t binop_x_120758 = sext_i64_i32(i_120756);
                int32_t get_bit_arg0_120759 = add32(binop_x_120741, binop_x_120758);
                int32_t defunc_0_get_bit_res_120760;
                
                if (futrts_get_bit_2253(ctx, &defunc_0_get_bit_res_120760, get_bit_arg0_120759, eta_p_120754) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                bool cond_120761 = get_bit_arg0_120759 == 63;
                int32_t defunc_0_get_bit_res_120762;
                
                if (cond_120761) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ defunc_0_get_bit_res_120760;
                    
                    defunc_0_get_bit_res_120762 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_120762 = defunc_0_get_bit_res_120760;
                }
                
                int8_t loopres_120764;
                
                if (futrts_set_bit_2464(ctx, &loopres_120764, binop_x_120758, y_120757, defunc_0_get_bit_res_120762) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_120764;
                
                y_120757 = y_tmp_133885;
            }
            defunc_0_f_res_120755 = y_120757;
            ((int8_t *) mem_133476)[i_133300] = defunc_0_f_res_120755;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_120769;
        int64_t offs_120772;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_120772 = (int64_t) 0;
        for (int64_t i_120771 = 0; i_120771 < up_to_120765; i_120771++) {
            int32_t binop_x_120774 = sext_i64_i32(i_120771);
            int8_t index_primexp_120775 = zext_i32_i8(binop_x_120774);
            
            if (memblock_alloc(ctx, &mem_133487, bytes_133468, "mem_133487")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_86115; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133476)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_120775;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133485.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_120772, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133487.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_120800 = add64(offs_120772, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133487, "mem_133487") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_120800;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_120772 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133496, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_120769 = offs_120772;
        if (memblock_alloc(ctx, &mem_133498, bytes_133468, "mem_133498")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_86115});
        if (memblock_alloc(ctx, &mem_133500, bytes_133468, "mem_133500")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_86115});
        
        bool partitioned_scatter_res_120807;
        int64_t partitioned_scatter_res_120810;
        bool loop_while_120811;
        int64_t p_120814;
        
        loop_while_120811 = loop_cond_120734;
        p_120814 = (int64_t) 0;
        while (loop_while_120811) {
            int64_t lower_bound_120815 = mul64(i16_res_120709, p_120814);
            int64_t min_arg1_120816 = add64(i16_res_120709, lower_bound_120815);
            int64_t min_res_120817 = smin64(n_86115, min_arg1_120816);
            int64_t j_m_i_120818 = sub64(min_res_120817, lower_bound_120815);
            bool empty_slice_120819 = j_m_i_120818 == (int64_t) 0;
            int64_t m_120820 = sub64(j_m_i_120818, (int64_t) 1);
            int64_t i_p_m_t_s_120821 = add64(lower_bound_120815, m_120820);
            bool zzero_leq_i_p_m_t_s_120822 = sle64((int64_t) 0, i_p_m_t_s_120821);
            bool i_p_m_t_s_leq_w_120823 = slt64(i_p_m_t_s_120821, n_86115);
            bool zzero_lte_i_120824 = sle64((int64_t) 0, lower_bound_120815);
            bool i_lte_j_120825 = sle64(lower_bound_120815, min_res_120817);
            bool y_120826 = i_p_m_t_s_leq_w_120823 && zzero_lte_i_120824;
            bool y_120827 = zzero_leq_i_p_m_t_s_120822 && y_120826;
            bool forwards_ok_120828 = i_lte_j_120825 && y_120827;
            bool ok_or_empty_120829 = empty_slice_120819 || forwards_ok_120828;
            bool index_certs_120830;
            
            if (!ok_or_empty_120829) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_120815, ":", (long long) min_res_120817, "] out of bounds for array of shape [", (long long) n_86115, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:132:96-99\n   #4  ftRelational.fut:128:78-89\n   #5  ftRelational.fut:127:9-128:90\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133507 = (int64_t) 8 * j_m_i_120818;
            
            if (mem_133508_cached_sizze_134283 < bytes_133507) {
                err = lexical_realloc(ctx, &mem_133508, &mem_133508_cached_sizze_134283, bytes_133507);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133498.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120815, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            if (mem_133510_cached_sizze_134284 < bytes_133507) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134284, bytes_133507);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133500.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120815, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_86115; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133496.mem)[write_iter_133320];
                int64_t write_iv_133324 = ((int64_t *) mem_param_133472.mem)[write_iter_133320];
                int64_t write_iv_133325 = ((int64_t *) mem_param_133475.mem)[write_iter_133320];
                bool cond_128220 = sle64(lower_bound_120815, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_120817);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_120815);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120818)) {
                    ((int64_t *) mem_133508)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120818)) {
                    ((int64_t *) mem_133510)[lifted_lambda_res_128223] = write_iv_133325;
                }
            }
            
            int64_t tmp_120842 = add64((int64_t) 1, p_120814);
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, lower_bound_120815, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133500.mem, lower_bound_120815, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            
            bool loop_cond_120850 = slt64(tmp_120842, m_120733);
            bool loop_while_tmp_133892 = loop_cond_120850;
            int64_t p_tmp_133895 = tmp_120842;
            
            loop_while_120811 = loop_while_tmp_133892;
            p_120814 = p_tmp_133895;
        }
        partitioned_scatter_res_120807 = loop_while_120811;
        partitioned_scatter_res_120810 = p_120814;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133534, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133533, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133536, bytes_133468, "mem_133536")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133536.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133534.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_86115});
    if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133538, bytes_133468, "mem_133538")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133538.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133533.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_86115});
    if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133536, "mem_133536") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133538, "mem_133538") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134280, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134281, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133476);
        free(mem_133508);
        free(mem_133510);
        if (memblock_unref(ctx, &mem_133538, "mem_133538") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133536, "mem_133536") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortColumn_short(struct futhark_context *ctx, struct memblock *mem_out_p_134285, struct memblock *mem_out_p_134286, struct memblock xs_mem_133466, int64_t n_84379, int64_t incr_84380, int16_t block_sizze_84381)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133476_cached_sizze_134287 = 0;
    unsigned char *mem_133476 = NULL;
    int64_t mem_133508_cached_sizze_134288 = 0;
    unsigned char *mem_133508 = NULL;
    int64_t mem_133510_cached_sizze_134289 = 0;
    unsigned char *mem_133510 = NULL;
    struct memblock mem_133538;
    
    mem_133538.references = NULL;
    
    struct memblock mem_133536;
    
    mem_133536.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133500;
    
    mem_133500.references = NULL;
    
    struct memblock mem_133498;
    
    mem_133498.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133487;
    
    mem_133487.references = NULL;
    
    struct memblock mem_param_133485;
    
    mem_param_133485.references = NULL;
    
    struct memblock ext_mem_133496;
    
    ext_mem_133496.references = NULL;
    
    struct memblock mem_param_133475;
    
    mem_param_133475.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133533;
    
    ext_mem_133533.references = NULL;
    
    struct memblock ext_mem_133534;
    
    ext_mem_133534.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock ext_mem_133467;
    
    ext_mem_133467.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_120709 = sext_i16_i64(block_sizze_84381);
    int64_t bytes_133468 = (int64_t) 8 * n_84379;
    bool zzero_120728 = i16_res_120709 == (int64_t) 0;
    bool nonzzero_120729 = !zzero_120728;
    bool nonzzero_cert_120732;
    
    if (!nonzzero_120729) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:132:96-99\n   #4  ftRelational.fut:124:78-89\n   #5  ftRelational.fut:123:9-124:90\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133537 = (int64_t) 2 * n_84379;
    
    if (futrts_indicesWithIncrement_11643(ctx, &ext_mem_133467, xs_mem_133466, n_84379, incr_84380) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_84379; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_120726 = add64(n_84379, i16_res_120709);
    int64_t zs_lhs_120727 = sub64(zm_lhs_120726, (int64_t) 1);
    int64_t m_120733 = sdiv_safe64(zs_lhs_120727, i16_res_120709);
    bool loop_cond_120734 = slt64((int64_t) 0, m_120733);
    
    if (mem_133476_cached_sizze_134287 < n_84379) {
        err = lexical_realloc(ctx, &mem_133476, &mem_133476_cached_sizze_134287, n_84379);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133475, &xs_mem_133466, "xs_mem_133466") != 0)
        return 1;
    for (int64_t i_120737 = 0; i_120737 < (int64_t) 8; i_120737++) {
        int32_t binop_x_120740 = sext_i64_i32(i_120737);
        int32_t binop_x_120741 = mul32(2, binop_x_120740);
        int32_t zm_lhs_120742 = add32(2, binop_x_120741);
        int32_t min_arg1_120743 = sub32(zm_lhs_120742, 1);
        int32_t min_res_120744 = smin32(16, min_arg1_120743);
        int32_t zp_lhs_120745 = sub32(min_res_120744, binop_x_120741);
        int32_t ij_bits_120746 = add32(1, zp_lhs_120745);
        int32_t up_to_120747 = shl32(1, ij_bits_120746);
        int64_t tmp_120748 = sext_i32_i64(zp_lhs_120745);
        bool bounds_invalid_upwards_120749 = slt32(zp_lhs_120745, 0);
        bool valid_120751 = !bounds_invalid_upwards_120749;
        bool range_valid_c_120752;
        
        if (!valid_120751) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_120748, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:32:58-60\n   #4  ftSMJ.fut:132:96-99\n   #5  ftRelational.fut:124:78-89\n   #6  ftRelational.fut:123:9-124:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_120765 = sext_i32_i64(up_to_120747);
        bool bounds_invalid_upwards_120766 = slt32(up_to_120747, 0);
        bool valid_120767 = !bounds_invalid_upwards_120766;
        bool range_valid_c_120768;
        
        if (!valid_120767) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_120765, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:132:96-99\n   #4  ftRelational.fut:124:78-89\n   #5  ftRelational.fut:123:9-124:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_120750 = add64((int64_t) 1, tmp_120748);
        
        for (int64_t i_133300 = 0; i_133300 < n_84379; i_133300++) {
            int16_t eta_p_120754 = ((int16_t *) mem_param_133475.mem)[i_133300];
            int8_t defunc_0_f_res_120755;
            int8_t y_120757 = (int8_t) 0;
            
            for (int64_t i_120756 = 0; i_120756 < distance_120750; i_120756++) {
                int32_t binop_x_120758 = sext_i64_i32(i_120756);
                int32_t get_bit_arg0_120759 = add32(binop_x_120741, binop_x_120758);
                int32_t defunc_0_get_bit_res_120760;
                
                if (futrts_get_bit_1844(ctx, &defunc_0_get_bit_res_120760, get_bit_arg0_120759, eta_p_120754) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                bool cond_120761 = get_bit_arg0_120759 == 15;
                int32_t defunc_0_get_bit_res_120762;
                
                if (cond_120761) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ defunc_0_get_bit_res_120760;
                    
                    defunc_0_get_bit_res_120762 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_120762 = defunc_0_get_bit_res_120760;
                }
                
                int8_t loopres_120764;
                
                if (futrts_set_bit_2464(ctx, &loopres_120764, binop_x_120758, y_120757, defunc_0_get_bit_res_120762) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_120764;
                
                y_120757 = y_tmp_133885;
            }
            defunc_0_f_res_120755 = y_120757;
            ((int8_t *) mem_133476)[i_133300] = defunc_0_f_res_120755;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_120769;
        int64_t offs_120772;
        
        if (memblock_set(ctx, &mem_param_133485, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_120772 = (int64_t) 0;
        for (int64_t i_120771 = 0; i_120771 < up_to_120765; i_120771++) {
            int32_t binop_x_120774 = sext_i64_i32(i_120771);
            int8_t index_primexp_120775 = zext_i32_i8(binop_x_120774);
            
            if (memblock_alloc(ctx, &mem_133487, bytes_133468, "mem_133487")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_84379; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133476)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_120775;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133485.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_120772, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133487.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_120800 = add64(offs_120772, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133487, "mem_133487") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_120800;
            
            if (memblock_set(ctx, &mem_param_133485, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_120772 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133496, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_120769 = offs_120772;
        if (memblock_alloc(ctx, &mem_133498, bytes_133468, "mem_133498")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_84379});
        if (memblock_alloc(ctx, &mem_133500, bytes_133537, "mem_133500")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_2b(ctx, 1, (uint16_t *) mem_133500.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint16_t *) mem_param_133475.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_84379});
        
        bool partitioned_scatter_res_120807;
        int64_t partitioned_scatter_res_120810;
        bool loop_while_120811;
        int64_t p_120814;
        
        loop_while_120811 = loop_cond_120734;
        p_120814 = (int64_t) 0;
        while (loop_while_120811) {
            int64_t lower_bound_120815 = mul64(i16_res_120709, p_120814);
            int64_t min_arg1_120816 = add64(i16_res_120709, lower_bound_120815);
            int64_t min_res_120817 = smin64(n_84379, min_arg1_120816);
            int64_t j_m_i_120818 = sub64(min_res_120817, lower_bound_120815);
            bool empty_slice_120819 = j_m_i_120818 == (int64_t) 0;
            int64_t m_120820 = sub64(j_m_i_120818, (int64_t) 1);
            int64_t i_p_m_t_s_120821 = add64(lower_bound_120815, m_120820);
            bool zzero_leq_i_p_m_t_s_120822 = sle64((int64_t) 0, i_p_m_t_s_120821);
            bool i_p_m_t_s_leq_w_120823 = slt64(i_p_m_t_s_120821, n_84379);
            bool zzero_lte_i_120824 = sle64((int64_t) 0, lower_bound_120815);
            bool i_lte_j_120825 = sle64(lower_bound_120815, min_res_120817);
            bool y_120826 = i_p_m_t_s_leq_w_120823 && zzero_lte_i_120824;
            bool y_120827 = zzero_leq_i_p_m_t_s_120822 && y_120826;
            bool forwards_ok_120828 = i_lte_j_120825 && y_120827;
            bool ok_or_empty_120829 = empty_slice_120819 || forwards_ok_120828;
            bool index_certs_120830;
            
            if (!ok_or_empty_120829) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_120815, ":", (long long) min_res_120817, "] out of bounds for array of shape [", (long long) n_84379, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:132:96-99\n   #4  ftRelational.fut:124:78-89\n   #5  ftRelational.fut:123:9-124:90\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133507 = (int64_t) 8 * j_m_i_120818;
            int64_t bytes_133509 = (int64_t) 2 * j_m_i_120818;
            
            if (mem_133508_cached_sizze_134288 < bytes_133507) {
                err = lexical_realloc(ctx, &mem_133508, &mem_133508_cached_sizze_134288, bytes_133507);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133498.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120815, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            if (mem_133510_cached_sizze_134289 < bytes_133509) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134289, bytes_133509);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_2b(ctx, 1, (uint16_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint16_t *) mem_133500.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120815, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_84379; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133496.mem)[write_iter_133320];
                int64_t write_iv_133324 = ((int64_t *) mem_param_133472.mem)[write_iter_133320];
                int16_t write_iv_133325 = ((int16_t *) mem_param_133475.mem)[write_iter_133320];
                bool cond_128220 = sle64(lower_bound_120815, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_120817);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_120815);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120818)) {
                    ((int64_t *) mem_133508)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120818)) {
                    ((int16_t *) mem_133510)[lifted_lambda_res_128223] = write_iv_133325;
                }
            }
            
            int64_t tmp_120842 = add64((int64_t) 1, p_120814);
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133498.mem, lower_bound_120815, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133508, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            lmad_copy_2b(ctx, 1, (uint16_t *) mem_133500.mem, lower_bound_120815, (int64_t []) {(int64_t) 1}, (uint16_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120818});
            
            bool loop_cond_120850 = slt64(tmp_120842, m_120733);
            bool loop_while_tmp_133892 = loop_cond_120850;
            int64_t p_tmp_133895 = tmp_120842;
            
            loop_while_120811 = loop_while_tmp_133892;
            p_120814 = p_tmp_133895;
        }
        partitioned_scatter_res_120807 = loop_while_120811;
        partitioned_scatter_res_120810 = p_120814;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133475, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133534, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133533, &mem_param_133475, "mem_param_133475") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133536, bytes_133468, "mem_133536")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133536.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133534.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_84379});
    if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133538, bytes_133537, "mem_133538")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_2b(ctx, 1, (uint16_t *) mem_133538.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint16_t *) ext_mem_133533.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_84379});
    if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133536, "mem_133536") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133538, "mem_133538") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134285, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134286, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133476);
        free(mem_133508);
        free(mem_133510);
        if (memblock_unref(ctx, &mem_133538, "mem_133538") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133536, "mem_133536") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133500, "mem_133500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133498, "mem_133498") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133487, "mem_133487") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133485, "mem_param_133485") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133496, "ext_mem_133496") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133475, "mem_param_133475") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133533, "ext_mem_133533") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133534, "ext_mem_133534") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133467, "ext_mem_133467") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_double(struct futhark_context *ctx, struct memblock *mem_out_p_134290, struct memblock *mem_out_p_134291, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_71590, int64_t b_71591, int16_t block_sizze_71592)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133477_cached_sizze_134292 = 0;
    unsigned char *mem_133477 = NULL;
    int64_t mem_133510_cached_sizze_134293 = 0;
    unsigned char *mem_133510 = NULL;
    int64_t mem_133512_cached_sizze_134294 = 0;
    unsigned char *mem_133512 = NULL;
    int64_t mem_133520_cached_sizze_134295 = 0;
    unsigned char *mem_133520 = NULL;
    struct memblock mem_133545;
    
    mem_133545.references = NULL;
    
    struct memblock mem_133543;
    
    mem_133543.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_133499;
    
    mem_133499.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133488;
    
    mem_133488.references = NULL;
    
    struct memblock mem_param_133486;
    
    mem_param_133486.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock mem_param_133476;
    
    mem_param_133476.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133540;
    
    ext_mem_133540.references = NULL;
    
    struct memblock ext_mem_133541;
    
    ext_mem_133541.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_122889 = sext_i16_i64(block_sizze_71592);
    int64_t bytes_133468 = (int64_t) 8 * n_71590;
    bool zzero_122909 = i16_res_122889 == (int64_t) 0;
    bool nonzzero_122910 = !zzero_122909;
    bool nonzzero_cert_122913;
    
    if (!nonzzero_122910) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:97:98-101\n   #4  ftRelational.fut:96:78-89\n   #5  ftRelational.fut:92:9-96:90\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133544 = n_71590 * b_71591;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_71590; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_122907 = add64(n_71590, i16_res_122889);
    int64_t zs_lhs_122908 = sub64(zm_lhs_122907, (int64_t) 1);
    int64_t m_122914 = sdiv_safe64(zs_lhs_122908, i16_res_122889);
    bool loop_cond_122915 = slt64((int64_t) 0, m_122914);
    
    if (mem_133477_cached_sizze_134292 < n_71590) {
        err = lexical_realloc(ctx, &mem_133477, &mem_133477_cached_sizze_134292, n_71590);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133520_cached_sizze_134295 < b_71591) {
        err = lexical_realloc(ctx, &mem_133520, &mem_133520_cached_sizze_134295, b_71591);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &k_mem_133466, "k_mem_133466") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133476, &pL_mem_133467, "pL_mem_133467") != 0)
        return 1;
    for (int64_t i_122918 = 0; i_122918 < (int64_t) 32; i_122918++) {
        int32_t binop_x_122921 = sext_i64_i32(i_122918);
        int32_t binop_x_122922 = mul32(2, binop_x_122921);
        int32_t zm_lhs_122923 = add32(2, binop_x_122922);
        int32_t min_arg1_122924 = sub32(zm_lhs_122923, 1);
        int32_t min_res_122925 = smin32(64, min_arg1_122924);
        int32_t zp_lhs_122926 = sub32(min_res_122925, binop_x_122922);
        int32_t ij_bits_122927 = add32(1, zp_lhs_122926);
        int32_t up_to_122928 = shl32(1, ij_bits_122927);
        int64_t tmp_122929 = sext_i32_i64(zp_lhs_122926);
        bool bounds_invalid_upwards_122930 = slt32(zp_lhs_122926, 0);
        bool valid_122932 = !bounds_invalid_upwards_122930;
        bool range_valid_c_122933;
        
        if (!valid_122932) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_122929, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:53:58-60\n   #4  ftSMJ.fut:97:98-101\n   #5  ftRelational.fut:96:78-89\n   #6  ftRelational.fut:92:9-96:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_122957 = sext_i32_i64(up_to_122928);
        bool bounds_invalid_upwards_122958 = slt32(up_to_122928, 0);
        bool valid_122959 = !bounds_invalid_upwards_122958;
        bool range_valid_c_122960;
        
        if (!valid_122959) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_122957, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:97:98-101\n   #4  ftRelational.fut:96:78-89\n   #5  ftRelational.fut:92:9-96:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_122931 = add64((int64_t) 1, tmp_122929);
        
        for (int64_t i_133300 = 0; i_133300 < n_71590; i_133300++) {
            double eta_p_122935 = ((double *) mem_param_133472.mem)[i_133300];
            int64_t i64_arg0_122936 = futrts_to_bits64(eta_p_122935);
            int64_t unsign_arg0_122937 = ashr64(i64_arg0_122936, (int64_t) 63);
            int64_t unsign_arg0_122938 = (int64_t) 1 & unsign_arg0_122937;
            int32_t to_i32_res_122939 = zext_i64_i32(unsign_arg0_122938);
            bool cond_122940 = to_i32_res_122939 == 1;
            bool x_122941 = !cond_122940;
            int8_t defunc_0_f_res_122942;
            int8_t y_122944 = (int8_t) 0;
            
            for (int64_t i_122943 = 0; i_122943 < distance_122931; i_122943++) {
                int32_t binop_x_122945 = sext_i64_i32(i_122943);
                int32_t get_bit_arg0_122946 = add32(binop_x_122922, binop_x_122945);
                int64_t unsign_arg0_122947 = zext_i32_i64(get_bit_arg0_122946);
                int64_t unsign_arg0_122948 = ashr64(i64_arg0_122936, unsign_arg0_122947);
                int64_t unsign_arg0_122949 = (int64_t) 1 & unsign_arg0_122948;
                int32_t to_i32_res_122950 = zext_i64_i32(unsign_arg0_122949);
                bool cond_f_res_122951 = get_bit_arg0_122946 == 63;
                bool y_122952 = x_122941 && cond_f_res_122951;
                bool cond_122953 = cond_122940 || y_122952;
                int32_t defunc_0_get_bit_res_122954;
                
                if (cond_122953) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ to_i32_res_122950;
                    
                    defunc_0_get_bit_res_122954 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_122954 = to_i32_res_122950;
                }
                
                int8_t loopres_122956;
                
                if (futrts_set_bit_2464(ctx, &loopres_122956, binop_x_122945, y_122944, defunc_0_get_bit_res_122954) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_122956;
                
                y_122944 = y_tmp_133885;
            }
            defunc_0_f_res_122942 = y_122944;
            ((int8_t *) mem_133477)[i_133300] = defunc_0_f_res_122942;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_122961;
        int64_t offs_122964;
        
        if (memblock_set(ctx, &mem_param_133486, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_122964 = (int64_t) 0;
        for (int64_t i_122963 = 0; i_122963 < up_to_122957; i_122963++) {
            int32_t binop_x_122966 = sext_i64_i32(i_122963);
            int8_t index_primexp_122967 = zext_i32_i8(binop_x_122966);
            
            if (memblock_alloc(ctx, &mem_133488, bytes_133468, "mem_133488")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_71590; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133477)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_122967;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133486.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_122964, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133488.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_122992 = add64(offs_122964, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133488, "mem_133488") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_122992;
            
            if (memblock_set(ctx, &mem_param_133486, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_122964 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133497, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_122961 = offs_122964;
        if (memblock_alloc(ctx, &mem_133499, bytes_133468, "mem_133499")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133499.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_71590});
        if (memblock_alloc(ctx, &mem_133501, bytes_133544, "mem_133501")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {b_71591, (int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0, (int64_t []) {b_71591, (int64_t) 1}, (int64_t []) {n_71590, b_71591});
        
        bool partitioned_scatter_res_122999;
        int64_t partitioned_scatter_res_123002;
        bool loop_while_123003;
        int64_t p_123006;
        
        loop_while_123003 = loop_cond_122915;
        p_123006 = (int64_t) 0;
        while (loop_while_123003) {
            int64_t lower_bound_123007 = mul64(i16_res_122889, p_123006);
            int64_t min_arg1_123008 = add64(i16_res_122889, lower_bound_123007);
            int64_t min_res_123009 = smin64(n_71590, min_arg1_123008);
            int64_t j_m_i_123010 = sub64(min_res_123009, lower_bound_123007);
            bool empty_slice_123011 = j_m_i_123010 == (int64_t) 0;
            int64_t m_123012 = sub64(j_m_i_123010, (int64_t) 1);
            int64_t i_p_m_t_s_123013 = add64(lower_bound_123007, m_123012);
            bool zzero_leq_i_p_m_t_s_123014 = sle64((int64_t) 0, i_p_m_t_s_123013);
            bool i_p_m_t_s_leq_w_123015 = slt64(i_p_m_t_s_123013, n_71590);
            bool zzero_lte_i_123016 = sle64((int64_t) 0, lower_bound_123007);
            bool i_lte_j_123017 = sle64(lower_bound_123007, min_res_123009);
            bool y_123018 = i_p_m_t_s_leq_w_123015 && zzero_lte_i_123016;
            bool y_123019 = zzero_leq_i_p_m_t_s_123014 && y_123018;
            bool forwards_ok_123020 = i_lte_j_123017 && y_123019;
            bool ok_or_empty_123021 = empty_slice_123011 || forwards_ok_123020;
            bool index_certs_123022;
            
            if (!ok_or_empty_123021) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_123007, ":", (long long) min_res_123009, "] out of bounds for array of shape [", (long long) n_71590, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:97:98-101\n   #4  ftRelational.fut:96:78-89\n   #5  ftRelational.fut:92:9-96:90\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133509 = (int64_t) 8 * j_m_i_123010;
            int64_t bytes_133511 = b_71591 * j_m_i_123010;
            
            if (mem_133510_cached_sizze_134293 < bytes_133509) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134293, bytes_133509);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133499.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_123007, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123010});
            if (mem_133512_cached_sizze_134294 < bytes_133511) {
                err = lexical_realloc(ctx, &mem_133512, &mem_133512_cached_sizze_134294, bytes_133511);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_71591, (int64_t) 1}, (uint8_t *) mem_133501.mem, (int64_t) 0 + b_71591 * lower_bound_123007, (int64_t []) {b_71591, (int64_t) 1}, (int64_t []) {j_m_i_123010, b_71591});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_71590; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133497.mem)[write_iter_133320];
                double write_iv_133324 = ((double *) mem_param_133472.mem)[write_iter_133320];
                
                lmad_copy_1b(ctx, 1, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0 + write_iter_133320 * b_71591, (int64_t []) {(int64_t) 1}, (int64_t []) {b_71591});
                
                bool cond_128220 = sle64(lower_bound_123007, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_123009);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_123007);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_123010)) {
                    ((double *) mem_133510)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if ((sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_123010)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(b_71591 - (int64_t) 1, b_71591))) {
                    lmad_copy_1b(ctx, 1, (uint8_t *) mem_133512, lifted_lambda_res_128223 * b_71591, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_71591});
                }
            }
            
            int64_t tmp_123034 = add64((int64_t) 1, p_123006);
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133499.mem, lower_bound_123007, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123010});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, b_71591 * lower_bound_123007, (int64_t []) {b_71591, (int64_t) 1}, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_71591, (int64_t) 1}, (int64_t []) {j_m_i_123010, b_71591});
            
            bool loop_cond_123042 = slt64(tmp_123034, m_122914);
            bool loop_while_tmp_133892 = loop_cond_123042;
            int64_t p_tmp_133895 = tmp_123034;
            
            loop_while_123003 = loop_while_tmp_133892;
            p_123006 = p_tmp_133895;
        }
        partitioned_scatter_res_122999 = loop_while_123003;
        partitioned_scatter_res_123002 = p_123006;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133476, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133541, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133540, &mem_param_133476, "mem_param_133476") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133543, bytes_133468, "mem_133543")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133543.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133541.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_71590});
    if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133545, bytes_133544, "mem_133545")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133545.mem, (int64_t) 0, (int64_t []) {b_71591, (int64_t) 1}, (uint8_t *) ext_mem_133540.mem, (int64_t) 0, (int64_t []) {b_71591, (int64_t) 1}, (int64_t []) {n_71590, b_71591});
    if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133543, "mem_133543") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133545, "mem_133545") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134290, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134291, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133477);
        free(mem_133510);
        free(mem_133512);
        free(mem_133520);
        if (memblock_unref(ctx, &mem_133545, "mem_133545") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133543, "mem_133543") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133488, "mem_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133476, "mem_param_133476") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_float(struct futhark_context *ctx, struct memblock *mem_out_p_134296, struct memblock *mem_out_p_134297, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_70640, int64_t b_70641, int16_t block_sizze_70642)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133477_cached_sizze_134298 = 0;
    unsigned char *mem_133477 = NULL;
    int64_t mem_133510_cached_sizze_134299 = 0;
    unsigned char *mem_133510 = NULL;
    int64_t mem_133512_cached_sizze_134300 = 0;
    unsigned char *mem_133512 = NULL;
    int64_t mem_133520_cached_sizze_134301 = 0;
    unsigned char *mem_133520 = NULL;
    struct memblock mem_133545;
    
    mem_133545.references = NULL;
    
    struct memblock mem_133543;
    
    mem_133543.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_133499;
    
    mem_133499.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133488;
    
    mem_133488.references = NULL;
    
    struct memblock mem_param_133486;
    
    mem_param_133486.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock mem_param_133476;
    
    mem_param_133476.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133540;
    
    ext_mem_133540.references = NULL;
    
    struct memblock ext_mem_133541;
    
    ext_mem_133541.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_122889 = sext_i16_i64(block_sizze_70642);
    int64_t bytes_133468 = (int64_t) 8 * n_70640;
    bool zzero_122908 = i16_res_122889 == (int64_t) 0;
    bool nonzzero_122909 = !zzero_122908;
    bool nonzzero_cert_122912;
    
    if (!nonzzero_122909) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:97:98-101\n   #4  ftRelational.fut:91:78-89\n   #5  ftRelational.fut:87:9-91:90\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133542 = (int64_t) 4 * n_70640;
    int64_t bytes_133544 = n_70640 * b_70641;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_70640; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_122906 = add64(n_70640, i16_res_122889);
    int64_t zs_lhs_122907 = sub64(zm_lhs_122906, (int64_t) 1);
    int64_t m_122913 = sdiv_safe64(zs_lhs_122907, i16_res_122889);
    bool loop_cond_122914 = slt64((int64_t) 0, m_122913);
    
    if (mem_133477_cached_sizze_134298 < n_70640) {
        err = lexical_realloc(ctx, &mem_133477, &mem_133477_cached_sizze_134298, n_70640);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133520_cached_sizze_134301 < b_70641) {
        err = lexical_realloc(ctx, &mem_133520, &mem_133520_cached_sizze_134301, b_70641);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &k_mem_133466, "k_mem_133466") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133476, &pL_mem_133467, "pL_mem_133467") != 0)
        return 1;
    for (int64_t i_122917 = 0; i_122917 < (int64_t) 16; i_122917++) {
        int32_t binop_x_122920 = sext_i64_i32(i_122917);
        int32_t binop_x_122921 = mul32(2, binop_x_122920);
        int32_t zm_lhs_122922 = add32(2, binop_x_122921);
        int32_t min_arg1_122923 = sub32(zm_lhs_122922, 1);
        int32_t min_res_122924 = smin32(32, min_arg1_122923);
        int32_t zp_lhs_122925 = sub32(min_res_122924, binop_x_122921);
        int32_t ij_bits_122926 = add32(1, zp_lhs_122925);
        int32_t up_to_122927 = shl32(1, ij_bits_122926);
        int64_t tmp_122928 = sext_i32_i64(zp_lhs_122925);
        bool bounds_invalid_upwards_122929 = slt32(zp_lhs_122925, 0);
        bool valid_122931 = !bounds_invalid_upwards_122929;
        bool range_valid_c_122932;
        
        if (!valid_122931) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_122928, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:53:58-60\n   #4  ftSMJ.fut:97:98-101\n   #5  ftRelational.fut:91:78-89\n   #6  ftRelational.fut:87:9-91:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_122953 = sext_i32_i64(up_to_122927);
        bool bounds_invalid_upwards_122954 = slt32(up_to_122927, 0);
        bool valid_122955 = !bounds_invalid_upwards_122954;
        bool range_valid_c_122956;
        
        if (!valid_122955) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_122953, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:97:98-101\n   #4  ftRelational.fut:91:78-89\n   #5  ftRelational.fut:87:9-91:90\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_122930 = add64((int64_t) 1, tmp_122928);
        
        for (int64_t i_133300 = 0; i_133300 < n_70640; i_133300++) {
            float eta_p_122934 = ((float *) mem_param_133472.mem)[i_133300];
            int32_t i32_arg0_122935 = futrts_to_bits32(eta_p_122934);
            int32_t unsign_arg0_122936 = ashr32(i32_arg0_122935, 31);
            int32_t unsign_arg0_122937 = 1 & unsign_arg0_122936;
            bool cond_122938 = unsign_arg0_122937 == 1;
            bool x_122939 = !cond_122938;
            int8_t defunc_0_f_res_122940;
            int8_t y_122942 = (int8_t) 0;
            
            for (int64_t i_122941 = 0; i_122941 < distance_122930; i_122941++) {
                int32_t binop_x_122943 = sext_i64_i32(i_122941);
                int32_t get_bit_arg0_122944 = add32(binop_x_122921, binop_x_122943);
                int32_t unsign_arg0_122945 = ashr32(i32_arg0_122935, get_bit_arg0_122944);
                int32_t unsign_arg0_122946 = 1 & unsign_arg0_122945;
                bool cond_f_res_122947 = get_bit_arg0_122944 == 31;
                bool y_122948 = x_122939 && cond_f_res_122947;
                bool cond_122949 = cond_122938 || y_122948;
                int32_t defunc_0_get_bit_res_122950;
                
                if (cond_122949) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ unsign_arg0_122946;
                    
                    defunc_0_get_bit_res_122950 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_122950 = unsign_arg0_122946;
                }
                
                int8_t loopres_122952;
                
                if (futrts_set_bit_2464(ctx, &loopres_122952, binop_x_122943, y_122942, defunc_0_get_bit_res_122950) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_122952;
                
                y_122942 = y_tmp_133885;
            }
            defunc_0_f_res_122940 = y_122942;
            ((int8_t *) mem_133477)[i_133300] = defunc_0_f_res_122940;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_122957;
        int64_t offs_122960;
        
        if (memblock_set(ctx, &mem_param_133486, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_122960 = (int64_t) 0;
        for (int64_t i_122959 = 0; i_122959 < up_to_122953; i_122959++) {
            int32_t binop_x_122962 = sext_i64_i32(i_122959);
            int8_t index_primexp_122963 = zext_i32_i8(binop_x_122962);
            
            if (memblock_alloc(ctx, &mem_133488, bytes_133468, "mem_133488")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_70640; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133477)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_122963;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133486.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_122960, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133488.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_122988 = add64(offs_122960, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133488, "mem_133488") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_122988;
            
            if (memblock_set(ctx, &mem_param_133486, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_122960 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133497, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_122957 = offs_122960;
        if (memblock_alloc(ctx, &mem_133499, bytes_133542, "mem_133499")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_4b(ctx, 1, (uint32_t *) mem_133499.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_70640});
        if (memblock_alloc(ctx, &mem_133501, bytes_133544, "mem_133501")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {b_70641, (int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0, (int64_t []) {b_70641, (int64_t) 1}, (int64_t []) {n_70640, b_70641});
        
        bool partitioned_scatter_res_122995;
        int64_t partitioned_scatter_res_122998;
        bool loop_while_122999;
        int64_t p_123002;
        
        loop_while_122999 = loop_cond_122914;
        p_123002 = (int64_t) 0;
        while (loop_while_122999) {
            int64_t lower_bound_123003 = mul64(i16_res_122889, p_123002);
            int64_t min_arg1_123004 = add64(i16_res_122889, lower_bound_123003);
            int64_t min_res_123005 = smin64(n_70640, min_arg1_123004);
            int64_t j_m_i_123006 = sub64(min_res_123005, lower_bound_123003);
            bool empty_slice_123007 = j_m_i_123006 == (int64_t) 0;
            int64_t m_123008 = sub64(j_m_i_123006, (int64_t) 1);
            int64_t i_p_m_t_s_123009 = add64(lower_bound_123003, m_123008);
            bool zzero_leq_i_p_m_t_s_123010 = sle64((int64_t) 0, i_p_m_t_s_123009);
            bool i_p_m_t_s_leq_w_123011 = slt64(i_p_m_t_s_123009, n_70640);
            bool zzero_lte_i_123012 = sle64((int64_t) 0, lower_bound_123003);
            bool i_lte_j_123013 = sle64(lower_bound_123003, min_res_123005);
            bool y_123014 = i_p_m_t_s_leq_w_123011 && zzero_lte_i_123012;
            bool y_123015 = zzero_leq_i_p_m_t_s_123010 && y_123014;
            bool forwards_ok_123016 = i_lte_j_123013 && y_123015;
            bool ok_or_empty_123017 = empty_slice_123007 || forwards_ok_123016;
            bool index_certs_123018;
            
            if (!ok_or_empty_123017) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_123003, ":", (long long) min_res_123005, "] out of bounds for array of shape [", (long long) n_70640, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:53:58-60\n   #3  ftSMJ.fut:97:98-101\n   #4  ftRelational.fut:91:78-89\n   #5  ftRelational.fut:87:9-91:90\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133509 = (int64_t) 4 * j_m_i_123006;
            int64_t bytes_133511 = b_70641 * j_m_i_123006;
            
            if (mem_133510_cached_sizze_134299 < bytes_133509) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134299, bytes_133509);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133499.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_123003, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123006});
            if (mem_133512_cached_sizze_134300 < bytes_133511) {
                err = lexical_realloc(ctx, &mem_133512, &mem_133512_cached_sizze_134300, bytes_133511);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_70641, (int64_t) 1}, (uint8_t *) mem_133501.mem, (int64_t) 0 + b_70641 * lower_bound_123003, (int64_t []) {b_70641, (int64_t) 1}, (int64_t []) {j_m_i_123006, b_70641});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_70640; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133497.mem)[write_iter_133320];
                float write_iv_133324 = ((float *) mem_param_133472.mem)[write_iter_133320];
                
                lmad_copy_1b(ctx, 1, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0 + write_iter_133320 * b_70641, (int64_t []) {(int64_t) 1}, (int64_t []) {b_70641});
                
                bool cond_128220 = sle64(lower_bound_123003, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_123005);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_123003);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_123006)) {
                    ((float *) mem_133510)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if ((sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_123006)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(b_70641 - (int64_t) 1, b_70641))) {
                    lmad_copy_1b(ctx, 1, (uint8_t *) mem_133512, lifted_lambda_res_128223 * b_70641, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_70641});
                }
            }
            
            int64_t tmp_123030 = add64((int64_t) 1, p_123002);
            
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133499.mem, lower_bound_123003, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_123006});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, b_70641 * lower_bound_123003, (int64_t []) {b_70641, (int64_t) 1}, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_70641, (int64_t) 1}, (int64_t []) {j_m_i_123006, b_70641});
            
            bool loop_cond_123038 = slt64(tmp_123030, m_122913);
            bool loop_while_tmp_133892 = loop_cond_123038;
            int64_t p_tmp_133895 = tmp_123030;
            
            loop_while_122999 = loop_while_tmp_133892;
            p_123002 = p_tmp_133895;
        }
        partitioned_scatter_res_122995 = loop_while_122999;
        partitioned_scatter_res_122998 = p_123002;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133476, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133541, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133540, &mem_param_133476, "mem_param_133476") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133543, bytes_133542, "mem_133543")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133543.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133541.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_70640});
    if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133545, bytes_133544, "mem_133545")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133545.mem, (int64_t) 0, (int64_t []) {b_70641, (int64_t) 1}, (uint8_t *) ext_mem_133540.mem, (int64_t) 0, (int64_t []) {b_70641, (int64_t) 1}, (int64_t []) {n_70640, b_70641});
    if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133543, "mem_133543") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133545, "mem_133545") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134296, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134297, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133477);
        free(mem_133510);
        free(mem_133512);
        free(mem_133520);
        if (memblock_unref(ctx, &mem_133545, "mem_133545") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133543, "mem_133543") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133488, "mem_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133476, "mem_param_133476") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_int(struct futhark_context *ctx, struct memblock *mem_out_p_134302, struct memblock *mem_out_p_134303, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_68806, int64_t b_68807, int16_t block_sizze_68808)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133477_cached_sizze_134304 = 0;
    unsigned char *mem_133477 = NULL;
    int64_t mem_133510_cached_sizze_134305 = 0;
    unsigned char *mem_133510 = NULL;
    int64_t mem_133512_cached_sizze_134306 = 0;
    unsigned char *mem_133512 = NULL;
    int64_t mem_133520_cached_sizze_134307 = 0;
    unsigned char *mem_133520 = NULL;
    struct memblock mem_133545;
    
    mem_133545.references = NULL;
    
    struct memblock mem_133543;
    
    mem_133543.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_133499;
    
    mem_133499.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133488;
    
    mem_133488.references = NULL;
    
    struct memblock mem_param_133486;
    
    mem_param_133486.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock mem_param_133476;
    
    mem_param_133476.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133540;
    
    ext_mem_133540.references = NULL;
    
    struct memblock ext_mem_133541;
    
    ext_mem_133541.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_120703 = sext_i16_i64(block_sizze_68808);
    int64_t bytes_133468 = (int64_t) 8 * n_68806;
    bool zzero_120722 = i16_res_120703 == (int64_t) 0;
    bool nonzzero_120723 = !zzero_120722;
    bool nonzzero_cert_120726;
    
    if (!nonzzero_120723) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:87:96-99\n   #4  ftRelational.fut:81:81-92\n   #5  ftRelational.fut:77:9-81:93\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133542 = (int64_t) 4 * n_68806;
    int64_t bytes_133544 = n_68806 * b_68807;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_68806; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_120720 = add64(n_68806, i16_res_120703);
    int64_t zs_lhs_120721 = sub64(zm_lhs_120720, (int64_t) 1);
    int64_t m_120727 = sdiv_safe64(zs_lhs_120721, i16_res_120703);
    bool loop_cond_120728 = slt64((int64_t) 0, m_120727);
    
    if (mem_133477_cached_sizze_134304 < n_68806) {
        err = lexical_realloc(ctx, &mem_133477, &mem_133477_cached_sizze_134304, n_68806);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133520_cached_sizze_134307 < b_68807) {
        err = lexical_realloc(ctx, &mem_133520, &mem_133520_cached_sizze_134307, b_68807);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &k_mem_133466, "k_mem_133466") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133476, &pL_mem_133467, "pL_mem_133467") != 0)
        return 1;
    for (int64_t i_120731 = 0; i_120731 < (int64_t) 16; i_120731++) {
        int32_t binop_x_120734 = sext_i64_i32(i_120731);
        int32_t binop_x_120735 = mul32(2, binop_x_120734);
        int32_t zm_lhs_120736 = add32(2, binop_x_120735);
        int32_t min_arg1_120737 = sub32(zm_lhs_120736, 1);
        int32_t min_res_120738 = smin32(32, min_arg1_120737);
        int32_t zp_lhs_120739 = sub32(min_res_120738, binop_x_120735);
        int32_t ij_bits_120740 = add32(1, zp_lhs_120739);
        int32_t up_to_120741 = shl32(1, ij_bits_120740);
        int64_t tmp_120742 = sext_i32_i64(zp_lhs_120739);
        bool bounds_invalid_upwards_120743 = slt32(zp_lhs_120739, 0);
        bool valid_120745 = !bounds_invalid_upwards_120743;
        bool range_valid_c_120746;
        
        if (!valid_120745) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_120742, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:32:58-60\n   #4  ftSMJ.fut:87:96-99\n   #5  ftRelational.fut:81:81-92\n   #6  ftRelational.fut:77:9-81:93\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_120759 = sext_i32_i64(up_to_120741);
        bool bounds_invalid_upwards_120760 = slt32(up_to_120741, 0);
        bool valid_120761 = !bounds_invalid_upwards_120760;
        bool range_valid_c_120762;
        
        if (!valid_120761) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_120759, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:87:96-99\n   #4  ftRelational.fut:81:81-92\n   #5  ftRelational.fut:77:9-81:93\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_120744 = add64((int64_t) 1, tmp_120742);
        
        for (int64_t i_133300 = 0; i_133300 < n_68806; i_133300++) {
            int32_t eta_p_120748 = ((int32_t *) mem_param_133472.mem)[i_133300];
            int8_t defunc_0_f_res_120749;
            int8_t y_120751 = (int8_t) 0;
            
            for (int64_t i_120750 = 0; i_120750 < distance_120744; i_120750++) {
                int32_t binop_x_120752 = sext_i64_i32(i_120750);
                int32_t get_bit_arg0_120753 = add32(binop_x_120735, binop_x_120752);
                int32_t zgzg_res_126074 = ashr32(eta_p_120748, get_bit_arg0_120753);
                int32_t za_res_126075 = 1 & zgzg_res_126074;
                bool cond_120755 = get_bit_arg0_120753 == 31;
                int32_t defunc_0_get_bit_res_120756;
                
                if (cond_120755) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ za_res_126075;
                    
                    defunc_0_get_bit_res_120756 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_120756 = za_res_126075;
                }
                
                int8_t loopres_120758;
                
                if (futrts_set_bit_2464(ctx, &loopres_120758, binop_x_120752, y_120751, defunc_0_get_bit_res_120756) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_120758;
                
                y_120751 = y_tmp_133885;
            }
            defunc_0_f_res_120749 = y_120751;
            ((int8_t *) mem_133477)[i_133300] = defunc_0_f_res_120749;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_120763;
        int64_t offs_120766;
        
        if (memblock_set(ctx, &mem_param_133486, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_120766 = (int64_t) 0;
        for (int64_t i_120765 = 0; i_120765 < up_to_120759; i_120765++) {
            int32_t binop_x_120768 = sext_i64_i32(i_120765);
            int8_t index_primexp_120769 = zext_i32_i8(binop_x_120768);
            
            if (memblock_alloc(ctx, &mem_133488, bytes_133468, "mem_133488")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_68806; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133477)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_120769;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133486.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_120766, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133488.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_120794 = add64(offs_120766, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133488, "mem_133488") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_120794;
            
            if (memblock_set(ctx, &mem_param_133486, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_120766 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133497, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_120763 = offs_120766;
        if (memblock_alloc(ctx, &mem_133499, bytes_133542, "mem_133499")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_4b(ctx, 1, (uint32_t *) mem_133499.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_68806});
        if (memblock_alloc(ctx, &mem_133501, bytes_133544, "mem_133501")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {b_68807, (int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0, (int64_t []) {b_68807, (int64_t) 1}, (int64_t []) {n_68806, b_68807});
        
        bool partitioned_scatter_res_120801;
        int64_t partitioned_scatter_res_120804;
        bool loop_while_120805;
        int64_t p_120808;
        
        loop_while_120805 = loop_cond_120728;
        p_120808 = (int64_t) 0;
        while (loop_while_120805) {
            int64_t lower_bound_120809 = mul64(i16_res_120703, p_120808);
            int64_t min_arg1_120810 = add64(i16_res_120703, lower_bound_120809);
            int64_t min_res_120811 = smin64(n_68806, min_arg1_120810);
            int64_t j_m_i_120812 = sub64(min_res_120811, lower_bound_120809);
            bool empty_slice_120813 = j_m_i_120812 == (int64_t) 0;
            int64_t m_120814 = sub64(j_m_i_120812, (int64_t) 1);
            int64_t i_p_m_t_s_120815 = add64(lower_bound_120809, m_120814);
            bool zzero_leq_i_p_m_t_s_120816 = sle64((int64_t) 0, i_p_m_t_s_120815);
            bool i_p_m_t_s_leq_w_120817 = slt64(i_p_m_t_s_120815, n_68806);
            bool zzero_lte_i_120818 = sle64((int64_t) 0, lower_bound_120809);
            bool i_lte_j_120819 = sle64(lower_bound_120809, min_res_120811);
            bool y_120820 = i_p_m_t_s_leq_w_120817 && zzero_lte_i_120818;
            bool y_120821 = zzero_leq_i_p_m_t_s_120816 && y_120820;
            bool forwards_ok_120822 = i_lte_j_120819 && y_120821;
            bool ok_or_empty_120823 = empty_slice_120813 || forwards_ok_120822;
            bool index_certs_120824;
            
            if (!ok_or_empty_120823) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_120809, ":", (long long) min_res_120811, "] out of bounds for array of shape [", (long long) n_68806, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:87:96-99\n   #4  ftRelational.fut:81:81-92\n   #5  ftRelational.fut:77:9-81:93\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133509 = (int64_t) 4 * j_m_i_120812;
            int64_t bytes_133511 = b_68807 * j_m_i_120812;
            
            if (mem_133510_cached_sizze_134305 < bytes_133509) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134305, bytes_133509);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133499.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120809, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120812});
            if (mem_133512_cached_sizze_134306 < bytes_133511) {
                err = lexical_realloc(ctx, &mem_133512, &mem_133512_cached_sizze_134306, bytes_133511);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_68807, (int64_t) 1}, (uint8_t *) mem_133501.mem, (int64_t) 0 + b_68807 * lower_bound_120809, (int64_t []) {b_68807, (int64_t) 1}, (int64_t []) {j_m_i_120812, b_68807});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_68806; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133497.mem)[write_iter_133320];
                int32_t write_iv_133324 = ((int32_t *) mem_param_133472.mem)[write_iter_133320];
                
                lmad_copy_1b(ctx, 1, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0 + write_iter_133320 * b_68807, (int64_t []) {(int64_t) 1}, (int64_t []) {b_68807});
                
                bool cond_128220 = sle64(lower_bound_120809, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_120811);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_120809);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120812)) {
                    ((int32_t *) mem_133510)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if ((sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120812)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(b_68807 - (int64_t) 1, b_68807))) {
                    lmad_copy_1b(ctx, 1, (uint8_t *) mem_133512, lifted_lambda_res_128223 * b_68807, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_68807});
                }
            }
            
            int64_t tmp_120836 = add64((int64_t) 1, p_120808);
            
            lmad_copy_4b(ctx, 1, (uint32_t *) mem_133499.mem, lower_bound_120809, (int64_t []) {(int64_t) 1}, (uint32_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120812});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, b_68807 * lower_bound_120809, (int64_t []) {b_68807, (int64_t) 1}, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_68807, (int64_t) 1}, (int64_t []) {j_m_i_120812, b_68807});
            
            bool loop_cond_120844 = slt64(tmp_120836, m_120727);
            bool loop_while_tmp_133892 = loop_cond_120844;
            int64_t p_tmp_133895 = tmp_120836;
            
            loop_while_120805 = loop_while_tmp_133892;
            p_120808 = p_tmp_133895;
        }
        partitioned_scatter_res_120801 = loop_while_120805;
        partitioned_scatter_res_120804 = p_120808;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133476, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133541, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133540, &mem_param_133476, "mem_param_133476") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133543, bytes_133542, "mem_133543")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_4b(ctx, 1, (uint32_t *) mem_133543.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint32_t *) ext_mem_133541.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_68806});
    if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133545, bytes_133544, "mem_133545")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133545.mem, (int64_t) 0, (int64_t []) {b_68807, (int64_t) 1}, (uint8_t *) ext_mem_133540.mem, (int64_t) 0, (int64_t []) {b_68807, (int64_t) 1}, (int64_t []) {n_68806, b_68807});
    if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133543, "mem_133543") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133545, "mem_133545") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134302, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134303, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133477);
        free(mem_133510);
        free(mem_133512);
        free(mem_133520);
        if (memblock_unref(ctx, &mem_133545, "mem_133545") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133543, "mem_133543") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133488, "mem_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133476, "mem_param_133476") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_long(struct futhark_context *ctx, struct memblock *mem_out_p_134308, struct memblock *mem_out_p_134309, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_69694, int64_t b_69695, int16_t block_sizze_69696)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133477_cached_sizze_134310 = 0;
    unsigned char *mem_133477 = NULL;
    int64_t mem_133510_cached_sizze_134311 = 0;
    unsigned char *mem_133510 = NULL;
    int64_t mem_133512_cached_sizze_134312 = 0;
    unsigned char *mem_133512 = NULL;
    int64_t mem_133520_cached_sizze_134313 = 0;
    unsigned char *mem_133520 = NULL;
    struct memblock mem_133545;
    
    mem_133545.references = NULL;
    
    struct memblock mem_133543;
    
    mem_133543.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_133499;
    
    mem_133499.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133488;
    
    mem_133488.references = NULL;
    
    struct memblock mem_param_133486;
    
    mem_param_133486.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock mem_param_133476;
    
    mem_param_133476.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133540;
    
    ext_mem_133540.references = NULL;
    
    struct memblock ext_mem_133541;
    
    ext_mem_133541.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_120703 = sext_i16_i64(block_sizze_69696);
    int64_t bytes_133468 = (int64_t) 8 * n_69694;
    bool zzero_120722 = i16_res_120703 == (int64_t) 0;
    bool nonzzero_120723 = !zzero_120722;
    bool nonzzero_cert_120726;
    
    if (!nonzzero_120723) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:87:96-99\n   #4  ftRelational.fut:86:81-92\n   #5  ftRelational.fut:82:9-86:93\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133544 = n_69694 * b_69695;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_69694; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_120720 = add64(n_69694, i16_res_120703);
    int64_t zs_lhs_120721 = sub64(zm_lhs_120720, (int64_t) 1);
    int64_t m_120727 = sdiv_safe64(zs_lhs_120721, i16_res_120703);
    bool loop_cond_120728 = slt64((int64_t) 0, m_120727);
    
    if (mem_133477_cached_sizze_134310 < n_69694) {
        err = lexical_realloc(ctx, &mem_133477, &mem_133477_cached_sizze_134310, n_69694);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133520_cached_sizze_134313 < b_69695) {
        err = lexical_realloc(ctx, &mem_133520, &mem_133520_cached_sizze_134313, b_69695);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &k_mem_133466, "k_mem_133466") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133476, &pL_mem_133467, "pL_mem_133467") != 0)
        return 1;
    for (int64_t i_120731 = 0; i_120731 < (int64_t) 32; i_120731++) {
        int32_t binop_x_120734 = sext_i64_i32(i_120731);
        int32_t binop_x_120735 = mul32(2, binop_x_120734);
        int32_t zm_lhs_120736 = add32(2, binop_x_120735);
        int32_t min_arg1_120737 = sub32(zm_lhs_120736, 1);
        int32_t min_res_120738 = smin32(64, min_arg1_120737);
        int32_t zp_lhs_120739 = sub32(min_res_120738, binop_x_120735);
        int32_t ij_bits_120740 = add32(1, zp_lhs_120739);
        int32_t up_to_120741 = shl32(1, ij_bits_120740);
        int64_t tmp_120742 = sext_i32_i64(zp_lhs_120739);
        bool bounds_invalid_upwards_120743 = slt32(zp_lhs_120739, 0);
        bool valid_120745 = !bounds_invalid_upwards_120743;
        bool range_valid_c_120746;
        
        if (!valid_120745) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_120742, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:32:58-60\n   #4  ftSMJ.fut:87:96-99\n   #5  ftRelational.fut:86:81-92\n   #6  ftRelational.fut:82:9-86:93\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_120759 = sext_i32_i64(up_to_120741);
        bool bounds_invalid_upwards_120760 = slt32(up_to_120741, 0);
        bool valid_120761 = !bounds_invalid_upwards_120760;
        bool range_valid_c_120762;
        
        if (!valid_120761) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_120759, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:87:96-99\n   #4  ftRelational.fut:86:81-92\n   #5  ftRelational.fut:82:9-86:93\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_120744 = add64((int64_t) 1, tmp_120742);
        
        for (int64_t i_133300 = 0; i_133300 < n_69694; i_133300++) {
            int64_t eta_p_120748 = ((int64_t *) mem_param_133472.mem)[i_133300];
            int8_t defunc_0_f_res_120749;
            int8_t y_120751 = (int8_t) 0;
            
            for (int64_t i_120750 = 0; i_120750 < distance_120744; i_120750++) {
                int32_t binop_x_120752 = sext_i64_i32(i_120750);
                int32_t get_bit_arg0_120753 = add32(binop_x_120735, binop_x_120752);
                int32_t defunc_0_get_bit_res_120754;
                
                if (futrts_get_bit_2253(ctx, &defunc_0_get_bit_res_120754, get_bit_arg0_120753, eta_p_120748) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                bool cond_120755 = get_bit_arg0_120753 == 63;
                int32_t defunc_0_get_bit_res_120756;
                
                if (cond_120755) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ defunc_0_get_bit_res_120754;
                    
                    defunc_0_get_bit_res_120756 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_120756 = defunc_0_get_bit_res_120754;
                }
                
                int8_t loopres_120758;
                
                if (futrts_set_bit_2464(ctx, &loopres_120758, binop_x_120752, y_120751, defunc_0_get_bit_res_120756) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_120758;
                
                y_120751 = y_tmp_133885;
            }
            defunc_0_f_res_120749 = y_120751;
            ((int8_t *) mem_133477)[i_133300] = defunc_0_f_res_120749;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_120763;
        int64_t offs_120766;
        
        if (memblock_set(ctx, &mem_param_133486, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_120766 = (int64_t) 0;
        for (int64_t i_120765 = 0; i_120765 < up_to_120759; i_120765++) {
            int32_t binop_x_120768 = sext_i64_i32(i_120765);
            int8_t index_primexp_120769 = zext_i32_i8(binop_x_120768);
            
            if (memblock_alloc(ctx, &mem_133488, bytes_133468, "mem_133488")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_69694; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133477)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_120769;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133486.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_120766, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133488.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_120794 = add64(offs_120766, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133488, "mem_133488") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_120794;
            
            if (memblock_set(ctx, &mem_param_133486, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_120766 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133497, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_120763 = offs_120766;
        if (memblock_alloc(ctx, &mem_133499, bytes_133468, "mem_133499")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133499.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_69694});
        if (memblock_alloc(ctx, &mem_133501, bytes_133544, "mem_133501")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {b_69695, (int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0, (int64_t []) {b_69695, (int64_t) 1}, (int64_t []) {n_69694, b_69695});
        
        bool partitioned_scatter_res_120801;
        int64_t partitioned_scatter_res_120804;
        bool loop_while_120805;
        int64_t p_120808;
        
        loop_while_120805 = loop_cond_120728;
        p_120808 = (int64_t) 0;
        while (loop_while_120805) {
            int64_t lower_bound_120809 = mul64(i16_res_120703, p_120808);
            int64_t min_arg1_120810 = add64(i16_res_120703, lower_bound_120809);
            int64_t min_res_120811 = smin64(n_69694, min_arg1_120810);
            int64_t j_m_i_120812 = sub64(min_res_120811, lower_bound_120809);
            bool empty_slice_120813 = j_m_i_120812 == (int64_t) 0;
            int64_t m_120814 = sub64(j_m_i_120812, (int64_t) 1);
            int64_t i_p_m_t_s_120815 = add64(lower_bound_120809, m_120814);
            bool zzero_leq_i_p_m_t_s_120816 = sle64((int64_t) 0, i_p_m_t_s_120815);
            bool i_p_m_t_s_leq_w_120817 = slt64(i_p_m_t_s_120815, n_69694);
            bool zzero_lte_i_120818 = sle64((int64_t) 0, lower_bound_120809);
            bool i_lte_j_120819 = sle64(lower_bound_120809, min_res_120811);
            bool y_120820 = i_p_m_t_s_leq_w_120817 && zzero_lte_i_120818;
            bool y_120821 = zzero_leq_i_p_m_t_s_120816 && y_120820;
            bool forwards_ok_120822 = i_lte_j_120819 && y_120821;
            bool ok_or_empty_120823 = empty_slice_120813 || forwards_ok_120822;
            bool index_certs_120824;
            
            if (!ok_or_empty_120823) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_120809, ":", (long long) min_res_120811, "] out of bounds for array of shape [", (long long) n_69694, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:87:96-99\n   #4  ftRelational.fut:86:81-92\n   #5  ftRelational.fut:82:9-86:93\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133509 = (int64_t) 8 * j_m_i_120812;
            int64_t bytes_133511 = b_69695 * j_m_i_120812;
            
            if (mem_133510_cached_sizze_134311 < bytes_133509) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134311, bytes_133509);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133499.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120809, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120812});
            if (mem_133512_cached_sizze_134312 < bytes_133511) {
                err = lexical_realloc(ctx, &mem_133512, &mem_133512_cached_sizze_134312, bytes_133511);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_69695, (int64_t) 1}, (uint8_t *) mem_133501.mem, (int64_t) 0 + b_69695 * lower_bound_120809, (int64_t []) {b_69695, (int64_t) 1}, (int64_t []) {j_m_i_120812, b_69695});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_69694; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133497.mem)[write_iter_133320];
                int64_t write_iv_133324 = ((int64_t *) mem_param_133472.mem)[write_iter_133320];
                
                lmad_copy_1b(ctx, 1, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0 + write_iter_133320 * b_69695, (int64_t []) {(int64_t) 1}, (int64_t []) {b_69695});
                
                bool cond_128220 = sle64(lower_bound_120809, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_120811);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_120809);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120812)) {
                    ((int64_t *) mem_133510)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if ((sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120812)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(b_69695 - (int64_t) 1, b_69695))) {
                    lmad_copy_1b(ctx, 1, (uint8_t *) mem_133512, lifted_lambda_res_128223 * b_69695, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_69695});
                }
            }
            
            int64_t tmp_120836 = add64((int64_t) 1, p_120808);
            
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_133499.mem, lower_bound_120809, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120812});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, b_69695 * lower_bound_120809, (int64_t []) {b_69695, (int64_t) 1}, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_69695, (int64_t) 1}, (int64_t []) {j_m_i_120812, b_69695});
            
            bool loop_cond_120844 = slt64(tmp_120836, m_120727);
            bool loop_while_tmp_133892 = loop_cond_120844;
            int64_t p_tmp_133895 = tmp_120836;
            
            loop_while_120805 = loop_while_tmp_133892;
            p_120808 = p_tmp_133895;
        }
        partitioned_scatter_res_120801 = loop_while_120805;
        partitioned_scatter_res_120804 = p_120808;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133476, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133541, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133540, &mem_param_133476, "mem_param_133476") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133543, bytes_133468, "mem_133543")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133543.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_133541.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_69694});
    if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133545, bytes_133544, "mem_133545")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133545.mem, (int64_t) 0, (int64_t []) {b_69695, (int64_t) 1}, (uint8_t *) ext_mem_133540.mem, (int64_t) 0, (int64_t []) {b_69695, (int64_t) 1}, (int64_t []) {n_69694, b_69695});
    if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133543, "mem_133543") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133545, "mem_133545") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134308, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134309, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133477);
        free(mem_133510);
        free(mem_133512);
        free(mem_133520);
        if (memblock_unref(ctx, &mem_133545, "mem_133545") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133543, "mem_133543") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133488, "mem_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133476, "mem_param_133476") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_radixSortRelation_short(struct futhark_context *ctx, struct memblock *mem_out_p_134314, struct memblock *mem_out_p_134315, struct memblock k_mem_133466, struct memblock pL_mem_133467, int64_t n_67912, int64_t b_67913, int16_t block_sizze_67914)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133477_cached_sizze_134316 = 0;
    unsigned char *mem_133477 = NULL;
    int64_t mem_133510_cached_sizze_134317 = 0;
    unsigned char *mem_133510 = NULL;
    int64_t mem_133512_cached_sizze_134318 = 0;
    unsigned char *mem_133512 = NULL;
    int64_t mem_133520_cached_sizze_134319 = 0;
    unsigned char *mem_133520 = NULL;
    struct memblock mem_133545;
    
    mem_133545.references = NULL;
    
    struct memblock mem_133543;
    
    mem_133543.references = NULL;
    
    struct memblock mem_param_tmp_133881;
    
    mem_param_tmp_133881.references = NULL;
    
    struct memblock mem_param_tmp_133880;
    
    mem_param_tmp_133880.references = NULL;
    
    struct memblock mem_133501;
    
    mem_133501.references = NULL;
    
    struct memblock mem_133499;
    
    mem_133499.references = NULL;
    
    struct memblock mem_param_tmp_133886;
    
    mem_param_tmp_133886.references = NULL;
    
    struct memblock mem_133488;
    
    mem_133488.references = NULL;
    
    struct memblock mem_param_133486;
    
    mem_param_133486.references = NULL;
    
    struct memblock ext_mem_133497;
    
    ext_mem_133497.references = NULL;
    
    struct memblock mem_param_133476;
    
    mem_param_133476.references = NULL;
    
    struct memblock mem_param_133472;
    
    mem_param_133472.references = NULL;
    
    struct memblock ext_mem_133540;
    
    ext_mem_133540.references = NULL;
    
    struct memblock ext_mem_133541;
    
    ext_mem_133541.references = NULL;
    
    struct memblock mem_133469;
    
    mem_133469.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t i16_res_120703 = sext_i16_i64(block_sizze_67914);
    int64_t bytes_133468 = (int64_t) 8 * n_67912;
    bool zzero_120722 = i16_res_120703 == (int64_t) 0;
    bool nonzzero_120723 = !zzero_120722;
    bool nonzzero_cert_120726;
    
    if (!nonzzero_120723) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:87:96-99\n   #4  ftRelational.fut:76:81-92\n   #5  ftRelational.fut:72:9-76:93\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133542 = (int64_t) 2 * n_67912;
    int64_t bytes_133544 = n_67912 * b_67913;
    
    if (memblock_alloc(ctx, &mem_133469, bytes_133468, "mem_133469")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133879 = 0; nest_i_133879 < n_67912; nest_i_133879++) {
        ((int64_t *) mem_133469.mem)[nest_i_133879] = (int64_t) 0;
    }
    
    int64_t zm_lhs_120720 = add64(n_67912, i16_res_120703);
    int64_t zs_lhs_120721 = sub64(zm_lhs_120720, (int64_t) 1);
    int64_t m_120727 = sdiv_safe64(zs_lhs_120721, i16_res_120703);
    bool loop_cond_120728 = slt64((int64_t) 0, m_120727);
    
    if (mem_133477_cached_sizze_134316 < n_67912) {
        err = lexical_realloc(ctx, &mem_133477, &mem_133477_cached_sizze_134316, n_67912);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133520_cached_sizze_134319 < b_67913) {
        err = lexical_realloc(ctx, &mem_133520, &mem_133520_cached_sizze_134319, b_67913);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_133472, &k_mem_133466, "k_mem_133466") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_133476, &pL_mem_133467, "pL_mem_133467") != 0)
        return 1;
    for (int64_t i_120731 = 0; i_120731 < (int64_t) 8; i_120731++) {
        int32_t binop_x_120734 = sext_i64_i32(i_120731);
        int32_t binop_x_120735 = mul32(2, binop_x_120734);
        int32_t zm_lhs_120736 = add32(2, binop_x_120735);
        int32_t min_arg1_120737 = sub32(zm_lhs_120736, 1);
        int32_t min_res_120738 = smin32(16, min_arg1_120737);
        int32_t zp_lhs_120739 = sub32(min_res_120738, binop_x_120735);
        int32_t ij_bits_120740 = add32(1, zp_lhs_120739);
        int32_t up_to_120741 = shl32(1, ij_bits_120740);
        int64_t tmp_120742 = sext_i32_i64(zp_lhs_120739);
        bool bounds_invalid_upwards_120743 = slt32(zp_lhs_120739, 0);
        bool valid_120745 = !bounds_invalid_upwards_120743;
        bool range_valid_c_120746;
        
        if (!valid_120745) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_120742, " is invalid.", "-> #0  ftbasics.fut:150:17-26\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftSMJ.fut:18:86-88\n   #3  ftSMJ.fut:32:58-60\n   #4  ftSMJ.fut:87:96-99\n   #5  ftRelational.fut:76:81-92\n   #6  ftRelational.fut:72:9-76:93\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t up_to_120759 = sext_i32_i64(up_to_120741);
        bool bounds_invalid_upwards_120760 = slt32(up_to_120741, 0);
        bool valid_120761 = !bounds_invalid_upwards_120760;
        bool range_valid_c_120762;
        
        if (!valid_120761) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..<", (long long) up_to_120759, " is invalid.", "-> #0  ftbasics.fut:171:21-30\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:87:96-99\n   #4  ftRelational.fut:76:81-92\n   #5  ftRelational.fut:72:9-76:93\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t distance_120744 = add64((int64_t) 1, tmp_120742);
        
        for (int64_t i_133300 = 0; i_133300 < n_67912; i_133300++) {
            int16_t eta_p_120748 = ((int16_t *) mem_param_133472.mem)[i_133300];
            int8_t defunc_0_f_res_120749;
            int8_t y_120751 = (int8_t) 0;
            
            for (int64_t i_120750 = 0; i_120750 < distance_120744; i_120750++) {
                int32_t binop_x_120752 = sext_i64_i32(i_120750);
                int32_t get_bit_arg0_120753 = add32(binop_x_120735, binop_x_120752);
                int32_t defunc_0_get_bit_res_120754;
                
                if (futrts_get_bit_1844(ctx, &defunc_0_get_bit_res_120754, get_bit_arg0_120753, eta_p_120748) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                bool cond_120755 = get_bit_arg0_120753 == 15;
                int32_t defunc_0_get_bit_res_120756;
                
                if (cond_120755) {
                    int32_t defunc_0_get_bit_res_t_res_128242 = 1 ^ defunc_0_get_bit_res_120754;
                    
                    defunc_0_get_bit_res_120756 = defunc_0_get_bit_res_t_res_128242;
                } else {
                    defunc_0_get_bit_res_120756 = defunc_0_get_bit_res_120754;
                }
                
                int8_t loopres_120758;
                
                if (futrts_set_bit_2464(ctx, &loopres_120758, binop_x_120752, y_120751, defunc_0_get_bit_res_120756) != 0) {
                    err = 1;
                    goto cleanup;
                }
                
                int8_t y_tmp_133885 = loopres_120758;
                
                y_120751 = y_tmp_133885;
            }
            defunc_0_f_res_120749 = y_120751;
            ((int8_t *) mem_133477)[i_133300] = defunc_0_f_res_120749;
        }
        
        int64_t defunc_0_radix_sort_multistep_res_120763;
        int64_t offs_120766;
        
        if (memblock_set(ctx, &mem_param_133486, &mem_133469, "mem_133469") != 0)
            return 1;
        offs_120766 = (int64_t) 0;
        for (int64_t i_120765 = 0; i_120765 < up_to_120759; i_120765++) {
            int32_t binop_x_120768 = sext_i64_i32(i_120765);
            int8_t index_primexp_120769 = zext_i32_i8(binop_x_120768);
            
            if (memblock_alloc(ctx, &mem_133488, bytes_133468, "mem_133488")) {
                err = 1;
                goto cleanup;
            }
            
            int64_t inpacc_128247;
            int64_t defunc_0_reduce_res_128248;
            int64_t inpacc_128128;
            int64_t inpacc_128129;
            
            inpacc_128128 = (int64_t) 0;
            inpacc_128129 = (int64_t) 0;
            for (int64_t i_133318 = 0; i_133318 < n_67912; i_133318++) {
                int8_t eta_p_133433 = ((int8_t *) mem_133477)[i_133318];
                bool lifted_lambda_res_133434 = eta_p_133433 == index_primexp_120769;
                int64_t bool_res_133435 = btoi_bool_i64(lifted_lambda_res_133434);
                int64_t eta_p_133448 = ((int64_t *) mem_param_133486.mem)[i_133318];
                int64_t defunc_0_op_res_133449 = add64(inpacc_128128, bool_res_133435);
                int64_t zm_lhs_133450 = add64(offs_120766, defunc_0_op_res_133449);
                int64_t lifted_lambda_res_133451 = sub64(zm_lhs_133450, (int64_t) 1);
                int64_t defunc_0_f_res_133452 = mul64(bool_res_133435, lifted_lambda_res_133451);
                int64_t defunc_0_f_res_133453 = add64(eta_p_133448, defunc_0_f_res_133452);
                int64_t defunc_0_op_res_128177 = add64(inpacc_128129, bool_res_133435);
                
                ((int64_t *) mem_133488.mem)[i_133318] = defunc_0_f_res_133453;
                
                int64_t inpacc_tmp_133889 = defunc_0_op_res_133449;
                int64_t inpacc_tmp_133890 = defunc_0_op_res_128177;
                
                inpacc_128128 = inpacc_tmp_133889;
                inpacc_128129 = inpacc_tmp_133890;
            }
            inpacc_128247 = inpacc_128128;
            defunc_0_reduce_res_128248 = inpacc_128129;
            
            int64_t tmp_120794 = add64(offs_120766, defunc_0_reduce_res_128248);
            
            if (memblock_set(ctx, &mem_param_tmp_133886, &mem_133488, "mem_133488") != 0)
                return 1;
            
            int64_t offs_tmp_133887 = tmp_120794;
            
            if (memblock_set(ctx, &mem_param_133486, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
                return 1;
            offs_120766 = offs_tmp_133887;
        }
        if (memblock_set(ctx, &ext_mem_133497, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        defunc_0_radix_sort_multistep_res_120763 = offs_120766;
        if (memblock_alloc(ctx, &mem_133499, bytes_133542, "mem_133499")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_2b(ctx, 1, (uint16_t *) mem_133499.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint16_t *) mem_param_133472.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_67912});
        if (memblock_alloc(ctx, &mem_133501, bytes_133544, "mem_133501")) {
            err = 1;
            goto cleanup;
        }
        lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, (int64_t) 0, (int64_t []) {b_67913, (int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0, (int64_t []) {b_67913, (int64_t) 1}, (int64_t []) {n_67912, b_67913});
        
        bool partitioned_scatter_res_120801;
        int64_t partitioned_scatter_res_120804;
        bool loop_while_120805;
        int64_t p_120808;
        
        loop_while_120805 = loop_cond_120728;
        p_120808 = (int64_t) 0;
        while (loop_while_120805) {
            int64_t lower_bound_120809 = mul64(i16_res_120703, p_120808);
            int64_t min_arg1_120810 = add64(i16_res_120703, lower_bound_120809);
            int64_t min_res_120811 = smin64(n_67912, min_arg1_120810);
            int64_t j_m_i_120812 = sub64(min_res_120811, lower_bound_120809);
            bool empty_slice_120813 = j_m_i_120812 == (int64_t) 0;
            int64_t m_120814 = sub64(j_m_i_120812, (int64_t) 1);
            int64_t i_p_m_t_s_120815 = add64(lower_bound_120809, m_120814);
            bool zzero_leq_i_p_m_t_s_120816 = sle64((int64_t) 0, i_p_m_t_s_120815);
            bool i_p_m_t_s_leq_w_120817 = slt64(i_p_m_t_s_120815, n_67912);
            bool zzero_lte_i_120818 = sle64((int64_t) 0, lower_bound_120809);
            bool i_lte_j_120819 = sle64(lower_bound_120809, min_res_120811);
            bool y_120820 = i_p_m_t_s_leq_w_120817 && zzero_lte_i_120818;
            bool y_120821 = zzero_leq_i_p_m_t_s_120816 && y_120820;
            bool forwards_ok_120822 = i_lte_j_120819 && y_120821;
            bool ok_or_empty_120823 = empty_slice_120813 || forwards_ok_120822;
            bool index_certs_120824;
            
            if (!ok_or_empty_120823) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_120809, ":", (long long) min_res_120811, "] out of bounds for array of shape [", (long long) n_67912, "].", "-> #0  ftbasics.fut:72:25-56\n   #1  ftSMJ.fut:18:86-88\n   #2  ftSMJ.fut:32:58-60\n   #3  ftSMJ.fut:87:96-99\n   #4  ftRelational.fut:76:81-92\n   #5  ftRelational.fut:72:9-76:93\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t bytes_133509 = (int64_t) 2 * j_m_i_120812;
            int64_t bytes_133511 = b_67913 * j_m_i_120812;
            
            if (mem_133510_cached_sizze_134317 < bytes_133509) {
                err = lexical_realloc(ctx, &mem_133510, &mem_133510_cached_sizze_134317, bytes_133509);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_2b(ctx, 1, (uint16_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint16_t *) mem_133499.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_120809, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120812});
            if (mem_133512_cached_sizze_134318 < bytes_133511) {
                err = lexical_realloc(ctx, &mem_133512, &mem_133512_cached_sizze_134318, bytes_133511);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_67913, (int64_t) 1}, (uint8_t *) mem_133501.mem, (int64_t) 0 + b_67913 * lower_bound_120809, (int64_t []) {b_67913, (int64_t) 1}, (int64_t []) {j_m_i_120812, b_67913});
            for (int64_t write_iter_133320 = 0; write_iter_133320 < n_67912; write_iter_133320++) {
                int64_t write_iv_133323 = ((int64_t *) ext_mem_133497.mem)[write_iter_133320];
                int16_t write_iv_133324 = ((int16_t *) mem_param_133472.mem)[write_iter_133320];
                
                lmad_copy_1b(ctx, 1, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_param_133476.mem, (int64_t) 0 + write_iter_133320 * b_67913, (int64_t []) {(int64_t) 1}, (int64_t []) {b_67913});
                
                bool cond_128220 = sle64(lower_bound_120809, write_iv_133323);
                bool cond_t_res_128221 = slt64(write_iv_133323, min_res_120811);
                bool x_128222 = cond_128220 && cond_t_res_128221;
                int64_t lifted_lambda_res_128223;
                
                if (x_128222) {
                    int64_t lifted_lambda_res_t_res_128250 = sub64(write_iv_133323, lower_bound_120809);
                    
                    lifted_lambda_res_128223 = lifted_lambda_res_t_res_128250;
                } else {
                    lifted_lambda_res_128223 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120812)) {
                    ((int16_t *) mem_133510)[lifted_lambda_res_128223] = write_iv_133324;
                }
                if ((sle64((int64_t) 0, lifted_lambda_res_128223) && slt64(lifted_lambda_res_128223, j_m_i_120812)) && (sle64((int64_t) 0, (int64_t) 0) && slt64(b_67913 - (int64_t) 1, b_67913))) {
                    lmad_copy_1b(ctx, 1, (uint8_t *) mem_133512, lifted_lambda_res_128223 * b_67913, (int64_t []) {(int64_t) 1}, (uint8_t *) mem_133520, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {b_67913});
                }
            }
            
            int64_t tmp_120836 = add64((int64_t) 1, p_120808);
            
            lmad_copy_2b(ctx, 1, (uint16_t *) mem_133499.mem, lower_bound_120809, (int64_t []) {(int64_t) 1}, (uint16_t *) mem_133510, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_120812});
            lmad_copy_1b(ctx, 2, (uint8_t *) mem_133501.mem, b_67913 * lower_bound_120809, (int64_t []) {b_67913, (int64_t) 1}, (uint8_t *) mem_133512, (int64_t) 0, (int64_t []) {b_67913, (int64_t) 1}, (int64_t []) {j_m_i_120812, b_67913});
            
            bool loop_cond_120844 = slt64(tmp_120836, m_120727);
            bool loop_while_tmp_133892 = loop_cond_120844;
            int64_t p_tmp_133895 = tmp_120836;
            
            loop_while_120805 = loop_while_tmp_133892;
            p_120808 = p_tmp_133895;
        }
        partitioned_scatter_res_120801 = loop_while_120805;
        partitioned_scatter_res_120804 = p_120808;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133880, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_133881, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133472, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_133476, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_133541, &mem_param_133472, "mem_param_133472") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_133540, &mem_param_133476, "mem_param_133476") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133543, bytes_133542, "mem_133543")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_2b(ctx, 1, (uint16_t *) mem_133543.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint16_t *) ext_mem_133541.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {n_67912});
    if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_133545, bytes_133544, "mem_133545")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_1b(ctx, 2, (uint8_t *) mem_133545.mem, (int64_t) 0, (int64_t []) {b_67913, (int64_t) 1}, (uint8_t *) ext_mem_133540.mem, (int64_t) 0, (int64_t []) {b_67913, (int64_t) 1}, (int64_t []) {n_67912, b_67913});
    if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133877, &mem_133543, "mem_133543") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133545, "mem_133545") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134314, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134315, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133477);
        free(mem_133510);
        free(mem_133512);
        free(mem_133520);
        if (memblock_unref(ctx, &mem_133545, "mem_133545") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133543, "mem_133543") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133881, "mem_param_tmp_133881") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133880, "mem_param_tmp_133880") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133501, "mem_133501") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133499, "mem_133499") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_133886, "mem_param_tmp_133886") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133488, "mem_133488") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133486, "mem_param_133486") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133497, "ext_mem_133497") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133476, "mem_param_133476") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_133472, "mem_param_133472") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133540, "ext_mem_133540") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_133541, "ext_mem_133541") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133469, "mem_133469") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_getPartitionBounds_12125(struct futhark_context *ctx, struct memblock *mem_out_p_134320, struct memblock *mem_out_p_134321, int64_t *out_prim_out_134322, int64_t *out_prim_out_134323, int32_t *out_prim_out_134324, struct memblock pXs_mem_133466, int64_t n_111148, int64_t b_111149, int32_t curDepth_111150, int32_t i_111152, int32_t j_111153)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133468_cached_sizze_134325 = 0;
    unsigned char *mem_133468 = NULL;
    int64_t mem_133470_cached_sizze_134326 = 0;
    unsigned char *mem_133470 = NULL;
    int64_t mem_133477_cached_sizze_134327 = 0;
    unsigned char *mem_133477 = NULL;
    int64_t mem_133478_cached_sizze_134328 = 0;
    unsigned char *mem_133478 = NULL;
    int64_t mem_133498_cached_sizze_134329 = 0;
    unsigned char *mem_133498 = NULL;
    struct memblock mem_133509;
    
    mem_133509.references = NULL;
    
    struct memblock mem_133507;
    
    mem_133507.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t prim_out_133879;
    int64_t prim_out_133880;
    int32_t prim_out_133881;
    int64_t dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154 = sub64(n_111148, (int64_t) 1);
    bool bounds_invalid_upwards_111158 = slt64(n_111148, (int64_t) 1);
    bool valid_111163 = !bounds_invalid_upwards_111158;
    bool range_valid_c_111164;
    
    if (!valid_111163) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 1, "..<", (long long) n_111148, " is invalid.", "-> #0  ftHashJoin.fut:228:23-28\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zm_lhs_126090 = mul64((int64_t) 8, b_111149);
    int64_t min_arg1_126091 = sub64(zm_lhs_126090, (int64_t) 1);
    int32_t i64_res_126076 = sext_i64_i32(b_111149);
    int32_t zm_lhs_126077 = mul32(8, i64_res_126076);
    int32_t min_arg1_126078 = sub32(zm_lhs_126077, 1);
    int32_t min_res_126079 = smin32(j_111153, min_arg1_126078);
    int32_t zm_rhs_126086 = sdiv32(min_res_126079, 8);
    int32_t zm_lhs_126087 = sub32(i64_res_126076, zm_rhs_126086);
    int32_t i32_arg0_126088 = sub32(zm_lhs_126087, 1);
    int64_t i32_res_126089 = sext_i32_i64(i32_arg0_126088);
    int64_t min_res_126092 = smin64(i32_res_126089, min_arg1_126091);
    bool y_126121 = slt64(min_res_126092, b_111149);
    bool x_126120 = sle64((int64_t) 0, min_res_126092);
    bool bounds_check_126122 = x_126120 && y_126121;
    bool index_certs_126123;
    
    if (!bounds_check_126122) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) min_res_126092, "] out of bounds for array of shape [", (long long) b_111149, "].", "-> #0  ftHashJoin.fut:32:38-54\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int32_t zm_rhs_126081 = sdiv32(i_111152, 8);
    int32_t zm_lhs_126082 = sub32(i64_res_126076, zm_rhs_126081);
    int32_t i32_arg0_126083 = sub32(zm_lhs_126082, 1);
    int64_t i32_res_126084 = sext_i32_i64(i32_arg0_126083);
    bool y_126110 = slt64(i32_res_126084, b_111149);
    bool x_126109 = sle64((int64_t) 0, i32_res_126084);
    bool bounds_check_126111 = x_126109 && y_126110;
    bool index_certs_126112;
    
    if (!bounds_check_126111) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i32_res_126084, "] out of bounds for array of shape [", (long long) b_111149, "].", "-> #0  ftHashJoin.fut:31:48-64\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int32_t lastBit_126094 = smod32(min_res_126079, 8);
    int32_t zm_lhs_126097 = sub32(8, lastBit_126094);
    int32_t i32_arg0_126098 = sub32(zm_lhs_126097, 1);
    int8_t unsign_arg0_126099 = zext_i32_i8(i32_arg0_126098);
    int8_t unsign_arg0_126100 = lshr8((int8_t) -1, unsign_arg0_126099);
    int32_t firstBit_126093 = smod32(i_111152, 8);
    int8_t unsign_arg0_126095 = zext_i32_i8(firstBit_126093);
    int8_t first_bitMask_126096 = shl8((int8_t) -1, unsign_arg0_126095);
    int64_t bytes_133467 = (int64_t) 8 * dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154;
    
    if (mem_133468_cached_sizze_134325 < bytes_133467) {
        err = lexical_realloc(ctx, &mem_133468, &mem_133468_cached_sizze_134325, bytes_133467);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133470_cached_sizze_134326 < bytes_133467) {
        err = lexical_realloc(ctx, &mem_133470, &mem_133470_cached_sizze_134326, bytes_133467);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133477_cached_sizze_134327 < b_111149) {
        err = lexical_realloc(ctx, &mem_133477, &mem_133477_cached_sizze_134327, b_111149);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_133478_cached_sizze_134328 < b_111149) {
        err = lexical_realloc(ctx, &mem_133478, &mem_133478_cached_sizze_134328, b_111149);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t discard_133315;
    int64_t scanacc_133309 = (int64_t) 0;
    
    for (int64_t i_133312 = 0; i_133312 < dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154; i_133312++) {
        int64_t index_primexp_133433 = add64((int64_t) 1, i_133312);
        bool x_128001 = sle64((int64_t) 0, index_primexp_133433);
        bool y_128002 = slt64(index_primexp_133433, n_111148);
        bool bounds_check_128003 = x_128001 && y_128002;
        bool index_certs_128004;
        
        if (!bounds_check_128003) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_primexp_133433, "] out of bounds for array of shape [", (long long) n_111148, "].", "-> #0  ftHashJoin.fut:229:22-30\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:229:8-44\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        bool y_128008 = slt64(i_133312, n_111148);
        bool index_certs_128010;
        
        if (!y_128008) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_133312, "] out of bounds for array of shape [", (long long) n_111148, "].", "-> #0  ftHashJoin.fut:229:32-42\n   #1  /prelude/functional.fut:9:44-45\n   #2  ftHashJoin.fut:229:8-44\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        for (int64_t i_133302 = 0; i_133302 < b_111149; i_133302++) {
            int8_t eta_p_128062 = ((int8_t *) pXs_mem_133466.mem)[index_primexp_133433 * b_111149 + i_133302];
            int8_t eta_p_128063 = ((int8_t *) pXs_mem_133466.mem)[i_133312 * b_111149 + i_133302];
            bool cond_128065 = sle64(i_133302, i32_res_126084);
            bool cond_t_res_128066 = sle64(min_res_126092, i_133302);
            bool x_128067 = cond_128065 && cond_t_res_128066;
            int8_t lifted_lambda_res_128068;
            
            if (x_128067) {
                lifted_lambda_res_128068 = eta_p_128062;
            } else {
                lifted_lambda_res_128068 = (int8_t) 0;
            }
            
            int8_t lifted_lambda_res_128073;
            
            if (x_128067) {
                lifted_lambda_res_128073 = eta_p_128063;
            } else {
                lifted_lambda_res_128073 = (int8_t) 0;
            }
            ((int8_t *) mem_133477)[i_133302] = lifted_lambda_res_128073;
            ((int8_t *) mem_133478)[i_133302] = lifted_lambda_res_128068;
        }
        
        int8_t za_lhs_128021 = ((int8_t *) mem_133478)[i32_res_126084];
        int8_t mod1_x_128022 = first_bitMask_126096 & za_lhs_128021;
        
        ((int8_t *) mem_133478)[i32_res_126084] = mod1_x_128022;
        
        int8_t za_lhs_128024 = ((int8_t *) mem_133478)[min_res_126092];
        int8_t tmp_128025 = unsign_arg0_126100 & za_lhs_128024;
        
        ((int8_t *) mem_133478)[min_res_126092] = tmp_128025;
        
        int8_t za_lhs_128034 = ((int8_t *) mem_133477)[i32_res_126084];
        int8_t mod1_x_128035 = first_bitMask_126096 & za_lhs_128034;
        
        ((int8_t *) mem_133477)[i32_res_126084] = mod1_x_128035;
        
        int8_t za_lhs_128037 = ((int8_t *) mem_133477)[min_res_126092];
        int8_t tmp_128038 = unsign_arg0_126100 & za_lhs_128037;
        
        ((int8_t *) mem_133477)[min_res_126092] = tmp_128038;
        
        bool defunc_0_reduce_res_128085;
        bool redout_133305 = 0;
        
        for (int64_t i_133306 = 0; i_133306 < b_111149; i_133306++) {
            int8_t eta_p_128055 = ((int8_t *) mem_133478)[i_133306];
            int8_t eta_p_128056 = ((int8_t *) mem_133477)[i_133306];
            bool lifted_lambda_res_128057 = eta_p_128055 == eta_p_128056;
            bool lifted_lambda_res_128058 = !lifted_lambda_res_128057;
            bool defunc_0_op_res_128051 = lifted_lambda_res_128058 || redout_133305;
            bool redout_tmp_133887 = defunc_0_op_res_128051;
            
            redout_133305 = redout_tmp_133887;
        }
        defunc_0_reduce_res_128085 = redout_133305;
        
        int64_t defunc_0_f_res_128052 = btoi_bool_i64(defunc_0_reduce_res_128085);
        int64_t defunc_0_op_res_120298 = add64(defunc_0_f_res_128052, scanacc_133309);
        
        ((int64_t *) mem_133468)[i_133312] = defunc_0_op_res_120298;
        ((int64_t *) mem_133470)[i_133312] = defunc_0_f_res_128052;
        
        int64_t scanacc_tmp_133882 = defunc_0_op_res_120298;
        
        scanacc_133309 = scanacc_tmp_133882;
    }
    discard_133315 = scanacc_133309;
    
    bool cond_120299 = dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154 == (int64_t) 0;
    bool x_120300 = !cond_120299;
    int64_t tmp_120301 = sub64(dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154, (int64_t) 1);
    bool x_120302 = sle64((int64_t) 0, tmp_120301);
    bool y_120303 = slt64(tmp_120301, dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154);
    bool bounds_check_120304 = x_120302 && y_120303;
    bool protect_assert_disj_120305 = cond_120299 || bounds_check_120304;
    bool index_certs_120306;
    
    if (!protect_assert_disj_120305) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_120301, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154, "].", "-> #0  /prelude/soacs.fut:257:33-47\n   #1  /prelude/functional.fut:9:44-45\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t m_f_res_120307;
    
    if (x_120300) {
        int64_t x_128086 = ((int64_t *) mem_133468)[tmp_120301];
        
        m_f_res_120307 = x_128086;
    } else {
        m_f_res_120307 = (int64_t) 0;
    }
    
    int64_t m_120309;
    
    if (cond_120299) {
        m_120309 = (int64_t) 0;
    } else {
        m_120309 = m_f_res_120307;
    }
    
    int64_t m_120319 = sub64(m_120309, (int64_t) 1);
    bool i_p_m_t_s_leq_w_120321 = slt64(m_120319, dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154);
    bool zzero_leq_i_p_m_t_s_120320 = sle64((int64_t) 0, m_120319);
    bool y_120323 = zzero_leq_i_p_m_t_s_120320 && i_p_m_t_s_leq_w_120321;
    bool i_lte_j_120322 = sle64((int64_t) 0, m_120309);
    bool forwards_ok_120324 = i_lte_j_120322 && y_120323;
    bool eq_x_zz_120316 = (int64_t) 0 == m_f_res_120307;
    bool p_and_eq_x_y_120317 = x_120300 && eq_x_zz_120316;
    bool empty_slice_120318 = cond_120299 || p_and_eq_x_y_120317;
    bool ok_or_empty_120325 = empty_slice_120318 || forwards_ok_120324;
    bool index_certs_120326;
    
    if (!ok_or_empty_120325) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) m_120309, "] out of bounds for array of shape [", (long long) dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154, "].", "-> #0  /prelude/soacs.fut:258:29-35\n   #1  /prelude/functional.fut:9:44-45\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133497 = (int64_t) 8 * m_120309;
    int64_t conc_tmp_117829 = (int64_t) 1 + m_120309;
    int64_t bytes_133506 = (int64_t) 8 * conc_tmp_117829;
    int64_t bytes_133508 = (int64_t) 4 * conc_tmp_117829;
    
    if (mem_133498_cached_sizze_134329 < bytes_133497) {
        err = lexical_realloc(ctx, &mem_133498, &mem_133498_cached_sizze_134329, bytes_133497);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t i_133888 = 0; i_133888 < m_120309; i_133888++) {
        int64_t x_133889 = (int64_t) 1 + i_133888 * (int64_t) 1;
        
        ((int64_t *) mem_133498)[i_133888] = x_133889;
    }
    for (int64_t write_iter_133316 = 0; write_iter_133316 < dzlz7bUZLzmZRz20Unz20U1z7dUzg_111154; write_iter_133316++) {
        int64_t write_iv_133318 = ((int64_t *) mem_133470)[write_iter_133316];
        int64_t write_iv_133319 = ((int64_t *) mem_133468)[write_iter_133316];
        int64_t index_primexp_133429 = add64((int64_t) 1, write_iter_133316);
        bool cond_127935 = write_iv_133318 == (int64_t) 1;
        int64_t lifted_lambda_res_127936;
        
        if (cond_127935) {
            int64_t lifted_lambda_res_t_res_128087 = sub64(write_iv_133319, (int64_t) 1);
            
            lifted_lambda_res_127936 = lifted_lambda_res_t_res_128087;
        } else {
            lifted_lambda_res_127936 = (int64_t) -1;
        }
        if (sle64((int64_t) 0, lifted_lambda_res_127936) && slt64(lifted_lambda_res_127936, m_120309)) {
            ((int64_t *) mem_133498)[lifted_lambda_res_127936] = index_primexp_133429;
        }
    }
    if (memblock_alloc(ctx, &mem_133507, bytes_133506, "mem_133507")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133891 = 0; nest_i_133891 < (int64_t) 1; nest_i_133891++) {
        ((int64_t *) mem_133507.mem)[nest_i_133891] = (int64_t) 0;
    }
    
    int64_t tmp_offs_133892 = (int64_t) 0;
    
    if (!(tmp_offs_133892 == (int64_t) 0)) {
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133507.mem, tmp_offs_133892, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133507.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    }
    tmp_offs_133892 += (int64_t) 1;
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_133507.mem, tmp_offs_133892, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133498, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {m_120309});
    tmp_offs_133892 += m_120309;
    if (memblock_alloc(ctx, &mem_133509, bytes_133508, "mem_133509")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t nest_i_133893 = 0; nest_i_133893 < conc_tmp_117829; nest_i_133893++) {
        ((int32_t *) mem_133509.mem)[nest_i_133893] = curDepth_111150;
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133507, "mem_133507") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_133878, &mem_133509, "mem_133509") != 0)
        return 1;
    prim_out_133879 = conc_tmp_117829;
    prim_out_133880 = conc_tmp_117829;
    prim_out_133881 = curDepth_111150;
    if (memblock_set(ctx, &*mem_out_p_134320, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134321, &mem_out_133878, "mem_out_133878") != 0)
        return 1;
    *out_prim_out_134322 = prim_out_133879;
    *out_prim_out_134323 = prim_out_133880;
    *out_prim_out_134324 = prim_out_133881;
    
  cleanup:
    {
        free(mem_133468);
        free(mem_133470);
        free(mem_133477);
        free(mem_133478);
        free(mem_133498);
        if (memblock_unref(ctx, &mem_133509, "mem_133509") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_133507, "mem_133507") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133878, "mem_out_133878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_get_bit_1844(struct futhark_context *ctx, int32_t *out_prim_out_134330, int32_t bit_67290, int16_t x_67291)
{
    (void) ctx;
    
    int err = 0;
    int32_t prim_out_133877;
    int16_t i32_res_117746 = sext_i32_i16(bit_67290);
    int16_t zgzg_res_117749 = ashr16(x_67291, i32_res_117746);
    int16_t za_res_117754 = (int16_t) 1 & zgzg_res_117749;
    int32_t to_i32_res_117756 = sext_i16_i32(za_res_117754);
    
    prim_out_133877 = to_i32_res_117756;
    *out_prim_out_134330 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_get_bit_2253(struct futhark_context *ctx, int32_t *out_prim_out_134331, int32_t bit_69072, int64_t x_69073)
{
    (void) ctx;
    
    int err = 0;
    int32_t prim_out_133877;
    int64_t i32_res_117746 = sext_i32_i64(bit_69072);
    int64_t zgzg_res_117749 = ashr64(x_69073, i32_res_117746);
    int64_t za_res_117754 = (int64_t) 1 & zgzg_res_117749;
    int32_t to_i32_res_117756 = sext_i64_i32(za_res_117754);
    
    prim_out_133877 = to_i32_res_117756;
    *out_prim_out_134331 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_greatest_divisor_leq_than_5357(struct futhark_context *ctx, int64_t *out_prim_out_134332, int64_t upper_bound_71619, int64_t n_71620)
{
    (void) ctx;
    
    int err = 0;
    int64_t prim_out_133877;
    bool upper_bound_71621 = sle64((int64_t) 1, upper_bound_71619);
    bool assert_c_71623;
    
    if (!upper_bound_71621) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (upper_bound >= 1)", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:189:21-58\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool cond_71632 = slt64(upper_bound_71619, n_71620);
    bool d_71641;
    int64_t d_71642;
    bool loop_while_71643;
    int64_t d_71644;
    
    loop_while_71643 = cond_71632;
    d_71644 = (int64_t) 1;
    while (loop_while_71643) {
        int64_t loopres_71645 = add64((int64_t) 1, d_71644);
        bool zzero_71647 = loopres_71645 == (int64_t) 0;
        bool nonzzero_71648 = !zzero_71647;
        bool nonzzero_cert_71649;
        
        if (!nonzzero_71648) {
            set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t zg_lhs_71650 = sdiv64(n_71620, loopres_71645);
        bool cond_71652 = slt64(upper_bound_71619, zg_lhs_71650);
        bool loop_cond_71653;
        
        if (cond_71652) {
            loop_cond_71653 = 1;
        } else {
            int64_t znze_lhs_71657 = smod64(n_71620, loopres_71645);
            bool loop_cond_f_res_71659 = znze_lhs_71657 == (int64_t) 0;
            bool loop_cond_f_res_71660 = !loop_cond_f_res_71659;
            
            loop_cond_71653 = loop_cond_f_res_71660;
        }
        
        bool loop_while_tmp_133878 = loop_cond_71653;
        int64_t d_tmp_133879 = loopres_71645;
        
        loop_while_71643 = loop_while_tmp_133878;
        d_71644 = d_tmp_133879;
    }
    d_71641 = loop_while_71643;
    d_71642 = d_71644;
    
    bool zzero_71662 = d_71642 == (int64_t) 0;
    bool nonzzero_71663 = !zzero_71662;
    bool nonzzero_cert_71664;
    
    if (!nonzzero_71663) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t greatest_divisor_leq_than_res_71665 = sdiv64(n_71620, d_71642);
    
    prim_out_133877 = greatest_divisor_leq_than_res_71665;
    *out_prim_out_134332 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11643(struct futhark_context *ctx, struct memblock *mem_out_p_134333, struct memblock nameless_mem_133466, int64_t n_83536, int64_t incr_83537)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133468;
    
    mem_133468.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t rng_83542 = add64(n_83536, incr_83537);
    bool bounds_invalid_upwards_83546 = slt64(rng_83542, incr_83537);
    bool valid_83551 = !bounds_invalid_upwards_83546;
    bool range_valid_c_83552;
    
    if (!valid_83551) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) incr_83537, "..<", (long long) rng_83542, " is invalid.", "-> #0  ftbasics.fut:11:25-40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133467 = (int64_t) 8 * n_83536;
    
    if (memblock_alloc(ctx, &mem_133468, bytes_133467, "mem_133468")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133878 = 0; i_133878 < n_83536; i_133878++) {
        int64_t x_133879 = incr_83537 + i_133878 * (int64_t) 1;
        
        ((int64_t *) mem_133468.mem)[i_133878] = x_133879;
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133468, "mem_133468") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134333, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133468, "mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11664(struct futhark_context *ctx, struct memblock *mem_out_p_134334, struct memblock nameless_mem_133466, int64_t n_84404, int64_t incr_84405)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133468;
    
    mem_133468.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t rng_84410 = add64(n_84404, incr_84405);
    bool bounds_invalid_upwards_84414 = slt64(rng_84410, incr_84405);
    bool valid_84419 = !bounds_invalid_upwards_84414;
    bool range_valid_c_84420;
    
    if (!valid_84419) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) incr_84405, "..<", (long long) rng_84410, " is invalid.", "-> #0  ftbasics.fut:11:25-40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133467 = (int64_t) 8 * n_84404;
    
    if (memblock_alloc(ctx, &mem_133468, bytes_133467, "mem_133468")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133878 = 0; i_133878 < n_84404; i_133878++) {
        int64_t x_133879 = incr_84405 + i_133878 * (int64_t) 1;
        
        ((int64_t *) mem_133468.mem)[i_133878] = x_133879;
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133468, "mem_133468") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134334, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133468, "mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11686(struct futhark_context *ctx, struct memblock *mem_out_p_134335, struct memblock nameless_mem_133466, int64_t n_85272, int64_t incr_85273)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133468;
    
    mem_133468.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t rng_85278 = add64(n_85272, incr_85273);
    bool bounds_invalid_upwards_85282 = slt64(rng_85278, incr_85273);
    bool valid_85287 = !bounds_invalid_upwards_85282;
    bool range_valid_c_85288;
    
    if (!valid_85287) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) incr_85273, "..<", (long long) rng_85278, " is invalid.", "-> #0  ftbasics.fut:11:25-40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133467 = (int64_t) 8 * n_85272;
    
    if (memblock_alloc(ctx, &mem_133468, bytes_133467, "mem_133468")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133878 = 0; i_133878 < n_85272; i_133878++) {
        int64_t x_133879 = incr_85273 + i_133878 * (int64_t) 1;
        
        ((int64_t *) mem_133468.mem)[i_133878] = x_133879;
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133468, "mem_133468") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134335, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133468, "mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11708(struct futhark_context *ctx, struct memblock *mem_out_p_134336, struct memblock nameless_mem_133466, int64_t n_86140, int64_t incr_86141)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133468;
    
    mem_133468.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t rng_86146 = add64(n_86140, incr_86141);
    bool bounds_invalid_upwards_86150 = slt64(rng_86146, incr_86141);
    bool valid_86155 = !bounds_invalid_upwards_86150;
    bool range_valid_c_86156;
    
    if (!valid_86155) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) incr_86141, "..<", (long long) rng_86146, " is invalid.", "-> #0  ftbasics.fut:11:25-40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133467 = (int64_t) 8 * n_86140;
    
    if (memblock_alloc(ctx, &mem_133468, bytes_133467, "mem_133468")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133878 = 0; i_133878 < n_86140; i_133878++) {
        int64_t x_133879 = incr_86141 + i_133878 * (int64_t) 1;
        
        ((int64_t *) mem_133468.mem)[i_133878] = x_133879;
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133468, "mem_133468") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134336, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133468, "mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_indicesWithIncrement_11729(struct futhark_context *ctx, struct memblock *mem_out_p_134337, struct memblock nameless_mem_133466, int64_t n_87029, int64_t incr_87030)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_133468;
    
    mem_133468.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    int64_t rng_87035 = add64(n_87029, incr_87030);
    bool bounds_invalid_upwards_87039 = slt64(rng_87035, incr_87030);
    bool valid_87044 = !bounds_invalid_upwards_87039;
    bool range_valid_c_87045;
    
    if (!valid_87044) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) incr_87030, "..<", (long long) rng_87035, " is invalid.", "-> #0  ftbasics.fut:11:25-40\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t bytes_133467 = (int64_t) 8 * n_87029;
    
    if (memblock_alloc(ctx, &mem_133468, bytes_133467, "mem_133468")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_133878 = 0; i_133878 < n_87029; i_133878++) {
        int64_t x_133879 = incr_87030 + i_133878 * (int64_t) 1;
        
        ((int64_t *) mem_133468.mem)[i_133878] = x_133879;
    }
    if (memblock_set(ctx, &mem_out_133877, &mem_133468, "mem_133468") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134337, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_133468, "mem_133468") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_lifted_normalizze_10748(struct futhark_context *ctx, int64_t *out_prim_out_134338, int64_t *out_prim_out_134339, int64_t *out_prim_out_134340, int64_t *out_prim_out_134341, int64_t *out_prim_out_134342, int64_t slo_71849, int64_t shi_71850, int64_t tlo_71851, int64_t thi_71852, int64_t count_71853)
{
    (void) ctx;
    
    int err = 0;
    int64_t prim_out_133877;
    int64_t prim_out_133878;
    int64_t prim_out_133879;
    int64_t prim_out_133880;
    int64_t prim_out_133881;
    int64_t min_arg1_71856 = add64(slo_71849, count_71853);
    int64_t min_res_117747 = smin64(shi_71850, min_arg1_71856);
    int64_t min_arg1_71860 = add64(tlo_71851, count_71853);
    int64_t min_res_117750 = smin64(thi_71852, min_arg1_71860);
    int64_t zp_lhs_71864 = sub64(min_res_117747, slo_71849);
    int64_t zp_rhs_71866 = sub64(min_res_117750, tlo_71851);
    int64_t zm_lhs_71868 = add64(zp_lhs_71864, zp_rhs_71866);
    int64_t slack_71870 = sub64(zm_lhs_71868, count_71853);
    int64_t min_res_117753 = smin64(zp_lhs_71864, slack_71870);
    int64_t min_res_117756 = smin64(zp_rhs_71866, min_res_117753);
    int64_t max_arg1_71880 = sub64(min_res_117747, min_res_117756);
    int64_t max_res_117759 = smax64(slo_71849, max_arg1_71880);
    int64_t max_arg1_71884 = sub64(min_res_117750, min_res_117756);
    int64_t max_res_117762 = smax64(tlo_71851, max_arg1_71884);
    int64_t zm_rhs_71888 = sub64(max_res_117759, slo_71849);
    int64_t zm_lhs_71890 = sub64(count_71853, zm_rhs_71888);
    int64_t zm_rhs_71892 = sub64(max_res_117762, tlo_71851);
    int64_t count_71894 = sub64(zm_lhs_71890, zm_rhs_71892);
    
    prim_out_133877 = max_res_117759;
    prim_out_133878 = min_res_117747;
    prim_out_133879 = max_res_117762;
    prim_out_133880 = min_res_117750;
    prim_out_133881 = count_71894;
    *out_prim_out_134338 = prim_out_133877;
    *out_prim_out_134339 = prim_out_133878;
    *out_prim_out_134340 = prim_out_133879;
    *out_prim_out_134341 = prim_out_133880;
    *out_prim_out_134342 = prim_out_133881;
    
  cleanup:
    { }
    return err;
}
FUTHARK_FUN_ATTR int futrts_partitioned_scatter_12235(struct futhark_context *ctx, struct memblock *mem_out_p_134343, struct memblock dest_mem_133466, struct memblock is_mem_133467, struct memblock vs_mem_133468, int64_t nd_114497, int64_t n_114498, int64_t psizze_114499)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_133473_cached_sizze_134344 = 0;
    unsigned char *mem_133473 = NULL;
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    bool zzero_114507 = psizze_114499 == (int64_t) 0;
    bool nonzzero_114508 = !zzero_114507;
    bool nonzzero_cert_114509;
    
    if (!nonzzero_114508) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ftbasics.fut:66:23-29\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t zm_lhs_114503 = add64(nd_114497, psizze_114499);
    int64_t zs_lhs_114505 = sub64(zm_lhs_114503, (int64_t) 1);
    int64_t m_114510 = sdiv64(zs_lhs_114505, psizze_114499);
    bool loop_cond_114514 = slt64((int64_t) 0, m_114510);
    bool partitioned_scatter_res_114515;
    int64_t partitioned_scatter_res_114517;
    bool loop_while_114518;
    int64_t p_114520;
    
    loop_while_114518 = loop_cond_114514;
    p_114520 = (int64_t) 0;
    while (loop_while_114518) {
        int64_t lower_bound_114521 = mul64(psizze_114499, p_114520);
        int64_t min_arg1_114523 = add64(psizze_114499, lower_bound_114521);
        int64_t min_res_118045 = smin64(nd_114497, min_arg1_114523);
        int64_t j_m_i_114532 = sub64(min_res_118045, lower_bound_114521);
        bool empty_slice_114539 = j_m_i_114532 == (int64_t) 0;
        int64_t m_114540 = sub64(j_m_i_114532, (int64_t) 1);
        int64_t i_p_m_t_s_114542 = add64(lower_bound_114521, m_114540);
        bool zzero_leq_i_p_m_t_s_114543 = sle64((int64_t) 0, i_p_m_t_s_114542);
        bool i_p_m_t_s_leq_w_114545 = slt64(i_p_m_t_s_114542, nd_114497);
        bool zzero_lte_i_114546 = sle64((int64_t) 0, lower_bound_114521);
        bool i_lte_j_114547 = sle64(lower_bound_114521, min_res_118045);
        bool y_114548 = i_p_m_t_s_leq_w_114545 && zzero_lte_i_114546;
        bool y_114549 = zzero_leq_i_p_m_t_s_114543 && y_114548;
        bool forwards_ok_114550 = i_lte_j_114547 && y_114549;
        bool ok_or_empty_114557 = empty_slice_114539 || forwards_ok_114550;
        bool index_certs_114559;
        
        if (!ok_or_empty_114557) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) lower_bound_114521, ":", (long long) min_res_118045, "] out of bounds for array of shape [", (long long) nd_114497, "].", "-> #0  ftbasics.fut:72:25-56\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t bytes_133472 = (int64_t) 8 * j_m_i_114532;
        
        if (mem_133473_cached_sizze_134344 < bytes_133472) {
            err = lexical_realloc(ctx, &mem_133473, &mem_133473_cached_sizze_134344, bytes_133472);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_133473, (int64_t) 0, (int64_t []) {(int64_t) 1}, (uint64_t *) dest_mem_133466.mem, (int64_t) 0 + (int64_t) 1 * lower_bound_114521, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_114532});
        for (int64_t write_iter_133298 = 0; write_iter_133298 < n_114498; write_iter_133298++) {
            int64_t write_iv_133300 = ((int64_t *) vs_mem_133468.mem)[write_iter_133298];
            int64_t write_iv_133301 = ((int64_t *) is_mem_133467.mem)[write_iter_133298];
            bool cond_127934 = sle64(lower_bound_114521, write_iv_133301);
            bool cond_t_res_127935 = slt64(write_iv_133301, min_res_118045);
            bool x_127936 = cond_127934 && cond_t_res_127935;
            int64_t lifted_lambda_res_127937;
            
            if (x_127936) {
                int64_t lifted_lambda_res_t_res_127943 = sub64(write_iv_133301, lower_bound_114521);
                
                lifted_lambda_res_127937 = lifted_lambda_res_t_res_127943;
            } else {
                lifted_lambda_res_127937 = (int64_t) -1;
            }
            if (sle64((int64_t) 0, lifted_lambda_res_127937) && slt64(lifted_lambda_res_127937, j_m_i_114532)) {
                ((int64_t *) mem_133473)[lifted_lambda_res_127937] = write_iv_133300;
            }
        }
        
        int64_t tmp_114577 = add64((int64_t) 1, p_114520);
        
        lmad_copy_8b(ctx, 1, (uint64_t *) dest_mem_133466.mem, lower_bound_114521, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_133473, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {j_m_i_114532});
        
        bool loop_cond_114622 = slt64(tmp_114577, m_114510);
        bool loop_while_tmp_133878 = loop_cond_114622;
        int64_t p_tmp_133880 = tmp_114577;
        
        loop_while_114518 = loop_while_tmp_133878;
        p_114520 = p_tmp_133880;
    }
    partitioned_scatter_res_114515 = loop_while_114518;
    partitioned_scatter_res_114517 = p_114520;
    if (memblock_set(ctx, &mem_out_133877, &dest_mem_133466, "dest_mem_133466") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_134343, &mem_out_133877, "mem_out_133877") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_133473);
        if (memblock_unref(ctx, &mem_out_133877, "mem_out_133877") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_set_bit_2464(struct futhark_context *ctx, int8_t *out_prim_out_134345, int32_t bit_66984, int8_t x_66985, int32_t b_66986)
{
    (void) ctx;
    
    int err = 0;
    int8_t prim_out_133877;
    int32_t i32_arg0_66987 = shl32(1, bit_66984);
    int32_t i32_arg_66989 = ~i32_arg0_66987;
    int8_t unsign_arg0_118044 = zext_i32_i8(i32_arg_66989);
    int8_t unsign_arg0_126074 = x_66985 & unsign_arg0_118044;
    int32_t i32_arg0_66994 = shl32(b_66986, bit_66984);
    int8_t unsign_arg0_118046 = zext_i32_i8(i32_arg0_66994);
    int8_t unsign_arg0_118049 = unsign_arg0_118046 | unsign_arg0_126074;
    
    prim_out_133877 = unsign_arg0_118049;
    *out_prim_out_134345 = prim_out_133877;
    
  cleanup:
    { }
    return err;
}

int futhark_entry_Inner_Radix_Hash_Join(struct futhark_context *ctx, struct futhark_opaque_joinPairs_bsq **out0, const int32_t in0, const struct futhark_u8_2d *in1, const struct futhark_u8_2d *in2, const struct futhark_opaque_partitionInfo *in3, const struct futhark_opaque_radix_hashTable *in4)
{
    int64_t nR_117695 = (int64_t) 0;
    int64_t b_117696 = (int64_t) 0;
    int64_t nS_117697 = (int64_t) 0;
    int64_t dz2081U_117698 = (int64_t) 0;
    int64_t dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699 = (int64_t) 0;
    int32_t radix_sizze_117700 = 0;
    int32_t maxDepth_117705 = 0;
    int64_t prim_out_133880 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock last_info_idx_mem_133471;
    
    last_info_idx_mem_133471.references = NULL;
    
    struct memblock first_info_idx_mem_133470;
    
    first_info_idx_mem_133470.references = NULL;
    
    struct memblock depths_mem_133469;
    
    depths_mem_133469.references = NULL;
    
    struct memblock bounds_mem_133468;
    
    bounds_mem_133468.references = NULL;
    
    struct memblock pS_mem_133467;
    
    pS_mem_133467.references = NULL;
    
    struct memblock pR_mem_133466;
    
    pR_mem_133466.references = NULL;
    radix_sizze_117700 = in0;
    pR_mem_133466 = in1->mem;
    nR_117695 = in1->shape[0];
    b_117696 = in1->shape[1];
    pS_mem_133467 = in2->mem;
    nS_117697 = in2->shape[0];
    b_117696 = in2->shape[1];
    bounds_mem_133468 = in3->v0->mem;
    dz2081U_117698 = in3->v0->shape[0];
    depths_mem_133469 = in3->v1->mem;
    dz2081U_117698 = in3->v1->shape[0];
    maxDepth_117705 = in3->v2;
    first_info_idx_mem_133470 = in4->v0->mem;
    dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699 = in4->v0->shape[0];
    last_info_idx_mem_133471 = in4->v1->mem;
    dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699 = in4->v1->shape[0];
    if (!((nR_117695 == in1->shape[0] && b_117696 == in1->shape[1]) && ((nS_117697 == in2->shape[0] && b_117696 == in2->shape[1]) && ((dz2081U_117698 == in3->v0->shape[0] && dz2081U_117698 == in3->v1->shape[0]) && (dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699 == in4->v0->shape[0] && dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699 == in4->v1->shape[0]))))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_Inner_Radix_Hash_Join(ctx, &mem_out_133877, &mem_out_133878, &mem_out_133879, &prim_out_133880, pR_mem_133466, pS_mem_133467, bounds_mem_133468, depths_mem_133469, first_info_idx_mem_133470, last_info_idx_mem_133471, nR_117695, b_117696, nS_117697, dz2081U_117698, dzlz7bUZLztztZRz20U2z20UZLi32z20Uradix_sizzeZRz7dUzg_117699, radix_sizze_117700, maxDepth_117705);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_joinPairs_bsq *) malloc(sizeof(struct futhark_opaque_joinPairs_bsq))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = prim_out_133880;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = prim_out_133880;
            assert(((*out0)->v2 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v2->mem = mem_out_133879;
            (*out0)->v2->shape[0] = prim_out_133880;
            (*out0)->v2->shape[1] = b_117696;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_argmin_double(struct futhark_context *ctx, int64_t *out0, const struct futhark_f64_1d *in0)
{
    int64_t n_61823 = (int64_t) 0;
    int64_t prim_out_133877 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock ks_mem_133466;
    
    ks_mem_133466.references = NULL;
    ks_mem_133466 = in0->mem;
    n_61823 = in0->shape[0];
    if (!(n_61823 == in0->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_argmin_double(ctx, &prim_out_133877, ks_mem_133466, n_61823);
        if (ret == 0) {
            *out0 = prim_out_133877;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_argmin_float(struct futhark_context *ctx, int64_t *out0, const struct futhark_f32_1d *in0)
{
    int64_t n_61646 = (int64_t) 0;
    int64_t prim_out_133877 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock ks_mem_133466;
    
    ks_mem_133466.references = NULL;
    ks_mem_133466 = in0->mem;
    n_61646 = in0->shape[0];
    if (!(n_61646 == in0->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_argmin_float(ctx, &prim_out_133877, ks_mem_133466, n_61646);
        if (ret == 0) {
            *out0 = prim_out_133877;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_argmin_int(struct futhark_context *ctx, int64_t *out0, const struct futhark_i32_1d *in0)
{
    int64_t n_61295 = (int64_t) 0;
    int64_t prim_out_133877 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock ks_mem_133466;
    
    ks_mem_133466.references = NULL;
    ks_mem_133466 = in0->mem;
    n_61295 = in0->shape[0];
    if (!(n_61295 == in0->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_argmin_int(ctx, &prim_out_133877, ks_mem_133466, n_61295);
        if (ret == 0) {
            *out0 = prim_out_133877;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_argmin_long(struct futhark_context *ctx, int64_t *out0, const struct futhark_i64_1d *in0)
{
    int64_t n_61469 = (int64_t) 0;
    int64_t prim_out_133877 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock ks_mem_133466;
    
    ks_mem_133466.references = NULL;
    ks_mem_133466 = in0->mem;
    n_61469 = in0->shape[0];
    if (!(n_61469 == in0->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_argmin_long(ctx, &prim_out_133877, ks_mem_133466, n_61469);
        if (ret == 0) {
            *out0 = prim_out_133877;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_argmin_short(struct futhark_context *ctx, int64_t *out0, const struct futhark_i16_1d *in0)
{
    int64_t n_61121 = (int64_t) 0;
    int64_t prim_out_133877 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock ks_mem_133466;
    
    ks_mem_133466.references = NULL;
    ks_mem_133466 = in0->mem;
    n_61121 = in0->shape[0];
    if (!(n_61121 == in0->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_argmin_short(ctx, &prim_out_133877, ks_mem_133466, n_61121);
        if (ret == 0) {
            *out0 = prim_out_133877;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_calc_partitions_from_partitioned_set(struct futhark_context *ctx, struct futhark_opaque_partitionInfo **out0, const int32_t in0, const struct futhark_u8_2d *in1, const int64_t in2, const int64_t in3, const int32_t in4)
{
    int64_t n_114179 = (int64_t) 0;
    int64_t b_114180 = (int64_t) 0;
    int32_t radix_sizze_114181 = 0;
    int64_t offset_114183 = (int64_t) 0;
    int64_t sizze_thresh_114184 = (int64_t) 0;
    int32_t max_depth_114185 = 0;
    int64_t prim_out_133879 = (int64_t) 0;
    int32_t prim_out_133880 = 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pXs_mem_133466;
    
    pXs_mem_133466.references = NULL;
    radix_sizze_114181 = in0;
    pXs_mem_133466 = in1->mem;
    n_114179 = in1->shape[0];
    b_114180 = in1->shape[1];
    offset_114183 = in2;
    sizze_thresh_114184 = in3;
    max_depth_114185 = in4;
    if (!(n_114179 == in1->shape[0] && b_114180 == in1->shape[1])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_calc_partitions_from_partitioned_set(ctx, &mem_out_133877, &mem_out_133878, &prim_out_133879, &prim_out_133880, pXs_mem_133466, n_114179, b_114180, radix_sizze_114181, offset_114183, sizze_thresh_114184, max_depth_114185);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_partitionInfo *) malloc(sizeof(struct futhark_opaque_partitionInfo))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = prim_out_133879;
            assert(((*out0)->v1 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = prim_out_133879;
            (*out0)->v2 = prim_out_133880;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_create_hash_table_from_partitioned_set(struct futhark_context *ctx, struct futhark_opaque_radix_hashTable **out0, const int32_t in0, const struct futhark_u8_2d *in1, const struct futhark_opaque_partitionInfo *in2, const int64_t in3)
{
    int64_t n_114971 = (int64_t) 0;
    int64_t b_114972 = (int64_t) 0;
    int64_t dz2080U_114973 = (int64_t) 0;
    int64_t dz2081U_114974 = (int64_t) 0;
    int32_t radix_sizze_114975 = 0;
    int32_t maxDepth_114979 = 0;
    int64_t scatter_psizze_114980 = (int64_t) 0;
    int64_t prim_out_133879 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock depths_mem_133468;
    
    depths_mem_133468.references = NULL;
    
    struct memblock bounds_mem_133467;
    
    bounds_mem_133467.references = NULL;
    
    struct memblock pXs_mem_133466;
    
    pXs_mem_133466.references = NULL;
    radix_sizze_114975 = in0;
    pXs_mem_133466 = in1->mem;
    n_114971 = in1->shape[0];
    b_114972 = in1->shape[1];
    bounds_mem_133467 = in2->v0->mem;
    dz2080U_114973 = in2->v0->shape[0];
    depths_mem_133468 = in2->v1->mem;
    dz2081U_114974 = in2->v1->shape[0];
    maxDepth_114979 = in2->v2;
    scatter_psizze_114980 = in3;
    if (!((n_114971 == in1->shape[0] && b_114972 == in1->shape[1]) && (dz2080U_114973 == in2->v0->shape[0] && dz2081U_114974 == in2->v1->shape[0]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_create_hash_table_from_partitioned_set(ctx, &mem_out_133877, &mem_out_133878, &prim_out_133879, pXs_mem_133466, bounds_mem_133467, depths_mem_133468, n_114971, b_114972, dz2080U_114973, dz2081U_114974, radix_sizze_114975, maxDepth_114979, scatter_psizze_114980);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_radix_hashTable *) malloc(sizeof(struct futhark_opaque_radix_hashTable))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = prim_out_133879;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = prim_out_133879;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_GFTR(struct futhark_context *ctx, struct futhark_u8_2d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const int64_t in3, const struct futhark_u8_2d *in4)
{
    int64_t niz2084U_65436 = (int64_t) 0;
    int64_t dz2083U_65437 = (int64_t) 0;
    int64_t incr_65438 = (int64_t) 0;
    int64_t psizze_65439 = (int64_t) 0;
    int64_t pL_bytes_65441 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_65438 = in0;
    psizze_65439 = in1;
    is_mem_133466 = in2->mem;
    niz2084U_65436 = in2->shape[0];
    pL_bytes_65441 = in3;
    ys_mem_133467 = in4->mem;
    dz2083U_65437 = in4->shape[0];
    if (!(niz2084U_65436 == in2->shape[0] && (dz2083U_65437 == in4->shape[0] && pL_bytes_65441 == in4->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_GFTR(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, niz2084U_65436, dz2083U_65437, incr_65438, psizze_65439, pL_bytes_65441);
        if (ret == 0) {
            assert((*out0 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = niz2084U_65436;
            (*out0)->shape[1] = pL_bytes_65441;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_double(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_f64_1d *in3)
{
    int64_t niz2084U_64972 = (int64_t) 0;
    int64_t dz2083U_64973 = (int64_t) 0;
    int64_t incr_64974 = (int64_t) 0;
    int64_t psizze_64975 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_64974 = in0;
    psizze_64975 = in1;
    is_mem_133466 = in2->mem;
    niz2084U_64972 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    dz2083U_64973 = in3->shape[0];
    if (!(niz2084U_64972 == in2->shape[0] && dz2083U_64973 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_double(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, niz2084U_64972, dz2083U_64973, incr_64974, psizze_64975);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = niz2084U_64972;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_double_GFUR(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_f64_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_f64_1d *in4)
{
    int64_t ni_66944 = (int64_t) 0;
    int64_t n_66945 = (int64_t) 0;
    int64_t incr_66946 = (int64_t) 0;
    int64_t psizze_66947 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133468;
    
    ys_mem_133468.references = NULL;
    
    struct memblock is_mem_133467;
    
    is_mem_133467.references = NULL;
    
    struct memblock preVals_mem_133466;
    
    preVals_mem_133466.references = NULL;
    incr_66946 = in0;
    psizze_66947 = in1;
    preVals_mem_133466 = in2->mem;
    ni_66944 = in2->shape[0];
    is_mem_133467 = in3->mem;
    ni_66944 = in3->shape[0];
    ys_mem_133468 = in4->mem;
    n_66945 = in4->shape[0];
    if (!(ni_66944 == in2->shape[0] && (ni_66944 == in3->shape[0] && n_66945 == in4->shape[0]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_double_GFUR(ctx, &mem_out_133877, preVals_mem_133466, is_mem_133467, ys_mem_133468, ni_66944, n_66945, incr_66946, psizze_66947);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = ni_66944;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_float(struct futhark_context *ctx, struct futhark_f32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_f32_1d *in3)
{
    int64_t niz2084U_64692 = (int64_t) 0;
    int64_t dz2083U_64693 = (int64_t) 0;
    int64_t incr_64694 = (int64_t) 0;
    int64_t psizze_64695 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_64694 = in0;
    psizze_64695 = in1;
    is_mem_133466 = in2->mem;
    niz2084U_64692 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    dz2083U_64693 = in3->shape[0];
    if (!(niz2084U_64692 == in2->shape[0] && dz2083U_64693 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_float(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, niz2084U_64692, dz2083U_64693, incr_64694, psizze_64695);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = niz2084U_64692;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_float_GFUR(struct futhark_context *ctx, struct futhark_f32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_f32_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_f32_1d *in4)
{
    int64_t ni_66643 = (int64_t) 0;
    int64_t n_66644 = (int64_t) 0;
    int64_t incr_66645 = (int64_t) 0;
    int64_t psizze_66646 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133468;
    
    ys_mem_133468.references = NULL;
    
    struct memblock is_mem_133467;
    
    is_mem_133467.references = NULL;
    
    struct memblock preVals_mem_133466;
    
    preVals_mem_133466.references = NULL;
    incr_66645 = in0;
    psizze_66646 = in1;
    preVals_mem_133466 = in2->mem;
    ni_66643 = in2->shape[0];
    is_mem_133467 = in3->mem;
    ni_66643 = in3->shape[0];
    ys_mem_133468 = in4->mem;
    n_66644 = in4->shape[0];
    if (!(ni_66643 == in2->shape[0] && (ni_66643 == in3->shape[0] && n_66644 == in4->shape[0]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_float_GFUR(ctx, &mem_out_133877, preVals_mem_133466, is_mem_133467, ys_mem_133468, ni_66643, n_66644, incr_66645, psizze_66646);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = ni_66643;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_int(struct futhark_context *ctx, struct futhark_i32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i32_1d *in3)
{
    int64_t niz2084U_64132 = (int64_t) 0;
    int64_t dz2083U_64133 = (int64_t) 0;
    int64_t incr_64134 = (int64_t) 0;
    int64_t psizze_64135 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_64134 = in0;
    psizze_64135 = in1;
    is_mem_133466 = in2->mem;
    niz2084U_64132 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    dz2083U_64133 = in3->shape[0];
    if (!(niz2084U_64132 == in2->shape[0] && dz2083U_64133 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_int(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, niz2084U_64132, dz2083U_64133, incr_64134, psizze_64135);
        if (ret == 0) {
            assert((*out0 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = niz2084U_64132;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_int_GFUR(struct futhark_context *ctx, struct futhark_i32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i32_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_i32_1d *in4)
{
    int64_t ni_66041 = (int64_t) 0;
    int64_t n_66042 = (int64_t) 0;
    int64_t incr_66043 = (int64_t) 0;
    int64_t psizze_66044 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133468;
    
    ys_mem_133468.references = NULL;
    
    struct memblock is_mem_133467;
    
    is_mem_133467.references = NULL;
    
    struct memblock preVals_mem_133466;
    
    preVals_mem_133466.references = NULL;
    incr_66043 = in0;
    psizze_66044 = in1;
    preVals_mem_133466 = in2->mem;
    ni_66041 = in2->shape[0];
    is_mem_133467 = in3->mem;
    ni_66041 = in3->shape[0];
    ys_mem_133468 = in4->mem;
    n_66042 = in4->shape[0];
    if (!(ni_66041 == in2->shape[0] && (ni_66041 == in3->shape[0] && n_66042 == in4->shape[0]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_int_GFUR(ctx, &mem_out_133877, preVals_mem_133466, is_mem_133467, ys_mem_133468, ni_66041, n_66042, incr_66043, psizze_66044);
        if (ret == 0) {
            assert((*out0 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = ni_66041;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_long(struct futhark_context *ctx, struct futhark_i64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i64_1d *in3)
{
    int64_t niz2084U_64412 = (int64_t) 0;
    int64_t dz2083U_64413 = (int64_t) 0;
    int64_t incr_64414 = (int64_t) 0;
    int64_t psizze_64415 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_64414 = in0;
    psizze_64415 = in1;
    is_mem_133466 = in2->mem;
    niz2084U_64412 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    dz2083U_64413 = in3->shape[0];
    if (!(niz2084U_64412 == in2->shape[0] && dz2083U_64413 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_long(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, niz2084U_64412, dz2083U_64413, incr_64414, psizze_64415);
        if (ret == 0) {
            assert((*out0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = niz2084U_64412;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_long_GFUR(struct futhark_context *ctx, struct futhark_i64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_i64_1d *in4)
{
    int64_t ni_66342 = (int64_t) 0;
    int64_t n_66343 = (int64_t) 0;
    int64_t incr_66344 = (int64_t) 0;
    int64_t psizze_66345 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133468;
    
    ys_mem_133468.references = NULL;
    
    struct memblock is_mem_133467;
    
    is_mem_133467.references = NULL;
    
    struct memblock preVals_mem_133466;
    
    preVals_mem_133466.references = NULL;
    incr_66344 = in0;
    psizze_66345 = in1;
    preVals_mem_133466 = in2->mem;
    ni_66342 = in2->shape[0];
    is_mem_133467 = in3->mem;
    ni_66342 = in3->shape[0];
    ys_mem_133468 = in4->mem;
    n_66343 = in4->shape[0];
    if (!(ni_66342 == in2->shape[0] && (ni_66342 == in3->shape[0] && n_66343 == in4->shape[0]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_long_GFUR(ctx, &mem_out_133877, preVals_mem_133466, is_mem_133467, ys_mem_133468, ni_66342, n_66343, incr_66344, psizze_66345);
        if (ret == 0) {
            assert((*out0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = ni_66342;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_short(struct futhark_context *ctx, struct futhark_i16_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i16_1d *in3)
{
    int64_t niz2084U_63852 = (int64_t) 0;
    int64_t dz2083U_63853 = (int64_t) 0;
    int64_t incr_63854 = (int64_t) 0;
    int64_t psizze_63855 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_63854 = in0;
    psizze_63855 = in1;
    is_mem_133466 = in2->mem;
    niz2084U_63852 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    dz2083U_63853 = in3->shape[0];
    if (!(niz2084U_63852 == in2->shape[0] && dz2083U_63853 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_short(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, niz2084U_63852, dz2083U_63853, incr_63854, psizze_63855);
        if (ret == 0) {
            assert((*out0 = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = niz2084U_63852;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_gather_payloads_short_GFUR(struct futhark_context *ctx, struct futhark_i16_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i16_1d *in2, const struct futhark_i64_1d *in3, const struct futhark_i16_1d *in4)
{
    int64_t ni_65740 = (int64_t) 0;
    int64_t n_65741 = (int64_t) 0;
    int64_t incr_65742 = (int64_t) 0;
    int64_t psizze_65743 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133468;
    
    ys_mem_133468.references = NULL;
    
    struct memblock is_mem_133467;
    
    is_mem_133467.references = NULL;
    
    struct memblock preVals_mem_133466;
    
    preVals_mem_133466.references = NULL;
    incr_65742 = in0;
    psizze_65743 = in1;
    preVals_mem_133466 = in2->mem;
    ni_65740 = in2->shape[0];
    is_mem_133467 = in3->mem;
    ni_65740 = in3->shape[0];
    ys_mem_133468 = in4->mem;
    n_65741 = in4->shape[0];
    if (!(ni_65740 == in2->shape[0] && (ni_65740 == in3->shape[0] && n_65741 == in4->shape[0]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_gather_payloads_short_GFUR(ctx, &mem_out_133877, preVals_mem_133466, is_mem_133467, ys_mem_133468, ni_65740, n_65741, incr_65742, psizze_65743);
        if (ret == 0) {
            assert((*out0 = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = ni_65740;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_inner_SMJ_double(struct futhark_context *ctx, struct futhark_opaque_joinPairs_double **out0, const struct futhark_f64_1d *in0, const struct futhark_f64_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5)
{
    int64_t nR_109429 = (int64_t) 0;
    int64_t nS_109430 = (int64_t) 0;
    int64_t offset_R_109433 = (int64_t) 0;
    int64_t offset_S_109434 = (int64_t) 0;
    int64_t partitionSizze_109435 = (int64_t) 0;
    int64_t scatter_psizze_109436 = (int64_t) 0;
    int64_t prim_out_133880 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock tS_mem_133467;
    
    tS_mem_133467.references = NULL;
    
    struct memblock tR_mem_133466;
    
    tR_mem_133466.references = NULL;
    tR_mem_133466 = in0->mem;
    nR_109429 = in0->shape[0];
    tS_mem_133467 = in1->mem;
    nS_109430 = in1->shape[0];
    offset_R_109433 = in2;
    offset_S_109434 = in3;
    partitionSizze_109435 = in4;
    scatter_psizze_109436 = in5;
    if (!(nR_109429 == in0->shape[0] && nS_109430 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_inner_SMJ_double(ctx, &mem_out_133877, &mem_out_133878, &mem_out_133879, &prim_out_133880, tR_mem_133466, tS_mem_133467, nR_109429, nS_109430, offset_R_109433, offset_S_109434, partitionSizze_109435, scatter_psizze_109436);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_joinPairs_double *) malloc(sizeof(struct futhark_opaque_joinPairs_double))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = prim_out_133880;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = prim_out_133880;
            assert(((*out0)->v2 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->v2->mem = mem_out_133879;
            (*out0)->v2->shape[0] = prim_out_133880;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_inner_SMJ_float(struct futhark_context *ctx, struct futhark_opaque_joinPairs_float **out0, const struct futhark_f32_1d *in0, const struct futhark_f32_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5)
{
    int64_t nR_107305 = (int64_t) 0;
    int64_t nS_107306 = (int64_t) 0;
    int64_t offset_R_107309 = (int64_t) 0;
    int64_t offset_S_107310 = (int64_t) 0;
    int64_t partitionSizze_107311 = (int64_t) 0;
    int64_t scatter_psizze_107312 = (int64_t) 0;
    int64_t prim_out_133880 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock tS_mem_133467;
    
    tS_mem_133467.references = NULL;
    
    struct memblock tR_mem_133466;
    
    tR_mem_133466.references = NULL;
    tR_mem_133466 = in0->mem;
    nR_107305 = in0->shape[0];
    tS_mem_133467 = in1->mem;
    nS_107306 = in1->shape[0];
    offset_R_107309 = in2;
    offset_S_107310 = in3;
    partitionSizze_107311 = in4;
    scatter_psizze_107312 = in5;
    if (!(nR_107305 == in0->shape[0] && nS_107306 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_inner_SMJ_float(ctx, &mem_out_133877, &mem_out_133878, &mem_out_133879, &prim_out_133880, tR_mem_133466, tS_mem_133467, nR_107305, nS_107306, offset_R_107309, offset_S_107310, partitionSizze_107311, scatter_psizze_107312);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_joinPairs_float *) malloc(sizeof(struct futhark_opaque_joinPairs_float))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = prim_out_133880;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = prim_out_133880;
            assert(((*out0)->v2 = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) != NULL);
            (*out0)->v2->mem = mem_out_133879;
            (*out0)->v2->shape[0] = prim_out_133880;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_inner_SMJ_int(struct futhark_context *ctx, struct futhark_opaque_joinPairs_int **out0, const struct futhark_i32_1d *in0, const struct futhark_i32_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5)
{
    int64_t nR_103069 = (int64_t) 0;
    int64_t nS_103070 = (int64_t) 0;
    int64_t offset_R_103073 = (int64_t) 0;
    int64_t offset_S_103074 = (int64_t) 0;
    int64_t partitionSizze_103075 = (int64_t) 0;
    int64_t scatter_psizze_103076 = (int64_t) 0;
    int64_t prim_out_133880 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock tS_mem_133467;
    
    tS_mem_133467.references = NULL;
    
    struct memblock tR_mem_133466;
    
    tR_mem_133466.references = NULL;
    tR_mem_133466 = in0->mem;
    nR_103069 = in0->shape[0];
    tS_mem_133467 = in1->mem;
    nS_103070 = in1->shape[0];
    offset_R_103073 = in2;
    offset_S_103074 = in3;
    partitionSizze_103075 = in4;
    scatter_psizze_103076 = in5;
    if (!(nR_103069 == in0->shape[0] && nS_103070 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_inner_SMJ_int(ctx, &mem_out_133877, &mem_out_133878, &mem_out_133879, &prim_out_133880, tR_mem_133466, tS_mem_133467, nR_103069, nS_103070, offset_R_103073, offset_S_103074, partitionSizze_103075, scatter_psizze_103076);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_joinPairs_int *) malloc(sizeof(struct futhark_opaque_joinPairs_int))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = prim_out_133880;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = prim_out_133880;
            assert(((*out0)->v2 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->v2->mem = mem_out_133879;
            (*out0)->v2->shape[0] = prim_out_133880;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_inner_SMJ_long(struct futhark_context *ctx, struct futhark_opaque_joinPairs_long **out0, const struct futhark_i64_1d *in0, const struct futhark_i64_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5)
{
    int64_t nR_105181 = (int64_t) 0;
    int64_t nS_105182 = (int64_t) 0;
    int64_t offset_R_105185 = (int64_t) 0;
    int64_t offset_S_105186 = (int64_t) 0;
    int64_t partitionSizze_105187 = (int64_t) 0;
    int64_t scatter_psizze_105188 = (int64_t) 0;
    int64_t prim_out_133880 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock tS_mem_133467;
    
    tS_mem_133467.references = NULL;
    
    struct memblock tR_mem_133466;
    
    tR_mem_133466.references = NULL;
    tR_mem_133466 = in0->mem;
    nR_105181 = in0->shape[0];
    tS_mem_133467 = in1->mem;
    nS_105182 = in1->shape[0];
    offset_R_105185 = in2;
    offset_S_105186 = in3;
    partitionSizze_105187 = in4;
    scatter_psizze_105188 = in5;
    if (!(nR_105181 == in0->shape[0] && nS_105182 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_inner_SMJ_long(ctx, &mem_out_133877, &mem_out_133878, &mem_out_133879, &prim_out_133880, tR_mem_133466, tS_mem_133467, nR_105181, nS_105182, offset_R_105185, offset_S_105186, partitionSizze_105187, scatter_psizze_105188);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_joinPairs_long *) malloc(sizeof(struct futhark_opaque_joinPairs_long))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = prim_out_133880;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = prim_out_133880;
            assert(((*out0)->v2 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v2->mem = mem_out_133879;
            (*out0)->v2->shape[0] = prim_out_133880;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_inner_SMJ_short(struct futhark_context *ctx, struct futhark_opaque_joinPairs_short **out0, const struct futhark_i16_1d *in0, const struct futhark_i16_1d *in1, const int64_t in2, const int64_t in3, const int64_t in4, const int64_t in5)
{
    int64_t nR_100945 = (int64_t) 0;
    int64_t nS_100946 = (int64_t) 0;
    int64_t offset_R_100949 = (int64_t) 0;
    int64_t offset_S_100950 = (int64_t) 0;
    int64_t partitionSizze_100951 = (int64_t) 0;
    int64_t scatter_psizze_100952 = (int64_t) 0;
    int64_t prim_out_133880 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133879;
    
    mem_out_133879.references = NULL;
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock tS_mem_133467;
    
    tS_mem_133467.references = NULL;
    
    struct memblock tR_mem_133466;
    
    tR_mem_133466.references = NULL;
    tR_mem_133466 = in0->mem;
    nR_100945 = in0->shape[0];
    tS_mem_133467 = in1->mem;
    nS_100946 = in1->shape[0];
    offset_R_100949 = in2;
    offset_S_100950 = in3;
    partitionSizze_100951 = in4;
    scatter_psizze_100952 = in5;
    if (!(nR_100945 == in0->shape[0] && nS_100946 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_inner_SMJ_short(ctx, &mem_out_133877, &mem_out_133878, &mem_out_133879, &prim_out_133880, tR_mem_133466, tS_mem_133467, nR_100945, nS_100946, offset_R_100949, offset_S_100950, partitionSizze_100951, scatter_psizze_100952);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_joinPairs_short *) malloc(sizeof(struct futhark_opaque_joinPairs_short))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = prim_out_133880;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = prim_out_133880;
            assert(((*out0)->v2 = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d))) != NULL);
            (*out0)->v2->mem = mem_out_133879;
            (*out0)->v2->shape[0] = prim_out_133880;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_max_idx(struct futhark_context *ctx, int64_t *out0, const struct futhark_i64_1d *in0)
{
    int64_t nz2080U_61900 = (int64_t) 0;
    int64_t prim_out_133877 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock eta_p_mem_133466;
    
    eta_p_mem_133466.references = NULL;
    eta_p_mem_133466 = in0->mem;
    nz2080U_61900 = in0->shape[0];
    if (!(nz2080U_61900 == in0->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_max_idx(ctx, &prim_out_133877, eta_p_mem_133466, nz2080U_61900);
        if (ret == 0) {
            *out0 = prim_out_133877;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortColumn_double(struct futhark_context *ctx, struct futhark_opaque_sortInfo_double **out0, const int64_t in0, const struct futhark_f64_1d *in1)
{
    int64_t n_98615 = (int64_t) 0;
    int64_t incr_98616 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_98616 = in0;
    xs_mem_133466 = in1->mem;
    n_98615 = in1->shape[0];
    if (!(n_98615 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortColumn_double(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_98615, incr_98616);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_double *) malloc(sizeof(struct futhark_opaque_sortInfo_double))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_98615;
            assert(((*out0)->v1 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_98615;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortColumn_float(struct futhark_context *ctx, struct futhark_opaque_sortInfo_float **out0, const int64_t in0, const struct futhark_f32_1d *in1)
{
    int64_t n_96470 = (int64_t) 0;
    int64_t incr_96471 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_96471 = in0;
    xs_mem_133466 = in1->mem;
    n_96470 = in1->shape[0];
    if (!(n_96470 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortColumn_float(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_96470, incr_96471);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_float *) malloc(sizeof(struct futhark_opaque_sortInfo_float))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_96470;
            assert(((*out0)->v1 = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_96470;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortColumn_int(struct futhark_context *ctx, struct futhark_opaque_sortInfo_int **out0, const int64_t in0, const struct futhark_i32_1d *in1)
{
    int64_t n_92184 = (int64_t) 0;
    int64_t incr_92185 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_92185 = in0;
    xs_mem_133466 = in1->mem;
    n_92184 = in1->shape[0];
    if (!(n_92184 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortColumn_int(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_92184, incr_92185);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_int *) malloc(sizeof(struct futhark_opaque_sortInfo_int))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_92184;
            assert(((*out0)->v1 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_92184;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortColumn_long(struct futhark_context *ctx, struct futhark_opaque_sortInfo_long **out0, const int64_t in0, const struct futhark_i64_1d *in1)
{
    int64_t n_94325 = (int64_t) 0;
    int64_t incr_94326 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_94326 = in0;
    xs_mem_133466 = in1->mem;
    n_94325 = in1->shape[0];
    if (!(n_94325 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortColumn_long(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_94325, incr_94326);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_long *) malloc(sizeof(struct futhark_opaque_sortInfo_long))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_94325;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_94325;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortColumn_short(struct futhark_context *ctx, struct futhark_opaque_sortInfo_short **out0, const int64_t in0, const struct futhark_i16_1d *in1)
{
    int64_t n_90039 = (int64_t) 0;
    int64_t incr_90040 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_90040 = in0;
    xs_mem_133466 = in1->mem;
    n_90039 = in1->shape[0];
    if (!(n_90039 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortColumn_short(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_90039, incr_90040);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_short *) malloc(sizeof(struct futhark_opaque_sortInfo_short))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_90039;
            assert(((*out0)->v1 = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_90039;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortRelation_double(struct futhark_context *ctx, struct futhark_opaque_sortStruct_double **out0, const struct futhark_opaque_sortStruct_double *in0)
{
    int64_t n_83511 = (int64_t) 0;
    int64_t b_83512 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    k_mem_133466 = in0->v0->mem;
    n_83511 = in0->v0->shape[0];
    pL_mem_133467 = in0->v1->mem;
    n_83511 = in0->v1->shape[0];
    b_83512 = in0->v1->shape[1];
    if (!(n_83511 == in0->v0->shape[0] && (n_83511 == in0->v1->shape[0] && b_83512 == in0->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortRelation_double(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_83511, b_83512);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_double *) malloc(sizeof(struct futhark_opaque_sortStruct_double))) != NULL);
            assert(((*out0)->v0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_83511;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_83511;
            (*out0)->v1->shape[1] = b_83512;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortRelation_float(struct futhark_context *ctx, struct futhark_opaque_sortStruct_float **out0, const struct futhark_opaque_sortStruct_float *in0)
{
    int64_t n_81146 = (int64_t) 0;
    int64_t b_81147 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    k_mem_133466 = in0->v0->mem;
    n_81146 = in0->v0->shape[0];
    pL_mem_133467 = in0->v1->mem;
    n_81146 = in0->v1->shape[0];
    b_81147 = in0->v1->shape[1];
    if (!(n_81146 == in0->v0->shape[0] && (n_81146 == in0->v1->shape[0] && b_81147 == in0->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortRelation_float(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_81146, b_81147);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_float *) malloc(sizeof(struct futhark_opaque_sortStruct_float))) != NULL);
            assert(((*out0)->v0 = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_81146;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_81146;
            (*out0)->v1->shape[1] = b_81147;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortRelation_int(struct futhark_context *ctx, struct futhark_opaque_sortStruct_int **out0, const struct futhark_opaque_sortStruct_int *in0)
{
    int64_t n_76426 = (int64_t) 0;
    int64_t b_76427 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    k_mem_133466 = in0->v0->mem;
    n_76426 = in0->v0->shape[0];
    pL_mem_133467 = in0->v1->mem;
    n_76426 = in0->v1->shape[0];
    b_76427 = in0->v1->shape[1];
    if (!(n_76426 == in0->v0->shape[0] && (n_76426 == in0->v1->shape[0] && b_76427 == in0->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortRelation_int(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_76426, b_76427);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_int *) malloc(sizeof(struct futhark_opaque_sortStruct_int))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_76426;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_76426;
            (*out0)->v1->shape[1] = b_76427;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortRelation_long(struct futhark_context *ctx, struct futhark_opaque_sortStruct_long **out0, const struct futhark_opaque_sortStruct_long *in0)
{
    int64_t n_78781 = (int64_t) 0;
    int64_t b_78782 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    k_mem_133466 = in0->v0->mem;
    n_78781 = in0->v0->shape[0];
    pL_mem_133467 = in0->v1->mem;
    n_78781 = in0->v1->shape[0];
    b_78782 = in0->v1->shape[1];
    if (!(n_78781 == in0->v0->shape[0] && (n_78781 == in0->v1->shape[0] && b_78782 == in0->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortRelation_long(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_78781, b_78782);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_long *) malloc(sizeof(struct futhark_opaque_sortStruct_long))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_78781;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_78781;
            (*out0)->v1->shape[1] = b_78782;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mergeSortRelation_short(struct futhark_context *ctx, struct futhark_opaque_sortStruct_short **out0, const struct futhark_opaque_sortStruct_short *in0)
{
    int64_t n_74061 = (int64_t) 0;
    int64_t b_74062 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    k_mem_133466 = in0->v0->mem;
    n_74061 = in0->v0->shape[0];
    pL_mem_133467 = in0->v1->mem;
    n_74061 = in0->v1->shape[0];
    b_74062 = in0->v1->shape[1];
    if (!(n_74061 == in0->v0->shape[0] && (n_74061 == in0->v1->shape[0] && b_74062 == in0->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_mergeSortRelation_short(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_74061, b_74062);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_short *) malloc(sizeof(struct futhark_opaque_sortStruct_short))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_74061;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_74061;
            (*out0)->v1->shape[1] = b_74062;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_min_idx(struct futhark_context *ctx, int64_t *out0, const struct futhark_i64_1d *in0)
{
    int64_t nz2080U_61860 = (int64_t) 0;
    int64_t prim_out_133877 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock eta_p_mem_133466;
    
    eta_p_mem_133466.references = NULL;
    eta_p_mem_133466 = in0->mem;
    nz2080U_61860 = in0->shape[0];
    if (!(nz2080U_61860 == in0->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_min_idx(ctx, &prim_out_133877, eta_p_mem_133466, nz2080U_61860);
        if (ret == 0) {
            *out0 = prim_out_133877;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_orderByIndices_double(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_f64_1d *in3)
{
    int64_t n_63570 = (int64_t) 0;
    int64_t incr_63571 = (int64_t) 0;
    int64_t block_sizze_63572 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_63571 = in0;
    block_sizze_63572 = in1;
    is_mem_133466 = in2->mem;
    n_63570 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    n_63570 = in3->shape[0];
    if (!(n_63570 == in2->shape[0] && n_63570 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_orderByIndices_double(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, n_63570, incr_63571, block_sizze_63572);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = n_63570;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_orderByIndices_float(struct futhark_context *ctx, struct futhark_f32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_f32_1d *in3)
{
    int64_t n_63236 = (int64_t) 0;
    int64_t incr_63237 = (int64_t) 0;
    int64_t block_sizze_63238 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_63237 = in0;
    block_sizze_63238 = in1;
    is_mem_133466 = in2->mem;
    n_63236 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    n_63236 = in3->shape[0];
    if (!(n_63236 == in2->shape[0] && n_63236 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_orderByIndices_float(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, n_63236, incr_63237, block_sizze_63238);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = n_63236;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_orderByIndices_int(struct futhark_context *ctx, struct futhark_i32_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i32_1d *in3)
{
    int64_t n_62568 = (int64_t) 0;
    int64_t incr_62569 = (int64_t) 0;
    int64_t block_sizze_62570 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_62569 = in0;
    block_sizze_62570 = in1;
    is_mem_133466 = in2->mem;
    n_62568 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    n_62568 = in3->shape[0];
    if (!(n_62568 == in2->shape[0] && n_62568 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_orderByIndices_int(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, n_62568, incr_62569, block_sizze_62570);
        if (ret == 0) {
            assert((*out0 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = n_62568;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_orderByIndices_long(struct futhark_context *ctx, struct futhark_i64_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i64_1d *in3)
{
    int64_t n_62902 = (int64_t) 0;
    int64_t incr_62903 = (int64_t) 0;
    int64_t block_sizze_62904 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_62903 = in0;
    block_sizze_62904 = in1;
    is_mem_133466 = in2->mem;
    n_62902 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    n_62902 = in3->shape[0];
    if (!(n_62902 == in2->shape[0] && n_62902 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_orderByIndices_long(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, n_62902, incr_62903, block_sizze_62904);
        if (ret == 0) {
            assert((*out0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = n_62902;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_orderByIndices_short(struct futhark_context *ctx, struct futhark_i16_1d **out0, const int64_t in0, const int64_t in1, const struct futhark_i64_1d *in2, const struct futhark_i16_1d *in3)
{
    int64_t n_62234 = (int64_t) 0;
    int64_t incr_62235 = (int64_t) 0;
    int64_t block_sizze_62236 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock ys_mem_133467;
    
    ys_mem_133467.references = NULL;
    
    struct memblock is_mem_133466;
    
    is_mem_133466.references = NULL;
    incr_62235 = in0;
    block_sizze_62236 = in1;
    is_mem_133466 = in2->mem;
    n_62234 = in2->shape[0];
    ys_mem_133467 = in3->mem;
    n_62234 = in3->shape[0];
    if (!(n_62234 == in2->shape[0] && n_62234 == in3->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_orderByIndices_short(ctx, &mem_out_133877, is_mem_133466, ys_mem_133467, n_62234, incr_62235, block_sizze_62236);
        if (ret == 0) {
            assert((*out0 = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d))) != NULL);
            (*out0)->mem = mem_out_133877;
            (*out0)->shape[0] = n_62234;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_partition_and_deepen_GFTR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFTR **out0, const int16_t in0, const int64_t in1, const int32_t in2, const struct futhark_u8_2d *in3, const struct futhark_u8_2d *in4, const int64_t in5, const int32_t in6)
{
    int64_t n_111999 = (int64_t) 0;
    int64_t b_112000 = (int64_t) 0;
    int64_t pL_b_112001 = (int64_t) 0;
    int16_t block_sizze_112002 = (int16_t) 0;
    int64_t gather_psizze_112003 = (int64_t) 0;
    int32_t radix_sizze_112004 = 0;
    int64_t sizze_thresh_112007 = (int64_t) 0;
    int32_t max_depth_112008 = 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    block_sizze_112002 = in0;
    gather_psizze_112003 = in1;
    radix_sizze_112004 = in2;
    xs_mem_133466 = in3->mem;
    n_111999 = in3->shape[0];
    b_112000 = in3->shape[1];
    pL_mem_133467 = in4->mem;
    n_111999 = in4->shape[0];
    pL_b_112001 = in4->shape[1];
    sizze_thresh_112007 = in5;
    max_depth_112008 = in6;
    if (!((n_111999 == in3->shape[0] && b_112000 == in3->shape[1]) && (n_111999 == in4->shape[0] && pL_b_112001 == in4->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_partition_and_deepen_GFTR(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, pL_mem_133467, n_111999, b_112000, pL_b_112001, block_sizze_112002, gather_psizze_112003, radix_sizze_112004, sizze_thresh_112007, max_depth_112008);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_partitionedSet_GFTR *) malloc(sizeof(struct futhark_opaque_partitionedSet_GFTR))) != NULL);
            assert(((*out0)->v0 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_111999;
            (*out0)->v0->shape[1] = b_112000;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_111999;
            (*out0)->v1->shape[1] = pL_b_112001;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_partition_and_deepen_GFUR(struct futhark_context *ctx, struct futhark_opaque_partitionedSet_GFUR **out0, const int16_t in0, const int64_t in1, const int32_t in2, const struct futhark_u8_2d *in3, const int64_t in4, const int64_t in5, const int32_t in6)
{
    int64_t n_113366 = (int64_t) 0;
    int64_t b_113367 = (int64_t) 0;
    int16_t block_sizze_113368 = (int16_t) 0;
    int64_t gather_psizze_113369 = (int64_t) 0;
    int32_t radix_sizze_113370 = 0;
    int64_t offset_113372 = (int64_t) 0;
    int64_t sizze_thresh_113373 = (int64_t) 0;
    int32_t max_depth_113374 = 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    block_sizze_113368 = in0;
    gather_psizze_113369 = in1;
    radix_sizze_113370 = in2;
    xs_mem_133466 = in3->mem;
    n_113366 = in3->shape[0];
    b_113367 = in3->shape[1];
    offset_113372 = in4;
    sizze_thresh_113373 = in5;
    max_depth_113374 = in6;
    if (!(n_113366 == in3->shape[0] && b_113367 == in3->shape[1])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_partition_and_deepen_GFUR(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_113366, b_113367, block_sizze_113368, gather_psizze_113369, radix_sizze_113370, offset_113372, sizze_thresh_113373, max_depth_113374);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_partitionedSet_GFUR *) malloc(sizeof(struct futhark_opaque_partitionedSet_GFUR))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_113366;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_113366;
            (*out0)->v1->shape[1] = b_113367;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortColumn_double(struct futhark_context *ctx, struct futhark_opaque_sortInfo_double **out0, const int64_t in0, const int16_t in1, const struct futhark_f64_1d *in2)
{
    int64_t n_87893 = (int64_t) 0;
    int64_t incr_87894 = (int64_t) 0;
    int16_t block_sizze_87895 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_87894 = in0;
    block_sizze_87895 = in1;
    xs_mem_133466 = in2->mem;
    n_87893 = in2->shape[0];
    if (!(n_87893 == in2->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortColumn_double(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_87893, incr_87894, block_sizze_87895);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_double *) malloc(sizeof(struct futhark_opaque_sortInfo_double))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_87893;
            assert(((*out0)->v1 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_87893;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortColumn_float(struct futhark_context *ctx, struct futhark_opaque_sortInfo_float **out0, const int64_t in0, const int16_t in1, const struct futhark_f32_1d *in2)
{
    int64_t n_87004 = (int64_t) 0;
    int64_t incr_87005 = (int64_t) 0;
    int16_t block_sizze_87006 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_87005 = in0;
    block_sizze_87006 = in1;
    xs_mem_133466 = in2->mem;
    n_87004 = in2->shape[0];
    if (!(n_87004 == in2->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortColumn_float(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_87004, incr_87005, block_sizze_87006);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_float *) malloc(sizeof(struct futhark_opaque_sortInfo_float))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_87004;
            assert(((*out0)->v1 = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_87004;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortColumn_int(struct futhark_context *ctx, struct futhark_opaque_sortInfo_int **out0, const int64_t in0, const int16_t in1, const struct futhark_i32_1d *in2)
{
    int64_t n_85247 = (int64_t) 0;
    int64_t incr_85248 = (int64_t) 0;
    int16_t block_sizze_85249 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_85248 = in0;
    block_sizze_85249 = in1;
    xs_mem_133466 = in2->mem;
    n_85247 = in2->shape[0];
    if (!(n_85247 == in2->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortColumn_int(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_85247, incr_85248, block_sizze_85249);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_int *) malloc(sizeof(struct futhark_opaque_sortInfo_int))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_85247;
            assert(((*out0)->v1 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_85247;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortColumn_long(struct futhark_context *ctx, struct futhark_opaque_sortInfo_long **out0, const int64_t in0, const int16_t in1, const struct futhark_i64_1d *in2)
{
    int64_t n_86115 = (int64_t) 0;
    int64_t incr_86116 = (int64_t) 0;
    int16_t block_sizze_86117 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_86116 = in0;
    block_sizze_86117 = in1;
    xs_mem_133466 = in2->mem;
    n_86115 = in2->shape[0];
    if (!(n_86115 == in2->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortColumn_long(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_86115, incr_86116, block_sizze_86117);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_long *) malloc(sizeof(struct futhark_opaque_sortInfo_long))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_86115;
            assert(((*out0)->v1 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_86115;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortColumn_short(struct futhark_context *ctx, struct futhark_opaque_sortInfo_short **out0, const int64_t in0, const int16_t in1, const struct futhark_i16_1d *in2)
{
    int64_t n_84379 = (int64_t) 0;
    int64_t incr_84380 = (int64_t) 0;
    int16_t block_sizze_84381 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock xs_mem_133466;
    
    xs_mem_133466.references = NULL;
    incr_84380 = in0;
    block_sizze_84381 = in1;
    xs_mem_133466 = in2->mem;
    n_84379 = in2->shape[0];
    if (!(n_84379 == in2->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortColumn_short(ctx, &mem_out_133877, &mem_out_133878, xs_mem_133466, n_84379, incr_84380, block_sizze_84381);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortInfo_short *) malloc(sizeof(struct futhark_opaque_sortInfo_short))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_84379;
            assert(((*out0)->v1 = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_84379;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortRelation_double(struct futhark_context *ctx, struct futhark_opaque_sortStruct_double **out0, const int16_t in0, const struct futhark_opaque_sortStruct_double *in1)
{
    int64_t n_71590 = (int64_t) 0;
    int64_t b_71591 = (int64_t) 0;
    int16_t block_sizze_71592 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    block_sizze_71592 = in0;
    k_mem_133466 = in1->v0->mem;
    n_71590 = in1->v0->shape[0];
    pL_mem_133467 = in1->v1->mem;
    n_71590 = in1->v1->shape[0];
    b_71591 = in1->v1->shape[1];
    if (!(n_71590 == in1->v0->shape[0] && (n_71590 == in1->v1->shape[0] && b_71591 == in1->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortRelation_double(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_71590, b_71591, block_sizze_71592);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_double *) malloc(sizeof(struct futhark_opaque_sortStruct_double))) != NULL);
            assert(((*out0)->v0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_71590;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_71590;
            (*out0)->v1->shape[1] = b_71591;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortRelation_float(struct futhark_context *ctx, struct futhark_opaque_sortStruct_float **out0, const int16_t in0, const struct futhark_opaque_sortStruct_float *in1)
{
    int64_t n_70640 = (int64_t) 0;
    int64_t b_70641 = (int64_t) 0;
    int16_t block_sizze_70642 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    block_sizze_70642 = in0;
    k_mem_133466 = in1->v0->mem;
    n_70640 = in1->v0->shape[0];
    pL_mem_133467 = in1->v1->mem;
    n_70640 = in1->v1->shape[0];
    b_70641 = in1->v1->shape[1];
    if (!(n_70640 == in1->v0->shape[0] && (n_70640 == in1->v1->shape[0] && b_70641 == in1->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortRelation_float(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_70640, b_70641, block_sizze_70642);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_float *) malloc(sizeof(struct futhark_opaque_sortStruct_float))) != NULL);
            assert(((*out0)->v0 = (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_70640;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_70640;
            (*out0)->v1->shape[1] = b_70641;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortRelation_int(struct futhark_context *ctx, struct futhark_opaque_sortStruct_int **out0, const int16_t in0, const struct futhark_opaque_sortStruct_int *in1)
{
    int64_t n_68806 = (int64_t) 0;
    int64_t b_68807 = (int64_t) 0;
    int16_t block_sizze_68808 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    block_sizze_68808 = in0;
    k_mem_133466 = in1->v0->mem;
    n_68806 = in1->v0->shape[0];
    pL_mem_133467 = in1->v1->mem;
    n_68806 = in1->v1->shape[0];
    b_68807 = in1->v1->shape[1];
    if (!(n_68806 == in1->v0->shape[0] && (n_68806 == in1->v1->shape[0] && b_68807 == in1->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortRelation_int(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_68806, b_68807, block_sizze_68808);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_int *) malloc(sizeof(struct futhark_opaque_sortStruct_int))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i32_1d *) malloc(sizeof(struct futhark_i32_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_68806;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_68806;
            (*out0)->v1->shape[1] = b_68807;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortRelation_long(struct futhark_context *ctx, struct futhark_opaque_sortStruct_long **out0, const int16_t in0, const struct futhark_opaque_sortStruct_long *in1)
{
    int64_t n_69694 = (int64_t) 0;
    int64_t b_69695 = (int64_t) 0;
    int16_t block_sizze_69696 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    block_sizze_69696 = in0;
    k_mem_133466 = in1->v0->mem;
    n_69694 = in1->v0->shape[0];
    pL_mem_133467 = in1->v1->mem;
    n_69694 = in1->v1->shape[0];
    b_69695 = in1->v1->shape[1];
    if (!(n_69694 == in1->v0->shape[0] && (n_69694 == in1->v1->shape[0] && b_69695 == in1->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortRelation_long(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_69694, b_69695, block_sizze_69696);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_long *) malloc(sizeof(struct futhark_opaque_sortStruct_long))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_69694;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_69694;
            (*out0)->v1->shape[1] = b_69695;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_radixSortRelation_short(struct futhark_context *ctx, struct futhark_opaque_sortStruct_short **out0, const int16_t in0, const struct futhark_opaque_sortStruct_short *in1)
{
    int64_t n_67912 = (int64_t) 0;
    int64_t b_67913 = (int64_t) 0;
    int16_t block_sizze_67914 = (int16_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_133878;
    
    mem_out_133878.references = NULL;
    
    struct memblock mem_out_133877;
    
    mem_out_133877.references = NULL;
    
    struct memblock pL_mem_133467;
    
    pL_mem_133467.references = NULL;
    
    struct memblock k_mem_133466;
    
    k_mem_133466.references = NULL;
    block_sizze_67914 = in0;
    k_mem_133466 = in1->v0->mem;
    n_67912 = in1->v0->shape[0];
    pL_mem_133467 = in1->v1->mem;
    n_67912 = in1->v1->shape[0];
    b_67913 = in1->v1->shape[1];
    if (!(n_67912 == in1->v0->shape[0] && (n_67912 == in1->v1->shape[0] && b_67913 == in1->v1->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_radixSortRelation_short(ctx, &mem_out_133877, &mem_out_133878, k_mem_133466, pL_mem_133467, n_67912, b_67913, block_sizze_67914);
        if (ret == 0) {
            assert((*out0 = (struct futhark_opaque_sortStruct_short *) malloc(sizeof(struct futhark_opaque_sortStruct_short))) != NULL);
            assert(((*out0)->v0 = (struct futhark_i16_1d *) malloc(sizeof(struct futhark_i16_1d))) != NULL);
            (*out0)->v0->mem = mem_out_133877;
            (*out0)->v0->shape[0] = n_67912;
            assert(((*out0)->v1 = (struct futhark_u8_2d *) malloc(sizeof(struct futhark_u8_2d))) != NULL);
            (*out0)->v1->mem = mem_out_133878;
            (*out0)->v1->shape[0] = n_67912;
            (*out0)->v1->shape[1] = b_67913;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
  
